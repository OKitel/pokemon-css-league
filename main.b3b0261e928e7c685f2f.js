/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/styles.scss":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/styles.scss ***!
  \***********************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _assets_landscape_jpg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../assets/landscape.jpg */ "./src/assets/landscape.jpg");
/* harmony import */ var _assets_pok_mon_logo_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../assets/pokémon_logo.png */ "./src/assets/pokémon_logo.png");
/* harmony import */ var _assets_mystic_logo_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../assets/mystic-logo.png */ "./src/assets/mystic-logo.png");
/* harmony import */ var _assets_rss_svg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../assets/rss.svg */ "./src/assets/rss.svg");
// Imports







var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(_assets_landscape_jpg__WEBPACK_IMPORTED_MODULE_3__);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(_assets_pok_mon_logo_png__WEBPACK_IMPORTED_MODULE_4__);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(_assets_mystic_logo_png__WEBPACK_IMPORTED_MODULE_5__);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(_assets_rss_svg__WEBPACK_IMPORTED_MODULE_6__);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@charset \"UTF-8\";\n/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */\n/* Document\n   ========================================================================== */\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in iOS.\n */\nhtml {\n  line-height: 1.15; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\n\n/* Sections\n   ========================================================================== */\n/**\n * Remove the margin in all browsers.\n */\nbody {\n  margin: 0;\n}\n\n/**\n * Render the `main` element consistently in IE.\n */\nmain {\n  display: block;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n/* Grouping content\n   ========================================================================== */\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/* Text-level semantics\n   ========================================================================== */\n/**\n * Remove the gray background on active links in IE 10.\n */\na {\n  background-color: transparent;\n}\n\n/**\n * 1. Remove the bottom border in Chrome 57-\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct font size in all browsers.\n */\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n/**\n * Remove the border on images inside links in IE 10.\n */\nimg {\n  border-style: none;\n}\n\n/* Forms\n   ========================================================================== */\n/**\n * 1. Change the font styles in all browsers.\n * 2. Remove the margin in Firefox and Safari.\n */\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * Correct the inability to style clickable types in iOS and Safari.\n */\nbutton,\n[type=button],\n[type=reset],\n[type=submit] {\n  -webkit-appearance: button;\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\nbutton::-moz-focus-inner,\n[type=button]::-moz-focus-inner,\n[type=reset]::-moz-focus-inner,\n[type=submit]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\nbutton:-moz-focusring,\n[type=button]:-moz-focusring,\n[type=reset]:-moz-focusring,\n[type=submit]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Correct the padding in Firefox.\n */\nfieldset {\n  padding: 0.35em 0.75em 0.625em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\nprogress {\n  vertical-align: baseline;\n}\n\n/**\n * Remove the default vertical scrollbar in IE 10+.\n */\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10.\n * 2. Remove the padding in IE 10.\n */\n[type=checkbox],\n[type=radio] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n[type=number]::-webkit-inner-spin-button,\n[type=number]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n[type=search] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding in Chrome and Safari on macOS.\n */\n[type=search]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/* Interactive\n   ========================================================================== */\n/*\n * Add the correct display in Edge, IE 10+, and Firefox.\n */\ndetails {\n  display: block;\n}\n\n/*\n * Add the correct display in all browsers.\n */\nsummary {\n  display: list-item;\n}\n\n/* Misc\n   ========================================================================== */\n/**\n * Add the correct display in IE 10+.\n */\ntemplate {\n  display: none;\n}\n\n/**\n * Add the correct display in IE 10.\n */\n[hidden] {\n  display: none;\n}\n\nbody {\n  font-family: \"Ysabeau Infant\", sans-serif;\n}\n\n.reset-btn, .modal-btn, .footer__link, .btn {\n  transition: all 0.3s ease-out;\n}\n\nhtml {\n  font-size: 10px;\n}\n\nbody {\n  font-size: 1.6rem;\n  font-style: normal;\n  font-weight: normal;\n  line-height: 2.6rem;\n}\n\n.container {\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n}\n\n#root {\n  background-color: #2f8bcc;\n  color: #111042;\n  text-shadow: 0px 0px 3px rgba(255, 255, 255, 0.5);\n}\n\n.background {\n  display: flex;\n  flex-direction: column;\n  flex: 1 0 auto;\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  background-size: cover;\n  background-repeat: no-repeat;\n}\n\n.btn {\n  border: 2px solid #111042;\n  border-radius: 1rem;\n  background-color: transparent;\n  cursor: pointer;\n  font-size: larger;\n}\n\n.btn:hover {\n  background-color: #111042;\n  color: #ffffff;\n}\n\n*,\n*:before,\n*:after {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.pokeball__container {\n  z-index: 10;\n  margin: 0 3rem;\n}\n\n/* Poké Styles */\n.pokeball {\n  position: relative;\n  width: 200px;\n  height: 200px;\n  background: #fff;\n  border: 10px solid #000;\n  border-radius: 50%;\n  overflow: hidden;\n  box-shadow: inset -10px 10px 0 10px #ccc;\n  animation: fall 0.25s ease-in-out, shake 1.25s cubic-bezier(0.36, 0.07, 0.19, 0.97) 2;\n}\n\n.finish {\n  animation: activeAnimation 1s infinite ease-in-out;\n}\n\n.pokeball::before,\n.pokeball::after {\n  content: \"\";\n  position: absolute;\n}\n\n.pokeball::before {\n  background: red;\n  width: 100%;\n  height: 50%;\n}\n\n.pokeball::after {\n  top: calc(50% - 10px);\n  width: 100%;\n  height: 20px;\n  background: #000;\n}\n\n.pokeball__button {\n  position: absolute;\n  top: calc(50% - 30px);\n  left: calc(50% - 30px);\n  width: 60px;\n  height: 60px;\n  background: #7f8c8d;\n  border: 10px solid #fff;\n  border-radius: 50%;\n  z-index: 10;\n  box-shadow: 0 0 0 10px black;\n  animation: blink 0.5s alternate 5;\n}\n\n/* Animation */\n@keyframes blink {\n  from {\n    background: #eee;\n  }\n  to {\n    background: #e74c3c;\n  }\n}\n@keyframes shake {\n  0% {\n    transform: translate(0, 0) rotate(0);\n  }\n  20% {\n    transform: translate(-10px, 0) rotate(-20deg);\n  }\n  30% {\n    transform: translate(10px, 0) rotate(20deg);\n  }\n  50% {\n    transform: translate(-10px, 0) rotate(-10deg);\n  }\n  60% {\n    transform: translate(10px, 0) rotate(10deg);\n  }\n  100% {\n    transform: translate(0, 0) rotate(0);\n  }\n}\n@keyframes fall {\n  0% {\n    top: -200px;\n  }\n  60% {\n    top: 0;\n  }\n  80% {\n    top: -20px;\n  }\n  100% {\n    top: 0;\n  }\n}\n.header {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  flex-shrink: 0;\n  padding: 1rem;\n}\n\n.header__logo {\n  width: 20rem;\n  height: 7rem;\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\n  background-size: contain;\n  background-repeat: no-repeat;\n}\n\n.header__title {\n  margin: 0;\n  font-size: 2.5rem;\n  font-style: normal;\n  font-weight: bold;\n  line-height: 2.6rem;\n}\n\n.header__link {\n  cursor: pointer;\n}\n\n.main {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  flex-grow: 1;\n}\n\n.task-title {\n  font-size: 7rem;\n  line-height: 7rem;\n  text-align: center;\n}\n\n.pokemons {\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  padding: 2rem 0;\n}\n\n.pokemon {\n  width: 20rem;\n}\n\n@media screen and (max-height: 800px) {\n  .task-title {\n    font-size: 5rem;\n    line-height: 6rem;\n  }\n  .pokemon {\n    width: 15rem;\n  }\n}\n@media screen and (max-width: 780px) {\n  .pokemon {\n    width: 10rem;\n  }\n  .task-title {\n    font-size: 5rem;\n    line-height: 6rem;\n  }\n}\n.editor {\n  display: flex;\n  min-width: 80%;\n  backdrop-filter: blur(3px);\n  box-shadow: 4px 4px 10px 0px rgba(17, 16, 66, 0.5);\n  padding: 1rem;\n}\n.editor__header {\n  background-color: #ffffff;\n  margin: 0;\n  text-align: center;\n  color: #111042;\n}\n\n#css-editor,\n#html-viewer {\n  flex: 1 1 50%;\n  position: relative;\n}\n\n.cm-editor {\n  background-color: #ffffff;\n  width: 100%;\n  height: 30rem;\n}\n\n@keyframes shakeEditor {\n  0% {\n    transform: translateX(0);\n  }\n  20% {\n    transform: translateX(-10px);\n  }\n  40% {\n    transform: translateX(10px);\n  }\n  60% {\n    transform: translateX(-10px);\n  }\n  80% {\n    transform: translateX(10px);\n  }\n  100% {\n    transform: translateX(0);\n  }\n}\n.shake {\n  animation: shakeEditor 0.5s infinite;\n}\n\n.enter-btn {\n  position: absolute;\n  bottom: 1rem;\n  right: 1rem;\n  width: 8rem;\n  height: 3rem;\n}\n\n@media screen and (max-height: 800px) {\n  .cm-editor {\n    height: 20rem;\n  }\n}\n.footer {\n  flex-shrink: 0;\n  color: #111042;\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  box-shadow: 0 -1px 10px 5px rgba(17, 16, 66, 0.5);\n  backdrop-filter: blur(3px);\n}\n\n.footer__link {\n  cursor: pointer;\n}\n.footer__link:hover {\n  transform: scale(1.05);\n}\n\n.github-icon {\n  width: 4rem;\n  height: 4rem;\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");\n  background-size: contain;\n}\n\n.rss-icon {\n  width: 8rem;\n  height: 4rem;\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ");\n  background-size: contain;\n  background-repeat: no-repeat;\n}\n\n.footer__year {\n  text-shadow: 0px 0px 3px rgba(255, 255, 255, 0.5);\n}\n\n.overlay-modal {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  backdrop-filter: blur(3px);\n  width: 100%;\n  height: 100%;\n  position: fixed;\n  z-index: -2;\n  top: 0;\n  left: 0;\n  transition: all 0.5s ease;\n  opacity: 0;\n}\n.overlay-modal.active {\n  opacity: 1;\n  z-index: 2;\n}\n\n.modal-content {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  background-color: #ffffff;\n  border-radius: 1rem;\n  padding: 1rem;\n}\n\n.modal {\n  width: 70%;\n  border-radius: 1rem;\n  box-shadow: 4px 4px 10px 0px rgba(17, 16, 66, 0.5);\n}\n\n.modal-btn-container {\n  padding: 2rem;\n}\n\n.modal-btn {\n  width: 25rem;\n  height: 4rem;\n  border: 2px solid #111042;\n  border-radius: 1rem;\n  background-color: transparent;\n  cursor: pointer;\n  font-size: larger;\n}\n\n.modal-btn:hover {\n  background-color: #111042;\n  color: #ffffff;\n}\n\n.modal-content__image {\n  padding-top: 1rem;\n}\n\n.modal-content__info {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  padding-top: 1rem;\n  width: 80%;\n}\n\n.modal-content__info-title {\n  font-weight: bold;\n  font-size: larger;\n}\n\n.modal-content__info-text {\n  text-align: justify;\n}\n\n.burger {\n  display: flex;\n  cursor: pointer;\n  flex-direction: column;\n  height: 22px;\n  justify-content: space-between;\n  position: fixed;\n  top: 35px;\n  right: 20px;\n  width: 29px;\n  z-index: 2;\n  transition: all 0.4s ease;\n}\n.burger .bar {\n  width: 100%;\n  height: 2px;\n  background-color: #111042;\n}\n.burger.active {\n  transform: rotate(90deg) translate(14px, 0);\n}\n\n.nav-links {\n  display: flex;\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n.nav-links li {\n  margin-bottom: 1rem;\n}\n.nav-links__item {\n  font-size: larger;\n  cursor: pointer;\n  transition: 0.3s;\n}\n.nav-links__item:hover {\n  color: #2f8bcc;\n  text-decoration: underline;\n}\n.nav-links__item-active {\n  color: #2f8bcc;\n  font-weight: bold;\n  padding-bottom: 3px;\n  cursor: default;\n}\n\n.menu-container {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-evenly;\n  align-items: center;\n  width: 25rem;\n  height: 100%;\n  position: fixed;\n  right: -25rem;\n  top: 0;\n  transition: all 0.5s ease;\n  z-index: 1;\n  background: #ffffff;\n  padding: 0 5rem;\n}\n\n.menu-container.active {\n  right: 0;\n  box-shadow: -1px 0px 5px 0px #111042;\n}\n\n.menu {\n  flex-direction: column;\n}\n\n.overlay {\n  backdrop-filter: blur(3px);\n  width: 100%;\n  height: 100%;\n  position: fixed;\n  z-index: -1;\n  top: 0;\n  left: 0;\n  transition: all 0.5s ease;\n  opacity: 0;\n}\n.overlay.active {\n  opacity: 1;\n  z-index: 1;\n}\n\n.body-overflow {\n  overflow: hidden;\n}\n\n.menu-title {\n  text-align: center;\n}\n\n.reset-btn {\n  width: 15rem;\n  height: 4rem;\n  border: 2px solid #111042;\n  border-radius: 1rem;\n  background-color: transparent;\n  cursor: pointer;\n  font-size: larger;\n}\n\n.reset-btn:hover {\n  background-color: #111042;\n  color: #ffffff;\n}\n\n.active-image {\n  animation: activeAnimation 1s infinite ease-in-out;\n}\n\n@keyframes activeAnimation {\n  0% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(1.1);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n.active {\n  animation-play-state: running;\n}\n\n.tiny {\n  width: 10rem;\n  margin: 0 2rem;\n}\n\n@media screen and (max-width: 780px) {\n  .tiny {\n    width: 7rem;\n    margin: 0 1rem;\n  }\n}", "",{"version":3,"sources":["webpack://./src/sass/styles.scss","webpack://./node_modules/normalize.css/normalize.css","webpack://./src/sass/abstract/_placeholders.scss","webpack://./src/sass/base/_base.scss","webpack://./src/sass/abstract/_mixins.scss","webpack://./src/sass/abstract/_constants.scss","webpack://./src/sass/items/_pokeball.scss","webpack://./src/sass/layouts/_header.scss","webpack://./src/sass/layouts/_main.scss","webpack://./src/sass/layouts/_editor.scss","webpack://./src/sass/layouts/_footer.scss","webpack://./src/sass/layouts/_modal.scss","webpack://./src/sass/layouts/_menu.scss","webpack://./src/sass/layouts/_pokemon.scss"],"names":[],"mappings":"AAAA,gBAAgB;ACAhB,2EAAA;AAEA;+EAAA;AAGA;;;EAAA;AAKA;EACE,iBAAA,EAAA,MAAA;EACA,8BAAA,EAAA,MAAA;ADDF;;ACIA;+EAAA;AAGA;;EAAA;AAIA;EACE,SAAA;ADHF;;ACMA;;EAAA;AAIA;EACE,cAAA;ADJF;;ACOA;;;EAAA;AAKA;EACE,cAAA;EACA,gBAAA;ADLF;;ACQA;+EAAA;AAGA;;;EAAA;AAKA;EACE,uBAAA,EAAA,MAAA;EACA,SAAA,EAAA,MAAA;EACA,iBAAA,EAAA,MAAA;ADPF;;ACUA;;;EAAA;AAKA;EACE,iCAAA,EAAA,MAAA;EACA,cAAA,EAAA,MAAA;ADRF;;ACWA;+EAAA;AAGA;;EAAA;AAIA;EACE,6BAAA;ADVF;;ACaA;;;EAAA;AAKA;EACE,mBAAA,EAAA,MAAA;EACA,0BAAA,EAAA,MAAA;EACA,iCAAA,EAAA,MAAA;ADXF;;ACcA;;EAAA;AAIA;;EAEE,mBAAA;ADZF;;ACeA;;;EAAA;AAKA;;;EAGE,iCAAA,EAAA,MAAA;EACA,cAAA,EAAA,MAAA;ADbF;;ACgBA;;EAAA;AAIA;EACE,cAAA;ADdF;;ACiBA;;;EAAA;AAKA;;EAEE,cAAA;EACA,cAAA;EACA,kBAAA;EACA,wBAAA;ADfF;;ACkBA;EACE,eAAA;ADfF;;ACkBA;EACE,WAAA;ADfF;;ACkBA;+EAAA;AAGA;;EAAA;AAIA;EACE,kBAAA;ADjBF;;ACoBA;+EAAA;AAGA;;;EAAA;AAKA;;;;;EAKE,oBAAA,EAAA,MAAA;EACA,eAAA,EAAA,MAAA;EACA,iBAAA,EAAA,MAAA;EACA,SAAA,EAAA,MAAA;ADnBF;;ACsBA;;;EAAA;AAKA;QACQ,MAAA;EACN,iBAAA;ADpBF;;ACuBA;;;EAAA;AAKA;SACS,MAAA;EACP,oBAAA;ADrBF;;ACwBA;;EAAA;AAIA;;;;EAIE,0BAAA;ADtBF;;ACyBA;;EAAA;AAIA;;;;EAIE,kBAAA;EACA,UAAA;ADvBF;;AC0BA;;EAAA;AAIA;;;;EAIE,8BAAA;ADxBF;;AC2BA;;EAAA;AAIA;EACE,8BAAA;ADzBF;;AC4BA;;;;;EAAA;AAOA;EACE,sBAAA,EAAA,MAAA;EACA,cAAA,EAAA,MAAA;EACA,cAAA,EAAA,MAAA;EACA,eAAA,EAAA,MAAA;EACA,UAAA,EAAA,MAAA;EACA,mBAAA,EAAA,MAAA;AD1BF;;AC6BA;;EAAA;AAIA;EACE,wBAAA;AD3BF;;AC8BA;;EAAA;AAIA;EACE,cAAA;AD5BF;;AC+BA;;;EAAA;AAKA;;EAEE,sBAAA,EAAA,MAAA;EACA,UAAA,EAAA,MAAA;AD7BF;;ACgCA;;EAAA;AAIA;;EAEE,YAAA;AD9BF;;ACiCA;;;EAAA;AAKA;EACE,6BAAA,EAAA,MAAA;EACA,oBAAA,EAAA,MAAA;AD/BF;;ACkCA;;EAAA;AAIA;EACE,wBAAA;ADhCF;;ACmCA;;;EAAA;AAKA;EACE,0BAAA,EAAA,MAAA;EACA,aAAA,EAAA,MAAA;ADjCF;;ACoCA;+EAAA;AAGA;;EAAA;AAIA;EACE,cAAA;ADnCF;;ACsCA;;EAAA;AAIA;EACE,kBAAA;ADpCF;;ACuCA;+EAAA;AAGA;;EAAA;AAIA;EACE,aAAA;ADtCF;;ACyCA;;EAAA;AAIA;EACE,aAAA;ADvCF;;AEpTA;EACE,yCAAA;AFuTF;;AEpTA;EACE,6BAAA;AFuTF;;AG5TA;EACE,eAAA;AH+TF;;AG5TA;ECHE,iBDKqB;ECJrB,kBAFyD;EAGzD,mBDGuD;ECFvD,mBDEsC;AHiUxC;;AG9TA;EACE,aAAA;EACA,sBAAA;EACA,aAAA;AHiUF;;AG9TA;EACE,yBEfU;EFgBV,cEfW;EFgBX,iDAAA;AHiUF;;AG9TA;EACE,aAAA;EACA,sBAAA;EACA,cAAA;EAEA,yDAAA;EACA,sBAAA;EACA,4BAAA;AHgUF;;AG7TA;EACE,yBAAA;EACA,mBAAA;EACA,6BAAA;EAEA,eAAA;EACA,iBAAA;AH+TF;;AG5TA;EACE,yBEvCW;EFwCX,cE1CY;ALyWd;;AMzWA;;;EAGE,8BAAA;EACA,2BAAA;EACA,sBAAA;AN4WF;;AMzWA;EACE,WAAA;EACA,cAAA;AN4WF;;AMzWA,gBAAA;AACA;EACE,kBAAA;EACA,YAAA;EACA,aAAA;EACA,gBAAA;EACA,uBAAA;EACA,kBAAA;EACA,gBAAA;EACA,wCAAA;EACA,qFAAA;AN4WF;;AMxWA;EACE,kDAAA;AN2WF;;AMxWA;;EAEE,WAAA;EACA,kBAAA;AN2WF;;AMxWA;EACE,eAAA;EACA,WAAA;EACA,WAAA;AN2WF;;AMxWA;EACE,qBAAA;EACA,WAAA;EACA,YAAA;EACA,gBAAA;AN2WF;;AMxWA;EACE,kBAAA;EACA,qBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,mBAAA;EACA,uBAAA;EACA,kBAAA;EACA,WAAA;EACA,4BAAA;EACA,iCAAA;AN2WF;;AMxWA,cAAA;AACA;EACE;IACE,gBAAA;EN2WF;EMxWA;IACE,mBAAA;EN0WF;AACF;AMvWA;EACE;IACE,oCAAA;ENyWF;EMtWA;IACE,6CAAA;ENwWF;EMrWA;IACE,2CAAA;ENuWF;EMpWA;IACE,6CAAA;ENsWF;EMnWA;IACE,2CAAA;ENqWF;EMlWA;IACE,oCAAA;ENoWF;AACF;AMjWA;EACE;IACE,WAAA;ENmWF;EMhWA;IACE,MAAA;ENkWF;EM/VA;IACE,UAAA;ENiWF;EM9VA;IACE,MAAA;ENgWF;AACF;AOpdA;EACE,aAAA;EACA,sBAAA;EACA,uBAAA;EACA,mBAAA;EACA,cAAA;EACA,aAAA;APsdF;;AOndA;EACE,YAAA;EACA,YAAA;EACA,yDAAA;EACA,wBAAA;EACA,4BAAA;APsdF;;AOndA;EACE,SAAA;EHjBA,iBGkBqB;EHjBrB,kBAFyD;EAGzD,iBGgBuD;EHfvD,mBGesC;APydxC;;AOtdA;EACE,eAAA;APydF;;AQhfA;EACE,aAAA;EACA,sBAAA;EACA,mBAAA;EACA,YAAA;ARmfF;;AQhfA;EACE,eAAA;EACA,iBAAA;EACA,kBAAA;ARmfF;;AQhfA;EACE,aAAA;EACA,6BAAA;EACA,mBAAA;EACA,eAAA;ARmfF;;AQhfA;EACE,YAAA;ARmfF;;AQhfA;EACE;IACE,eAAA;IACA,iBAAA;ERmfF;EQ/eA;IACE,YAAA;ERifF;AACF;AQ7eA;EACE;IACE,YAAA;ER+eF;EQ5eA;IACE,eAAA;IACA,iBAAA;ER8eF;AACF;AS3hBA;EACE,aAAA;EACA,cAAA;EACA,0BAAA;EACA,kDAAA;EACA,aAAA;AT6hBF;AS3hBE;EACE,yBJRU;EISV,SAAA;EACA,kBAAA;EACA,cJTS;ALsiBb;;ASzhBA;;EAEE,aAAA;EACA,kBAAA;AT4hBF;;ASzhBA;EACE,yBJtBY;EIuBZ,WAAA;EACA,aAAA;AT4hBF;;ASzhBA;EACE;IACE,wBAAA;ET4hBF;ESzhBA;IACE,4BAAA;ET2hBF;ESxhBA;IACE,2BAAA;ET0hBF;ESvhBA;IACE,4BAAA;ETyhBF;ESthBA;IACE,2BAAA;ETwhBF;ESrhBA;IACE,wBAAA;ETuhBF;AACF;ASphBA;EACE,oCAAA;ATshBF;;ASnhBA;EACE,kBAAA;EACA,YAAA;EACA,WAAA;EACA,WAAA;EACA,YAAA;ATshBF;;ASnhBA;EACE;IACE,aAAA;ETshBF;AACF;AU1lBA;EACE,cAAA;EAEA,cLDW;EKGX,aAAA;EACA,6BAAA;EACA,mBAAA;EACA,iDAAA;EACA,0BAAA;AV0lBF;;AUvlBA;EACE,eAAA;AV0lBF;AUtlBE;EACE,sBAAA;AVwlBJ;;AUplBA;EACE,WAAA;EACA,YAAA;EACA,yDAAA;EACA,wBAAA;AVulBF;;AUplBA;EACE,WAAA;EACA,YAAA;EACA,yDAAA;EACA,wBAAA;EACA,4BAAA;AVulBF;;AUplBA;EACE,iDAAA;AVulBF;;AW7nBA;EACE,aAAA;EACA,mBAAA;EACA,uBAAA;EACA,0BAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,WAAA;EACA,MAAA;EACA,OAAA;EACA,yBAAA;EACA,UAAA;AXgoBF;AW9nBE;EACE,UAAA;EACA,UAAA;AXgoBJ;;AW5nBA;EACE,aAAA;EACA,sBAAA;EACA,mBAAA;EACA,yBNxBY;EMyBZ,mBAAA;EACA,aAAA;AX+nBF;;AW5nBA;EACE,UAAA;EACA,mBAAA;EACA,kDAAA;AX+nBF;;AW5nBA;EACE,aAAA;AX+nBF;;AW5nBA;EACE,YAAA;EACA,YAAA;EACA,yBAAA;EACA,mBAAA;EACA,6BAAA;EAEA,eAAA;EACA,iBAAA;AX8nBF;;AW3nBA;EACE,yBNjDW;EMkDX,cNpDY;ALkrBd;;AW3nBA;EACE,iBAAA;AX8nBF;;AW3nBA;EACE,aAAA;EACA,sBAAA;EACA,mBAAA;EACA,iBAAA;EACA,UAAA;AX8nBF;;AW3nBA;EACE,iBAAA;EACA,iBAAA;AX8nBF;;AW3nBA;EACE,mBAAA;AX8nBF;;AYvsBA;EACE,aAAA;EACA,eAAA;EACA,sBAAA;EACA,YAAA;EACA,8BAAA;EACA,eAAA;EACA,SAAA;EACA,WAAA;EACA,WAAA;EACA,UAAA;EACA,yBAAA;AZ0sBF;AYxsBE;EACE,WAAA;EACA,WAAA;EACA,yBPdS;ALwtBb;AYvsBE;EACE,2CAAA;AZysBJ;;AYrsBA;EACE,aAAA;EACA,gBAAA;EACA,UAAA;EACA,SAAA;AZwsBF;AYtsBE;EACE,mBAAA;AZwsBJ;AYpsBE;EACE,iBAAA;EACA,eAAA;EACA,gBAAA;AZssBJ;AYpsBI;EACE,cPxCM;EOyCN,0BAAA;AZssBN;AYnsBI;EACE,cP7CM;EO8CN,iBAAA;EACA,mBAAA;EACA,eAAA;AZqsBN;;AYhsBA;EACE,aAAA;EACA,sBAAA;EACA,6BAAA;EACA,mBAAA;EACA,YAAA;EACA,YAAA;EACA,eAAA;EACA,aAAA;EACA,MAAA;EACA,yBAAA;EACA,UAAA;EACA,mBPlEY;EOmEZ,eAAA;AZmsBF;;AYhsBA;EACE,QAAA;EACA,oCAAA;AZmsBF;;AYhsBA;EACE,sBAAA;AZmsBF;;AY/rBA;EACE,0BAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,WAAA;EACA,MAAA;EACA,OAAA;EACA,yBAAA;EACA,UAAA;AZksBF;AYhsBE;EACE,UAAA;EACA,UAAA;AZksBJ;;AY9rBA;EACE,gBAAA;AZisBF;;AY9rBA;EACE,kBAAA;AZisBF;;AY9rBA;EACE,YAAA;EACA,YAAA;EACA,yBAAA;EACA,mBAAA;EACA,6BAAA;EAEA,eAAA;EACA,iBAAA;AZgsBF;;AY7rBA;EACE,yBPnHW;EOoHX,cPtHY;ALszBd;;AatzBA;EACE,kDAAA;AbyzBF;;AatzBA;EACE;IACE,mBAAA;EbyzBF;EatzBA;IACE,qBAAA;EbwzBF;EarzBA;IACE,mBAAA;EbuzBF;AACF;AapzBA;EACE,6BAAA;AbszBF;;AanzBA;EACE,YAAA;EACA,cAAA;AbszBF;;AanzBA;EACE;IACE,WAAA;IACA,cAAA;EbszBF;AACF","sourcesContent":["@charset \"UTF-8\";\n/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */\n/* Document\n   ========================================================================== */\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in iOS.\n */\nhtml {\n  line-height: 1.15; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\n\n/* Sections\n   ========================================================================== */\n/**\n * Remove the margin in all browsers.\n */\nbody {\n  margin: 0;\n}\n\n/**\n * Render the `main` element consistently in IE.\n */\nmain {\n  display: block;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n/* Grouping content\n   ========================================================================== */\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/* Text-level semantics\n   ========================================================================== */\n/**\n * Remove the gray background on active links in IE 10.\n */\na {\n  background-color: transparent;\n}\n\n/**\n * 1. Remove the bottom border in Chrome 57-\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct font size in all browsers.\n */\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n/**\n * Remove the border on images inside links in IE 10.\n */\nimg {\n  border-style: none;\n}\n\n/* Forms\n   ========================================================================== */\n/**\n * 1. Change the font styles in all browsers.\n * 2. Remove the margin in Firefox and Safari.\n */\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * Correct the inability to style clickable types in iOS and Safari.\n */\nbutton,\n[type=button],\n[type=reset],\n[type=submit] {\n  -webkit-appearance: button;\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\nbutton::-moz-focus-inner,\n[type=button]::-moz-focus-inner,\n[type=reset]::-moz-focus-inner,\n[type=submit]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\nbutton:-moz-focusring,\n[type=button]:-moz-focusring,\n[type=reset]:-moz-focusring,\n[type=submit]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Correct the padding in Firefox.\n */\nfieldset {\n  padding: 0.35em 0.75em 0.625em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\nprogress {\n  vertical-align: baseline;\n}\n\n/**\n * Remove the default vertical scrollbar in IE 10+.\n */\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10.\n * 2. Remove the padding in IE 10.\n */\n[type=checkbox],\n[type=radio] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n[type=number]::-webkit-inner-spin-button,\n[type=number]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n[type=search] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding in Chrome and Safari on macOS.\n */\n[type=search]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/* Interactive\n   ========================================================================== */\n/*\n * Add the correct display in Edge, IE 10+, and Firefox.\n */\ndetails {\n  display: block;\n}\n\n/*\n * Add the correct display in all browsers.\n */\nsummary {\n  display: list-item;\n}\n\n/* Misc\n   ========================================================================== */\n/**\n * Add the correct display in IE 10+.\n */\ntemplate {\n  display: none;\n}\n\n/**\n * Add the correct display in IE 10.\n */\n[hidden] {\n  display: none;\n}\n\nbody {\n  font-family: \"Ysabeau Infant\", sans-serif;\n}\n\n.reset-btn, .modal-btn, .footer__link, .btn {\n  transition: all 0.3s ease-out;\n}\n\nhtml {\n  font-size: 10px;\n}\n\nbody {\n  font-size: 1.6rem;\n  font-style: normal;\n  font-weight: normal;\n  line-height: 2.6rem;\n}\n\n.container {\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n}\n\n#root {\n  background-color: #2f8bcc;\n  color: #111042;\n  text-shadow: 0px 0px 3px rgba(255, 255, 255, 0.5);\n}\n\n.background {\n  display: flex;\n  flex-direction: column;\n  flex: 1 0 auto;\n  background-image: url(\"../assets/landscape.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n}\n\n.btn {\n  border: 2px solid #111042;\n  border-radius: 1rem;\n  background-color: transparent;\n  cursor: pointer;\n  font-size: larger;\n}\n\n.btn:hover {\n  background-color: #111042;\n  color: #ffffff;\n}\n\n*,\n*:before,\n*:after {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.pokeball__container {\n  z-index: 10;\n  margin: 0 3rem;\n}\n\n/* Poké Styles */\n.pokeball {\n  position: relative;\n  width: 200px;\n  height: 200px;\n  background: #fff;\n  border: 10px solid #000;\n  border-radius: 50%;\n  overflow: hidden;\n  box-shadow: inset -10px 10px 0 10px #ccc;\n  animation: fall 0.25s ease-in-out, shake 1.25s cubic-bezier(0.36, 0.07, 0.19, 0.97) 2;\n}\n\n.finish {\n  animation: activeAnimation 1s infinite ease-in-out;\n}\n\n.pokeball::before,\n.pokeball::after {\n  content: \"\";\n  position: absolute;\n}\n\n.pokeball::before {\n  background: red;\n  width: 100%;\n  height: 50%;\n}\n\n.pokeball::after {\n  top: calc(50% - 10px);\n  width: 100%;\n  height: 20px;\n  background: #000;\n}\n\n.pokeball__button {\n  position: absolute;\n  top: calc(50% - 30px);\n  left: calc(50% - 30px);\n  width: 60px;\n  height: 60px;\n  background: #7f8c8d;\n  border: 10px solid #fff;\n  border-radius: 50%;\n  z-index: 10;\n  box-shadow: 0 0 0 10px black;\n  animation: blink 0.5s alternate 5;\n}\n\n/* Animation */\n@keyframes blink {\n  from {\n    background: #eee;\n  }\n  to {\n    background: #e74c3c;\n  }\n}\n@keyframes shake {\n  0% {\n    transform: translate(0, 0) rotate(0);\n  }\n  20% {\n    transform: translate(-10px, 0) rotate(-20deg);\n  }\n  30% {\n    transform: translate(10px, 0) rotate(20deg);\n  }\n  50% {\n    transform: translate(-10px, 0) rotate(-10deg);\n  }\n  60% {\n    transform: translate(10px, 0) rotate(10deg);\n  }\n  100% {\n    transform: translate(0, 0) rotate(0);\n  }\n}\n@keyframes fall {\n  0% {\n    top: -200px;\n  }\n  60% {\n    top: 0;\n  }\n  80% {\n    top: -20px;\n  }\n  100% {\n    top: 0;\n  }\n}\n.header {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  flex-shrink: 0;\n  padding: 1rem;\n}\n\n.header__logo {\n  width: 20rem;\n  height: 7rem;\n  background-image: url(\"../assets/pokémon_logo.png\");\n  background-size: contain;\n  background-repeat: no-repeat;\n}\n\n.header__title {\n  margin: 0;\n  font-size: 2.5rem;\n  font-style: normal;\n  font-weight: bold;\n  line-height: 2.6rem;\n}\n\n.header__link {\n  cursor: pointer;\n}\n\n.main {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  flex-grow: 1;\n}\n\n.task-title {\n  font-size: 7rem;\n  line-height: 7rem;\n  text-align: center;\n}\n\n.pokemons {\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  padding: 2rem 0;\n}\n\n.pokemon {\n  width: 20rem;\n}\n\n@media screen and (max-height: 800px) {\n  .task-title {\n    font-size: 5rem;\n    line-height: 6rem;\n  }\n  .pokemon {\n    width: 15rem;\n  }\n}\n@media screen and (max-width: 780px) {\n  .pokemon {\n    width: 10rem;\n  }\n  .task-title {\n    font-size: 5rem;\n    line-height: 6rem;\n  }\n}\n.editor {\n  display: flex;\n  min-width: 80%;\n  backdrop-filter: blur(3px);\n  box-shadow: 4px 4px 10px 0px rgba(17, 16, 66, 0.5);\n  padding: 1rem;\n}\n.editor__header {\n  background-color: #ffffff;\n  margin: 0;\n  text-align: center;\n  color: #111042;\n}\n\n#css-editor,\n#html-viewer {\n  flex: 1 1 50%;\n  position: relative;\n}\n\n.cm-editor {\n  background-color: #ffffff;\n  width: 100%;\n  height: 30rem;\n}\n\n@keyframes shakeEditor {\n  0% {\n    transform: translateX(0);\n  }\n  20% {\n    transform: translateX(-10px);\n  }\n  40% {\n    transform: translateX(10px);\n  }\n  60% {\n    transform: translateX(-10px);\n  }\n  80% {\n    transform: translateX(10px);\n  }\n  100% {\n    transform: translateX(0);\n  }\n}\n.shake {\n  animation: shakeEditor 0.5s infinite;\n}\n\n.enter-btn {\n  position: absolute;\n  bottom: 1rem;\n  right: 1rem;\n  width: 8rem;\n  height: 3rem;\n}\n\n@media screen and (max-height: 800px) {\n  .cm-editor {\n    height: 20rem;\n  }\n}\n.footer {\n  flex-shrink: 0;\n  color: #111042;\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  box-shadow: 0 -1px 10px 5px rgba(17, 16, 66, 0.5);\n  backdrop-filter: blur(3px);\n}\n\n.footer__link {\n  cursor: pointer;\n}\n.footer__link:hover {\n  transform: scale(1.05);\n}\n\n.github-icon {\n  width: 4rem;\n  height: 4rem;\n  background-image: url(\"../assets/mystic-logo.png\");\n  background-size: contain;\n}\n\n.rss-icon {\n  width: 8rem;\n  height: 4rem;\n  background-image: url(\"../assets/rss.svg\");\n  background-size: contain;\n  background-repeat: no-repeat;\n}\n\n.footer__year {\n  text-shadow: 0px 0px 3px rgba(255, 255, 255, 0.5);\n}\n\n.overlay-modal {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  backdrop-filter: blur(3px);\n  width: 100%;\n  height: 100%;\n  position: fixed;\n  z-index: -2;\n  top: 0;\n  left: 0;\n  transition: all 0.5s ease;\n  opacity: 0;\n}\n.overlay-modal.active {\n  opacity: 1;\n  z-index: 2;\n}\n\n.modal-content {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  background-color: #ffffff;\n  border-radius: 1rem;\n  padding: 1rem;\n}\n\n.modal {\n  width: 70%;\n  border-radius: 1rem;\n  box-shadow: 4px 4px 10px 0px rgba(17, 16, 66, 0.5);\n}\n\n.modal-btn-container {\n  padding: 2rem;\n}\n\n.modal-btn {\n  width: 25rem;\n  height: 4rem;\n  border: 2px solid #111042;\n  border-radius: 1rem;\n  background-color: transparent;\n  cursor: pointer;\n  font-size: larger;\n}\n\n.modal-btn:hover {\n  background-color: #111042;\n  color: #ffffff;\n}\n\n.modal-content__image {\n  padding-top: 1rem;\n}\n\n.modal-content__info {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  padding-top: 1rem;\n  width: 80%;\n}\n\n.modal-content__info-title {\n  font-weight: bold;\n  font-size: larger;\n}\n\n.modal-content__info-text {\n  text-align: justify;\n}\n\n.burger {\n  display: flex;\n  cursor: pointer;\n  flex-direction: column;\n  height: 22px;\n  justify-content: space-between;\n  position: fixed;\n  top: 35px;\n  right: 20px;\n  width: 29px;\n  z-index: 2;\n  transition: all 0.4s ease;\n}\n.burger .bar {\n  width: 100%;\n  height: 2px;\n  background-color: #111042;\n}\n.burger.active {\n  transform: rotate(90deg) translate(14px, 0);\n}\n\n.nav-links {\n  display: flex;\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n.nav-links li {\n  margin-bottom: 1rem;\n}\n.nav-links__item {\n  font-size: larger;\n  cursor: pointer;\n  transition: 0.3s;\n}\n.nav-links__item:hover {\n  color: #2f8bcc;\n  text-decoration: underline;\n}\n.nav-links__item-active {\n  color: #2f8bcc;\n  font-weight: bold;\n  padding-bottom: 3px;\n  cursor: default;\n}\n\n.menu-container {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-evenly;\n  align-items: center;\n  width: 25rem;\n  height: 100%;\n  position: fixed;\n  right: -25rem;\n  top: 0;\n  transition: all 0.5s ease;\n  z-index: 1;\n  background: #ffffff;\n  padding: 0 5rem;\n}\n\n.menu-container.active {\n  right: 0;\n  box-shadow: -1px 0px 5px 0px #111042;\n}\n\n.menu {\n  flex-direction: column;\n}\n\n.overlay {\n  backdrop-filter: blur(3px);\n  width: 100%;\n  height: 100%;\n  position: fixed;\n  z-index: -1;\n  top: 0;\n  left: 0;\n  transition: all 0.5s ease;\n  opacity: 0;\n}\n.overlay.active {\n  opacity: 1;\n  z-index: 1;\n}\n\n.body-overflow {\n  overflow: hidden;\n}\n\n.menu-title {\n  text-align: center;\n}\n\n.reset-btn {\n  width: 15rem;\n  height: 4rem;\n  border: 2px solid #111042;\n  border-radius: 1rem;\n  background-color: transparent;\n  cursor: pointer;\n  font-size: larger;\n}\n\n.reset-btn:hover {\n  background-color: #111042;\n  color: #ffffff;\n}\n\n.active-image {\n  animation: activeAnimation 1s infinite ease-in-out;\n}\n\n@keyframes activeAnimation {\n  0% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(1.1);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n.active {\n  animation-play-state: running;\n}\n\n.tiny {\n  width: 10rem;\n  margin: 0 2rem;\n}\n\n@media screen and (max-width: 780px) {\n  .tiny {\n    width: 7rem;\n    margin: 0 1rem;\n  }\n}","/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in iOS.\n */\n\nhtml {\n  line-height: 1.15; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\n\n/* Sections\n   ========================================================================== */\n\n/**\n * Remove the margin in all browsers.\n */\n\nbody {\n  margin: 0;\n}\n\n/**\n * Render the `main` element consistently in IE.\n */\n\nmain {\n  display: block;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\n\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n/* Grouping content\n   ========================================================================== */\n\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\n\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/* Text-level semantics\n   ========================================================================== */\n\n/**\n * Remove the gray background on active links in IE 10.\n */\n\na {\n  background-color: transparent;\n}\n\n/**\n * 1. Remove the bottom border in Chrome 57-\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\n\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct font size in all browsers.\n */\n\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n\n/**\n * Remove the border on images inside links in IE 10.\n */\n\nimg {\n  border-style: none;\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers.\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button;\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Correct the padding in Firefox.\n */\n\nfieldset {\n  padding: 0.35em 0.75em 0.625em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  vertical-align: baseline;\n}\n\n/**\n * Remove the default vertical scrollbar in IE 10+.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10.\n * 2. Remove the padding in IE 10.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/* Interactive\n   ========================================================================== */\n\n/*\n * Add the correct display in Edge, IE 10+, and Firefox.\n */\n\ndetails {\n  display: block;\n}\n\n/*\n * Add the correct display in all browsers.\n */\n\nsummary {\n  display: list-item;\n}\n\n/* Misc\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 10+.\n */\n\ntemplate {\n  display: none;\n}\n\n/**\n * Add the correct display in IE 10.\n */\n\n[hidden] {\n  display: none;\n}\n","%font-prim {\r\n  font-family: 'Ysabeau Infant', sans-serif;\r\n}\r\n\r\n%transition {\r\n  transition: all .3s ease-out;\r\n}","html {\r\n  font-size: 10px;\r\n}\r\n\r\nbody {\r\n  @extend %font-prim;\r\n  @include font($size: 1.6rem, $height: 2.6rem, $weight: normal);\r\n}\r\n\r\n.container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  height: 100vh;\r\n}\r\n\r\n#root {\r\n  background-color: $color-sky;\r\n  color: $color-dark;\r\n  text-shadow: 0px 0px 3px rgba(255, 255, 255, 0.5);\r\n}\r\n\r\n.background {\r\n  display: flex;\r\n  flex-direction: column;\r\n  flex: 1 0 auto;\r\n\r\n  background-image: url('../assets/landscape.jpg');\r\n  background-size: cover;\r\n  background-repeat: no-repeat;\r\n}\r\n\r\n.btn {\r\n  border: 2px solid $color-dark;\r\n  border-radius: 1rem;\r\n  background-color: transparent;\r\n  @extend %transition;\r\n  cursor: pointer;\r\n  font-size: larger;\r\n}\r\n\r\n.btn:hover {\r\n  background-color: $color-dark;\r\n  color: $color-light;\r\n}","@mixin font ($size, $height: $size, $weight: bold, $style: normal) {\r\n  font-size: $size;\r\n  font-style: $style;\r\n  font-weight: $weight;\r\n  line-height: $height;\r\n}\r\n\r\n@mixin gridSize($size) {\r\n  grid-template-columns: repeat($size, 3rem);\r\n}","$color-light: #ffffff;\r\n$color-sky: #2f8bcc;\r\n$color-dark: #111042;","*,\r\n*:before,\r\n*:after {\r\n  -webkit-box-sizing: border-box;\r\n  -moz-box-sizing: border-box;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.pokeball__container {\r\n  z-index: 10;\r\n  margin: 0 3rem;\r\n}\r\n\r\n/* Poké Styles */\r\n.pokeball {\r\n  position: relative;\r\n  width: 200px;\r\n  height: 200px;\r\n  background: #fff;\r\n  border: 10px solid #000;\r\n  border-radius: 50%;\r\n  overflow: hidden;\r\n  box-shadow: inset -10px 10px 0 10px #ccc;\r\n  animation: fall .25s ease-in-out,\r\n    shake 1.25s cubic-bezier(.36, .07, .19, .97) 2;\r\n}\r\n\r\n.finish {\r\n  animation: activeAnimation 1s infinite ease-in-out;\r\n}\r\n\r\n.pokeball::before,\r\n.pokeball::after {\r\n  content: \"\";\r\n  position: absolute;\r\n}\r\n\r\n.pokeball::before {\r\n  background: red;\r\n  width: 100%;\r\n  height: 50%;\r\n}\r\n\r\n.pokeball::after {\r\n  top: calc(50% - 10px);\r\n  width: 100%;\r\n  height: 20px;\r\n  background: #000;\r\n}\r\n\r\n.pokeball__button {\r\n  position: absolute;\r\n  top: calc(50% - 30px);\r\n  left: calc(50% - 30px);\r\n  width: 60px;\r\n  height: 60px;\r\n  background: #7f8c8d;\r\n  border: 10px solid #fff;\r\n  border-radius: 50%;\r\n  z-index: 10;\r\n  box-shadow: 0 0 0 10px black;\r\n  animation: blink .5s alternate 5;\r\n}\r\n\r\n/* Animation */\r\n@keyframes blink {\r\n  from {\r\n    background: #eee;\r\n  }\r\n\r\n  to {\r\n    background: #e74c3c;\r\n  }\r\n}\r\n\r\n@keyframes shake {\r\n  0% {\r\n    transform: translate(0, 0) rotate(0);\r\n  }\r\n\r\n  20% {\r\n    transform: translate(-10px, 0) rotate(-20deg);\r\n  }\r\n\r\n  30% {\r\n    transform: translate(10px, 0) rotate(20deg);\r\n  }\r\n\r\n  50% {\r\n    transform: translate(-10px, 0) rotate(-10deg);\r\n  }\r\n\r\n  60% {\r\n    transform: translate(10px, 0) rotate(10deg);\r\n  }\r\n\r\n  100% {\r\n    transform: translate(0, 0) rotate(0);\r\n  }\r\n}\r\n\r\n@keyframes fall {\r\n  0% {\r\n    top: -200px\r\n  }\r\n\r\n  60% {\r\n    top: 0\r\n  }\r\n\r\n  80% {\r\n    top: -20px\r\n  }\r\n\r\n  100% {\r\n    top: 0\r\n  }\r\n}",".header {\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n  flex-shrink: 0;\r\n  padding: 1rem;\r\n}\r\n\r\n.header__logo {\r\n  width: 20rem;\r\n  height: 7rem;\r\n  background-image: url('../assets/pokémon_logo.png');\r\n  background-size: contain;\r\n  background-repeat: no-repeat;\r\n}\r\n\r\n.header__title {\r\n  margin: 0;\r\n  @include font($size: 2.5rem, $height: 2.6rem, $weight: bold);\r\n}\r\n\r\n.header__link {\r\n  cursor: pointer;\r\n}",".main {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  flex-grow: 1;\r\n}\r\n\r\n.task-title {\r\n  font-size: 7rem;\r\n  line-height: 7rem;\r\n  text-align: center;\r\n}\r\n\r\n.pokemons {\r\n  display: flex;\r\n  justify-content: space-around;\r\n  align-items: center;\r\n  padding: 2rem 0;\r\n}\r\n\r\n.pokemon {\r\n  width: 20rem;\r\n}\r\n\r\n@media screen and (max-height: 800px) {\r\n  .task-title {\r\n    font-size: 5rem;\r\n    line-height: 6rem;\r\n  }\r\n\r\n\r\n  .pokemon {\r\n    width: 15rem;\r\n  }\r\n\r\n}\r\n\r\n@media screen and (max-width: 780px) {\r\n  .pokemon {\r\n    width: 10rem;\r\n  }\r\n\r\n  .task-title {\r\n    font-size: 5rem;\r\n    line-height: 6rem;\r\n  }\r\n}",".editor {\r\n  display: flex;\r\n  min-width: 80%;\r\n  backdrop-filter: blur(3px);\r\n  box-shadow: 4px 4px 10px 0px rgba(17, 16, 66, 0.5);\r\n  padding: 1rem;\r\n\r\n  &__header {\r\n    background-color: $color-light;\r\n    margin: 0;\r\n    text-align: center;\r\n    color: $color-dark;\r\n  }\r\n}\r\n\r\n#css-editor,\r\n#html-viewer {\r\n  flex: 1 1 50%;\r\n  position: relative;\r\n}\r\n\r\n.cm-editor {\r\n  background-color: $color-light;\r\n  width: 100%;\r\n  height: 30rem;\r\n}\r\n\r\n@keyframes shakeEditor {\r\n  0% {\r\n    transform: translateX(0);\r\n  }\r\n\r\n  20% {\r\n    transform: translateX(-10px);\r\n  }\r\n\r\n  40% {\r\n    transform: translateX(10px);\r\n  }\r\n\r\n  60% {\r\n    transform: translateX(-10px);\r\n  }\r\n\r\n  80% {\r\n    transform: translateX(10px);\r\n  }\r\n\r\n  100% {\r\n    transform: translateX(0);\r\n  }\r\n}\r\n\r\n.shake {\r\n  animation: shakeEditor 0.5s infinite;\r\n}\r\n\r\n.enter-btn {\r\n  position: absolute;\r\n  bottom: 1rem;\r\n  right: 1rem;\r\n  width: 8rem;\r\n  height: 3rem;\r\n}\r\n\r\n@media screen and (max-height: 800px) {\r\n  .cm-editor {\r\n    height: 20rem;\r\n  }\r\n}",".footer {\r\n  flex-shrink: 0;\r\n\r\n  color: $color-dark;\r\n\r\n  display: flex;\r\n  justify-content: space-around;\r\n  align-items: center;\r\n  box-shadow: 0 -1px 10px 5px rgba(17, 16, 66, 0.5);\r\n  backdrop-filter: blur(3px);\r\n}\r\n\r\n.footer__link {\r\n  cursor: pointer;\r\n  @extend %transition;\r\n\r\n\r\n  &:hover {\r\n    transform: scale(1.05);\r\n  }\r\n}\r\n\r\n.github-icon {\r\n  width: 4rem;\r\n  height: 4rem;\r\n  background-image: url(\"../assets/mystic-logo.png\");\r\n  background-size: contain;\r\n}\r\n\r\n.rss-icon {\r\n  width: 8rem;\r\n  height: 4rem;\r\n  background-image: url(\"../assets/rss.svg\");\r\n  background-size: contain;\r\n  background-repeat: no-repeat;\r\n}\r\n\r\n.footer__year {\r\n  text-shadow: 0px 0px 3px rgba(255, 255, 255, 0.5);\r\n}",".overlay-modal {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  backdrop-filter: blur(3px);\r\n  width: 100%;\r\n  height: 100%;\r\n  position: fixed;\r\n  z-index: -2;\r\n  top: 0;\r\n  left: 0;\r\n  transition: all 0.5s ease;\r\n  opacity: 0;\r\n\r\n  &.active {\r\n    opacity: 1;\r\n    z-index: 2;\r\n  }\r\n}\r\n\r\n.modal-content {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  background-color: $color-light;\r\n  border-radius: 1rem;\r\n  padding: 1rem;\r\n}\r\n\r\n.modal {\r\n  width: 70%;\r\n  border-radius: 1rem;\r\n  box-shadow: 4px 4px 10px 0px rgba(17, 16, 66, 0.5);\r\n}\r\n\r\n.modal-btn-container {\r\n  padding: 2rem;\r\n}\r\n\r\n.modal-btn {\r\n  width: 25rem;\r\n  height: 4rem;\r\n  border: 2px solid $color-dark;\r\n  border-radius: 1rem;\r\n  background-color: transparent;\r\n  @extend %transition;\r\n  cursor: pointer;\r\n  font-size: larger;\r\n}\r\n\r\n.modal-btn:hover {\r\n  background-color: $color-dark;\r\n  color: $color-light;\r\n}\r\n\r\n.modal-content__image {\r\n  padding-top: 1rem;\r\n}\r\n\r\n.modal-content__info {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  padding-top: 1rem;\r\n  width: 80%;\r\n}\r\n\r\n.modal-content__info-title {\r\n  font-weight: bold;\r\n  font-size: larger;\r\n}\r\n\r\n.modal-content__info-text {\r\n  text-align: justify;\r\n}",".burger {\r\n  display: flex;\r\n  cursor: pointer;\r\n  flex-direction: column;\r\n  height: 22px;\r\n  justify-content: space-between;\r\n  position: fixed;\r\n  top: 35px;\r\n  right: 20px;\r\n  width: 29px;\r\n  z-index: 2;\r\n  transition: all 0.4s ease;\r\n\r\n  .bar {\r\n    width: 100%;\r\n    height: 2px;\r\n    background-color: $color-dark;\r\n  }\r\n\r\n  &.active {\r\n    transform: rotate(90deg) translate(14px, 0);\r\n  }\r\n}\r\n\r\n.nav-links {\r\n  display: flex;\r\n  list-style: none;\r\n  padding: 0;\r\n  margin: 0;\r\n\r\n  li {\r\n    margin-bottom: 1rem;\r\n  }\r\n\r\n\r\n  &__item {\r\n    font-size: larger;\r\n    cursor: pointer;\r\n    transition: 0.3s;\r\n\r\n    &:hover {\r\n      color: $color-sky;\r\n      text-decoration: underline;\r\n    }\r\n\r\n    &-active {\r\n      color: $color-sky;\r\n      font-weight: bold;\r\n      padding-bottom: 3px;\r\n      cursor: default;\r\n    }\r\n  }\r\n}\r\n\r\n.menu-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: space-evenly;\r\n  align-items: center;\r\n  width: 25rem;\r\n  height: 100%;\r\n  position: fixed;\r\n  right: -25rem;\r\n  top: 0;\r\n  transition: all 0.5s ease;\r\n  z-index: 1;\r\n  background: $color-light;\r\n  padding: 0 5rem;\r\n}\r\n\r\n.menu-container.active {\r\n  right: 0;\r\n  box-shadow: -1px 0px 5px 0px $color-dark;\r\n}\r\n\r\n.menu {\r\n  flex-direction: column;\r\n}\r\n\r\n//Overlay menu\r\n.overlay {\r\n  backdrop-filter: blur(3px);\r\n  width: 100%;\r\n  height: 100%;\r\n  position: fixed;\r\n  z-index: -1;\r\n  top: 0;\r\n  left: 0;\r\n  transition: all 0.5s ease;\r\n  opacity: 0;\r\n\r\n  &.active {\r\n    opacity: 1;\r\n    z-index: 1;\r\n  }\r\n}\r\n\r\n.body-overflow {\r\n  overflow: hidden;\r\n}\r\n\r\n.menu-title {\r\n  text-align: center;\r\n}\r\n\r\n.reset-btn {\r\n  width: 15rem;\r\n  height: 4rem;\r\n  border: 2px solid $color-dark;\r\n  border-radius: 1rem;\r\n  background-color: transparent;\r\n  @extend %transition;\r\n  cursor: pointer;\r\n  font-size: larger;\r\n}\r\n\r\n.reset-btn:hover {\r\n  background-color: $color-dark;\r\n  color: $color-light;\r\n}",".active-image {\r\n  animation: activeAnimation 1s infinite ease-in-out;\r\n}\r\n\r\n@keyframes activeAnimation {\r\n  0% {\r\n    transform: scale(1);\r\n  }\r\n\r\n  50% {\r\n    transform: scale(1.1);\r\n  }\r\n\r\n  100% {\r\n    transform: scale(1);\r\n  }\r\n}\r\n\r\n.active {\r\n  animation-play-state: running;\r\n}\r\n\r\n.tiny {\r\n  width: 10rem;\r\n  margin: 0 2rem;\r\n}\r\n\r\n@media screen and (max-width: 780px) {\r\n  .tiny {\r\n    width: 7rem;\r\n    margin: 0 1rem;\r\n  }\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

module.exports = function cssWithMappingToString(item) {
  var _item = _slicedToArray(item, 4),
      content = _item[1],
      cssMapping = _item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    // eslint-disable-next-line no-undef
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    // eslint-disable-next-line no-param-reassign
    options = {};
  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign


  url = url && url.__esModule ? url.default : url;

  if (typeof url !== "string") {
    return url;
  } // If url is already wrapped in quotes, remove them


  if (/^['"].*['"]$/.test(url)) {
    // eslint-disable-next-line no-param-reassign
    url = url.slice(1, -1);
  }

  if (options.hash) {
    // eslint-disable-next-line no-param-reassign
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }

  return url;
};

/***/ }),

/***/ "./src/sass/styles.scss":
/*!******************************!*\
  !*** ./src/sass/styles.scss ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./styles.scss */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/styles.scss");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_scss__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_scss__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./src/consts.ts":
/*!***********************!*\
  !*** ./src/consts.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APP_INVITE_TEXT = exports.APP_DESCRIPTION = exports.APP_MODAL_TITLE = exports.POKEMON_COM_LINK = exports.RSS_LINK = exports.GITHUB_LINK = void 0;
exports.GITHUB_LINK = 'https://github.com/OKitel';
exports.RSS_LINK = 'https://rs.school/js/';
exports.POKEMON_COM_LINK = 'https://www.pokemon.com/us';
// Modal info text
exports.APP_MODAL_TITLE = '🔥 Calling all aspiring trainers and CSS enthusiasts! 🔥';
exports.APP_DESCRIPTION = "Dive into the world of Pokemon and sharpen your web styling abilities in an exciting new way. With this immersive simulator, you'll embark on a breath-catching journey where your CSS selectors are your ultimate Pokemon-catching tools!";
exports.APP_INVITE_TEXT = 'Are you ready to take your CSS selector skills to the next level?';


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__webpack_require__(/*! ./sass/styles.scss */ "./src/sass/styles.scss");
const menu_1 = __webpack_require__(/*! ./modules/menu */ "./src/modules/menu.ts");
const modal_1 = __importDefault(__webpack_require__(/*! ./modules/modal */ "./src/modules/modal.ts"));
const header_1 = __webpack_require__(/*! ./modules/header */ "./src/modules/header.ts");
const footer_1 = __importDefault(__webpack_require__(/*! ./modules/footer */ "./src/modules/footer.ts"));
const main_1 = __importDefault(__webpack_require__(/*! ./modules/main */ "./src/modules/main.ts"));
const level_1 = __webpack_require__(/*! ./modules/level */ "./src/modules/level.ts");
const render_1 = __importDefault(__webpack_require__(/*! ./modules/render */ "./src/modules/render.ts"));
const createView = () => {
    const root = document.getElementById('root');
    const container = document.createElement('div');
    container.classList.add('container');
    const header = (0, header_1.createHeaderView)();
    container.appendChild(header);
    const main = (0, main_1.default)();
    const footer = (0, footer_1.default)();
    const backgroundContainer = document.createElement('div');
    backgroundContainer.className = 'background';
    backgroundContainer.appendChild(main);
    backgroundContainer.appendChild(footer);
    container.appendChild(backgroundContainer);
    if (root) {
        root.appendChild(container);
    }
    (0, menu_1.initMenu)();
    if (localStorage.getItem('start') !== 'read') {
        (0, modal_1.default)();
    }
};
createView();
const currentLevel = (0, level_1.getCurrentLevel)();
(0, render_1.default)(currentLevel);


/***/ }),

/***/ "./src/modules/editor.ts":
/*!*******************************!*\
  !*** ./src/modules/editor.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shakeEditor = exports.initHtmlEditor = exports.getEditorValue = exports.initCssEditor = void 0;
const codemirror_1 = __webpack_require__(/*! codemirror */ "./node_modules/codemirror/dist/index.cjs");
const view_1 = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.cjs");
const lang_css_1 = __webpack_require__(/*! @codemirror/lang-css */ "./node_modules/@codemirror/lang-css/dist/index.cjs");
const lang_html_1 = __webpack_require__(/*! @codemirror/lang-html */ "./node_modules/@codemirror/lang-html/dist/index.cjs");
const level_1 = __webpack_require__(/*! ./level */ "./src/modules/level.ts");
const handleSubmit = (target) => {
    const userAnswer = target.state.doc.toString();
    (0, level_1.checkAnswer)(userAnswer);
    return true;
};
const keysMap = view_1.keymap.of([
    {
        key: 'Enter',
        run: handleSubmit,
        preventDefault: true,
    },
]);
let cssEditorView;
const initCssEditor = (parent) => {
    cssEditorView = new codemirror_1.EditorView({
        extensions: [keysMap, codemirror_1.basicSetup, (0, lang_css_1.css)(), (0, view_1.placeholder)(`Type your CSS here and hit Enter`)],
        parent,
    });
};
exports.initCssEditor = initCssEditor;
const getEditorValue = () => cssEditorView.state.doc.toString();
exports.getEditorValue = getEditorValue;
let htmlEditorView;
const initHtmlEditor = (parent, htmlDescription) => {
    htmlEditorView = new codemirror_1.EditorView({
        doc: htmlDescription,
        extensions: [codemirror_1.basicSetup, (0, lang_html_1.html)()],
        parent,
    });
    return htmlEditorView;
};
exports.initHtmlEditor = initHtmlEditor;
const shakeEditor = () => {
    const editorField = document.querySelector('.editor');
    if (editorField) {
        editorField.classList.add('shake');
        setTimeout(() => {
            editorField.classList.remove('shake');
        }, 500);
    }
};
exports.shakeEditor = shakeEditor;


/***/ }),

/***/ "./src/modules/footer.ts":
/*!*******************************!*\
  !*** ./src/modules/footer.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const consts_1 = __webpack_require__(/*! ../consts */ "./src/consts.ts");
const createFooterView = () => {
    const footer = document.createElement('footer');
    footer.className = 'footer';
    const githubLink = document.createElement('a');
    githubLink.className = 'footer__link';
    githubLink.href = consts_1.GITHUB_LINK;
    githubLink.target = '_blank';
    const githubIcon = document.createElement('div');
    githubIcon.className = 'github-icon';
    githubLink.appendChild(githubIcon);
    const year = document.createElement('h3');
    year.className = 'footer__year';
    year.textContent = '2023';
    const rssLink = document.createElement('a');
    rssLink.className = 'footer__link';
    rssLink.href = consts_1.RSS_LINK;
    rssLink.target = '_blank';
    const rssIcon = document.createElement('div');
    rssIcon.className = 'rss-icon';
    rssLink.appendChild(rssIcon);
    footer.appendChild(githubLink);
    footer.appendChild(year);
    footer.appendChild(rssLink);
    return footer;
};
exports["default"] = createFooterView;


/***/ }),

/***/ "./src/modules/header.ts":
/*!*******************************!*\
  !*** ./src/modules/header.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createHeaderView = exports.createLogoWithLink = void 0;
const consts_1 = __webpack_require__(/*! ../consts */ "./src/consts.ts");
const createLogoWithLink = () => {
    const link = document.createElement('a');
    link.className = 'header__link';
    link.href = consts_1.POKEMON_COM_LINK;
    link.target = '_blank';
    const logo = document.createElement('div');
    logo.className = 'header__logo';
    link.appendChild(logo);
    return link;
};
exports.createLogoWithLink = createLogoWithLink;
const createHeaderView = () => {
    const header = document.createElement('header');
    header.className = 'header';
    const link = (0, exports.createLogoWithLink)();
    const title = document.createElement('h1');
    title.className = 'header__title';
    title.textContent = 'CSS League';
    const burger = document.createElement('div');
    burger.className = 'burger';
    for (let i = 0; i < 3; i += 1) {
        const bar = document.createElement('div');
        bar.className = 'bar';
        burger.appendChild(bar);
    }
    header.appendChild(link);
    header.appendChild(title);
    header.appendChild(burger);
    return header;
};
exports.createHeaderView = createHeaderView;


/***/ }),

/***/ "./src/modules/level.ts":
/*!******************************!*\
  !*** ./src/modules/level.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkAnswer = exports.setLevel = exports.getCurrentLevel = exports.levels = exports.createLevels = void 0;
const pokemonRepository_1 = __webpack_require__(/*! ../repo/pokemonRepository */ "./src/repo/pokemonRepository.ts");
const dataBase = __importStar(__webpack_require__(/*! ../levels.json */ "./src/levels.json"));
const render_1 = __importDefault(__webpack_require__(/*! ./render */ "./src/modules/render.ts"));
const pokeball_1 = __importDefault(__webpack_require__(/*! ./pokeball */ "./src/modules/pokeball.ts"));
const finish_png_1 = __importDefault(__webpack_require__(/*! ../assets/finish.png */ "./src/assets/finish.png"));
const editor_1 = __webpack_require__(/*! ./editor */ "./src/modules/editor.ts");
const main_1 = __importDefault(__webpack_require__(/*! ./main */ "./src/modules/main.ts"));
const jsonData = dataBase;
const createLevels = (data) => {
    return data.levels.map((level) => {
        const pokemonsters = (0, pokemonRepository_1.getPokemonsByIds)(level.pokemons);
        const corAns = level.correctAnswers.map(({ css, pokemons }) => ({
            css,
            pokemons: (0, pokemonRepository_1.getPokemonsByIds)(pokemons),
        }));
        const wrongAns = level.wrongAnswers?.map(({ css, pokemons }) => ({
            css,
            pokemons: (0, pokemonRepository_1.getPokemonsByIds)(pokemons),
        }));
        return { ...level, pokemons: pokemonsters, correctAnswers: corAns, wrongAnswers: wrongAns };
    });
};
exports.createLevels = createLevels;
exports.levels = (0, exports.createLevels)(jsonData);
const getCurrentLevel = () => {
    const currentLevel = localStorage.getItem('level') || '0';
    const level = exports.levels[+currentLevel];
    return level;
};
exports.getCurrentLevel = getCurrentLevel;
const showFinish = () => {
    const main = document.querySelector('.main');
    if (main) {
        main.innerHTML = '';
        const finishImg = document.createElement('img');
        finishImg.src = finish_png_1.default;
        finishImg.className = 'finish';
        main.appendChild(finishImg);
        setTimeout(() => {
            const parent = main.parentElement;
            const newMain = (0, main_1.default)();
            if (parent) {
                parent.replaceChild(newMain, main);
            }
            (0, render_1.default)(exports.levels[0]);
        }, 3000);
    }
};
const setLevel = (level) => {
    if (level < exports.levels.length) {
        localStorage.setItem('level', `${level}`);
        const l = exports.levels[level];
        (0, render_1.default)(l);
    }
    else {
        showFinish();
    }
};
exports.setLevel = setLevel;
const setNextLevel = () => {
    const l = +(localStorage.getItem('level') || '0');
    localStorage.setItem(`level ${l}`, 'done');
    (0, exports.setLevel)(l + 1);
};
const checkAnswer = (answer) => {
    const level = (0, exports.getCurrentLevel)();
    const { correctAnswers } = level;
    const match = correctAnswers.find((ans) => ans.css === answer.trim());
    const catchedPokemons = match?.pokemons;
    const vanishedPokemons = level.pokemons.filter((pokemon) => !catchedPokemons?.includes(pokemon));
    if (catchedPokemons) {
        const activeImages = document.querySelectorAll('.active-image');
        activeImages.forEach((img) => {
            if (img) {
                const parent = img.parentElement;
                const pokeball = (0, pokeball_1.default)();
                if (parent) {
                    parent.replaceChild(pokeball, img);
                }
            }
        });
        level.done = true;
        setTimeout(() => setNextLevel(), 3000);
        return true;
    }
    if (vanishedPokemons) {
        (0, editor_1.shakeEditor)();
    }
    return false;
};
exports.checkAnswer = checkAnswer;


/***/ }),

/***/ "./src/modules/main.ts":
/*!*****************************!*\
  !*** ./src/modules/main.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const editor_1 = __webpack_require__(/*! ./editor */ "./src/modules/editor.ts");
const level_1 = __webpack_require__(/*! ./level */ "./src/modules/level.ts");
const createCssEditorView = () => {
    const cssEditorDiv = document.createElement('div');
    cssEditorDiv.id = 'css-editor';
    const cssEditorHeader = document.createElement('h3');
    cssEditorHeader.className = 'editor__header';
    cssEditorHeader.textContent = 'CSS Editor';
    const cssViewerContainer = document.createElement('div');
    cssViewerContainer.className = 'css-viewer__container';
    const enterBtn = document.createElement('button');
    enterBtn.className = 'enter-btn btn';
    enterBtn.textContent = 'Enter';
    enterBtn.addEventListener('click', () => {
        const userAnswer = (0, editor_1.getEditorValue)();
        (0, level_1.checkAnswer)(userAnswer);
    });
    cssEditorDiv.appendChild(cssEditorHeader);
    cssEditorDiv.appendChild(cssViewerContainer);
    cssEditorDiv.appendChild(enterBtn);
    return cssEditorDiv;
};
const createHtmlEditorView = () => {
    const htmlViewerDiv = document.createElement('div');
    htmlViewerDiv.id = 'html-viewer';
    const htmlViewerHeader = document.createElement('h3');
    htmlViewerHeader.className = 'editor__header';
    htmlViewerHeader.textContent = 'HTML Viewer';
    const htmlViewerContainer = document.createElement('div');
    htmlViewerContainer.className = 'html-viewer__container';
    htmlViewerDiv.appendChild(htmlViewerHeader);
    htmlViewerDiv.appendChild(htmlViewerContainer);
    return htmlViewerDiv;
};
const createMainView = () => {
    const main = document.createElement('main');
    main.className = 'main';
    const editorDiv = document.createElement('div');
    editorDiv.className = 'editor';
    const cssEditorDiv = createCssEditorView();
    const htmlViewerDiv = createHtmlEditorView();
    editorDiv.appendChild(cssEditorDiv);
    editorDiv.appendChild(htmlViewerDiv);
    const pokemonsDiv = document.createElement('div');
    pokemonsDiv.className = 'pokemons';
    main.appendChild(editorDiv);
    main.appendChild(pokemonsDiv);
    return main;
};
exports["default"] = createMainView;


/***/ }),

/***/ "./src/modules/menu.ts":
/*!*****************************!*\
  !*** ./src/modules/menu.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initMenu = exports.createMenu = exports.createUl = void 0;
const level_1 = __webpack_require__(/*! ./level */ "./src/modules/level.ts");
const MARK_EMOJI = '✔️';
const createUl = () => {
    const ul = document.createElement('ul');
    ul.className = 'nav-links menu';
    level_1.levels.forEach(({ menuTitle }, index) => {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.className = 'nav-links__item';
        const done = !!localStorage.getItem(`level ${index}`);
        const mark = done ? MARK_EMOJI : '';
        a.textContent = `${menuTitle} ${mark}`;
        a.addEventListener('click', () => {
            (0, level_1.setLevel)(index);
        });
        li.appendChild(a);
        ul.appendChild(li);
    });
    return ul;
};
exports.createUl = createUl;
const createMenu = () => {
    const overlayDiv = document.createElement('div');
    overlayDiv.className = 'overlay';
    const menuContainerDiv = document.createElement('div');
    menuContainerDiv.className = 'menu-container';
    const nav = document.createElement('nav');
    const h3 = document.createElement('h3');
    h3.className = 'menu-title';
    h3.textContent = 'Choose a level';
    const ul = (0, exports.createUl)();
    nav.appendChild(h3);
    nav.appendChild(ul);
    menuContainerDiv.appendChild(nav);
    const resetBtn = document.createElement('button');
    resetBtn.textContent = 'Reset progress';
    resetBtn.className = 'reset-btn';
    resetBtn.addEventListener('click', () => {
        localStorage.clear();
        (0, level_1.setLevel)(0);
    });
    menuContainerDiv.appendChild(resetBtn);
    overlayDiv.appendChild(menuContainerDiv);
    return overlayDiv;
};
exports.createMenu = createMenu;
const initMenu = () => {
    const root = document.getElementById('root');
    if (root)
        root.appendChild((0, exports.createMenu)());
    const { body } = document;
    const adaptMenu = document.querySelector('.menu-container');
    const overlay = document.querySelector('.overlay');
    const burger = document.querySelector('.burger');
    if (adaptMenu) {
        const menuLinksArray = Array.from(adaptMenu.querySelectorAll('.nav-links__item'));
        const handleMenu = (event) => {
            const clickedElement = event.target;
            if (clickedElement && burger && overlay) {
                const isClickOnBar = clickedElement.closest('.burger') === burger;
                const isClickOutsideOfAdaptMenu = !adaptMenu.contains(clickedElement);
                const isClickOnBurgerIcon = clickedElement === burger || isClickOnBar;
                if ((isClickOutsideOfAdaptMenu && !isClickOnBurgerIcon) || menuLinksArray.includes(clickedElement)) {
                    burger.classList.remove('active');
                    overlay.classList.remove('active');
                    adaptMenu.classList.remove('active');
                    body.classList.remove('body-overflow');
                }
                if (isClickOnBurgerIcon) {
                    burger.classList.toggle('active');
                    overlay.classList.toggle('active');
                    adaptMenu.classList.toggle('active');
                    body.classList.toggle('body-overflow');
                }
            }
        };
        if (burger)
            burger.addEventListener('click', handleMenu);
        if (overlay)
            overlay.addEventListener('click', handleMenu);
    }
};
exports.initMenu = initMenu;


/***/ }),

/***/ "./src/modules/modal.ts":
/*!******************************!*\
  !*** ./src/modules/modal.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const consts_1 = __webpack_require__(/*! ../consts */ "./src/consts.ts");
const pikachu_png_1 = __importDefault(__webpack_require__(/*! ../assets/pikachu.png */ "./src/assets/pikachu.png"));
const header_1 = __webpack_require__(/*! ./header */ "./src/modules/header.ts");
const createModalContentInfo = () => {
    const modalContentInfoDiv = document.createElement('div');
    modalContentInfoDiv.className = 'modal-content__info';
    const modalContentInfoTitle = document.createElement('h3');
    modalContentInfoTitle.className = 'modal-content__info-title';
    modalContentInfoTitle.textContent = consts_1.APP_MODAL_TITLE;
    const modalContentInfoText1 = document.createElement('h4');
    modalContentInfoText1.className = 'modal-content__info-text';
    modalContentInfoText1.textContent = consts_1.APP_DESCRIPTION;
    const modalContentInfoText2 = document.createElement('h4');
    modalContentInfoText2.className = 'modal-content__info-text';
    modalContentInfoText2.textContent = consts_1.APP_INVITE_TEXT;
    const modalBtnContainerDiv = document.createElement('div');
    modalBtnContainerDiv.className = 'modal-btn-container';
    const modalBtn = document.createElement('button');
    modalBtn.className = 'modal-btn';
    modalBtn.textContent = 'Start your adventure now!';
    modalBtn.addEventListener('click', () => {
        localStorage.setItem('start', 'read');
    });
    modalBtnContainerDiv.appendChild(modalBtn);
    modalContentInfoDiv.appendChild(modalContentInfoTitle);
    modalContentInfoDiv.appendChild(modalContentInfoText1);
    modalContentInfoDiv.appendChild(modalContentInfoText2);
    modalContentInfoDiv.appendChild(modalBtnContainerDiv);
    return modalContentInfoDiv;
};
const createModalView = () => {
    const overlayModalDiv = document.createElement('div');
    overlayModalDiv.className = 'overlay-modal';
    const modalDiv = document.createElement('div');
    modalDiv.className = 'modal';
    const modalContentDiv = document.createElement('div');
    modalContentDiv.className = 'modal-content';
    const link = (0, header_1.createLogoWithLink)();
    const modalContentImageDiv = document.createElement('div');
    modalContentImageDiv.className = 'modal-content__image';
    const modalImage = document.createElement('img');
    modalImage.src = pikachu_png_1.default;
    modalContentImageDiv.appendChild(modalImage);
    const modalContentInfoDiv = createModalContentInfo();
    modalContentDiv.appendChild(link);
    modalContentDiv.appendChild(modalContentImageDiv);
    modalContentDiv.appendChild(modalContentInfoDiv);
    modalDiv.appendChild(modalContentDiv);
    overlayModalDiv.appendChild(modalDiv);
    return overlayModalDiv;
};
const initModal = () => {
    const root = document.getElementById('root');
    if (root)
        root.appendChild(createModalView());
    const { body } = document;
    const modalBtn = document.querySelector('.modal-btn');
    const modal = document.querySelector('.overlay-modal');
    const modalCont = document.querySelector('.modal-content');
    if (modal && body && modalCont) {
        const openModal = () => {
            modal.classList.add('active');
            body.classList.add('body-overflow');
        };
        openModal();
        const closeModal = () => {
            body.classList.remove('body-overflow');
            modal.classList.remove('active');
        };
        const handleModal = (event) => {
            const clickedElement = event.target;
            const isClickOutsideOfModal = !modalCont.contains(clickedElement);
            const isClickOnModalBtn = clickedElement === modalBtn;
            if (isClickOutsideOfModal || isClickOnModalBtn) {
                closeModal();
            }
        };
        if (modalBtn)
            modalBtn.addEventListener('click', handleModal);
        if (modal)
            modal.addEventListener('click', handleModal);
    }
};
exports["default"] = initModal;


/***/ }),

/***/ "./src/modules/pokeball.ts":
/*!*********************************!*\
  !*** ./src/modules/pokeball.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const createPokeballView = () => {
    const container = document.createElement('div');
    container.className = 'pokeball__container';
    const pokeball = document.createElement('div');
    pokeball.className = 'pokeball';
    const pokeballButton = document.createElement('div');
    pokeballButton.className = 'pokeball__button';
    pokeball.appendChild(pokeballButton);
    container.appendChild(pokeball);
    return container;
};
exports["default"] = createPokeballView;


/***/ }),

/***/ "./src/modules/render.ts":
/*!*******************************!*\
  !*** ./src/modules/render.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const editor_1 = __webpack_require__(/*! ./editor */ "./src/modules/editor.ts");
const menu_1 = __webpack_require__(/*! ./menu */ "./src/modules/menu.ts");
const renderTitle = (level) => {
    const title = document.querySelector('.task-title');
    if (title instanceof HTMLElement) {
        title.innerText = level.title;
    }
    else {
        const main = document.querySelector('.main');
        const levelTitle = document.createElement('h2');
        levelTitle.className = 'task-title';
        levelTitle.innerText = level.title;
        if (main) {
            main.prepend(levelTitle);
        }
    }
};
const renderCssViewer = () => {
    const editorField = document.querySelector('.editor');
    if (editorField) {
        const cssEditorField = document.querySelector('.css-viewer__container');
        if (cssEditorField instanceof HTMLElement) {
            cssEditorField.innerHTML = '';
            (0, editor_1.initCssEditor)(cssEditorField);
        }
    }
};
const renderHtmlViewer = (level) => {
    const htmlViewerField = document.querySelector('.html-viewer__container');
    if (htmlViewerField instanceof HTMLElement) {
        htmlViewerField.innerHTML = '';
        (0, editor_1.initHtmlEditor)(htmlViewerField, level.html);
    }
};
const renderPokemons = (level) => {
    const pokemonsField = document.querySelector('.pokemons');
    const correctPokemonIds = level.correctAnswers.flatMap((ans) => ans.pokemons.map((p) => p.id));
    if (pokemonsField) {
        pokemonsField.innerHTML = '';
        const { pokemons } = level;
        pokemons.forEach((p) => {
            const pImg = document.createElement('img');
            pImg.src = p.src;
            pImg.classList.add('pokemon');
            if (correctPokemonIds.includes(p.id)) {
                pImg.classList.add('active-image');
            }
            if (p.attrClass) {
                pImg.classList.add('tiny');
            }
            pokemonsField.appendChild(pImg);
        });
    }
};
const renderMenu = () => {
    const navLinks = document.querySelector('.nav-links');
    const ul = (0, menu_1.createUl)();
    if (navLinks) {
        const parent = navLinks.parentElement;
        if (parent) {
            parent.replaceChild(ul, navLinks);
        }
    }
    const menuLinks = document.querySelectorAll('.nav-links__item');
    if (menuLinks) {
        menuLinks.forEach((link) => {
            link.classList.remove('nav-links__item-active');
        });
        const currentLevel = localStorage.getItem('level') || '0';
        menuLinks[+currentLevel].classList.add('nav-links__item-active');
    }
};
const render = (level) => {
    renderTitle(level);
    renderCssViewer();
    renderHtmlViewer(level);
    renderPokemons(level);
    renderMenu();
};
exports["default"] = render;


/***/ }),

/***/ "./src/repo/pokemonRepository.ts":
/*!***************************************!*\
  !*** ./src/repo/pokemonRepository.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPokemonsByIds = exports.getPokemonById = void 0;
const charmander_png_1 = __importDefault(__webpack_require__(/*! ../assets/charmander.png */ "./src/assets/charmander.png"));
const bulbasaur_png_1 = __importDefault(__webpack_require__(/*! ../assets/bulbasaur.png */ "./src/assets/bulbasaur.png"));
const pikachu_png_1 = __importDefault(__webpack_require__(/*! ../assets/pikachu.png */ "./src/assets/pikachu.png"));
const squirtle_png_1 = __importDefault(__webpack_require__(/*! ../assets/squirtle.png */ "./src/assets/squirtle.png"));
const lapras_png_1 = __importDefault(__webpack_require__(/*! ../assets/lapras.png */ "./src/assets/lapras.png"));
const pokemon_1 = __importDefault(__webpack_require__(/*! ../types/pokemon */ "./src/types/pokemon.ts"));
const shiny_charmander_png_1 = __importDefault(__webpack_require__(/*! ../assets/shiny-charmander.png */ "./src/assets/shiny-charmander.png"));
const sad_pikachu_png_1 = __importDefault(__webpack_require__(/*! ../assets/sad-pikachu.png */ "./src/assets/sad-pikachu.png"));
const pikachu = new pokemon_1.default({
    id: 1,
    name: 'pikachu',
    src: pikachu_png_1.default,
});
const bulbasaur = new pokemon_1.default({
    id: 2,
    name: 'bulbasaur',
    src: bulbasaur_png_1.default,
});
const charmander = new pokemon_1.default({
    id: 3,
    name: 'charmander',
    src: charmander_png_1.default,
});
const squirtle = new pokemon_1.default({
    id: 4,
    name: 'squirtle',
    src: squirtle_png_1.default,
});
const lapras = new pokemon_1.default({
    id: 5,
    name: 'lapras',
    src: lapras_png_1.default,
});
const shinyCharmander = new pokemon_1.default({
    id: 6,
    name: 'charmander',
    src: shiny_charmander_png_1.default,
});
const cagedPikachu = new pokemon_1.default({
    id: 7,
    name: 'pikachu',
    src: sad_pikachu_png_1.default,
});
const tinyBulbasaur = new pokemon_1.default({
    id: 8,
    name: 'bulbasaur',
    src: bulbasaur_png_1.default,
    attrClass: 'tiny',
});
const tinyCharmander = new pokemon_1.default({
    id: 9,
    name: 'charmander',
    src: charmander_png_1.default,
    attrClass: 'tiny',
});
const tinyPikachu = new pokemon_1.default({
    id: 10,
    name: 'pikachu',
    src: pikachu_png_1.default,
    attrClass: 'tiny',
});
const tinyCagedPikachu = new pokemon_1.default({
    id: 11,
    name: 'pikachu',
    src: sad_pikachu_png_1.default,
    attrClass: 'tiny',
});
const tinySquirtle = new pokemon_1.default({
    id: 12,
    name: 'squirtle',
    src: squirtle_png_1.default,
    attrClass: 'tiny',
});
const clonePikachu = new pokemon_1.default({
    id: 13,
    name: 'pikachu',
    src: pikachu_png_1.default,
});
const cloneBulbasaur = new pokemon_1.default({
    id: 14,
    name: 'bulbasaur',
    src: bulbasaur_png_1.default,
});
const dataBase = [
    pikachu,
    bulbasaur,
    charmander,
    squirtle,
    lapras,
    shinyCharmander,
    cagedPikachu,
    tinyBulbasaur,
    tinyCharmander,
    tinyPikachu,
    tinyCagedPikachu,
    tinySquirtle,
    clonePikachu,
    cloneBulbasaur,
];
const getPokemonById = (id) => {
    return dataBase.find((pokemon) => pokemon.id === id);
};
exports.getPokemonById = getPokemonById;
const getPokemonsByIds = (ids) => {
    const pokemons = [];
    ids.forEach((id) => {
        const pokemon = (0, exports.getPokemonById)(id);
        if (pokemon)
            pokemons.push(pokemon);
    });
    return pokemons;
};
exports.getPokemonsByIds = getPokemonsByIds;


/***/ }),

/***/ "./src/types/pokemon.ts":
/*!******************************!*\
  !*** ./src/types/pokemon.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Pokemon {
    constructor(p) {
        this.id = p.id;
        this.name = p.name;
        this.src = p.src;
        this.attrId = p.attrId;
        this.attrClass = p.attrClass;
    }
}
exports["default"] = Pokemon;


/***/ }),

/***/ "./src/assets/bulbasaur.png":
/*!**********************************!*\
  !*** ./src/assets/bulbasaur.png ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1926caa07921400533e0.png";

/***/ }),

/***/ "./src/assets/charmander.png":
/*!***********************************!*\
  !*** ./src/assets/charmander.png ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8255a116e4b4511f0bee.png";

/***/ }),

/***/ "./src/assets/finish.png":
/*!*******************************!*\
  !*** ./src/assets/finish.png ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/15533ffcaf473f8e783e.png";

/***/ }),

/***/ "./src/assets/landscape.jpg":
/*!**********************************!*\
  !*** ./src/assets/landscape.jpg ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6cdc05aae32677ca2885.jpg";

/***/ }),

/***/ "./src/assets/lapras.png":
/*!*******************************!*\
  !*** ./src/assets/lapras.png ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/af6cb36e98bf98272255.png";

/***/ }),

/***/ "./src/assets/mystic-logo.png":
/*!************************************!*\
  !*** ./src/assets/mystic-logo.png ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/5d06da1adc9cfde60042.png";

/***/ }),

/***/ "./src/assets/pikachu.png":
/*!********************************!*\
  !*** ./src/assets/pikachu.png ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b319e26b7c96f39af9d5.png";

/***/ }),

/***/ "./src/assets/pokémon_logo.png":
/*!*************************************!*\
  !*** ./src/assets/pokémon_logo.png ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/afb67588740de820ff68.png";

/***/ }),

/***/ "./src/assets/rss.svg":
/*!****************************!*\
  !*** ./src/assets/rss.svg ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7dac27ebf3179035b223.svg";

/***/ }),

/***/ "./src/assets/sad-pikachu.png":
/*!************************************!*\
  !*** ./src/assets/sad-pikachu.png ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/593dab521f3f51f3d5f0.png";

/***/ }),

/***/ "./src/assets/shiny-charmander.png":
/*!*****************************************!*\
  !*** ./src/assets/shiny-charmander.png ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f9aba7c36583160456fd.png";

/***/ }),

/***/ "./src/assets/squirtle.png":
/*!*********************************!*\
  !*** ./src/assets/squirtle.png ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d4d8920e6e64393ba98d.png";

/***/ }),

/***/ "./node_modules/@codemirror/autocomplete/dist/index.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var state = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.cjs");
var view = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.cjs");
var language = __webpack_require__(/*! @codemirror/language */ "./node_modules/@codemirror/language/dist/index.cjs");

/**
An instance of this is passed to completion source functions.
*/
class CompletionContext {
    /**
    Create a new completion context. (Mostly useful for testing
    completion sources—in the editor, the extension will create
    these for you.)
    */
    constructor(
    /**
    The editor state that the completion happens in.
    */
    state, 
    /**
    The position at which the completion is happening.
    */
    pos, 
    /**
    Indicates whether completion was activated explicitly, or
    implicitly by typing. The usual way to respond to this is to
    only return completions when either there is part of a
    completable entity before the cursor, or `explicit` is true.
    */
    explicit, 
    /**
    The editor view. May be undefined if the context was created
    in a situation where there is no such view available, such as
    in synchronous updates via
    [`CompletionResult.update`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.update)
    or when called by test code.
    */
    view) {
        this.state = state;
        this.pos = pos;
        this.explicit = explicit;
        this.view = view;
        /**
        @internal
        */
        this.abortListeners = [];
        /**
        @internal
        */
        this.abortOnDocChange = false;
    }
    /**
    Get the extent, content, and (if there is a token) type of the
    token before `this.pos`.
    */
    tokenBefore(types) {
        let token = language.syntaxTree(this.state).resolveInner(this.pos, -1);
        while (token && types.indexOf(token.name) < 0)
            token = token.parent;
        return token ? { from: token.from, to: this.pos,
            text: this.state.sliceDoc(token.from, this.pos),
            type: token.type } : null;
    }
    /**
    Get the match of the given expression directly before the
    cursor.
    */
    matchBefore(expr) {
        let line = this.state.doc.lineAt(this.pos);
        let start = Math.max(line.from, this.pos - 250);
        let str = line.text.slice(start - line.from, this.pos - line.from);
        let found = str.search(ensureAnchor(expr, false));
        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
    }
    /**
    Yields true when the query has been aborted. Can be useful in
    asynchronous queries to avoid doing work that will be ignored.
    */
    get aborted() { return this.abortListeners == null; }
    /**
    Allows you to register abort handlers, which will be called when
    the query is
    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
    
    By default, running queries will not be aborted for regular
    typing or backspacing, on the assumption that they are likely to
    return a result with a
    [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
    allows the result to be used after all. Passing `onDocChange:
    true` will cause this query to be aborted for any document
    change.
    */
    addEventListener(type, listener, options) {
        if (type == "abort" && this.abortListeners) {
            this.abortListeners.push(listener);
            if (options && options.onDocChange)
                this.abortOnDocChange = true;
        }
    }
}
function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words = /\w/.test(flat);
    if (words)
        flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
    let first = Object.create(null), rest = Object.create(null);
    for (let { label } of options) {
        first[label[0]] = true;
        for (let i = 1; i < label.length; i++)
            rest[label[i]] = true;
    }
    let source = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source), new RegExp(source)];
}
/**
Given a a fixed array of options, return an autocompleter that
completes them.
*/
function completeFromList(list) {
    let options = list.map(o => typeof o == "string" ? { label: o } : o);
    let [validFor, match] = options.every(o => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
    return (context) => {
        let token = context.matchBefore(match);
        return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
    };
}
/**
Wrap the given completion source so that it will only fire when the
cursor is in a syntax node with one of the given names.
*/
function ifIn(nodes, source) {
    return (context) => {
        for (let pos = language.syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
            if (nodes.indexOf(pos.name) > -1)
                return source(context);
            if (pos.type.isTop)
                break;
        }
        return null;
    };
}
/**
Wrap the given completion source so that it will not fire when the
cursor is in a syntax node with one of the given names.
*/
function ifNotIn(nodes, source) {
    return (context) => {
        for (let pos = language.syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
            if (nodes.indexOf(pos.name) > -1)
                return null;
            if (pos.type.isTop)
                break;
        }
        return source(context);
    };
}
class Option {
    constructor(completion, source, match, score) {
        this.completion = completion;
        this.source = source;
        this.match = match;
        this.score = score;
    }
}
function cur(state) { return state.selection.main.from; }
// Make sure the given regexp has a $ at its end and, if `start` is
// true, a ^ at its start.
function ensureAnchor(expr, start) {
    var _a;
    let { source } = expr;
    let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd)
        return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? "i" : ""));
}
/**
This annotation is added to transactions that are produced by
picking a completion.
*/
const pickedCompletion = state.Annotation.define();
/**
Helper function that returns a transaction spec which inserts a
completion's text in the main selection range, and any other
selection range that has the same text in front of it.
*/
function insertCompletionText(state$1, text, from, to) {
    let { main } = state$1.selection, fromOff = from - main.from, toOff = to - main.from;
    return Object.assign(Object.assign({}, state$1.changeByRange(range => {
        if (range != main && from != to &&
            state$1.sliceDoc(range.from + fromOff, range.from + toOff) != state$1.sliceDoc(from, to))
            return { range };
        let lines = state$1.toText(text);
        return {
            changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },
            range: state.EditorSelection.cursor(range.from + fromOff + lines.length)
        };
    })), { scrollIntoView: true, userEvent: "input.complete" });
}
const SourceCache = new WeakMap();
function asSource(source) {
    if (!Array.isArray(source))
        return source;
    let known = SourceCache.get(source);
    if (!known)
        SourceCache.set(source, known = completeFromList(source));
    return known;
}
const startCompletionEffect = state.StateEffect.define();
const closeCompletionEffect = state.StateEffect.define();

// A pattern matcher for fuzzy completion matching. Create an instance
// once for a pattern, and then use that to match any number of
// completions.
class FuzzyMatcher {
    constructor(pattern) {
        this.pattern = pattern;
        this.chars = [];
        this.folded = [];
        // Buffers reused by calls to `match` to track matched character
        // positions.
        this.any = [];
        this.precise = [];
        this.byWord = [];
        this.score = 0;
        this.matched = [];
        for (let p = 0; p < pattern.length;) {
            let char = state.codePointAt(pattern, p), size = state.codePointSize(char);
            this.chars.push(char);
            let part = pattern.slice(p, p + size), upper = part.toUpperCase();
            this.folded.push(state.codePointAt(upper == part ? part.toLowerCase() : upper, 0));
            p += size;
        }
        this.astral = pattern.length != this.chars.length;
    }
    ret(score, matched) {
        this.score = score;
        this.matched = matched;
        return this;
    }
    // Matches a given word (completion) against the pattern (input).
    // Will return a boolean indicating whether there was a match and,
    // on success, set `this.score` to the score, `this.matched` to an
    // array of `from, to` pairs indicating the matched parts of `word`.
    //
    // The score is a number that is more negative the worse the match
    // is. See `Penalty` above.
    match(word) {
        if (this.pattern.length == 0)
            return this.ret(-100 /* Penalty.NotFull */, []);
        if (word.length < this.pattern.length)
            return null;
        let { chars, folded, any, precise, byWord } = this;
        // For single-character queries, only match when they occur right
        // at the start
        if (chars.length == 1) {
            let first = state.codePointAt(word, 0), firstSize = state.codePointSize(first);
            let score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */;
            if (first == chars[0]) ;
            else if (first == folded[0])
                score += -200 /* Penalty.CaseFold */;
            else
                return null;
            return this.ret(score, [0, firstSize]);
        }
        let direct = word.indexOf(this.pattern);
        if (direct == 0)
            return this.ret(word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */, [0, this.pattern.length]);
        let len = chars.length, anyTo = 0;
        if (direct < 0) {
            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {
                let next = state.codePointAt(word, i);
                if (next == chars[anyTo] || next == folded[anyTo])
                    any[anyTo++] = i;
                i += state.codePointSize(next);
            }
            // No match, exit immediately
            if (anyTo < len)
                return null;
        }
        // This tracks the extent of the precise (non-folded, not
        // necessarily adjacent) match
        let preciseTo = 0;
        // Tracks whether there is a match that hits only characters that
        // appear to be starting words. `byWordFolded` is set to true when
        // a case folded character is encountered in such a match
        let byWordTo = 0, byWordFolded = false;
        // If we've found a partial adjacent match, these track its state
        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
        let hasLower = /[a-z]/.test(word), wordAdjacent = true;
        // Go over the option's text, scanning for the various kinds of matches
        for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */; i < e && byWordTo < len;) {
            let next = state.codePointAt(word, i);
            if (direct < 0) {
                if (preciseTo < len && next == chars[preciseTo])
                    precise[preciseTo++] = i;
                if (adjacentTo < len) {
                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
                        if (adjacentTo == 0)
                            adjacentStart = i;
                        adjacentEnd = i + 1;
                        adjacentTo++;
                    }
                    else {
                        adjacentTo = 0;
                    }
                }
            }
            let ch, type = next < 0xff
                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Tp.Lower */ : next >= 65 && next <= 90 ? 1 /* Tp.Upper */ : 0 /* Tp.NonWord */)
                : ((ch = state.fromCodePoint(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */ : ch != ch.toUpperCase() ? 2 /* Tp.Lower */ : 0 /* Tp.NonWord */);
            if (!i || type == 1 /* Tp.Upper */ && hasLower || prevType == 0 /* Tp.NonWord */ && type != 0 /* Tp.NonWord */) {
                if (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true)))
                    byWord[byWordTo++] = i;
                else if (byWord.length)
                    wordAdjacent = false;
            }
            prevType = type;
            i += state.codePointSize(next);
        }
        if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
            return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0), byWord, word);
        if (adjacentTo == len && adjacentStart == 0)
            return this.ret(-200 /* Penalty.CaseFold */ - word.length + (adjacentEnd == word.length ? 0 : -100 /* Penalty.NotFull */), [0, adjacentEnd]);
        if (direct > -1)
            return this.ret(-700 /* Penalty.NotStart */ - word.length, [direct, direct + this.pattern.length]);
        if (adjacentTo == len)
            return this.ret(-200 /* Penalty.CaseFold */ + -700 /* Penalty.NotStart */ - word.length, [adjacentStart, adjacentEnd]);
        if (byWordTo == len)
            return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0) + -700 /* Penalty.NotStart */ +
                (wordAdjacent ? 0 : -1100 /* Penalty.Gap */), byWord, word);
        return chars.length == 2 ? null
            : this.result((any[0] ? -700 /* Penalty.NotStart */ : 0) + -200 /* Penalty.CaseFold */ + -1100 /* Penalty.Gap */, any, word);
    }
    result(score, positions, word) {
        let result = [], i = 0;
        for (let pos of positions) {
            let to = pos + (this.astral ? state.codePointSize(state.codePointAt(word, pos)) : 1);
            if (i && result[i - 1] == pos)
                result[i - 1] = to;
            else {
                result[i++] = pos;
                result[i++] = to;
            }
        }
        return this.ret(score - word.length, result);
    }
}
class StrictMatcher {
    constructor(pattern) {
        this.pattern = pattern;
        this.matched = [];
        this.score = 0;
        this.folded = pattern.toLowerCase();
    }
    match(word) {
        if (word.length < this.pattern.length)
            return null;
        let start = word.slice(0, this.pattern.length);
        let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 /* Penalty.CaseFold */ : null;
        if (match == null)
            return null;
        this.matched = [0, start.length];
        this.score = match + (word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */);
        return this;
    }
}

const completionConfig = state.Facet.define({
    combine(configs) {
        return state.combineConfig(configs, {
            activateOnTyping: true,
            activateOnCompletion: () => false,
            activateOnTypingDelay: 100,
            selectOnOpen: true,
            override: null,
            closeOnBlur: true,
            maxRenderedOptions: 100,
            defaultKeymap: true,
            tooltipClass: () => "",
            optionClass: () => "",
            aboveCursor: false,
            icons: true,
            addToOptions: [],
            positionInfo: defaultPositionInfo,
            filterStrict: false,
            compareCompletions: (a, b) => a.label.localeCompare(b.label),
            interactionDelay: 75,
            updateSyncTime: 100
        }, {
            defaultKeymap: (a, b) => a && b,
            closeOnBlur: (a, b) => a && b,
            icons: (a, b) => a && b,
            tooltipClass: (a, b) => c => joinClass(a(c), b(c)),
            optionClass: (a, b) => c => joinClass(a(c), b(c)),
            addToOptions: (a, b) => a.concat(b),
            filterStrict: (a, b) => a || b,
        });
    }
});
function joinClass(a, b) {
    return a ? b ? a + " " + b : a : b;
}
function defaultPositionInfo(view$1, list, option, info, space, tooltip) {
    let rtl = view$1.textDirection == view.Direction.RTL, left = rtl, narrow = false;
    let side = "top", offset, maxWidth;
    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;
    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
    if (left && spaceLeft < Math.min(infoWidth, spaceRight))
        left = false;
    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
        left = true;
    if (infoWidth <= (left ? spaceLeft : spaceRight)) {
        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
        maxWidth = Math.min(400 /* Info.Width */, left ? spaceLeft : spaceRight);
    }
    else {
        narrow = true;
        maxWidth = Math.min(400 /* Info.Width */, (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */);
        let spaceBelow = space.bottom - list.bottom;
        if (spaceBelow >= infoHeight || spaceBelow > list.top) { // Below the completion
            offset = option.bottom - list.top;
        }
        else { // Above it
            side = "bottom";
            offset = list.bottom - option.top;
        }
    }
    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
    let scaleX = (list.right - list.left) / tooltip.offsetWidth;
    return {
        style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
        class: "cm-completionInfo-" + (narrow ? (rtl ? "left-narrow" : "right-narrow") : left ? "left" : "right")
    };
}

function optionContent(config) {
    let content = config.addToOptions.slice();
    if (config.icons)
        content.push({
            render(completion) {
                let icon = document.createElement("div");
                icon.classList.add("cm-completionIcon");
                if (completion.type)
                    icon.classList.add(...completion.type.split(/\s+/g).map(cls => "cm-completionIcon-" + cls));
                icon.setAttribute("aria-hidden", "true");
                return icon;
            },
            position: 20
        });
    content.push({
        render(completion, _s, _v, match) {
            let labelElt = document.createElement("span");
            labelElt.className = "cm-completionLabel";
            let label = completion.displayLabel || completion.label, off = 0;
            for (let j = 0; j < match.length;) {
                let from = match[j++], to = match[j++];
                if (from > off)
                    labelElt.appendChild(document.createTextNode(label.slice(off, from)));
                let span = labelElt.appendChild(document.createElement("span"));
                span.appendChild(document.createTextNode(label.slice(from, to)));
                span.className = "cm-completionMatchedText";
                off = to;
            }
            if (off < label.length)
                labelElt.appendChild(document.createTextNode(label.slice(off)));
            return labelElt;
        },
        position: 50
    }, {
        render(completion) {
            if (!completion.detail)
                return null;
            let detailElt = document.createElement("span");
            detailElt.className = "cm-completionDetail";
            detailElt.textContent = completion.detail;
            return detailElt;
        },
        position: 80
    });
    return content.sort((a, b) => a.position - b.position).map(a => a.render);
}
function rangeAroundSelected(total, selected, max) {
    if (total <= max)
        return { from: 0, to: total };
    if (selected < 0)
        selected = 0;
    if (selected <= (total >> 1)) {
        let off = Math.floor(selected / max);
        return { from: off * max, to: (off + 1) * max };
    }
    let off = Math.floor((total - selected) / max);
    return { from: total - (off + 1) * max, to: total - off * max };
}
class CompletionTooltip {
    constructor(view, stateField, applyCompletion) {
        this.view = view;
        this.stateField = stateField;
        this.applyCompletion = applyCompletion;
        this.info = null;
        this.infoDestroy = null;
        this.placeInfoReq = {
            read: () => this.measureInfo(),
            write: (pos) => this.placeInfo(pos),
            key: this
        };
        this.space = null;
        this.currentClass = "";
        let cState = view.state.field(stateField);
        let { options, selected } = cState.open;
        let config = view.state.facet(completionConfig);
        this.optionContent = optionContent(config);
        this.optionClass = config.optionClass;
        this.tooltipClass = config.tooltipClass;
        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);
        this.dom = document.createElement("div");
        this.dom.className = "cm-tooltip-autocomplete";
        this.updateTooltipClass(view.state);
        this.dom.addEventListener("mousedown", (e) => {
            let { options } = view.state.field(stateField).open;
            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
                if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
                    this.applyCompletion(view, options[+match[1]]);
                    e.preventDefault();
                    return;
                }
            }
        });
        this.dom.addEventListener("focusout", (e) => {
            let state = view.state.field(this.stateField, false);
            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur &&
                e.relatedTarget != view.contentDOM)
                view.dispatch({ effects: closeCompletionEffect.of(null) });
        });
        this.showOptions(options, cState.id);
    }
    mount() { this.updateSel(); }
    showOptions(options, id) {
        if (this.list)
            this.list.remove();
        this.list = this.dom.appendChild(this.createListBox(options, id, this.range));
        this.list.addEventListener("scroll", () => {
            if (this.info)
                this.view.requestMeasure(this.placeInfoReq);
        });
    }
    update(update) {
        var _a;
        let cState = update.state.field(this.stateField);
        let prevState = update.startState.field(this.stateField);
        this.updateTooltipClass(update.state);
        if (cState != prevState) {
            let { options, selected, disabled } = cState.open;
            if (!prevState.open || prevState.open.options != options) {
                this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
                this.showOptions(options, cState.id);
            }
            this.updateSel();
            if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled))
                this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
        }
    }
    updateTooltipClass(state) {
        let cls = this.tooltipClass(state);
        if (cls != this.currentClass) {
            for (let c of this.currentClass.split(" "))
                if (c)
                    this.dom.classList.remove(c);
            for (let c of cls.split(" "))
                if (c)
                    this.dom.classList.add(c);
            this.currentClass = cls;
        }
    }
    positioned(space) {
        this.space = space;
        if (this.info)
            this.view.requestMeasure(this.placeInfoReq);
    }
    updateSel() {
        let cState = this.view.state.field(this.stateField), open = cState.open;
        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
            this.showOptions(open.options, cState.id);
        }
        if (this.updateSelectedOption(open.selected)) {
            this.destroyInfo();
            let { completion } = open.options[open.selected];
            let { info } = completion;
            if (!info)
                return;
            let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
            if (!infoResult)
                return;
            if ("then" in infoResult) {
                infoResult.then(obj => {
                    if (obj && this.view.state.field(this.stateField, false) == cState)
                        this.addInfoPane(obj, completion);
                }).catch(e => view.logException(this.view.state, e, "completion info"));
            }
            else {
                this.addInfoPane(infoResult, completion);
            }
        }
    }
    addInfoPane(content, completion) {
        this.destroyInfo();
        let wrap = this.info = document.createElement("div");
        wrap.className = "cm-tooltip cm-completionInfo";
        if (content.nodeType != null) {
            wrap.appendChild(content);
            this.infoDestroy = null;
        }
        else {
            let { dom, destroy } = content;
            wrap.appendChild(dom);
            this.infoDestroy = destroy || null;
        }
        this.dom.appendChild(wrap);
        this.view.requestMeasure(this.placeInfoReq);
    }
    updateSelectedOption(selected) {
        let set = null;
        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
            if (opt.nodeName != "LI" || !opt.id) {
                i--; // A section header
            }
            else if (i == selected) {
                if (!opt.hasAttribute("aria-selected")) {
                    opt.setAttribute("aria-selected", "true");
                    set = opt;
                }
            }
            else {
                if (opt.hasAttribute("aria-selected"))
                    opt.removeAttribute("aria-selected");
            }
        }
        if (set)
            scrollIntoView(this.list, set);
        return set;
    }
    measureInfo() {
        let sel = this.dom.querySelector("[aria-selected]");
        if (!sel || !this.info)
            return null;
        let listRect = this.dom.getBoundingClientRect();
        let infoRect = this.info.getBoundingClientRect();
        let selRect = sel.getBoundingClientRect();
        let space = this.space;
        if (!space) {
            let win = this.dom.ownerDocument.defaultView || window;
            space = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };
        }
        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 ||
            selRect.bottom < Math.max(space.top, listRect.top) + 10)
            return null;
        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);
    }
    placeInfo(pos) {
        if (this.info) {
            if (pos) {
                if (pos.style)
                    this.info.style.cssText = pos.style;
                this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
            }
            else {
                this.info.style.cssText = "top: -1e6px";
            }
        }
    }
    createListBox(options, id, range) {
        const ul = document.createElement("ul");
        ul.id = id;
        ul.setAttribute("role", "listbox");
        ul.setAttribute("aria-expanded", "true");
        ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
        let curSection = null;
        for (let i = range.from; i < range.to; i++) {
            let { completion, match } = options[i], { section } = completion;
            if (section) {
                let name = typeof section == "string" ? section : section.name;
                if (name != curSection && (i > range.from || range.from == 0)) {
                    curSection = name;
                    if (typeof section != "string" && section.header) {
                        ul.appendChild(section.header(section));
                    }
                    else {
                        let header = ul.appendChild(document.createElement("completion-section"));
                        header.textContent = name;
                    }
                }
            }
            const li = ul.appendChild(document.createElement("li"));
            li.id = id + "-" + i;
            li.setAttribute("role", "option");
            let cls = this.optionClass(completion);
            if (cls)
                li.className = cls;
            for (let source of this.optionContent) {
                let node = source(completion, this.view.state, this.view, match);
                if (node)
                    li.appendChild(node);
            }
        }
        if (range.from)
            ul.classList.add("cm-completionListIncompleteTop");
        if (range.to < options.length)
            ul.classList.add("cm-completionListIncompleteBottom");
        return ul;
    }
    destroyInfo() {
        if (this.info) {
            if (this.infoDestroy)
                this.infoDestroy();
            this.info.remove();
            this.info = null;
        }
    }
    destroy() {
        this.destroyInfo();
    }
}
function completionTooltip(stateField, applyCompletion) {
    return (view) => new CompletionTooltip(view, stateField, applyCompletion);
}
function scrollIntoView(container, element) {
    let parent = container.getBoundingClientRect();
    let self = element.getBoundingClientRect();
    let scaleY = parent.height / container.offsetHeight;
    if (self.top < parent.top)
        container.scrollTop -= (parent.top - self.top) / scaleY;
    else if (self.bottom > parent.bottom)
        container.scrollTop += (self.bottom - parent.bottom) / scaleY;
}

// Used to pick a preferred option when two options with the same
// label occur in the result.
function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +
        (option.type ? 1 : 0);
}
function sortOptions(active, state) {
    let options = [];
    let sections = null;
    let addOption = (option) => {
        options.push(option);
        let { section } = option.completion;
        if (section) {
            if (!sections)
                sections = [];
            let name = typeof section == "string" ? section : section.name;
            if (!sections.some(s => s.name == name))
                sections.push(typeof section == "string" ? { name } : section);
        }
    };
    let conf = state.facet(completionConfig);
    for (let a of active)
        if (a.hasResult()) {
            let getMatch = a.result.getMatch;
            if (a.result.filter === false) {
                for (let option of a.result.options) {
                    addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
                }
            }
            else {
                let pattern = state.sliceDoc(a.from, a.to), match;
                let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
                for (let option of a.result.options)
                    if (match = matcher.match(option.label)) {
                        let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];
                        addOption(new Option(option, a.source, matched, match.score + (option.boost || 0)));
                    }
            }
        }
    if (sections) {
        let sectionOrder = Object.create(null), pos = 0;
        let cmp = (a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1); };
        for (let s of sections.sort(cmp)) {
            pos -= 1e5;
            sectionOrder[s.name] = pos;
        }
        for (let option of options) {
            let { section } = option.completion;
            if (section)
                option.score += sectionOrder[typeof section == "string" ? section : section.name];
        }
    }
    let result = [], prev = null;
    let compare = conf.compareCompletions;
    for (let opt of options.sort((a, b) => (b.score - a.score) || compare(a.completion, b.completion))) {
        let cur = opt.completion;
        if (!prev || prev.label != cur.label || prev.detail != cur.detail ||
            (prev.type != null && cur.type != null && prev.type != cur.type) ||
            prev.apply != cur.apply || prev.boost != cur.boost)
            result.push(opt);
        else if (score(opt.completion) > score(prev))
            result[result.length - 1] = opt;
        prev = opt.completion;
    }
    return result;
}
class CompletionDialog {
    constructor(options, attrs, tooltip, timestamp, selected, disabled) {
        this.options = options;
        this.attrs = attrs;
        this.tooltip = tooltip;
        this.timestamp = timestamp;
        this.selected = selected;
        this.disabled = disabled;
    }
    setSelected(selected, id) {
        return selected == this.selected || selected >= this.options.length ? this
            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
    }
    static build(active, state, id, prev, conf, didSetActive) {
        if (prev && !didSetActive && active.some(s => s.isPending))
            return prev.setDisabled();
        let options = sortOptions(active, state);
        if (!options.length)
            return prev && active.some(a => a.isPending) ? prev.setDisabled() : null;
        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
        if (prev && prev.selected != selected && prev.selected != -1) {
            let selectedValue = prev.options[prev.selected].completion;
            for (let i = 0; i < options.length; i++)
                if (options[i].completion == selectedValue) {
                    selected = i;
                    break;
                }
        }
        return new CompletionDialog(options, makeAttrs(id, selected), {
            pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
            create: createTooltip,
            above: conf.aboveCursor,
        }, prev ? prev.timestamp : Date.now(), selected, false);
    }
    map(changes) {
        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
    }
    setDisabled() {
        return new CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
    }
}
class CompletionState {
    constructor(active, id, open) {
        this.active = active;
        this.id = id;
        this.open = open;
    }
    static start() {
        return new CompletionState(none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
        let { state } = tr, conf = state.facet(completionConfig);
        let sources = conf.override ||
            state.languageDataAt("autocomplete", cur(state)).map(asSource);
        let active = sources.map(source => {
            let value = this.active.find(s => s.source == source) ||
                new ActiveSource(source, this.active.some(a => a.state != 0 /* State.Inactive */) ? 1 /* State.Pending */ : 0 /* State.Inactive */);
            return value.update(tr, conf);
        });
        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
            active = this.active;
        let open = this.open, didSet = tr.effects.some(e => e.is(setActiveEffect));
        if (open && tr.docChanged)
            open = open.map(tr.changes);
        if (tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||
            !sameResults(active, this.active) || didSet)
            open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
        else if (open && open.disabled && !active.some(a => a.isPending))
            open = null;
        if (!open && active.every(a => !a.isPending) && active.some(a => a.hasResult()))
            active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */) : a);
        for (let effect of tr.effects)
            if (effect.is(setSelectedEffect))
                open = open && open.setSelected(effect.value, this.id);
        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
    }
    get tooltip() { return this.open ? this.open.tooltip : null; }
    get attrs() { return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs; }
}
function sameResults(a, b) {
    if (a == b)
        return true;
    for (let iA = 0, iB = 0;;) {
        while (iA < a.length && !a[iA].hasResult())
            iA++;
        while (iB < b.length && !b[iB].hasResult())
            iB++;
        let endA = iA == a.length, endB = iB == b.length;
        if (endA || endB)
            return endA == endB;
        if (a[iA++].result != b[iB++].result)
            return false;
    }
}
const baseAttrs = {
    "aria-autocomplete": "list"
};
const noAttrs = {};
function makeAttrs(id, selected) {
    let result = {
        "aria-autocomplete": "list",
        "aria-haspopup": "listbox",
        "aria-controls": id
    };
    if (selected > -1)
        result["aria-activedescendant"] = id + "-" + selected;
    return result;
}
const none = [];
function getUpdateType(tr, conf) {
    if (tr.isUserEvent("input.complete")) {
        let completion = tr.annotation(pickedCompletion);
        if (completion && conf.activateOnCompletion(completion))
            return 4 /* UpdateType.Activate */ | 8 /* UpdateType.Reset */;
    }
    let typing = tr.isUserEvent("input.type");
    return typing && conf.activateOnTyping ? 4 /* UpdateType.Activate */ | 1 /* UpdateType.Typing */
        : typing ? 1 /* UpdateType.Typing */
            : tr.isUserEvent("delete.backward") ? 2 /* UpdateType.Backspacing */
                : tr.selection ? 8 /* UpdateType.Reset */
                    : tr.docChanged ? 16 /* UpdateType.ResetIfTouching */ : 0 /* UpdateType.None */;
}
class ActiveSource {
    constructor(source, state, explicit = false) {
        this.source = source;
        this.state = state;
        this.explicit = explicit;
    }
    hasResult() { return false; }
    get isPending() { return this.state == 1 /* State.Pending */; }
    update(tr, conf) {
        let type = getUpdateType(tr, conf), value = this;
        if ((type & 8 /* UpdateType.Reset */) || (type & 16 /* UpdateType.ResetIfTouching */) && this.touches(tr))
            value = new ActiveSource(value.source, 0 /* State.Inactive */);
        if ((type & 4 /* UpdateType.Activate */) && value.state == 0 /* State.Inactive */)
            value = new ActiveSource(this.source, 1 /* State.Pending */);
        value = value.updateFor(tr, type);
        for (let effect of tr.effects) {
            if (effect.is(startCompletionEffect))
                value = new ActiveSource(value.source, 1 /* State.Pending */, effect.value);
            else if (effect.is(closeCompletionEffect))
                value = new ActiveSource(value.source, 0 /* State.Inactive */);
            else if (effect.is(setActiveEffect))
                for (let active of effect.value)
                    if (active.source == value.source)
                        value = active;
        }
        return value;
    }
    updateFor(tr, type) { return this.map(tr.changes); }
    map(changes) { return this; }
    touches(tr) {
        return tr.changes.touchesRange(cur(tr.state));
    }
}
class ActiveResult extends ActiveSource {
    constructor(source, explicit, limit, result, from, to) {
        super(source, 3 /* State.Result */, explicit);
        this.limit = limit;
        this.result = result;
        this.from = from;
        this.to = to;
    }
    hasResult() { return true; }
    updateFor(tr, type) {
        var _a;
        if (!(type & 3 /* UpdateType.SimpleInteraction */))
            return this.map(tr.changes);
        let result = this.result;
        if (result.map && !tr.changes.empty)
            result = result.map(result, tr.changes);
        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
        let pos = cur(tr.state);
        if (pos > to || !result ||
            (type & 2 /* UpdateType.Backspacing */) && (cur(tr.startState) == this.from || pos < this.limit))
            return new ActiveSource(this.source, type & 4 /* UpdateType.Activate */ ? 1 /* State.Pending */ : 0 /* State.Inactive */);
        let limit = tr.changes.mapPos(this.limit);
        if (checkValid(result.validFor, tr.state, from, to))
            return new ActiveResult(this.source, this.explicit, limit, result, from, to);
        if (result.update &&
            (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false))))
            return new ActiveResult(this.source, this.explicit, limit, result, result.from, (_a = result.to) !== null && _a !== void 0 ? _a : cur(tr.state));
        return new ActiveSource(this.source, 1 /* State.Pending */, this.explicit);
    }
    map(mapping) {
        if (mapping.empty)
            return this;
        let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
        if (!result)
            return new ActiveSource(this.source, 0 /* State.Inactive */);
        return new ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
    }
    touches(tr) {
        return tr.changes.touchesRange(this.from, this.to);
    }
}
function checkValid(validFor, state, from, to) {
    if (!validFor)
        return false;
    let text = state.sliceDoc(from, to);
    return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
}
const setActiveEffect = state.StateEffect.define({
    map(sources, mapping) { return sources.map(s => s.map(mapping)); }
});
const setSelectedEffect = state.StateEffect.define();
const completionState = state.StateField.define({
    create() { return CompletionState.start(); },
    update(value, tr) { return value.update(tr); },
    provide: f => [
        view.showTooltip.from(f, val => val.tooltip),
        view.EditorView.contentAttributes.from(f, state => state.attrs)
    ]
});
function applyCompletion(view, option) {
    const apply = option.completion.apply || option.completion.label;
    let result = view.state.field(completionState).active.find(a => a.source == option.source);
    if (!(result instanceof ActiveResult))
        return false;
    if (typeof apply == "string")
        view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
    else
        apply(view, option.completion, result.from, result.to);
    return true;
}
const createTooltip = completionTooltip(completionState, applyCompletion);

/**
Returns a command that moves the completion selection forward or
backward by the given amount.
*/
function moveCompletionSelection(forward, by = "option") {
    return (view$1) => {
        let cState = view$1.state.field(completionState, false);
        if (!cState || !cState.open || cState.open.disabled ||
            Date.now() - cState.open.timestamp < view$1.state.facet(completionConfig).interactionDelay)
            return false;
        let step = 1, tooltip;
        if (by == "page" && (tooltip = view.getTooltip(view$1, cState.open.tooltip)))
            step = Math.max(2, Math.floor(tooltip.dom.offsetHeight /
                tooltip.dom.querySelector("li").offsetHeight) - 1);
        let { length } = cState.open.options;
        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
        if (selected < 0)
            selected = by == "page" ? 0 : length - 1;
        else if (selected >= length)
            selected = by == "page" ? length - 1 : 0;
        view$1.dispatch({ effects: setSelectedEffect.of(selected) });
        return true;
    };
}
/**
Accept the current completion.
*/
const acceptCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled ||
        Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
        return false;
    return applyCompletion(view, cState.open.options[cState.open.selected]);
};
/**
Explicitly start autocompletion.
*/
const startCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState)
        return false;
    view.dispatch({ effects: startCompletionEffect.of(true) });
    return true;
};
/**
Close the currently active completion.
*/
const closeCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some(a => a.state != 0 /* State.Inactive */))
        return false;
    view.dispatch({ effects: closeCompletionEffect.of(null) });
    return true;
};
class RunningQuery {
    constructor(active, context) {
        this.active = active;
        this.context = context;
        this.time = Date.now();
        this.updates = [];
        // Note that 'undefined' means 'not done yet', whereas 'null' means
        // 'query returned null'.
        this.done = undefined;
    }
}
const MaxUpdateCount = 50, MinAbortTime = 1000;
const completionPlugin = view.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.debounceUpdate = -1;
        this.running = [];
        this.debounceAccept = -1;
        this.pendingStart = false;
        this.composing = 0 /* CompositionState.None */;
        for (let active of view.state.field(completionState).active)
            if (active.isPending)
                this.startQuery(active);
    }
    update(update) {
        let cState = update.state.field(completionState);
        let conf = update.state.facet(completionConfig);
        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
            return;
        let doesReset = update.transactions.some(tr => {
            let type = getUpdateType(tr, conf);
            return (type & 8 /* UpdateType.Reset */) || (tr.selection || tr.docChanged) && !(type & 3 /* UpdateType.SimpleInteraction */);
        });
        for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i];
            if (doesReset ||
                query.context.abortOnDocChange && update.docChanged ||
                query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
                for (let handler of query.context.abortListeners) {
                    try {
                        handler();
                    }
                    catch (e) {
                        view.logException(this.view.state, e);
                    }
                }
                query.context.abortListeners = null;
                this.running.splice(i--, 1);
            }
            else {
                query.updates.push(...update.transactions);
            }
        }
        if (this.debounceUpdate > -1)
            clearTimeout(this.debounceUpdate);
        if (update.transactions.some(tr => tr.effects.some(e => e.is(startCompletionEffect))))
            this.pendingStart = true;
        let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;
        this.debounceUpdate = cState.active.some(a => a.isPending && !this.running.some(q => q.active.source == a.source))
            ? setTimeout(() => this.startUpdate(), delay) : -1;
        if (this.composing != 0 /* CompositionState.None */)
            for (let tr of update.transactions) {
                if (tr.isUserEvent("input.type"))
                    this.composing = 2 /* CompositionState.Changed */;
                else if (this.composing == 2 /* CompositionState.Changed */ && tr.selection)
                    this.composing = 3 /* CompositionState.ChangedAndMoved */;
            }
    }
    startUpdate() {
        this.debounceUpdate = -1;
        this.pendingStart = false;
        let { state } = this.view, cState = state.field(completionState);
        for (let active of cState.active) {
            if (active.isPending && !this.running.some(r => r.active.source == active.source))
                this.startQuery(active);
        }
        if (this.running.length && cState.open && cState.open.disabled)
            this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
    }
    startQuery(active) {
        let { state } = this.view, pos = cur(state);
        let context = new CompletionContext(state, pos, active.explicit, this.view);
        let pending = new RunningQuery(active, context);
        this.running.push(pending);
        Promise.resolve(active.source(context)).then(result => {
            if (!pending.context.aborted) {
                pending.done = result || null;
                this.scheduleAccept();
            }
        }, err => {
            this.view.dispatch({ effects: closeCompletionEffect.of(null) });
            view.logException(this.view.state, err);
        });
    }
    scheduleAccept() {
        if (this.running.every(q => q.done !== undefined))
            this.accept();
        else if (this.debounceAccept < 0)
            this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
    }
    // For each finished query in this.running, try to create a result
    // or, if appropriate, restart the query.
    accept() {
        var _a;
        if (this.debounceAccept > -1)
            clearTimeout(this.debounceAccept);
        this.debounceAccept = -1;
        let updated = [];
        let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
        for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i];
            if (query.done === undefined)
                continue;
            this.running.splice(i--, 1);
            if (query.done) {
                let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);
                let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));
                let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : pos);
                // Replay the transactions that happened since the start of
                // the request and see if that preserves the result
                for (let tr of query.updates)
                    active = active.update(tr, conf);
                if (active.hasResult()) {
                    updated.push(active);
                    continue;
                }
            }
            let current = cState.active.find(a => a.source == query.active.source);
            if (current && current.isPending) {
                if (query.done == null) {
                    // Explicitly failed. Should clear the pending status if it
                    // hasn't been re-set in the meantime.
                    let active = new ActiveSource(query.active.source, 0 /* State.Inactive */);
                    for (let tr of query.updates)
                        active = active.update(tr, conf);
                    if (!active.isPending)
                        updated.push(active);
                }
                else {
                    // Cleared by subsequent transactions. Restart.
                    this.startQuery(current);
                }
            }
        }
        if (updated.length || cState.open && cState.open.disabled)
            this.view.dispatch({ effects: setActiveEffect.of(updated) });
    }
}, {
    eventHandlers: {
        blur(event) {
            let state = this.view.state.field(completionState, false);
            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
                let dialog = state.open && view.getTooltip(this.view, state.open.tooltip);
                if (!dialog || !dialog.dom.contains(event.relatedTarget))
                    setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
            }
        },
        compositionstart() {
            this.composing = 1 /* CompositionState.Started */;
        },
        compositionend() {
            if (this.composing == 3 /* CompositionState.ChangedAndMoved */) {
                // Safari fires compositionend events synchronously, possibly
                // from inside an update, so dispatch asynchronously to avoid reentrancy
                setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
            }
            this.composing = 0 /* CompositionState.None */;
        }
    }
});
const windows = typeof navigator == "object" && /Win/.test(navigator.platform);
const commitCharacters = state.Prec.highest(view.EditorView.domEventHandlers({
    keydown(event, view) {
        let field = view.state.field(completionState, false);
        if (!field || !field.open || field.open.disabled || field.open.selected < 0 ||
            event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey)
            return false;
        let option = field.open.options[field.open.selected];
        let result = field.active.find(a => a.source == option.source);
        let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
        if (commitChars && commitChars.indexOf(event.key) > -1)
            applyCompletion(view, option);
        return false;
    }
}));

const baseTheme = view.EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
        "& > ul": {
            fontFamily: "monospace",
            whiteSpace: "nowrap",
            overflow: "hidden auto",
            maxWidth_fallback: "700px",
            maxWidth: "min(700px, 95vw)",
            minWidth: "250px",
            maxHeight: "10em",
            height: "100%",
            listStyle: "none",
            margin: 0,
            padding: 0,
            "& > li, & > completion-section": {
                padding: "1px 3px",
                lineHeight: 1.2
            },
            "& > li": {
                overflowX: "hidden",
                textOverflow: "ellipsis",
                cursor: "pointer"
            },
            "& > completion-section": {
                display: "list-item",
                borderBottom: "1px solid silver",
                paddingLeft: "0.5em",
                opacity: 0.7
            }
        }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#17c",
        color: "white",
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#777",
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#347",
        color: "white",
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#444",
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
        content: '"···"',
        opacity: 0.5,
        display: "block",
        textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
        position: "absolute",
        padding: "3px 9px",
        width: "max-content",
        maxWidth: `${400 /* Info.Width */}px`,
        boxSizing: "border-box",
        whiteSpace: "pre-line"
    },
    ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
    ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
    ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30 /* Info.Margin */}px` },
    ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30 /* Info.Margin */}px` },
    "&light .cm-snippetField": { backgroundColor: "#00000022" },
    "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
    ".cm-snippetFieldPosition": {
        verticalAlign: "text-top",
        width: 0,
        height: "1.15em",
        display: "inline-block",
        margin: "0 -0.7px -.7em",
        borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
        textDecoration: "underline"
    },
    ".cm-completionDetail": {
        marginLeft: "0.5em",
        fontStyle: "italic"
    },
    ".cm-completionIcon": {
        fontSize: "90%",
        width: ".8em",
        display: "inline-block",
        textAlign: "center",
        paddingRight: ".6em",
        opacity: "0.6",
        boxSizing: "content-box"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
        "&:after": { content: "'ƒ'" }
    },
    ".cm-completionIcon-class": {
        "&:after": { content: "'○'" }
    },
    ".cm-completionIcon-interface": {
        "&:after": { content: "'◌'" }
    },
    ".cm-completionIcon-variable": {
        "&:after": { content: "'𝑥'" }
    },
    ".cm-completionIcon-constant": {
        "&:after": { content: "'𝐶'" }
    },
    ".cm-completionIcon-type": {
        "&:after": { content: "'𝑡'" }
    },
    ".cm-completionIcon-enum": {
        "&:after": { content: "'∪'" }
    },
    ".cm-completionIcon-property": {
        "&:after": { content: "'□'" }
    },
    ".cm-completionIcon-keyword": {
        "&:after": { content: "'🔑\uFE0E'" } // Disable emoji rendering
    },
    ".cm-completionIcon-namespace": {
        "&:after": { content: "'▢'" }
    },
    ".cm-completionIcon-text": {
        "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
    }
});

class FieldPos {
    constructor(field, line, from, to) {
        this.field = field;
        this.line = line;
        this.from = from;
        this.to = to;
    }
}
class FieldRange {
    constructor(field, from, to) {
        this.field = field;
        this.from = from;
        this.to = to;
    }
    map(changes) {
        let from = changes.mapPos(this.from, -1, state.MapMode.TrackDel);
        let to = changes.mapPos(this.to, 1, state.MapMode.TrackDel);
        return from == null || to == null ? null : new FieldRange(this.field, from, to);
    }
}
class Snippet {
    constructor(lines, fieldPositions) {
        this.lines = lines;
        this.fieldPositions = fieldPositions;
    }
    instantiate(state, pos) {
        let text = [], lineStart = [pos];
        let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
        for (let line of this.lines) {
            if (text.length) {
                let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
                for (let i = 0; i < tabs; i++)
                    indent += state.facet(language.indentUnit);
                lineStart.push(pos + indent.length - tabs);
                line = indent + line.slice(tabs);
            }
            text.push(line);
            pos += line.length + 1;
        }
        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));
        return { text, ranges };
    }
    static parse(template) {
        let fields = [];
        let lines = [], positions = [], m;
        for (let line of template.split(/\r\n?|\n/)) {
            while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(line)) {
                let seq = m[1] ? +m[1] : null, rawName = m[2] || m[3] || "", found = -1;
                let name = rawName.replace(/\\[{}]/g, m => m[1]);
                for (let i = 0; i < fields.length; i++) {
                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)
                        found = i;
                }
                if (found < 0) {
                    let i = 0;
                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))
                        i++;
                    fields.splice(i, 0, { seq, name });
                    found = i;
                    for (let pos of positions)
                        if (pos.field >= found)
                            pos.field++;
                }
                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));
                line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length);
            }
            line = line.replace(/\\([{}])/g, (_, brace, index) => {
                for (let pos of positions)
                    if (pos.line == lines.length && pos.from > index) {
                        pos.from--;
                        pos.to--;
                    }
                return brace;
            });
            lines.push(line);
        }
        return new Snippet(lines, positions);
    }
}
let fieldMarker = view.Decoration.widget({ widget: new class extends view.WidgetType {
        toDOM() {
            let span = document.createElement("span");
            span.className = "cm-snippetFieldPosition";
            return span;
        }
        ignoreEvent() { return false; }
    } });
let fieldRange = view.Decoration.mark({ class: "cm-snippetField" });
class ActiveSnippet {
    constructor(ranges, active) {
        this.ranges = ranges;
        this.active = active;
        this.deco = view.Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
    }
    map(changes) {
        let ranges = [];
        for (let r of this.ranges) {
            let mapped = r.map(changes);
            if (!mapped)
                return null;
            ranges.push(mapped);
        }
        return new ActiveSnippet(ranges, this.active);
    }
    selectionInsideField(sel) {
        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));
    }
}
const setActive = state.StateEffect.define({
    map(value, changes) { return value && value.map(changes); }
});
const moveToField = state.StateEffect.define();
const snippetState = state.StateField.define({
    create() { return null; },
    update(value, tr) {
        for (let effect of tr.effects) {
            if (effect.is(setActive))
                return effect.value;
            if (effect.is(moveToField) && value)
                return new ActiveSnippet(value.ranges, effect.value);
        }
        if (value && tr.docChanged)
            value = value.map(tr.changes);
        if (value && tr.selection && !value.selectionInsideField(tr.selection))
            value = null;
        return value;
    },
    provide: f => view.EditorView.decorations.from(f, val => val ? val.deco : view.Decoration.none)
});
function fieldSelection(ranges, field) {
    return state.EditorSelection.create(ranges.filter(r => r.field == field).map(r => state.EditorSelection.range(r.from, r.to)));
}
/**
Convert a snippet template to a function that can
[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written
using syntax like this:

    "for (let ${index} = 0; ${index} < ${end}; ${index}++) {\n\t${}\n}"

Each `${}` placeholder (you may also use `#{}`) indicates a field
that the user can fill in. Its name, if any, will be the default
content for the field.

When the snippet is activated by calling the returned function,
the code is inserted at the given position. Newlines in the
template are indented by the indentation of the start line, plus
one [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after
the newline.

On activation, (all instances of) the first field are selected.
The user can move between fields with Tab and Shift-Tab as long as
the fields are active. Moving to the last field or moving the
cursor out of the current field deactivates the fields.

The order of fields defaults to textual order, but you can add
numbers to placeholders (`${1}` or `${1:defaultText}`) to provide
a custom order.

To include a literal `{` or `}` in your template, put a backslash
in front of it. This will be removed and the brace will not be
interpreted as indicating a placeholder.
*/
function snippet(template) {
    let snippet = Snippet.parse(template);
    return (editor, completion, from, to) => {
        let { text, ranges } = snippet.instantiate(editor.state, from);
        let spec = {
            changes: { from, to, insert: state.Text.of(text) },
            scrollIntoView: true,
            annotations: completion ? [pickedCompletion.of(completion), state.Transaction.userEvent.of("input.complete")] : undefined
        };
        if (ranges.length)
            spec.selection = fieldSelection(ranges, 0);
        if (ranges.some(r => r.field > 0)) {
            let active = new ActiveSnippet(ranges, 0);
            let effects = spec.effects = [setActive.of(active)];
            if (editor.state.field(snippetState, false) === undefined)
                effects.push(state.StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));
        }
        editor.dispatch(editor.state.update(spec));
    };
}
function moveField(dir) {
    return ({ state, dispatch }) => {
        let active = state.field(snippetState, false);
        if (!active || dir < 0 && active.active == 0)
            return false;
        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);
        dispatch(state.update({
            selection: fieldSelection(active.ranges, next),
            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),
            scrollIntoView: true
        }));
        return true;
    };
}
/**
A command that clears the active snippet, if any.
*/
const clearSnippet = ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active)
        return false;
    dispatch(state.update({ effects: setActive.of(null) }));
    return true;
};
/**
Move to the next snippet field, if available.
*/
const nextSnippetField = moveField(1);
/**
Move to the previous snippet field, if available.
*/
const prevSnippetField = moveField(-1);
/**
Check if there is an active snippet with a next field for
`nextSnippetField` to move to.
*/
function hasNextSnippetField(state) {
    let active = state.field(snippetState, false);
    return !!(active && active.ranges.some(r => r.field == active.active + 1));
}
/**
Returns true if there is an active snippet and a previous field
for `prevSnippetField` to move to.
*/
function hasPrevSnippetField(state) {
    let active = state.field(snippetState, false);
    return !!(active && active.active > 0);
}
const defaultSnippetKeymap = [
    { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
    { key: "Escape", run: clearSnippet }
];
/**
A facet that can be used to configure the key bindings used by
snippets. The default binds Tab to
[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to
[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape
to [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).
*/
const snippetKeymap = state.Facet.define({
    combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }
});
const addSnippetKeymap = state.Prec.highest(view.keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));
/**
Create a completion from a snippet. Returns an object with the
properties from `completion`, plus an `apply` function that
applies the snippet.
*/
function snippetCompletion(template, completion) {
    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });
}
const snippetPointerHandler = view.EditorView.domEventHandlers({
    mousedown(event, view) {
        let active = view.state.field(snippetState, false), pos;
        if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
            return false;
        let match = active.ranges.find(r => r.from <= pos && r.to >= pos);
        if (!match || match.field == active.active)
            return false;
        view.dispatch({
            selection: fieldSelection(active.ranges, match.field),
            effects: setActive.of(active.ranges.some(r => r.field > match.field)
                ? new ActiveSnippet(active.ranges, match.field) : null),
            scrollIntoView: true
        });
        return true;
    }
});

function wordRE(wordChars) {
    let escaped = wordChars.replace(/[\]\-\\]/g, "\\$&");
    try {
        return new RegExp(`[\\p{Alphabetic}\\p{Number}_${escaped}]+`, "ug");
    }
    catch (_a) {
        return new RegExp(`[\w${escaped}]`, "g");
    }
}
function mapRE(re, f) {
    return new RegExp(f(re.source), re.unicode ? "u" : "");
}
const wordCaches = Object.create(null);
function wordCache(wordChars) {
    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);
}
function storeWords(doc, wordRE, result, seen, ignoreAt) {
    for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {
        let { value } = lines, m;
        wordRE.lastIndex = 0;
        while (m = wordRE.exec(value)) {
            if (!seen[m[0]] && pos + m.index != ignoreAt) {
                result.push({ type: "text", label: m[0] });
                seen[m[0]] = true;
                if (result.length >= 2000 /* C.MaxList */)
                    return;
            }
        }
        pos += value.length + 1;
    }
}
function collectWords(doc, cache, wordRE, to, ignoreAt) {
    let big = doc.length >= 1000 /* C.MinCacheLen */;
    let cached = big && cache.get(doc);
    if (cached)
        return cached;
    let result = [], seen = Object.create(null);
    if (doc.children) {
        let pos = 0;
        for (let ch of doc.children) {
            if (ch.length >= 1000 /* C.MinCacheLen */) {
                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {
                    if (!seen[c.label]) {
                        seen[c.label] = true;
                        result.push(c);
                    }
                }
            }
            else {
                storeWords(ch, wordRE, result, seen, ignoreAt - pos);
            }
            pos += ch.length + 1;
        }
    }
    else {
        storeWords(doc, wordRE, result, seen, ignoreAt);
    }
    if (big && result.length < 2000 /* C.MaxList */)
        cache.set(doc, result);
    return result;
}
/**
A completion source that will scan the document for words (using a
[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and
return those as completions.
*/
const completeAnyWord = context => {
    let wordChars = context.state.languageDataAt("wordChars", context.pos).join("");
    let re = wordRE(wordChars);
    let token = context.matchBefore(mapRE(re, s => s + "$"));
    if (!token && !context.explicit)
        return null;
    let from = token ? token.from : context.pos;
    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */, from);
    return { from, options, validFor: mapRE(re, s => "^" + s) };
};

const defaults = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>",
    stringPrefixes: []
};
const closeBracketEffect = state.StateEffect.define({
    map(value, mapping) {
        let mapped = mapping.mapPos(value, -1, state.MapMode.TrackAfter);
        return mapped == null ? undefined : mapped;
    }
});
const closedBracket = new class extends state.RangeValue {
};
closedBracket.startSide = 1;
closedBracket.endSide = -1;
const bracketState = state.StateField.define({
    create() { return state.RangeSet.empty; },
    update(value, tr) {
        value = value.map(tr.changes);
        if (tr.selection) {
            let line = tr.state.doc.lineAt(tr.selection.main.head);
            value = value.update({ filter: from => from >= line.from && from <= line.to });
        }
        for (let effect of tr.effects)
            if (effect.is(closeBracketEffect))
                value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
        return value;
    }
});
/**
Extension to enable bracket-closing behavior. When a closeable
bracket is typed, its closing bracket is immediately inserted
after the cursor. When closing a bracket directly in front of a
closing bracket inserted by the extension, the cursor moves over
that bracket.
*/
function closeBrackets() {
    return [inputHandler, bracketState];
}
const definedClosing = "()[]{}<>";
function closing(ch) {
    for (let i = 0; i < definedClosing.length; i += 2)
        if (definedClosing.charCodeAt(i) == ch)
            return definedClosing.charAt(i + 1);
    return state.fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state, pos) {
    return state.languageDataAt("closeBrackets", pos)[0] || defaults;
}
const android = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
const inputHandler = view.EditorView.inputHandler.of((view, from, to, insert) => {
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
        return false;
    let sel = view.state.selection.main;
    if (insert.length > 2 || insert.length == 2 && state.codePointSize(state.codePointAt(insert, 0)) == 1 ||
        from != sel.from || to != sel.to)
        return false;
    let tr = insertBracket(view.state, insert);
    if (!tr)
        return false;
    view.dispatch(tr);
    return true;
});
/**
Command that implements deleting a pair of matching brackets when
the cursor is between them.
*/
const deleteBracketPair = ({ state: state$1, dispatch }) => {
    if (state$1.readOnly)
        return false;
    let conf = config(state$1, state$1.selection.main.head);
    let tokens = conf.brackets || defaults.brackets;
    let dont = null, changes = state$1.changeByRange(range => {
        if (range.empty) {
            let before = prevChar(state$1.doc, range.head);
            for (let token of tokens) {
                if (token == before && nextChar(state$1.doc, range.head) == closing(state.codePointAt(token, 0)))
                    return { changes: { from: range.head - token.length, to: range.head + token.length },
                        range: state.EditorSelection.cursor(range.head - token.length) };
            }
        }
        return { range: dont = range };
    });
    if (!dont)
        dispatch(state$1.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
    return !dont;
};
/**
Close-brackets related key bindings. Binds Backspace to
[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).
*/
const closeBracketsKeymap = [
    { key: "Backspace", run: deleteBracketPair }
];
/**
Implements the extension's behavior on text insertion. If the
given string counts as a bracket in the language around the
selection, and replacing the selection with it requires custom
behavior (inserting a closing version or skipping past a
previously-closed bracket), this function returns a transaction
representing that custom behavior. (You only need this if you want
to programmatically insert brackets—the
[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will
take care of running this for user input.)
*/
function insertBracket(state$1, bracket) {
    let conf = config(state$1, state$1.selection.main.head);
    let tokens = conf.brackets || defaults.brackets;
    for (let tok of tokens) {
        let closed = closing(state.codePointAt(tok, 0));
        if (bracket == tok)
            return closed == tok ? handleSame(state$1, tok, tokens.indexOf(tok + tok + tok) > -1, conf)
                : handleOpen(state$1, tok, closed, conf.before || defaults.before);
        if (bracket == closed && closedBracketAt(state$1, state$1.selection.main.from))
            return handleClose(state$1, tok, closed);
    }
    return null;
}
function closedBracketAt(state, pos) {
    let found = false;
    state.field(bracketState).between(0, state.doc.length, from => {
        if (from == pos)
            found = true;
    });
    return found;
}
function nextChar(doc, pos) {
    let next = doc.sliceString(pos, pos + 2);
    return next.slice(0, state.codePointSize(state.codePointAt(next, 0)));
}
function prevChar(doc, pos) {
    let prev = doc.sliceString(pos - 2, pos);
    return state.codePointSize(state.codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state$1, open, close, closeBefore) {
    let dont = null, changes = state$1.changeByRange(range => {
        if (!range.empty)
            return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
                effects: closeBracketEffect.of(range.to + open.length),
                range: state.EditorSelection.range(range.anchor + open.length, range.head + open.length) };
        let next = nextChar(state$1.doc, range.head);
        if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
            return { changes: { insert: open + close, from: range.head },
                effects: closeBracketEffect.of(range.head + open.length),
                range: state.EditorSelection.cursor(range.head + open.length) };
        return { range: dont = range };
    });
    return dont ? null : state$1.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
    });
}
function handleClose(state$1, _open, close) {
    let dont = null, changes = state$1.changeByRange(range => {
        if (range.empty && nextChar(state$1.doc, range.head) == close)
            return { changes: { from: range.head, to: range.head + close.length, insert: close },
                range: state.EditorSelection.cursor(range.head + close.length) };
        return dont = { range };
    });
    return dont ? null : state$1.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
    });
}
// Handles cases where the open and close token are the same, and
// possibly triple quotes (as in `"""abc"""`-style quoting).
function handleSame(state$1, token, allowTriple, config) {
    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;
    let dont = null, changes = state$1.changeByRange(range => {
        if (!range.empty)
            return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
                effects: closeBracketEffect.of(range.to + token.length),
                range: state.EditorSelection.range(range.anchor + token.length, range.head + token.length) };
        let pos = range.head, next = nextChar(state$1.doc, pos), start;
        if (next == token) {
            if (nodeStart(state$1, pos)) {
                return { changes: { insert: token + token, from: pos },
                    effects: closeBracketEffect.of(pos + token.length),
                    range: state.EditorSelection.cursor(pos + token.length) };
            }
            else if (closedBracketAt(state$1, pos)) {
                let isTriple = allowTriple && state$1.sliceDoc(pos, pos + token.length * 3) == token + token + token;
                let content = isTriple ? token + token + token : token;
                return { changes: { from: pos, to: pos + content.length, insert: content },
                    range: state.EditorSelection.cursor(pos + content.length) };
            }
        }
        else if (allowTriple && state$1.sliceDoc(pos - 2 * token.length, pos) == token + token &&
            (start = canStartStringAt(state$1, pos - 2 * token.length, stringPrefixes)) > -1 &&
            nodeStart(state$1, start)) {
            return { changes: { insert: token + token + token + token, from: pos },
                effects: closeBracketEffect.of(pos + token.length),
                range: state.EditorSelection.cursor(pos + token.length) };
        }
        else if (state$1.charCategorizer(pos)(next) != state.CharCategory.Word) {
            if (canStartStringAt(state$1, pos, stringPrefixes) > -1 && !probablyInString(state$1, pos, token, stringPrefixes))
                return { changes: { insert: token + token, from: pos },
                    effects: closeBracketEffect.of(pos + token.length),
                    range: state.EditorSelection.cursor(pos + token.length) };
        }
        return { range: dont = range };
    });
    return dont ? null : state$1.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
    });
}
function nodeStart(state, pos) {
    let tree = language.syntaxTree(state).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
    let node = language.syntaxTree(state).resolveInner(pos, -1);
    let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
    for (let i = 0; i < 5; i++) {
        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
        let quotePos = start.indexOf(quoteToken);
        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
            let first = node.firstChild;
            while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
                    return false;
                first = first.firstChild;
            }
            return true;
        }
        let parent = node.to == pos && node.parent;
        if (!parent)
            break;
        node = parent;
    }
    return false;
}
function canStartStringAt(state$1, pos, prefixes) {
    let charCat = state$1.charCategorizer(pos);
    if (charCat(state$1.sliceDoc(pos - 1, pos)) != state.CharCategory.Word)
        return pos;
    for (let prefix of prefixes) {
        let start = pos - prefix.length;
        if (state$1.sliceDoc(start, pos) == prefix && charCat(state$1.sliceDoc(start - 1, start)) != state.CharCategory.Word)
            return start;
    }
    return -1;
}

/**
Returns an extension that enables autocompletion.
*/
function autocompletion(config = {}) {
    return [
        commitCharacters,
        completionState,
        completionConfig.of(config),
        completionPlugin,
        completionKeymapExt,
        baseTheme
    ];
}
/**
Basic keybindings for autocompletion.

 - Ctrl-Space (and Alt-\` on macOS): [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)
 - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)
 - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`
 - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`
 - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
 - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
 - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)
*/
const completionKeymap = [
    { key: "Ctrl-Space", run: startCompletion },
    { mac: "Alt-`", run: startCompletion },
    { key: "Escape", run: closeCompletion },
    { key: "ArrowDown", run: moveCompletionSelection(true) },
    { key: "ArrowUp", run: moveCompletionSelection(false) },
    { key: "PageDown", run: moveCompletionSelection(true, "page") },
    { key: "PageUp", run: moveCompletionSelection(false, "page") },
    { key: "Enter", run: acceptCompletion }
];
const completionKeymapExt = state.Prec.highest(view.keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
/**
Get the current completion status. When completions are available,
this will return `"active"`. When completions are pending (in the
process of being queried), this returns `"pending"`. Otherwise, it
returns `null`.
*/
function completionStatus(state) {
    let cState = state.field(completionState, false);
    return cState && cState.active.some(a => a.isPending) ? "pending"
        : cState && cState.active.some(a => a.state != 0 /* State.Inactive */) ? "active" : null;
}
const completionArrayCache = new WeakMap;
/**
Returns the available completions as an array.
*/
function currentCompletions(state) {
    var _a;
    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
    if (!open || open.disabled)
        return [];
    let completions = completionArrayCache.get(open.options);
    if (!completions)
        completionArrayCache.set(open.options, completions = open.options.map(o => o.completion));
    return completions;
}
/**
Return the currently selected completion, if any.
*/
function selectedCompletion(state) {
    var _a;
    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;
}
/**
Returns the currently selected position in the active completion
list, or null if no completions are active.
*/
function selectedCompletionIndex(state) {
    var _a;
    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
    return open && !open.disabled && open.selected >= 0 ? open.selected : null;
}
/**
Create an effect that can be attached to a transaction to change
the currently selected completion.
*/
function setSelectedCompletion(index) {
    return setSelectedEffect.of(index);
}

exports.CompletionContext = CompletionContext;
exports.acceptCompletion = acceptCompletion;
exports.autocompletion = autocompletion;
exports.clearSnippet = clearSnippet;
exports.closeBrackets = closeBrackets;
exports.closeBracketsKeymap = closeBracketsKeymap;
exports.closeCompletion = closeCompletion;
exports.completeAnyWord = completeAnyWord;
exports.completeFromList = completeFromList;
exports.completionKeymap = completionKeymap;
exports.completionStatus = completionStatus;
exports.currentCompletions = currentCompletions;
exports.deleteBracketPair = deleteBracketPair;
exports.hasNextSnippetField = hasNextSnippetField;
exports.hasPrevSnippetField = hasPrevSnippetField;
exports.ifIn = ifIn;
exports.ifNotIn = ifNotIn;
exports.insertBracket = insertBracket;
exports.insertCompletionText = insertCompletionText;
exports.moveCompletionSelection = moveCompletionSelection;
exports.nextSnippetField = nextSnippetField;
exports.pickedCompletion = pickedCompletion;
exports.prevSnippetField = prevSnippetField;
exports.selectedCompletion = selectedCompletion;
exports.selectedCompletionIndex = selectedCompletionIndex;
exports.setSelectedCompletion = setSelectedCompletion;
exports.snippet = snippet;
exports.snippetCompletion = snippetCompletion;
exports.snippetKeymap = snippetKeymap;
exports.startCompletion = startCompletion;


/***/ }),

/***/ "./node_modules/@codemirror/commands/dist/index.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var state = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.cjs");
var view = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.cjs");
var language = __webpack_require__(/*! @codemirror/language */ "./node_modules/@codemirror/language/dist/index.cjs");
var common = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.cjs");

/**
Comment or uncomment the current selection. Will use line comments
if available, otherwise falling back to block comments.
*/
const toggleComment = target => {
    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);
    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
    return ({ state, dispatch }) => {
        if (state.readOnly)
            return false;
        let tr = f(option, state);
        if (!tr)
            return false;
        dispatch(state.update(tr));
        return true;
    };
}
/**
Comment or uncomment the current selection using line comments.
The line comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/
const toggleLineComment = command(changeLineComment, 0 /* CommentOption.Toggle */);
/**
Comment the current selection using line comments.
*/
const lineComment = command(changeLineComment, 1 /* CommentOption.Comment */);
/**
Uncomment the current selection using line comments.
*/
const lineUncomment = command(changeLineComment, 2 /* CommentOption.Uncomment */);
/**
Comment or uncomment the current selection using block comments.
The block comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/
const toggleBlockComment = command(changeBlockComment, 0 /* CommentOption.Toggle */);
/**
Comment the current selection using block comments.
*/
const blockComment = command(changeBlockComment, 1 /* CommentOption.Comment */);
/**
Uncomment the current selection using block comments.
*/
const blockUncomment = command(changeBlockComment, 2 /* CommentOption.Uncomment */);
/**
Comment or uncomment the lines around the current selection using
block comments.
*/
const toggleBlockCommentByLine = command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */);
function getConfig(state, pos) {
    let data = state.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
}
const SearchMargin = 50;
/**
Determines if the given range is block-commented in the given
state.
*/
function findBlockComment(state, { open, close }, from, to) {
    let textBefore = state.sliceDoc(from - SearchMargin, from);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&
        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
        startText = endText = state.sliceDoc(from, to);
    }
    else {
        startText = state.sliceDoc(from, from + SearchMargin);
        endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open &&
        endText.slice(endOff, endOff + close.length) == close) {
        return { open: { pos: from + startSpace + open.length,
                margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },
            close: { pos: to - endSpace - close.length,
                margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };
    }
    return null;
}
function selectedLineRanges(state) {
    let ranges = [];
    for (let r of state.selection.ranges) {
        let fromLine = state.doc.lineAt(r.from);
        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
        if (toLine.from > fromLine.from && toLine.from == r.to)
            toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);
        let last = ranges.length - 1;
        if (last >= 0 && ranges[last].to > fromLine.from)
            ranges[last].to = toLine.to;
        else
            ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
    }
    return ranges;
}
// Performs toggle, comment and uncomment of block comments in
// languages that support them.
function changeBlockComment(option, state, ranges = state.selection.ranges) {
    let tokens = ranges.map(r => getConfig(state, r.from).block);
    if (!tokens.every(c => c))
        return null;
    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
    if (option != 2 /* CommentOption.Uncomment */ && !comments.every(c => c)) {
        return { changes: state.changes(ranges.map((range, i) => {
                if (comments[i])
                    return [];
                return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
            })) };
    }
    else if (option != 1 /* CommentOption.Comment */ && comments.some(c => c)) {
        let changes = [];
        for (let i = 0, comment; i < comments.length; i++)
            if (comment = comments[i]) {
                let token = tokens[i], { open, close } = comment;
                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
            }
        return { changes };
    }
    return null;
}
// Performs toggle, comment and uncomment of line comments.
function changeLineComment(option, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from, to } of ranges) {
        let startI = lines.length, minIndent = 1e9;
        let token = getConfig(state, from).line;
        if (!token)
            continue;
        for (let pos = from; pos <= to;) {
            let line = state.doc.lineAt(pos);
            if (line.from > prevLine && (from == to || to > line.from)) {
                prevLine = line.from;
                let indent = /^\s*/.exec(line.text)[0].length;
                let empty = indent == line.length;
                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
                if (indent < line.text.length && indent < minIndent)
                    minIndent = indent;
                lines.push({ line, comment, token, indent, empty, single: false });
            }
            pos = line.to + 1;
        }
        if (minIndent < 1e9)
            for (let i = startI; i < lines.length; i++)
                if (lines[i].indent < lines[i].line.text.length)
                    lines[i].indent = minIndent;
        if (lines.length == startI + 1)
            lines[startI].single = true;
    }
    if (option != 2 /* CommentOption.Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {
        let changes = [];
        for (let { line, token, indent, empty, single } of lines)
            if (single || !empty)
                changes.push({ from: line.from + indent, insert: token + " " });
        let changeSet = state.changes(changes);
        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
    }
    else if (option != 1 /* CommentOption.Comment */ && lines.some(l => l.comment >= 0)) {
        let changes = [];
        for (let { line, comment, token } of lines)
            if (comment >= 0) {
                let from = line.from + comment, to = from + token.length;
                if (line.text[to - line.from] == " ")
                    to++;
                changes.push({ from, to });
            }
        return { changes };
    }
    return null;
}

const fromHistory = state.Annotation.define();
/**
Transaction annotation that will prevent that transaction from
being combined with other transactions in the undo history. Given
`"before"`, it'll prevent merging with previous transactions. With
`"after"`, subsequent transactions won't be combined with this
one. With `"full"`, the transaction is isolated on both sides.
*/
const isolateHistory = state.Annotation.define();
/**
This facet provides a way to register functions that, given a
transaction, provide a set of effects that the history should
store when inverting the transaction. This can be used to
integrate some kinds of effects in the history, so that they can
be undone (and redone again).
*/
const invertedEffects = state.Facet.define();
const historyConfig = state.Facet.define({
    combine(configs) {
        return state.combineConfig(configs, {
            minDepth: 100,
            newGroupDelay: 500,
            joinToEvent: (_t, isAdjacent) => isAdjacent,
        }, {
            minDepth: Math.max,
            newGroupDelay: Math.min,
            joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
        });
    }
});
const historyField_ = state.StateField.define({
    create() {
        return HistoryState.empty;
    },
    update(state$1, tr) {
        let config = tr.state.facet(historyConfig);
        let fromHist = tr.annotation(fromHistory);
        if (fromHist) {
            let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
            let other = from == 0 /* BranchName.Done */ ? state$1.undone : state$1.done;
            if (item)
                other = updateBranch(other, other.length, config.minDepth, item);
            else
                other = addSelection(other, tr.startState.selection);
            return new HistoryState(from == 0 /* BranchName.Done */ ? fromHist.rest : other, from == 0 /* BranchName.Done */ ? other : fromHist.rest);
        }
        let isolate = tr.annotation(isolateHistory);
        if (isolate == "full" || isolate == "before")
            state$1 = state$1.isolate();
        if (tr.annotation(state.Transaction.addToHistory) === false)
            return !tr.changes.empty ? state$1.addMapping(tr.changes.desc) : state$1;
        let event = HistEvent.fromTransaction(tr);
        let time = tr.annotation(state.Transaction.time), userEvent = tr.annotation(state.Transaction.userEvent);
        if (event)
            state$1 = state$1.addChanges(event, time, userEvent, config, tr);
        else if (tr.selection)
            state$1 = state$1.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
        if (isolate == "full" || isolate == "after")
            state$1 = state$1.isolate();
        return state$1;
    },
    toJSON(value) {
        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };
    },
    fromJSON(json) {
        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
});
/**
Create a history extension with the given configuration.
*/
function history(config = {}) {
    return [
        historyField_,
        historyConfig.of(config),
        view.EditorView.domEventHandlers({
            beforeinput(e, view) {
                let command = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
                if (!command)
                    return false;
                e.preventDefault();
                return command(view);
            }
        })
    ];
}
/**
The state field used to store the history data. Should probably
only be used when you want to
[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or
[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way
that preserves history.
*/
const historyField = historyField_;
function cmd(side, selection) {
    return function ({ state, dispatch }) {
        if (!selection && state.readOnly)
            return false;
        let historyState = state.field(historyField_, false);
        if (!historyState)
            return false;
        let tr = historyState.pop(side, state, selection);
        if (!tr)
            return false;
        dispatch(tr);
        return true;
    };
}
/**
Undo a single group of history events. Returns false if no group
was available.
*/
const undo = cmd(0 /* BranchName.Done */, false);
/**
Redo a group of history events. Returns false if no group was
available.
*/
const redo = cmd(1 /* BranchName.Undone */, false);
/**
Undo a change or selection change.
*/
const undoSelection = cmd(0 /* BranchName.Done */, true);
/**
Redo a change or selection change.
*/
const redoSelection = cmd(1 /* BranchName.Undone */, true);
function depth(side) {
    return function (state) {
        let histState = state.field(historyField_, false);
        if (!histState)
            return 0;
        let branch = side == 0 /* BranchName.Done */ ? histState.done : histState.undone;
        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
    };
}
/**
The amount of undoable change events available in a given state.
*/
const undoDepth = depth(0 /* BranchName.Done */);
/**
The amount of redoable change events available in a given state.
*/
const redoDepth = depth(1 /* BranchName.Undone */);
// History events store groups of changes or effects that need to be
// undone/redone together.
class HistEvent {
    constructor(
    // The changes in this event. Normal events hold at least one
    // change or effect. But it may be necessary to store selection
    // events before the first change, in which case a special type of
    // instance is created which doesn't hold any changes, with
    // changes == startSelection == undefined
    changes, 
    // The effects associated with this event
    effects, 
    // Accumulated mapping (from addToHistory==false) that should be
    // applied to events below this one.
    mapped, 
    // The selection before this event
    startSelection, 
    // Stores selection changes after this event, to be used for
    // selection undo/redo.
    selectionsAfter) {
        this.changes = changes;
        this.effects = effects;
        this.mapped = mapped;
        this.startSelection = startSelection;
        this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
        var _a, _b, _c;
        return {
            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())
        };
    }
    static fromJSON(json) {
        return new HistEvent(json.changes && state.ChangeSet.fromJSON(json.changes), [], json.mapped && state.ChangeDesc.fromJSON(json.mapped), json.startSelection && state.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(state.EditorSelection.fromJSON));
    }
    // This does not check `addToHistory` and such, it assumes the
    // transaction needs to be converted to an item. Returns null when
    // there are no changes or effects in the transaction.
    static fromTransaction(tr, selection) {
        let effects = none;
        for (let invert of tr.startState.facet(invertedEffects)) {
            let result = invert(tr);
            if (result.length)
                effects = effects.concat(result);
        }
        if (!effects.length && tr.changes.empty)
            return null;
        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);
    }
    static selection(selections) {
        return new HistEvent(undefined, none, undefined, undefined, selections);
    }
}
function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
}
function isAdjacent(a, b) {
    let ranges = [], isAdjacent = false;
    a.iterChangedRanges((f, t) => ranges.push(f, t));
    b.iterChangedRanges((_f, _t, f, t) => {
        for (let i = 0; i < ranges.length;) {
            let from = ranges[i++], to = ranges[i++];
            if (t >= from && f <= to)
                isAdjacent = true;
        }
    });
    return isAdjacent;
}
function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length &&
        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
}
const none = [];
const MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
    if (!branch.length) {
        return [HistEvent.selection([selection])];
    }
    else {
        let lastEvent = branch[branch.length - 1];
        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
        if (sels.length && sels[sels.length - 1].eq(selection))
            return branch;
        sels.push(selection);
        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
}
// Assumes the top item has one or more selectionAfter values
function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
}
// Add a mapping to the top event in the given branch. If this maps
// away all the changes and effects in that item, drop it and
// propagate the mapping to the next item.
function addMappingToBranch(branch, mapping) {
    if (!branch.length)
        return branch;
    let length = branch.length, selections = none;
    while (length) {
        let event = mapEvent(branch[length - 1], mapping, selections);
        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping
            let result = branch.slice(0, length);
            result[length - 1] = event;
            return result;
        }
        else { // Drop this event, since there's no changes or effects left
            mapping = event.mapped;
            length--;
            selections = event.selectionsAfter;
        }
    }
    return selections.length ? [HistEvent.selection(selections)] : none;
}
function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);
    // Change-less events don't store mappings (they are always the last event in a branch)
    if (!event.changes)
        return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, state.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
const joinableUserEvent = /^(input\.type|delete)($|\.)/;
class HistoryState {
    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {
        this.done = done;
        this.undone = undone;
        this.prevTime = prevTime;
        this.prevUserEvent = prevUserEvent;
    }
    isolate() {
        return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, config, tr) {
        let done = this.done, lastEvent = done[done.length - 1];
        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes &&
            (!userEvent || joinableUserEvent.test(userEvent)) &&
            ((!lastEvent.selectionsAfter.length &&
                time - this.prevTime < config.newGroupDelay &&
                config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes))) ||
                // For compose (but not compose.start) events, always join with previous event
                userEvent == "input.type.compose")) {
            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(state.StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
        }
        else {
            done = updateBranch(done, done.length, config.minDepth, event);
        }
        return new HistoryState(done, none, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
        if (last.length > 0 &&
            time - this.prevTime < newGroupDelay &&
            userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) &&
            eqSelectionShape(last[last.length - 1], selection))
            return this;
        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, onlySelection) {
        let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone;
        if (branch.length == 0)
            return null;
        let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;
        if (onlySelection && event.selectionsAfter.length) {
            return state.update({
                selection: event.selectionsAfter[event.selectionsAfter.length - 1],
                annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),
                userEvent: side == 0 /* BranchName.Done */ ? "select.undo" : "select.redo",
                scrollIntoView: true
            });
        }
        else if (!event.changes) {
            return null;
        }
        else {
            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
            if (event.mapped)
                rest = addMappingToBranch(rest, event.mapped);
            return state.update({
                changes: event.changes,
                selection: event.startSelection,
                effects: event.effects,
                annotations: fromHistory.of({ side, rest, selection }),
                filter: false,
                userEvent: side == 0 /* BranchName.Done */ ? "undo" : "redo",
                scrollIntoView: true
            });
        }
    }
}
HistoryState.empty = new HistoryState(none, none);
/**
Default key bindings for the undo history.

- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).
- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).
- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).
- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).
*/
const historyKeymap = [
    { key: "Mod-z", run: undo, preventDefault: true },
    { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
    { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
    { key: "Mod-u", run: undoSelection, preventDefault: true },
    { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];

function updateSel(sel, by) {
    return state.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
    return state.update({ selection, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
    let selection = updateSel(state.selection, how);
    if (selection.eq(state.selection, true))
        return false;
    dispatch(setSel(state, selection));
    return true;
}
function rangeEnd(range, forward) {
    return state.EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view$1) {
    return view$1.textDirectionAt(view$1.state.selection.main.head) == view.Direction.LTR;
}
/**
Move the selection one character to the left (which is backward in
left-to-right text, forward in right-to-left text).
*/
const cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));
/**
Move the selection one character to the right.
*/
const cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));
/**
Move the selection one character forward.
*/
const cursorCharForward = view => cursorByChar(view, true);
/**
Move the selection one character backward.
*/
const cursorCharBackward = view => cursorByChar(view, false);
function byCharLogical(state$1, range, forward) {
    let pos = range.head, line = state$1.doc.lineAt(pos);
    if (pos == (forward ? line.to : line.from))
        pos = forward ? Math.min(state$1.doc.length, line.to + 1) : Math.max(0, line.from - 1);
    else
        pos = line.from + state.findClusterBreak(line.text, pos - line.from, forward);
    return state.EditorSelection.cursor(pos, forward ? -1 : 1);
}
function moveByCharLogical(target, forward) {
    return moveSel(target, range => range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward));
}
/**
Move the selection one character forward, in logical
(non-text-direction-aware) string index order.
*/
const cursorCharForwardLogical = target => moveByCharLogical(target, true);
/**
Move the selection one character backward, in logical string index
order.
*/
const cursorCharBackwardLogical = target => moveByCharLogical(target, false);
function cursorByGroup(view, forward) {
    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
/**
Move the selection to the left across one group of word or
non-word (but also non-space) characters.
*/
const cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));
/**
Move the selection one group to the right.
*/
const cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));
/**
Move the selection one group forward.
*/
const cursorGroupForward = view => cursorByGroup(view, true);
/**
Move the selection one group backward.
*/
const cursorGroupBackward = view => cursorByGroup(view, false);
const segmenter = typeof Intl != "undefined" && Intl.Segmenter ?
    new (Intl.Segmenter)(undefined, { granularity: "word" }) : null;
function moveBySubword(view, range, forward) {
    let categorize = view.state.charCategorizer(range.from);
    let cat = state.CharCategory.Space, pos = range.from, steps = 0;
    let done = false, sawUpper = false, sawLower = false;
    let step = (next) => {
        if (done)
            return false;
        pos += forward ? next.length : -next.length;
        let nextCat = categorize(next), ahead;
        if (nextCat == state.CharCategory.Word && next.charCodeAt(0) < 128 && /[\W_]/.test(next))
            nextCat = -1; // Treat word punctuation specially
        if (cat == state.CharCategory.Space)
            cat = nextCat;
        if (cat != nextCat)
            return false;
        if (cat == state.CharCategory.Word) {
            if (next.toLowerCase() == next) {
                if (!forward && sawUpper)
                    return false;
                sawLower = true;
            }
            else if (sawLower) {
                if (forward)
                    return false;
                done = true;
            }
            else {
                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == state.CharCategory.Word &&
                    ahead.toLowerCase() == ahead)
                    return false;
                sawUpper = true;
            }
        }
        steps++;
        return true;
    };
    let end = view.moveByChar(range, forward, start => {
        step(start);
        return step;
    });
    if (segmenter && cat == state.CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {
        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);
        let skipped = view.state.sliceDoc(from, to);
        if (skipped.length > 1 && /[\u4E00-\uffff]/.test(skipped)) {
            let segments = Array.from(segmenter.segment(skipped));
            if (segments.length > 1) {
                if (forward)
                    return state.EditorSelection.cursor(range.head + segments[1].index, -1);
                return state.EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);
            }
        }
    }
    return end;
}
function cursorBySubword(view, forward) {
    return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));
}
/**
Move the selection one group or camel-case subword forward.
*/
const cursorSubwordForward = view => cursorBySubword(view, true);
/**
Move the selection one group or camel-case subword backward.
*/
const cursorSubwordBackward = view => cursorBySubword(view, false);
function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp))
        return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state$1, start, forward) {
    let pos = language.syntaxTree(state$1).resolveInner(start.head);
    let bracketProp = forward ? common.NodeProp.closedBy : common.NodeProp.openedBy;
    // Scan forward through child nodes to see if there's an interesting
    // node ahead.
    for (let at = start.head;;) {
        let next = forward ? pos.childAfter(at) : pos.childBefore(at);
        if (!next)
            break;
        if (interestingNode(state$1, next, bracketProp))
            pos = next;
        else
            at = forward ? next.to : next.from;
    }
    let bracket = pos.type.prop(bracketProp), match, newPos;
    if (bracket && (match = forward ? language.matchBrackets(state$1, pos.from, 1) : language.matchBrackets(state$1, pos.to, -1)) && match.matched)
        newPos = forward ? match.end.to : match.end.from;
    else
        newPos = forward ? pos.to : pos.from;
    return state.EditorSelection.cursor(newPos, forward ? -1 : 1);
}
/**
Move the cursor over the next syntactic element to the left.
*/
const cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
/**
Move the cursor over the next syntactic element to the right.
*/
const cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
    return moveSel(view, range => {
        if (!range.empty)
            return rangeEnd(range, forward);
        let moved = view.moveVertically(range, forward);
        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
}
/**
Move the selection one line up.
*/
const cursorLineUp = view => cursorByLine(view, false);
/**
Move the selection one line down.
*/
const cursorLineDown = view => cursorByLine(view, true);
function pageInfo(view$1) {
    let selfScroll = view$1.scrollDOM.clientHeight < view$1.scrollDOM.scrollHeight - 2;
    let marginTop = 0, marginBottom = 0, height;
    if (selfScroll) {
        for (let source of view$1.state.facet(view.EditorView.scrollMargins)) {
            let margins = source(view$1);
            if (margins === null || margins === void 0 ? void 0 : margins.top)
                marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
            if (margins === null || margins === void 0 ? void 0 : margins.bottom)
                marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
        }
        height = view$1.scrollDOM.clientHeight - marginTop - marginBottom;
    }
    else {
        height = (view$1.dom.ownerDocument.defaultView || window).innerHeight;
    }
    return { marginTop, marginBottom, selfScroll,
        height: Math.max(view$1.defaultLineHeight, height - 5) };
}
function cursorByPage(view$1, forward) {
    let page = pageInfo(view$1);
    let { state } = view$1, selection = updateSel(state.selection, range => {
        return range.empty ? view$1.moveVertically(range, forward, page.height)
            : rangeEnd(range, forward);
    });
    if (selection.eq(state.selection))
        return false;
    let effect;
    if (page.selfScroll) {
        let startPos = view$1.coordsAtPos(state.selection.main.head);
        let scrollRect = view$1.scrollDOM.getBoundingClientRect();
        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
            effect = view.EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop });
    }
    view$1.dispatch(setSel(state, selection), { effects: effect });
    return true;
}
/**
Move the selection one page up.
*/
const cursorPageUp = view => cursorByPage(view, false);
/**
Move the selection one page down.
*/
const cursorPageDown = view => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
        moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
        let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
        if (space && start.head != line.from + space)
            moved = state.EditorSelection.cursor(line.from + space);
    }
    return moved;
}
/**
Move the selection to the next line wrap point, or to the end of
the line if there isn't one left on this line.
*/
const cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));
/**
Move the selection to previous line wrap point, or failing that to
the start of the line. If the line is indented, and the cursor
isn't already at the end of the indentation, this will move to the
end of the indentation instead of the start of the line.
*/
const cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));
/**
Move the selection one line wrap point to the left.
*/
const cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
/**
Move the selection one line wrap point to the right.
*/
const cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
/**
Move the selection to the start of the line.
*/
const cursorLineStart = view => moveSel(view, range => state.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
/**
Move the selection to the end of the line.
*/
const cursorLineEnd = view => moveSel(view, range => state.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state$1, dispatch, extend) {
    let found = false, selection = updateSel(state$1.selection, range => {
        let matching = language.matchBrackets(state$1, range.head, -1)
            || language.matchBrackets(state$1, range.head, 1)
            || (range.head > 0 && language.matchBrackets(state$1, range.head - 1, 1))
            || (range.head < state$1.doc.length && language.matchBrackets(state$1, range.head + 1, -1));
        if (!matching || !matching.end)
            return range;
        found = true;
        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
        return extend ? state.EditorSelection.range(range.anchor, head) : state.EditorSelection.cursor(head);
    });
    if (!found)
        return false;
    dispatch(setSel(state$1, selection));
    return true;
}
/**
Move the selection to the bracket matching the one it is currently
on, if any.
*/
const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
/**
Extend the selection to the bracket matching the one the selection
head is currently on, if any.
*/
const selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);
function extendSel(target, how) {
    let selection = updateSel(target.state.selection, range => {
        let head = how(range);
        return state.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);
    });
    if (selection.eq(target.state.selection))
        return false;
    target.dispatch(setSel(target.state, selection));
    return true;
}
function selectByChar(view, forward) {
    return extendSel(view, range => view.moveByChar(range, forward));
}
/**
Move the selection head one character to the left, while leaving
the anchor in place.
*/
const selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));
/**
Move the selection head one character to the right.
*/
const selectCharRight = view => selectByChar(view, ltrAtCursor(view));
/**
Move the selection head one character forward.
*/
const selectCharForward = view => selectByChar(view, true);
/**
Move the selection head one character backward.
*/
const selectCharBackward = view => selectByChar(view, false);
/**
Move the selection head one character forward by logical
(non-direction aware) string index order.
*/
const selectCharForwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, true));
/**
Move the selection head one character backward by logical string
index order.
*/
const selectCharBackwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, false));
function selectByGroup(view, forward) {
    return extendSel(view, range => view.moveByGroup(range, forward));
}
/**
Move the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to
the left.
*/
const selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));
/**
Move the selection head one group to the right.
*/
const selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));
/**
Move the selection head one group forward.
*/
const selectGroupForward = view => selectByGroup(view, true);
/**
Move the selection head one group backward.
*/
const selectGroupBackward = view => selectByGroup(view, false);
function selectBySubword(view, forward) {
    return extendSel(view, range => moveBySubword(view, range, forward));
}
/**
Move the selection head one group or camel-case subword forward.
*/
const selectSubwordForward = view => selectBySubword(view, true);
/**
Move the selection head one group or subword backward.
*/
const selectSubwordBackward = view => selectBySubword(view, false);
/**
Move the selection head over the next syntactic element to the left.
*/
const selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
/**
Move the selection head over the next syntactic element to the right.
*/
const selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
    return extendSel(view, range => view.moveVertically(range, forward));
}
/**
Move the selection head one line up.
*/
const selectLineUp = view => selectByLine(view, false);
/**
Move the selection head one line down.
*/
const selectLineDown = view => selectByLine(view, true);
function selectByPage(view, forward) {
    return extendSel(view, range => view.moveVertically(range, forward, pageInfo(view).height));
}
/**
Move the selection head one page up.
*/
const selectPageUp = view => selectByPage(view, false);
/**
Move the selection head one page down.
*/
const selectPageDown = view => selectByPage(view, true);
/**
Move the selection head to the next line boundary.
*/
const selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));
/**
Move the selection head to the previous line boundary.
*/
const selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));
/**
Move the selection head one line boundary to the left.
*/
const selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
/**
Move the selection head one line boundary to the right.
*/
const selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
/**
Move the selection head to the start of the line.
*/
const selectLineStart = view => extendSel(view, range => state.EditorSelection.cursor(view.lineBlockAt(range.head).from));
/**
Move the selection head to the end of the line.
*/
const selectLineEnd = view => extendSel(view, range => state.EditorSelection.cursor(view.lineBlockAt(range.head).to));
/**
Move the selection to the start of the document.
*/
const cursorDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: 0 }));
    return true;
};
/**
Move the selection to the end of the document.
*/
const cursorDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.doc.length }));
    return true;
};
/**
Move the selection head to the start of the document.
*/
const selectDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
    return true;
};
/**
Move the selection head to the end of the document.
*/
const selectDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
    return true;
};
/**
Select the entire document.
*/
const selectAll = ({ state, dispatch }) => {
    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
    return true;
};
/**
Expand the selection to cover entire lines.
*/
const selectLine = ({ state: state$1, dispatch }) => {
    let ranges = selectedLineBlocks(state$1).map(({ from, to }) => state.EditorSelection.range(from, Math.min(to + 1, state$1.doc.length)));
    dispatch(state$1.update({ selection: state.EditorSelection.create(ranges), userEvent: "select" }));
    return true;
};
/**
Select the next syntactic construct that is larger than the
selection. Note that this will only work insofar as the language
[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full
syntax tree.
*/
const selectParentSyntax = ({ state: state$1, dispatch }) => {
    let selection = updateSel(state$1.selection, range => {
        let tree = language.syntaxTree(state$1), stack = tree.resolveStack(range.from, 1);
        if (range.empty) {
            let stackBefore = tree.resolveStack(range.from, -1);
            if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
                stack = stackBefore;
        }
        for (let cur = stack; cur; cur = cur.next) {
            let { node } = cur;
            if (((node.from < range.from && node.to >= range.to) ||
                (node.to > range.to && node.from <= range.from)) &&
                cur.next)
                return state.EditorSelection.range(node.to, node.from);
        }
        return range;
    });
    if (selection.eq(state$1.selection))
        return false;
    dispatch(setSel(state$1, selection));
    return true;
};
/**
Simplify the current selection. When multiple ranges are selected,
reduce it to its main range. Otherwise, if the selection is
non-empty, convert it to a cursor selection.
*/
const simplifySelection = ({ state: state$1, dispatch }) => {
    let cur = state$1.selection, selection = null;
    if (cur.ranges.length > 1)
        selection = state.EditorSelection.create([cur.main]);
    else if (!cur.main.empty)
        selection = state.EditorSelection.create([state.EditorSelection.cursor(cur.main.head)]);
    if (!selection)
        return false;
    dispatch(setSel(state$1, selection));
    return true;
};
function deleteBy(target, by) {
    if (target.state.readOnly)
        return false;
    let event = "delete.selection", { state: state$1 } = target;
    let changes = state$1.changeByRange(range => {
        let { from, to } = range;
        if (from == to) {
            let towards = by(range);
            if (towards < from) {
                event = "delete.backward";
                towards = skipAtomic(target, towards, false);
            }
            else if (towards > from) {
                event = "delete.forward";
                towards = skipAtomic(target, towards, true);
            }
            from = Math.min(from, towards);
            to = Math.max(to, towards);
        }
        else {
            from = skipAtomic(target, from, false);
            to = skipAtomic(target, to, true);
        }
        return from == to ? { range } : { changes: { from, to }, range: state.EditorSelection.cursor(from, from < range.head ? -1 : 1) };
    });
    if (changes.changes.empty)
        return false;
    target.dispatch(state$1.update(changes, {
        scrollIntoView: true,
        userEvent: event,
        effects: event == "delete.selection" ? view.EditorView.announce.of(state$1.phrase("Selection deleted")) : undefined
    }));
    return true;
}
function skipAtomic(target, pos, forward) {
    if (target instanceof view.EditorView)
        for (let ranges of target.state.facet(view.EditorView.atomicRanges).map(f => f(target)))
            ranges.between(pos, pos, (from, to) => {
                if (from < pos && to > pos)
                    pos = forward ? to : from;
            });
    return pos;
}
const deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, range => {
    let pos = range.from, { state: state$1 } = target, line = state$1.doc.lineAt(pos), before, targetPos;
    if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 &&
        !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
        if (before[before.length - 1] == "\t")
            return pos - 1;
        let col = state.countColumn(before, state$1.tabSize), drop = col % language.getIndentUnit(state$1) || language.getIndentUnit(state$1);
        for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
            pos--;
        targetPos = pos;
    }
    else {
        targetPos = state.findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
        if (targetPos == pos && line.number != (forward ? state$1.doc.lines : 1))
            targetPos += forward ? 1 : -1;
        else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
            targetPos = state.findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
    }
    return targetPos;
});
/**
Delete the selection, or, for cursor selections, the character or
indentation unit before the cursor.
*/
const deleteCharBackward = view => deleteByChar(view, false, true);
/**
Delete the selection or the character before the cursor. Does not
implement any extended behavior like deleting whole indentation
units in one go.
*/
const deleteCharBackwardStrict = view => deleteByChar(view, false, false);
/**
Delete the selection or the character after the cursor.
*/
const deleteCharForward = view => deleteByChar(view, true, false);
const deleteByGroup = (target, forward) => deleteBy(target, range => {
    let pos = range.head, { state: state$1 } = target, line = state$1.doc.lineAt(pos);
    let categorize = state$1.charCategorizer(pos);
    for (let cat = null;;) {
        if (pos == (forward ? line.to : line.from)) {
            if (pos == range.head && line.number != (forward ? state$1.doc.lines : 1))
                pos += forward ? 1 : -1;
            break;
        }
        let next = state.findClusterBreak(line.text, pos - line.from, forward) + line.from;
        let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
        let nextCat = categorize(nextChar);
        if (cat != null && nextCat != cat)
            break;
        if (nextChar != " " || pos != range.head)
            cat = nextCat;
        pos = next;
    }
    return pos;
});
/**
Delete the selection or backward until the end of the next
[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of
whitespace when they consist of a single space.
*/
const deleteGroupBackward = target => deleteByGroup(target, false);
/**
Delete the selection or forward until the end of the next group.
*/
const deleteGroupForward = target => deleteByGroup(target, true);
/**
Delete the selection, or, if it is a cursor selection, delete to
the end of the line. If the cursor is directly at the end of the
line, delete the line break after it.
*/
const deleteToLineEnd = view => deleteBy(view, range => {
    let lineEnd = view.lineBlockAt(range.head).to;
    return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
/**
Delete the selection, or, if it is a cursor selection, delete to
the start of the line. If the cursor is directly at the start of the
line, delete the line break before it.
*/
const deleteToLineStart = view => deleteBy(view, range => {
    let lineStart = view.lineBlockAt(range.head).from;
    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
/**
Delete the selection, or, if it is a cursor selection, delete to
the start of the line or the next line wrap before the cursor.
*/
const deleteLineBoundaryBackward = view => deleteBy(view, range => {
    let lineStart = view.moveToLineBoundary(range, false).head;
    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
/**
Delete the selection, or, if it is a cursor selection, delete to
the end of the line or the next line wrap after the cursor.
*/
const deleteLineBoundaryForward = view => deleteBy(view, range => {
    let lineStart = view.moveToLineBoundary(range, true).head;
    return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
/**
Delete all whitespace directly before a line end from the
document.
*/
const deleteTrailingWhitespace = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let changes = [];
    for (let pos = 0, prev = "", iter = state.doc.iter();;) {
        iter.next();
        if (iter.lineBreak || iter.done) {
            let trailing = prev.search(/\s+$/);
            if (trailing > -1)
                changes.push({ from: pos - (prev.length - trailing), to: pos });
            if (iter.done)
                break;
            prev = "";
        }
        else {
            prev = iter.value;
        }
        pos += iter.value.length;
    }
    if (!changes.length)
        return false;
    dispatch(state.update({ changes, userEvent: "delete" }));
    return true;
};
/**
Replace each selection range with a line break, leaving the cursor
on the line before the break.
*/
const splitLine = ({ state: state$1, dispatch }) => {
    if (state$1.readOnly)
        return false;
    let changes = state$1.changeByRange(range => {
        return { changes: { from: range.from, to: range.to, insert: state.Text.of(["", ""]) },
            range: state.EditorSelection.cursor(range.from) };
    });
    dispatch(state$1.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
};
/**
Flip the characters before and after the cursor(s).
*/
const transposeChars = ({ state: state$1, dispatch }) => {
    if (state$1.readOnly)
        return false;
    let changes = state$1.changeByRange(range => {
        if (!range.empty || range.from == 0 || range.from == state$1.doc.length)
            return { range };
        let pos = range.from, line = state$1.doc.lineAt(pos);
        let from = pos == line.from ? pos - 1 : state.findClusterBreak(line.text, pos - line.from, false) + line.from;
        let to = pos == line.to ? pos + 1 : state.findClusterBreak(line.text, pos - line.from, true) + line.from;
        return { changes: { from, to, insert: state$1.doc.slice(pos, to).append(state$1.doc.slice(from, pos)) },
            range: state.EditorSelection.cursor(to) };
    });
    if (changes.changes.empty)
        return false;
    dispatch(state$1.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
};
function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range of state.selection.ranges) {
        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
        if (!range.empty && range.to == endLine.from)
            endLine = state.doc.lineAt(range.to - 1);
        if (upto >= startLine.number) {
            let prev = blocks[blocks.length - 1];
            prev.to = endLine.to;
            prev.ranges.push(range);
        }
        else {
            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
        }
        upto = endLine.number + 1;
    }
    return blocks;
}
function moveLine(state$1, dispatch, forward) {
    if (state$1.readOnly)
        return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state$1)) {
        if (forward ? block.to == state$1.doc.length : block.from == 0)
            continue;
        let nextLine = state$1.doc.lineAt(forward ? block.to + 1 : block.from - 1);
        let size = nextLine.length + 1;
        if (forward) {
            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state$1.lineBreak });
            for (let r of block.ranges)
                ranges.push(state.EditorSelection.range(Math.min(state$1.doc.length, r.anchor + size), Math.min(state$1.doc.length, r.head + size)));
        }
        else {
            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state$1.lineBreak + nextLine.text });
            for (let r of block.ranges)
                ranges.push(state.EditorSelection.range(r.anchor - size, r.head - size));
        }
    }
    if (!changes.length)
        return false;
    dispatch(state$1.update({
        changes,
        scrollIntoView: true,
        selection: state.EditorSelection.create(ranges, state$1.selection.mainIndex),
        userEvent: "move.line"
    }));
    return true;
}
/**
Move the selected lines up one line.
*/
const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
/**
Move the selected lines down one line.
*/
const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
    if (state.readOnly)
        return false;
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
        if (forward)
            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
        else
            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
    }
    dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
}
/**
Create a copy of the selected lines. Keep the selection in the top copy.
*/
const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
/**
Create a copy of the selected lines. Keep the selection in the bottom copy.
*/
const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
/**
Delete selected lines.
*/
const deleteLine = view => {
    if (view.state.readOnly)
        return false;
    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
        if (from > 0)
            from--;
        else if (to < state.doc.length)
            to++;
        return { from, to };
    }));
    let selection = updateSel(state.selection, range => {
        let dist = undefined;
        if (view.lineWrapping) {
            let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
            if (pos)
                dist = (block.bottom + view.documentTop) - pos.bottom + view.defaultLineHeight / 2;
        }
        return view.moveVertically(range, true, dist);
    }).map(changes);
    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
    return true;
};
/**
Replace the selection with a newline.
*/
const insertNewline = ({ state, dispatch }) => {
    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: "input" }));
    return true;
};
/**
Replace the selection with a newline and the same amount of
indentation as the line above.
*/
const insertNewlineKeepIndent = ({ state: state$1, dispatch }) => {
    dispatch(state$1.update(state$1.changeByRange(range => {
        let indent = /^\s*/.exec(state$1.doc.lineAt(range.from).text)[0];
        return {
            changes: { from: range.from, to: range.to, insert: state$1.lineBreak + indent },
            range: state.EditorSelection.cursor(range.from + indent.length + 1)
        };
    }), { scrollIntoView: true, userEvent: "input" }));
    return true;
};
function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
        return { from: pos, to: pos };
    let context = language.syntaxTree(state).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos &&
        (closedBy = before.type.prop(common.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 &&
        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from &&
        !/\S/.test(state.sliceDoc(before.to, after.from)))
        return { from: before.to, to: after.from };
    return null;
}
/**
Replace the selection with a newline and indent the newly created
line(s). If the current line consists only of whitespace, this
will also delete that whitespace. When the cursor is between
matching brackets, an additional newline will be inserted after
the cursor.
*/
const insertNewlineAndIndent = newlineAndIndent(false);
/**
Create a blank, indented line below the current line.
*/
const insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
    return ({ state: state$1, dispatch }) => {
        if (state$1.readOnly)
            return false;
        let changes = state$1.changeByRange(range => {
            let { from, to } = range, line = state$1.doc.lineAt(from);
            let explode = !atEof && from == to && isBetweenBrackets(state$1, from);
            if (atEof)
                from = to = (to <= line.to ? line : state$1.doc.lineAt(to)).to;
            let cx = new language.IndentContext(state$1, { simulateBreak: from, simulateDoubleBreak: !!explode });
            let indent = language.getIndentation(cx, from);
            if (indent == null)
                indent = state.countColumn(/^\s*/.exec(state$1.doc.lineAt(from).text)[0], state$1.tabSize);
            while (to < line.to && /\s/.test(line.text[to - line.from]))
                to++;
            if (explode)
                ({ from, to } = explode);
            else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
                from = line.from;
            let insert = ["", language.indentString(state$1, indent)];
            if (explode)
                insert.push(language.indentString(state$1, cx.lineIndent(line.from, -1)));
            return { changes: { from, to, insert: state.Text.of(insert) },
                range: state.EditorSelection.cursor(from + 1 + insert[1].length) };
        });
        dispatch(state$1.update(changes, { scrollIntoView: true, userEvent: "input" }));
        return true;
    };
}
function changeBySelectedLine(state$1, f) {
    let atLine = -1;
    return state$1.changeByRange(range => {
        let changes = [];
        for (let pos = range.from; pos <= range.to;) {
            let line = state$1.doc.lineAt(pos);
            if (line.number > atLine && (range.empty || range.to > line.from)) {
                f(line, changes, range);
                atLine = line.number;
            }
            pos = line.to + 1;
        }
        let changeSet = state$1.changes(changes);
        return { changes,
            range: state.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };
    });
}
/**
Auto-indent the selected lines. This uses the [indentation service
facet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent
information.
*/
const indentSelection = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let updated = Object.create(null);
    let context = new language.IndentContext(state, { overrideIndentation: start => {
            let found = updated[start];
            return found == null ? -1 : found;
        } });
    let changes = changeBySelectedLine(state, (line, changes, range) => {
        let indent = language.getIndentation(context, line.from);
        if (indent == null)
            return;
        if (!/\S/.test(line.text))
            indent = 0;
        let cur = /^\s*/.exec(line.text)[0];
        let norm = language.indentString(state, indent);
        if (cur != norm || range.from < line.from + cur.length) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
    });
    if (!changes.changes.empty)
        dispatch(state.update(changes, { userEvent: "indent" }));
    return true;
};
/**
Add a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected
lines.
*/
const indentMore = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        changes.push({ from: line.from, insert: state.facet(language.indentUnit) });
    }), { userEvent: "input.indent" }));
    return true;
};
/**
Remove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all
selected lines.
*/
const indentLess = ({ state: state$1, dispatch }) => {
    if (state$1.readOnly)
        return false;
    dispatch(state$1.update(changeBySelectedLine(state$1, (line, changes) => {
        let space = /^\s*/.exec(line.text)[0];
        if (!space)
            return;
        let col = state.countColumn(space, state$1.tabSize), keep = 0;
        let insert = language.indentString(state$1, Math.max(0, col - language.getIndentUnit(state$1)));
        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
            keep++;
        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
};
/**
Enables or disables
[tab-focus mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode). While on, this
prevents the editor's key bindings from capturing Tab or
Shift-Tab, making it possible for the user to move focus out of
the editor with the keyboard.
*/
const toggleTabFocusMode = view => {
    view.setTabFocusMode();
    return true;
};
/**
Temporarily enables [tab-focus
mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode) for two seconds or until
another key is pressed.
*/
const temporarilySetTabFocusMode = view => {
    view.setTabFocusMode(2000);
    return true;
};
/**
Insert a tab character at the cursor or, if something is selected,
use [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire
selection.
*/
const insertTab = ({ state, dispatch }) => {
    if (state.selection.ranges.some(r => !r.empty))
        return indentMore({ state, dispatch });
    dispatch(state.update(state.replaceSelection("\t"), { scrollIntoView: true, userEvent: "input" }));
    return true;
};
/**
Array of key bindings containing the Emacs-style bindings that are
available on macOS by default.

 - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
 - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)
 - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)
 - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)
 - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)
 - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)
*/
const emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown },
];
/**
An array of key bindings closely sticking to platform-standard or
widely used bindings. (This includes the bindings from
[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`
property changed to `mac`.)

 - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)
 - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)
 - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)
 - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)
 - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Enter and Shift-Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)
 - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)
 - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
 - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)
 - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).
 - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).
*/
const standardKeymap = [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
    { mac: "Mod-Delete", run: deleteLineBoundaryForward }
].concat(emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));
/**
The default keymap. Includes all bindings from
[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:

- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)
- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)
- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)
- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)
- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)
- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)
- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)
- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)
- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)
- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)
- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)
- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)
- Ctrl-Alt-\\ (Cmd-Alt-\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)
- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)
- Shift-Ctrl-\\ (Shift-Cmd-\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)
- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).
- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).
- Ctrl-m (Alt-Shift-m on macOS): [`toggleTabFocusMode`](https://codemirror.net/6/docs/ref/#commands.toggleTabFocusMode).
*/
const defaultKeymap = [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment },
    { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode },
].concat(standardKeymap);
/**
A binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and
Shift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).
Please see the [Tab example](../../examples/tab/) before using
this.
*/
const indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };

exports.blockComment = blockComment;
exports.blockUncomment = blockUncomment;
exports.copyLineDown = copyLineDown;
exports.copyLineUp = copyLineUp;
exports.cursorCharBackward = cursorCharBackward;
exports.cursorCharBackwardLogical = cursorCharBackwardLogical;
exports.cursorCharForward = cursorCharForward;
exports.cursorCharForwardLogical = cursorCharForwardLogical;
exports.cursorCharLeft = cursorCharLeft;
exports.cursorCharRight = cursorCharRight;
exports.cursorDocEnd = cursorDocEnd;
exports.cursorDocStart = cursorDocStart;
exports.cursorGroupBackward = cursorGroupBackward;
exports.cursorGroupForward = cursorGroupForward;
exports.cursorGroupLeft = cursorGroupLeft;
exports.cursorGroupRight = cursorGroupRight;
exports.cursorLineBoundaryBackward = cursorLineBoundaryBackward;
exports.cursorLineBoundaryForward = cursorLineBoundaryForward;
exports.cursorLineBoundaryLeft = cursorLineBoundaryLeft;
exports.cursorLineBoundaryRight = cursorLineBoundaryRight;
exports.cursorLineDown = cursorLineDown;
exports.cursorLineEnd = cursorLineEnd;
exports.cursorLineStart = cursorLineStart;
exports.cursorLineUp = cursorLineUp;
exports.cursorMatchingBracket = cursorMatchingBracket;
exports.cursorPageDown = cursorPageDown;
exports.cursorPageUp = cursorPageUp;
exports.cursorSubwordBackward = cursorSubwordBackward;
exports.cursorSubwordForward = cursorSubwordForward;
exports.cursorSyntaxLeft = cursorSyntaxLeft;
exports.cursorSyntaxRight = cursorSyntaxRight;
exports.defaultKeymap = defaultKeymap;
exports.deleteCharBackward = deleteCharBackward;
exports.deleteCharBackwardStrict = deleteCharBackwardStrict;
exports.deleteCharForward = deleteCharForward;
exports.deleteGroupBackward = deleteGroupBackward;
exports.deleteGroupForward = deleteGroupForward;
exports.deleteLine = deleteLine;
exports.deleteLineBoundaryBackward = deleteLineBoundaryBackward;
exports.deleteLineBoundaryForward = deleteLineBoundaryForward;
exports.deleteToLineEnd = deleteToLineEnd;
exports.deleteToLineStart = deleteToLineStart;
exports.deleteTrailingWhitespace = deleteTrailingWhitespace;
exports.emacsStyleKeymap = emacsStyleKeymap;
exports.history = history;
exports.historyField = historyField;
exports.historyKeymap = historyKeymap;
exports.indentLess = indentLess;
exports.indentMore = indentMore;
exports.indentSelection = indentSelection;
exports.indentWithTab = indentWithTab;
exports.insertBlankLine = insertBlankLine;
exports.insertNewline = insertNewline;
exports.insertNewlineAndIndent = insertNewlineAndIndent;
exports.insertNewlineKeepIndent = insertNewlineKeepIndent;
exports.insertTab = insertTab;
exports.invertedEffects = invertedEffects;
exports.isolateHistory = isolateHistory;
exports.lineComment = lineComment;
exports.lineUncomment = lineUncomment;
exports.moveLineDown = moveLineDown;
exports.moveLineUp = moveLineUp;
exports.redo = redo;
exports.redoDepth = redoDepth;
exports.redoSelection = redoSelection;
exports.selectAll = selectAll;
exports.selectCharBackward = selectCharBackward;
exports.selectCharBackwardLogical = selectCharBackwardLogical;
exports.selectCharForward = selectCharForward;
exports.selectCharForwardLogical = selectCharForwardLogical;
exports.selectCharLeft = selectCharLeft;
exports.selectCharRight = selectCharRight;
exports.selectDocEnd = selectDocEnd;
exports.selectDocStart = selectDocStart;
exports.selectGroupBackward = selectGroupBackward;
exports.selectGroupForward = selectGroupForward;
exports.selectGroupLeft = selectGroupLeft;
exports.selectGroupRight = selectGroupRight;
exports.selectLine = selectLine;
exports.selectLineBoundaryBackward = selectLineBoundaryBackward;
exports.selectLineBoundaryForward = selectLineBoundaryForward;
exports.selectLineBoundaryLeft = selectLineBoundaryLeft;
exports.selectLineBoundaryRight = selectLineBoundaryRight;
exports.selectLineDown = selectLineDown;
exports.selectLineEnd = selectLineEnd;
exports.selectLineStart = selectLineStart;
exports.selectLineUp = selectLineUp;
exports.selectMatchingBracket = selectMatchingBracket;
exports.selectPageDown = selectPageDown;
exports.selectPageUp = selectPageUp;
exports.selectParentSyntax = selectParentSyntax;
exports.selectSubwordBackward = selectSubwordBackward;
exports.selectSubwordForward = selectSubwordForward;
exports.selectSyntaxLeft = selectSyntaxLeft;
exports.selectSyntaxRight = selectSyntaxRight;
exports.simplifySelection = simplifySelection;
exports.splitLine = splitLine;
exports.standardKeymap = standardKeymap;
exports.temporarilySetTabFocusMode = temporarilySetTabFocusMode;
exports.toggleBlockComment = toggleBlockComment;
exports.toggleBlockCommentByLine = toggleBlockCommentByLine;
exports.toggleComment = toggleComment;
exports.toggleLineComment = toggleLineComment;
exports.toggleTabFocusMode = toggleTabFocusMode;
exports.transposeChars = transposeChars;
exports.undo = undo;
exports.undoDepth = undoDepth;
exports.undoSelection = undoSelection;


/***/ }),

/***/ "./node_modules/@codemirror/lang-css/dist/index.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@codemirror/lang-css/dist/index.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var css$1 = __webpack_require__(/*! @lezer/css */ "./node_modules/@lezer/css/dist/index.cjs");
var language = __webpack_require__(/*! @codemirror/language */ "./node_modules/@codemirror/language/dist/index.cjs");
var common = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.cjs");

let _properties = null;
function properties() {
    if (!_properties && typeof document == "object" && document.body) {
        let { style } = document.body, names = [], seen = new Set;
        for (let prop in style)
            if (prop != "cssText" && prop != "cssFloat") {
                if (typeof style[prop] == "string") {
                    if (/[A-Z]/.test(prop))
                        prop = prop.replace(/[A-Z]/g, ch => "-" + ch.toLowerCase());
                    if (!seen.has(prop)) {
                        names.push(prop);
                        seen.add(prop);
                    }
                }
            }
        _properties = names.sort().map(name => ({ type: "property", label: name, apply: name + ": " }));
    }
    return _properties || [];
}
const pseudoClasses = [
    "active", "after", "any-link", "autofill", "backdrop", "before",
    "checked", "cue", "default", "defined", "disabled", "empty",
    "enabled", "file-selector-button", "first", "first-child",
    "first-letter", "first-line", "first-of-type", "focus",
    "focus-visible", "focus-within", "fullscreen", "has", "host",
    "host-context", "hover", "in-range", "indeterminate", "invalid",
    "is", "lang", "last-child", "last-of-type", "left", "link", "marker",
    "modal", "not", "nth-child", "nth-last-child", "nth-last-of-type",
    "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range",
    "part", "placeholder", "placeholder-shown", "read-only", "read-write",
    "required", "right", "root", "scope", "selection", "slotted", "target",
    "target-text", "valid", "visited", "where"
].map(name => ({ type: "class", label: name }));
const values = [
    "above", "absolute", "activeborder", "additive", "activecaption", "after-white-space",
    "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always",
    "antialiased", "appworkspace", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column",
    "avoid-page", "avoid-region", "axis-pan", "background", "backwards", "baseline", "below",
    "bidi-override", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "capitalize",
    "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle",
    "cjk-decimal", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn",
    "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content",
    "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover",
    "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in",
    "destination-out", "destination-over", "difference", "disc", "discard", "disclosure-closed",
    "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize",
    "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end",
    "ethiopic-abegede-gez", "ethiopic-halehame-aa-er", "ethiopic-halehame-gez", "ew-resize", "exclusion",
    "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fill-box",
    "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from",
    "geometricPrecision", "graytext", "grid", "groove", "hand", "hard-light", "help", "hidden", "hide",
    "higher", "highlight", "highlighttext", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext",
    "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid",
    "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "keep-all",
    "landscape", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear",
    "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower",
    "lower-hexadecimal", "lower-latin", "lower-norwegian", "lowercase", "ltr", "luminosity", "manipulation",
    "match", "matrix", "matrix3d", "medium", "menu", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "n-resize", "narrower",
    "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none",
    "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize",
    "oblique", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "outset", "outside",
    "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused",
    "perspective", "pinch-zoom", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait",
    "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio",
    "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat",
    "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round",
    "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation",
    "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position",
    "se-resize", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show",
    "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps",
    "small-caption", "smaller", "soft-light", "solid", "source-atop", "source-in", "source-out",
    "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "start",
    "static", "status-bar", "stretch", "stroke", "stroke-box", "sub", "subpixel-antialiased", "svg_masks",
    "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell",
    "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row",
    "table-row-group", "text", "text-bottom", "text-top", "textarea", "textfield", "thick", "thin",
    "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "to", "top",
    "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent",
    "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up", "upper-latin",
    "uppercase", "url", "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill",
    "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe",
    "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"
].map(name => ({ type: "keyword", label: name })).concat([
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
].map(name => ({ type: "constant", label: name })));
const tags = [
    "a", "abbr", "address", "article", "aside", "b", "bdi", "bdo", "blockquote", "body",
    "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "dd", "del",
    "details", "dfn", "dialog", "div", "dl", "dt", "em", "figcaption", "figure", "footer",
    "form", "header", "hgroup", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "html", "i", "iframe",
    "img", "input", "ins", "kbd", "label", "legend", "li", "main", "meter", "nav", "ol", "output",
    "p", "pre", "ruby", "section", "select", "small", "source", "span", "strong", "sub", "summary",
    "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "tr", "u", "ul"
].map(name => ({ type: "type", label: name }));
const atRules = [
    "@charset", "@color-profile", "@container", "@counter-style", "@font-face", "@font-feature-values",
    "@font-palette-values", "@import", "@keyframes", "@layer", "@media", "@namespace", "@page",
    "@position-try", "@property", "@scope", "@starting-style", "@supports", "@view-transition"
].map(label => ({ type: "keyword", label }));
const identifier = /^(\w[\w-]*|-\w[\w-]*|)$/, variable = /^-(-[\w-]*)?$/;
function isVarArg(node, doc) {
    var _a;
    if (node.name == "(" || node.type.isError)
        node = node.parent || node;
    if (node.name != "ArgList")
        return false;
    let callee = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.firstChild;
    if ((callee === null || callee === void 0 ? void 0 : callee.name) != "Callee")
        return false;
    return doc.sliceString(callee.from, callee.to) == "var";
}
const VariablesByNode = new common.NodeWeakMap();
const declSelector = ["Declaration"];
function astTop(node) {
    for (let cur = node;;) {
        if (cur.type.isTop)
            return cur;
        if (!(cur = cur.parent))
            return node;
    }
}
function variableNames(doc, node, isVariable) {
    if (node.to - node.from > 4096) {
        let known = VariablesByNode.get(node);
        if (known)
            return known;
        let result = [], seen = new Set, cursor = node.cursor(common.IterMode.IncludeAnonymous);
        if (cursor.firstChild())
            do {
                for (let option of variableNames(doc, cursor.node, isVariable))
                    if (!seen.has(option.label)) {
                        seen.add(option.label);
                        result.push(option);
                    }
            } while (cursor.nextSibling());
        VariablesByNode.set(node, result);
        return result;
    }
    else {
        let result = [], seen = new Set;
        node.cursor().iterate(node => {
            var _a;
            if (isVariable(node) && node.matchContext(declSelector) && ((_a = node.node.nextSibling) === null || _a === void 0 ? void 0 : _a.name) == ":") {
                let name = doc.sliceString(node.from, node.to);
                if (!seen.has(name)) {
                    seen.add(name);
                    result.push({ label: name, type: "variable" });
                }
            }
        });
        return result;
    }
}
/**
Create a completion source for a CSS dialect, providing a
predicate for determining what kind of syntax node can act as a
completable variable. This is used by language modes like Sass and
Less to reuse this package's completion logic.
*/
const defineCSSCompletionSource = (isVariable) => context => {
    let { state, pos } = context, node = language.syntaxTree(state).resolveInner(pos, -1);
    let isDash = node.type.isError && node.from == node.to - 1 && state.doc.sliceString(node.from, node.to) == "-";
    if (node.name == "PropertyName" ||
        (isDash || node.name == "TagName") && /^(Block|Styles)$/.test(node.resolve(node.to).name))
        return { from: node.from, options: properties(), validFor: identifier };
    if (node.name == "ValueName")
        return { from: node.from, options: values, validFor: identifier };
    if (node.name == "PseudoClassName")
        return { from: node.from, options: pseudoClasses, validFor: identifier };
    if (isVariable(node) || (context.explicit || isDash) && isVarArg(node, state.doc))
        return { from: isVariable(node) || isDash ? node.from : pos,
            options: variableNames(state.doc, astTop(node), isVariable),
            validFor: variable };
    if (node.name == "TagName") {
        for (let { parent } = node; parent; parent = parent.parent)
            if (parent.name == "Block")
                return { from: node.from, options: properties(), validFor: identifier };
        return { from: node.from, options: tags, validFor: identifier };
    }
    if (node.name == "AtKeyword")
        return { from: node.from, options: atRules, validFor: identifier };
    if (!context.explicit)
        return null;
    let above = node.resolve(pos), before = above.childBefore(pos);
    if (before && before.name == ":" && above.name == "PseudoClassSelector")
        return { from: pos, options: pseudoClasses, validFor: identifier };
    if (before && before.name == ":" && above.name == "Declaration" || above.name == "ArgList")
        return { from: pos, options: values, validFor: identifier };
    if (above.name == "Block" || above.name == "Styles")
        return { from: pos, options: properties(), validFor: identifier };
    return null;
};
/**
CSS property, variable, and value keyword completion source.
*/
const cssCompletionSource = defineCSSCompletionSource(n => n.name == "VariableName");

/**
A language provider based on the [Lezer CSS
parser](https://github.com/lezer-parser/css), extended with
highlighting and indentation information.
*/
const cssLanguage = language.LRLanguage.define({
    name: "css",
    parser: css$1.parser.configure({
        props: [
            language.indentNodeProp.add({
                Declaration: language.continuedIndent()
            }),
            language.foldNodeProp.add({
                "Block KeyframeList": language.foldInside
            })
        ]
    }),
    languageData: {
        commentTokens: { block: { open: "/*", close: "*/" } },
        indentOnInput: /^\s*\}$/,
        wordChars: "-"
    }
});
/**
Language support for CSS.
*/
function css() {
    return new language.LanguageSupport(cssLanguage, cssLanguage.data.of({ autocomplete: cssCompletionSource }));
}

exports.css = css;
exports.cssCompletionSource = cssCompletionSource;
exports.cssLanguage = cssLanguage;
exports.defineCSSCompletionSource = defineCSSCompletionSource;


/***/ }),

/***/ "./node_modules/@codemirror/lang-html/dist/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@codemirror/lang-html/dist/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var html$1 = __webpack_require__(/*! @lezer/html */ "./node_modules/@lezer/html/dist/index.cjs");
var langCss = __webpack_require__(/*! @codemirror/lang-css */ "./node_modules/@codemirror/lang-css/dist/index.cjs");
var langJavascript = __webpack_require__(/*! @codemirror/lang-javascript */ "./node_modules/@codemirror/lang-javascript/dist/index.cjs");
var view = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.cjs");
var state = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.cjs");
var language = __webpack_require__(/*! @codemirror/language */ "./node_modules/@codemirror/language/dist/index.cjs");

const Targets = ["_blank", "_self", "_top", "_parent"];
const Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
const Methods = ["get", "post", "put", "delete"];
const Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
const Bool = ["true", "false"];
const S = {}; // Empty tag spec
const Tags = {
    a: {
        attrs: {
            href: null, ping: null, type: null,
            media: null,
            target: Targets,
            hreflang: null
        }
    },
    abbr: S,
    address: S,
    area: {
        attrs: {
            alt: null, coords: null, href: null, target: null, ping: null,
            media: null, hreflang: null, type: null,
            shape: ["default", "rect", "circle", "poly"]
        }
    },
    article: S,
    aside: S,
    audio: {
        attrs: {
            src: null, mediagroup: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["none", "metadata", "auto"],
            autoplay: ["autoplay"],
            loop: ["loop"],
            controls: ["controls"]
        }
    },
    b: S,
    base: { attrs: { href: null, target: Targets } },
    bdi: S,
    bdo: S,
    blockquote: { attrs: { cite: null } },
    body: S,
    br: S,
    button: {
        attrs: {
            form: null, formaction: null, name: null, value: null,
            autofocus: ["autofocus"],
            disabled: ["autofocus"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            type: ["submit", "reset", "button"]
        }
    },
    canvas: { attrs: { width: null, height: null } },
    caption: S,
    center: S,
    cite: S,
    code: S,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
        attrs: {
            type: ["command", "checkbox", "radio"],
            label: null, icon: null, radiogroup: null, command: null, title: null,
            disabled: ["disabled"],
            checked: ["checked"]
        }
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
    datalist: { attrs: { data: null } },
    dd: S,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ["open"] } },
    dfn: S,
    div: S,
    dl: S,
    dt: S,
    em: S,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
    figcaption: S,
    figure: S,
    footer: S,
    form: {
        attrs: {
            action: null, name: null,
            "accept-charset": Charsets,
            autocomplete: ["on", "off"],
            enctype: Encs,
            method: Methods,
            novalidate: ["novalidate"],
            target: Targets
        }
    },
    h1: S, h2: S, h3: S, h4: S, h5: S, h6: S,
    head: {
        children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
    },
    header: S,
    hgroup: S,
    hr: S,
    html: {
        attrs: { manifest: null }
    },
    i: S,
    iframe: {
        attrs: {
            src: null, srcdoc: null, name: null, width: null, height: null,
            sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
            seamless: ["seamless"]
        }
    },
    img: {
        attrs: {
            alt: null, src: null, ismap: null, usemap: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"]
        }
    },
    input: {
        attrs: {
            alt: null, dirname: null, form: null, formaction: null,
            height: null, list: null, max: null, maxlength: null, min: null,
            name: null, pattern: null, placeholder: null, size: null, src: null,
            step: null, value: null, width: null,
            accept: ["audio/*", "video/*", "image/*"],
            autocomplete: ["on", "off"],
            autofocus: ["autofocus"],
            checked: ["checked"],
            disabled: ["disabled"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            multiple: ["multiple"],
            readonly: ["readonly"],
            required: ["required"],
            type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month",
                "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio",
                "file", "submit", "image", "reset", "button"]
        }
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: S,
    keygen: {
        attrs: {
            challenge: null, form: null, name: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            keytype: ["RSA"]
        }
    },
    label: { attrs: { for: null, form: null } },
    legend: S,
    li: { attrs: { value: null } },
    link: {
        attrs: {
            href: null, type: null,
            hreflang: null,
            media: null,
            sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
        }
    },
    map: { attrs: { name: null } },
    mark: S,
    menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
    meta: {
        attrs: {
            content: null,
            charset: Charsets,
            name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
            "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
        }
    },
    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
    nav: S,
    noscript: S,
    object: {
        attrs: {
            data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,
            typemustmatch: ["typemustmatch"]
        }
    },
    ol: { attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
        children: ["li", "script", "template", "ul", "ol"] },
    optgroup: { attrs: { disabled: ["disabled"], label: null } },
    option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
    output: { attrs: { for: null, form: null, name: null } },
    p: S,
    param: { attrs: { name: null, value: null } },
    pre: S,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: S,
    rt: S,
    ruby: S,
    samp: S,
    script: {
        attrs: {
            type: ["text/javascript"],
            src: null,
            async: ["async"],
            defer: ["defer"],
            charset: Charsets
        }
    },
    section: S,
    select: {
        attrs: {
            form: null, name: null, size: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            multiple: ["multiple"]
        }
    },
    slot: { attrs: { name: null } },
    small: S,
    source: { attrs: { src: null, type: null, media: null } },
    span: S,
    strong: S,
    style: {
        attrs: {
            type: ["text/css"],
            media: null,
            scoped: null
        }
    },
    sub: S,
    summary: S,
    sup: S,
    table: S,
    tbody: S,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    template: S,
    textarea: {
        attrs: {
            dirname: null, form: null, maxlength: null, name: null, placeholder: null,
            rows: null, cols: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            readonly: ["readonly"],
            required: ["required"],
            wrap: ["soft", "hard"]
        }
    },
    tfoot: S,
    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
    thead: S,
    time: { attrs: { datetime: null } },
    title: S,
    tr: S,
    track: {
        attrs: {
            src: null, label: null, default: null,
            kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
            srclang: null
        }
    },
    ul: { children: ["li", "script", "template", "ul", "ol"] },
    var: S,
    video: {
        attrs: {
            src: null, poster: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["auto", "metadata", "none"],
            autoplay: ["autoplay"],
            mediagroup: ["movie"],
            muted: ["muted"],
            controls: ["controls"]
        }
    },
    wbr: S
};
const GlobalAttrs = {
    accesskey: null,
    class: null,
    contenteditable: Bool,
    contextmenu: null,
    dir: ["ltr", "rtl", "auto"],
    draggable: ["true", "false", "auto"],
    dropzone: ["copy", "move", "link", "string:", "file:"],
    hidden: ["hidden"],
    id: null,
    inert: ["inert"],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ["itemscope"],
    itemtype: null,
    lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
    spellcheck: Bool,
    autocorrect: Bool,
    autocapitalize: Bool,
    style: null,
    tabindex: null,
    title: null,
    translate: ["yes", "no"],
    rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
    role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
    "aria-activedescendant": null,
    "aria-atomic": Bool,
    "aria-autocomplete": ["inline", "list", "both", "none"],
    "aria-busy": Bool,
    "aria-checked": ["true", "false", "mixed", "undefined"],
    "aria-controls": null,
    "aria-describedby": null,
    "aria-disabled": Bool,
    "aria-dropeffect": null,
    "aria-expanded": ["true", "false", "undefined"],
    "aria-flowto": null,
    "aria-grabbed": ["true", "false", "undefined"],
    "aria-haspopup": Bool,
    "aria-hidden": Bool,
    "aria-invalid": ["true", "false", "grammar", "spelling"],
    "aria-label": null,
    "aria-labelledby": null,
    "aria-level": null,
    "aria-live": ["off", "polite", "assertive"],
    "aria-multiline": Bool,
    "aria-multiselectable": Bool,
    "aria-owns": null,
    "aria-posinset": null,
    "aria-pressed": ["true", "false", "mixed", "undefined"],
    "aria-readonly": Bool,
    "aria-relevant": null,
    "aria-required": Bool,
    "aria-selected": ["true", "false", "undefined"],
    "aria-setsize": null,
    "aria-sort": ["ascending", "descending", "none", "other"],
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null
};
const eventAttributes = ("beforeunload copy cut dragstart dragover dragleave dragenter dragend " +
    "drag paste focus blur change click load mousedown mouseenter mouseleave " +
    "mouseup keydown keyup resize scroll unload").split(" ").map(n => "on" + n);
for (let a of eventAttributes)
    GlobalAttrs[a] = null;
class Schema {
    constructor(extraTags, extraAttrs) {
        this.tags = Object.assign(Object.assign({}, Tags), extraTags);
        this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);
        this.allTags = Object.keys(this.tags);
        this.globalAttrNames = Object.keys(this.globalAttrs);
    }
}
Schema.default = new Schema;
function elementName(doc, tree, max = doc.length) {
    if (!tree)
        return "";
    let tag = tree.firstChild;
    let name = tag && tag.getChild("TagName");
    return name ? doc.sliceString(name.from, Math.min(name.to, max)) : "";
}
function findParentElement(tree, skip = false) {
    for (; tree; tree = tree.parent)
        if (tree.name == "Element") {
            if (skip)
                skip = false;
            else
                return tree;
        }
    return null;
}
function allowedChildren(doc, tree, schema) {
    let parentInfo = schema.tags[elementName(doc, findParentElement(tree))];
    return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;
}
function openTags(doc, tree) {
    let open = [];
    for (let parent = findParentElement(tree); parent && !parent.type.isTop; parent = findParentElement(parent.parent)) {
        let tagName = elementName(doc, parent);
        if (tagName && parent.lastChild.name == "CloseTag")
            break;
        if (tagName && open.indexOf(tagName) < 0 && (tree.name == "EndTag" || tree.from >= parent.firstChild.to))
            open.push(tagName);
    }
    return open;
}
const identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
function completeTag(state, schema, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    let parent = findParentElement(tree, true);
    return { from, to,
        options: allowedChildren(state.doc, parent, schema).map(tagName => ({ label: tagName, type: "type" })).concat(openTags(state.doc, tree).map((tag, i) => ({ label: "/" + tag, apply: "/" + tag + end,
            type: "type", boost: 99 - i }))),
        validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeCloseTag(state, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return { from, to,
        options: openTags(state.doc, tree).map((tag, i) => ({ label: tag, apply: tag + end, type: "type", boost: 99 - i })),
        validFor: identifier };
}
function completeStartTag(state, schema, tree, pos) {
    let options = [], level = 0;
    for (let tagName of allowedChildren(state.doc, tree, schema))
        options.push({ label: "<" + tagName, type: "type" });
    for (let open of openTags(state.doc, tree))
        options.push({ label: "</" + open + ">", type: "type", boost: 99 - level++ });
    return { from: pos, to: pos, options, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeAttrName(state, schema, tree, from, to) {
    let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;
    let localAttrs = info && info.attrs ? Object.keys(info.attrs) : [];
    let names = info && info.globalAttrs === false ? localAttrs
        : localAttrs.length ? localAttrs.concat(schema.globalAttrNames) : schema.globalAttrNames;
    return { from, to,
        options: names.map(attrName => ({ label: attrName, type: "property" })),
        validFor: identifier };
}
function completeAttrValue(state, schema, tree, from, to) {
    var _a;
    let nameNode = (_a = tree.parent) === null || _a === void 0 ? void 0 : _a.getChild("AttributeName");
    let options = [], token = undefined;
    if (nameNode) {
        let attrName = state.sliceDoc(nameNode.from, nameNode.to);
        let attrs = schema.globalAttrs[attrName];
        if (!attrs) {
            let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;
            attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
        }
        if (attrs) {
            let base = state.sliceDoc(from, to).toLowerCase(), quoteStart = '"', quoteEnd = '"';
            if (/^['"]/.test(base)) {
                token = base[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
                quoteStart = "";
                quoteEnd = state.sliceDoc(to, to + 1) == base[0] ? "" : base[0];
                base = base.slice(1);
                from++;
            }
            else {
                token = /^[^\s<>='"]*$/;
            }
            for (let value of attrs)
                options.push({ label: value, apply: quoteStart + value + quoteEnd, type: "constant" });
        }
    }
    return { from, to, options, validFor: token };
}
function htmlCompletionFor(schema, context) {
    let { state, pos } = context, tree = language.syntaxTree(state).resolveInner(pos, -1), around = tree.resolve(pos);
    for (let scan = pos, before; around == tree && (before = tree.childBefore(scan));) {
        let last = before.lastChild;
        if (!last || !last.type.isError || last.from < last.to)
            break;
        around = tree = before;
        scan = last.from;
    }
    if (tree.name == "TagName") {
        return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos)
            : completeTag(state, schema, tree, tree.from, pos);
    }
    else if (tree.name == "StartTag") {
        return completeTag(state, schema, tree, pos, pos);
    }
    else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") {
        return completeCloseTag(state, tree, pos, pos);
    }
    else if (tree.name == "OpenTag" || tree.name == "SelfClosingTag" || tree.name == "AttributeName") {
        return completeAttrName(state, schema, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
    }
    else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") {
        return completeAttrValue(state, schema, tree, tree.name == "Is" ? pos : tree.from, pos);
    }
    else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
        return completeStartTag(state, schema, tree, pos);
    }
    else {
        return null;
    }
}
/**
HTML tag completion. Opens and closes tags and attributes in a
context-aware way.
*/
function htmlCompletionSource(context) {
    return htmlCompletionFor(Schema.default, context);
}
/**
Create a completion source for HTML extended with additional tags
or attributes.
*/
function htmlCompletionSourceWith(config) {
    let { extraTags, extraGlobalAttributes: extraAttrs } = config;
    let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
    return (context) => htmlCompletionFor(schema, context);
}

const jsonParser = langJavascript.javascriptLanguage.parser.configure({ top: "SingleExpression" });
const defaultNesting = [
    { tag: "script",
        attrs: attrs => attrs.type == "text/typescript" || attrs.lang == "ts",
        parser: langJavascript.typescriptLanguage.parser },
    { tag: "script",
        attrs: attrs => attrs.type == "text/babel" || attrs.type == "text/jsx",
        parser: langJavascript.jsxLanguage.parser },
    { tag: "script",
        attrs: attrs => attrs.type == "text/typescript-jsx",
        parser: langJavascript.tsxLanguage.parser },
    { tag: "script",
        attrs(attrs) {
            return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(attrs.type);
        },
        parser: jsonParser },
    { tag: "script",
        attrs(attrs) {
            return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
        },
        parser: langJavascript.javascriptLanguage.parser },
    { tag: "style",
        attrs(attrs) {
            return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
        },
        parser: langCss.cssLanguage.parser }
];
const defaultAttrs = [
    { name: "style",
        parser: langCss.cssLanguage.parser.configure({ top: "Styles" }) }
].concat(eventAttributes.map(name => ({ name, parser: langJavascript.javascriptLanguage.parser })));
/**
A language provider based on the [Lezer HTML
parser](https://github.com/lezer-parser/html), extended with the
JavaScript and CSS parsers to parse the content of `<script>` and
`<style>` tags.
*/
const htmlPlain = language.LRLanguage.define({
    name: "html",
    parser: html$1.parser.configure({
        props: [
            language.indentNodeProp.add({
                Element(context) {
                    let after = /^(\s*)(<\/)?/.exec(context.textAfter);
                    if (context.node.to <= context.pos + after[0].length)
                        return context.continue();
                    return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
                },
                "OpenTag CloseTag SelfClosingTag"(context) {
                    return context.column(context.node.from) + context.unit;
                },
                Document(context) {
                    if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to)
                        return context.continue();
                    let endElt = null, close;
                    for (let cur = context.node;;) {
                        let last = cur.lastChild;
                        if (!last || last.name != "Element" || last.to != cur.to)
                            break;
                        endElt = cur = last;
                    }
                    if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag")))
                        return context.lineIndent(endElt.from) + context.unit;
                    return null;
                }
            }),
            language.foldNodeProp.add({
                Element(node) {
                    let first = node.firstChild, last = node.lastChild;
                    if (!first || first.name != "OpenTag")
                        return null;
                    return { from: first.to, to: last.name == "CloseTag" ? last.from : node.to };
                }
            }),
            language.bracketMatchingHandle.add({
                "OpenTag CloseTag": node => node.getChild("TagName")
            })
        ]
    }),
    languageData: {
        commentTokens: { block: { open: "<!--", close: "-->" } },
        indentOnInput: /^\s*<\/\w+\W$/,
        wordChars: "-._"
    }
});
/**
A language provider based on the [Lezer HTML
parser](https://github.com/lezer-parser/html), extended with the
JavaScript and CSS parsers to parse the content of `<script>` and
`<style>` tags.
*/
const htmlLanguage = htmlPlain.configure({
    wrap: html$1.configureNesting(defaultNesting, defaultAttrs)
});
/**
Language support for HTML, including
[`htmlCompletion`](https://codemirror.net/6/docs/ref/#lang-html.htmlCompletion) and JavaScript and
CSS support extensions.
*/
function html(config = {}) {
    let dialect = "", wrap;
    if (config.matchClosingTags === false)
        dialect = "noMatch";
    if (config.selfClosingTags === true)
        dialect = (dialect ? dialect + " " : "") + "selfClosing";
    if (config.nestedLanguages && config.nestedLanguages.length ||
        config.nestedAttributes && config.nestedAttributes.length)
        wrap = html$1.configureNesting((config.nestedLanguages || []).concat(defaultNesting), (config.nestedAttributes || []).concat(defaultAttrs));
    let lang = wrap ? htmlPlain.configure({ wrap, dialect }) : dialect ? htmlLanguage.configure({ dialect }) : htmlLanguage;
    return new language.LanguageSupport(lang, [
        htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config) }),
        config.autoCloseTags !== false ? autoCloseTags : [],
        langJavascript.javascript().support,
        langCss.css().support
    ]);
}
const selfClosers = new Set("area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" "));
/**
Extension that will automatically insert close tags when a `>` or
`/` is typed.
*/
const autoCloseTags = view.EditorView.inputHandler.of((view, from, to, text, insertTransaction) => {
    if (view.composing || view.state.readOnly || from != to || (text != ">" && text != "/") ||
        !htmlLanguage.isActiveAt(view.state, from, -1))
        return false;
    let base = insertTransaction(), { state: state$1 } = base;
    let closeTags = state$1.changeByRange(range => {
        var _a, _b, _c;
        let didType = state$1.doc.sliceString(range.from - 1, range.to) == text;
        let { head } = range, after = language.syntaxTree(state$1).resolveInner(head, -1), name;
        if (didType && text == ">" && after.name == "EndTag") {
            let tag = after.parent;
            if (((_b = (_a = tag.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" &&
                (name = elementName(state$1.doc, tag.parent, head)) &&
                !selfClosers.has(name)) {
                let to = head + (state$1.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
                let insert = `</${name}>`;
                return { range, changes: { from: head, to, insert } };
            }
        }
        else if (didType && text == "/" && after.name == "IncompleteCloseTag") {
            let tag = after.parent;
            if (after.from == head - 2 && ((_c = tag.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" &&
                (name = elementName(state$1.doc, tag, head)) && !selfClosers.has(name)) {
                let to = head + (state$1.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
                let insert = `${name}>`;
                return {
                    range: state.EditorSelection.cursor(head + insert.length, -1),
                    changes: { from: head, to, insert }
                };
            }
        }
        return { range };
    });
    if (closeTags.changes.empty)
        return false;
    view.dispatch([
        base,
        state$1.update(closeTags, {
            userEvent: "input.complete",
            scrollIntoView: true
        })
    ]);
    return true;
});

exports.autoCloseTags = autoCloseTags;
exports.html = html;
exports.htmlCompletionSource = htmlCompletionSource;
exports.htmlCompletionSourceWith = htmlCompletionSourceWith;
exports.htmlLanguage = htmlLanguage;
exports.htmlPlain = htmlPlain;


/***/ }),

/***/ "./node_modules/@codemirror/lang-javascript/dist/index.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@codemirror/lang-javascript/dist/index.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var javascript$1 = __webpack_require__(/*! @lezer/javascript */ "./node_modules/@lezer/javascript/dist/index.cjs");
var language = __webpack_require__(/*! @codemirror/language */ "./node_modules/@codemirror/language/dist/index.cjs");
var state = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.cjs");
var view = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.cjs");
var autocomplete = __webpack_require__(/*! @codemirror/autocomplete */ "./node_modules/@codemirror/autocomplete/dist/index.cjs");
var common = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.cjs");

/**
A collection of JavaScript-related
[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).
*/
const snippets = [
    autocomplete.snippetCompletion("function ${name}(${params}) {\n\t${}\n}", {
        label: "function",
        detail: "definition",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}", {
        label: "for",
        detail: "loop",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("for (let ${name} of ${collection}) {\n\t${}\n}", {
        label: "for",
        detail: "of loop",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("do {\n\t${}\n} while (${})", {
        label: "do",
        detail: "loop",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("while (${}) {\n\t${}\n}", {
        label: "while",
        detail: "loop",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("try {\n\t${}\n} catch (${error}) {\n\t${}\n}", {
        label: "try",
        detail: "/ catch block",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("if (${}) {\n\t${}\n}", {
        label: "if",
        detail: "block",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("if (${}) {\n\t${}\n} else {\n\t${}\n}", {
        label: "if",
        detail: "/ else block",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}", {
        label: "class",
        detail: "definition",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("import {${names}} from \"${module}\"\n${}", {
        label: "import",
        detail: "named",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("import ${name} from \"${module}\"\n${}", {
        label: "import",
        detail: "default",
        type: "keyword"
    })
];
/**
A collection of snippet completions for TypeScript. Includes the
JavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).
*/
const typescriptSnippets = snippets.concat([
    autocomplete.snippetCompletion("interface ${name} {\n\t${}\n}", {
        label: "interface",
        detail: "definition",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("type ${name} = ${type}", {
        label: "type",
        detail: "definition",
        type: "keyword"
    }),
    autocomplete.snippetCompletion("enum ${name} {\n\t${}\n}", {
        label: "enum",
        detail: "definition",
        type: "keyword"
    })
]);

const cache = new common.NodeWeakMap();
const ScopeNodes = new Set([
    "Script", "Block",
    "FunctionExpression", "FunctionDeclaration", "ArrowFunction", "MethodDeclaration",
    "ForStatement"
]);
function defID(type) {
    return (node, def) => {
        let id = node.node.getChild("VariableDefinition");
        if (id)
            def(id, type);
        return true;
    };
}
const functionContext = ["FunctionDeclaration"];
const gatherCompletions = {
    FunctionDeclaration: defID("function"),
    ClassDeclaration: defID("class"),
    ClassExpression: () => true,
    EnumDeclaration: defID("constant"),
    TypeAliasDeclaration: defID("type"),
    NamespaceDeclaration: defID("namespace"),
    VariableDefinition(node, def) { if (!node.matchContext(functionContext))
        def(node, "variable"); },
    TypeDefinition(node, def) { def(node, "type"); },
    __proto__: null
};
function getScope(doc, node) {
    let cached = cache.get(node);
    if (cached)
        return cached;
    let completions = [], top = true;
    function def(node, type) {
        let name = doc.sliceString(node.from, node.to);
        completions.push({ label: name, type });
    }
    node.cursor(common.IterMode.IncludeAnonymous).iterate(node => {
        if (top) {
            top = false;
        }
        else if (node.name) {
            let gather = gatherCompletions[node.name];
            if (gather && gather(node, def) || ScopeNodes.has(node.name))
                return false;
        }
        else if (node.to - node.from > 8192) {
            // Allow caching for bigger internal nodes
            for (let c of getScope(doc, node.node))
                completions.push(c);
            return false;
        }
    });
    cache.set(node, completions);
    return completions;
}
const Identifier = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
const dontComplete = [
    "TemplateString", "String", "RegExp",
    "LineComment", "BlockComment",
    "VariableDefinition", "TypeDefinition", "Label",
    "PropertyDefinition", "PropertyName",
    "PrivatePropertyDefinition", "PrivatePropertyName",
    ".", "?."
];
/**
Completion source that looks up locally defined names in
JavaScript code.
*/
function localCompletionSource(context) {
    let inner = language.syntaxTree(context.state).resolveInner(context.pos, -1);
    if (dontComplete.indexOf(inner.name) > -1)
        return null;
    let isWord = inner.name == "VariableName" ||
        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));
    if (!isWord && !context.explicit)
        return null;
    let options = [];
    for (let pos = inner; pos; pos = pos.parent) {
        if (ScopeNodes.has(pos.name))
            options = options.concat(getScope(context.state.doc, pos));
    }
    return {
        options,
        from: isWord ? inner.from : context.pos,
        validFor: Identifier
    };
}
function pathFor(read, member, name) {
    var _a;
    let path = [];
    for (;;) {
        let obj = member.firstChild, prop;
        if ((obj === null || obj === void 0 ? void 0 : obj.name) == "VariableName") {
            path.push(read(obj));
            return { path: path.reverse(), name };
        }
        else if ((obj === null || obj === void 0 ? void 0 : obj.name) == "MemberExpression" && ((_a = (prop = obj.lastChild)) === null || _a === void 0 ? void 0 : _a.name) == "PropertyName") {
            path.push(read(prop));
            member = obj;
        }
        else {
            return null;
        }
    }
}
/**
Helper function for defining JavaScript completion sources. It
returns the completable name and object path for a completion
context, or null if no name/property completion should happen at
that position. For example, when completing after `a.b.c` it will
return `{path: ["a", "b"], name: "c"}`. When completing after `x`
it will return `{path: [], name: "x"}`. When not in a property or
name, it will return null if `context.explicit` is false, and
`{path: [], name: ""}` otherwise.
*/
function completionPath(context) {
    let read = (node) => context.state.doc.sliceString(node.from, node.to);
    let inner = language.syntaxTree(context.state).resolveInner(context.pos, -1);
    if (inner.name == "PropertyName") {
        return pathFor(read, inner.parent, read(inner));
    }
    else if ((inner.name == "." || inner.name == "?.") && inner.parent.name == "MemberExpression") {
        return pathFor(read, inner.parent, "");
    }
    else if (dontComplete.indexOf(inner.name) > -1) {
        return null;
    }
    else if (inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {
        return { path: [], name: read(inner) };
    }
    else if (inner.name == "MemberExpression") {
        return pathFor(read, inner, "");
    }
    else {
        return context.explicit ? { path: [], name: "" } : null;
    }
}
function enumeratePropertyCompletions(obj, top) {
    let options = [], seen = new Set;
    for (let depth = 0;; depth++) {
        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {
            if (!/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(name) || seen.has(name))
                continue;
            seen.add(name);
            let value;
            try {
                value = obj[name];
            }
            catch (_) {
                continue;
            }
            options.push({
                label: name,
                type: typeof value == "function" ? (/^[A-Z]/.test(name) ? "class" : top ? "function" : "method")
                    : top ? "variable" : "property",
                boost: -depth
            });
        }
        let next = Object.getPrototypeOf(obj);
        if (!next)
            return options;
        obj = next;
    }
}
/**
Defines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that
completes from the given scope object (for example `globalThis`).
Will enter properties of the object when completing properties on
a directly-named path.
*/
function scopeCompletionSource(scope) {
    let cache = new Map;
    return (context) => {
        let path = completionPath(context);
        if (!path)
            return null;
        let target = scope;
        for (let step of path.path) {
            target = target[step];
            if (!target)
                return null;
        }
        let options = cache.get(target);
        if (!options)
            cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));
        return {
            from: context.pos - path.name.length,
            options,
            validFor: Identifier
        };
    };
}

/**
A language provider based on the [Lezer JavaScript
parser](https://github.com/lezer-parser/javascript), extended with
highlighting and indentation information.
*/
const javascriptLanguage = language.LRLanguage.define({
    name: "javascript",
    parser: javascript$1.parser.configure({
        props: [
            language.indentNodeProp.add({
                IfStatement: language.continuedIndent({ except: /^\s*({|else\b)/ }),
                TryStatement: language.continuedIndent({ except: /^\s*({|catch\b|finally\b)/ }),
                LabeledStatement: language.flatIndent,
                SwitchBody: context => {
                    let after = context.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
                },
                Block: language.delimitedIndent({ closing: "}" }),
                ArrowFunction: cx => cx.baseIndent + cx.unit,
                "TemplateString BlockComment": () => null,
                "Statement Property": language.continuedIndent({ except: /^{/ }),
                JSXElement(context) {
                    let closed = /^\s*<\//.test(context.textAfter);
                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
                },
                JSXEscape(context) {
                    let closed = /\s*\}/.test(context.textAfter);
                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
                },
                "JSXOpenTag JSXSelfClosingTag"(context) {
                    return context.column(context.node.from) + context.unit;
                }
            }),
            language.foldNodeProp.add({
                "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": language.foldInside,
                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }
            })
        ]
    }),
    languageData: {
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
        commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
        indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
        wordChars: "$"
    }
});
const jsxSublanguage = {
    test: node => /^JSX/.test(node.name),
    facet: language.defineLanguageFacet({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
};
/**
A language provider for TypeScript.
*/
const typescriptLanguage = javascriptLanguage.configure({ dialect: "ts" }, "typescript");
/**
Language provider for JSX.
*/
const jsxLanguage = javascriptLanguage.configure({
    dialect: "jsx",
    props: [language.sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]
});
/**
Language provider for JSX + TypeScript.
*/
const tsxLanguage = javascriptLanguage.configure({
    dialect: "jsx ts",
    props: [language.sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]
}, "typescript");
let kwCompletion = (name) => ({ label: name, type: "keyword" });
const keywords = "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(kwCompletion);
const typescriptKeywords = keywords.concat(["declare", "implements", "private", "protected", "public"].map(kwCompletion));
/**
JavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)
and local variable completion.
*/
function javascript(config = {}) {
    let lang = config.jsx ? (config.typescript ? tsxLanguage : jsxLanguage)
        : config.typescript ? typescriptLanguage : javascriptLanguage;
    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);
    return new language.LanguageSupport(lang, [
        javascriptLanguage.data.of({
            autocomplete: autocomplete.ifNotIn(dontComplete, autocomplete.completeFromList(completions))
        }),
        javascriptLanguage.data.of({
            autocomplete: localCompletionSource
        }),
        config.jsx ? autoCloseTags : [],
    ]);
}
function findOpenTag(node) {
    for (;;) {
        if (node.name == "JSXOpenTag" || node.name == "JSXSelfClosingTag" || node.name == "JSXFragmentTag")
            return node;
        if (node.name == "JSXEscape" || !node.parent)
            return null;
        node = node.parent;
    }
}
function elementName(doc, tree, max = doc.length) {
    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {
        if (ch.name == "JSXIdentifier" || ch.name == "JSXBuiltin" || ch.name == "JSXNamespacedName" ||
            ch.name == "JSXMemberExpression")
            return doc.sliceString(ch.from, Math.min(ch.to, max));
    }
    return "";
}
const android = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
/**
Extension that will automatically insert JSX close tags when a `>` or
`/` is typed.
*/
const autoCloseTags = view.EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly ||
        from != to || (text != ">" && text != "/") ||
        !javascriptLanguage.isActiveAt(view.state, from, -1))
        return false;
    let base = defaultInsert(), { state: state$1 } = base;
    let closeTags = state$1.changeByRange(range => {
        var _a;
        let { head } = range, around = language.syntaxTree(state$1).resolveInner(head - 1, -1), name;
        if (around.name == "JSXStartTag")
            around = around.parent;
        if (state$1.doc.sliceString(head - 1, head) != text || around.name == "JSXAttributeValue" && around.to > head) ;
        else if (text == ">" && around.name == "JSXFragmentTag") {
            return { range, changes: { from: head, insert: `</>` } };
        }
        else if (text == "/" && around.name == "JSXStartCloseTag") {
            let empty = around.parent, base = empty.parent;
            if (base && empty.from == head - 2 &&
                ((name = elementName(state$1.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == "JSXFragmentTag")) {
                let insert = `${name}>`;
                return { range: state.EditorSelection.cursor(head + insert.length, -1), changes: { from: head, insert } };
            }
        }
        else if (text == ">") {
            let openTag = findOpenTag(around);
            if (openTag && openTag.name == "JSXOpenTag" &&
                !/^\/?>|^<\//.test(state$1.doc.sliceString(head, head + 2)) &&
                (name = elementName(state$1.doc, openTag, head)))
                return { range, changes: { from: head, insert: `</${name}>` } };
        }
        return { range };
    });
    if (closeTags.changes.empty)
        return false;
    view.dispatch([
        base,
        state$1.update(closeTags, { userEvent: "input.complete", scrollIntoView: true })
    ]);
    return true;
});

/**
Connects an [ESLint](https://eslint.org/) linter to CodeMirror's
[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the
[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)
class, and `config` an optional ESLint configuration. The return
value of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)
to create a JavaScript linting extension.

Note that ESLint targets node, and is tricky to run in the
browser. The
[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)
package may help with that (see
[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).
*/
function esLint(eslint, config) {
    if (!config) {
        config = {
            parserOptions: { ecmaVersion: 2019, sourceType: "module" },
            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },
            rules: {}
        };
        eslint.getRules().forEach((desc, name) => {
            if (desc.meta.docs.recommended)
                config.rules[name] = 2;
        });
    }
    return (view) => {
        let { state } = view, found = [];
        for (let { from, to } of javascriptLanguage.findRegions(state)) {
            let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };
            for (let d of eslint.verify(state.sliceDoc(from, to), config))
                found.push(translateDiagnostic(d, state.doc, offset));
        }
        return found;
    };
}
function mapPos(line, col, doc, offset) {
    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);
}
function translateDiagnostic(input, doc, offset) {
    let start = mapPos(input.line, input.column, doc, offset);
    let result = {
        from: start,
        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,
        message: input.message,
        source: input.ruleId ? "eslint:" + input.ruleId : "eslint",
        severity: input.severity == 1 ? "warning" : "error",
    };
    if (input.fix) {
        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;
        result.actions = [{
                name: "fix",
                apply(view, start) {
                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });
                }
            }];
    }
    return result;
}

exports.autoCloseTags = autoCloseTags;
exports.completionPath = completionPath;
exports.esLint = esLint;
exports.javascript = javascript;
exports.javascriptLanguage = javascriptLanguage;
exports.jsxLanguage = jsxLanguage;
exports.localCompletionSource = localCompletionSource;
exports.scopeCompletionSource = scopeCompletionSource;
exports.snippets = snippets;
exports.tsxLanguage = tsxLanguage;
exports.typescriptLanguage = typescriptLanguage;
exports.typescriptSnippets = typescriptSnippets;


/***/ }),

/***/ "./node_modules/@codemirror/language/dist/index.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var common = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.cjs");
var state = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.cjs");
var view = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.cjs");
var highlight = __webpack_require__(/*! @lezer/highlight */ "./node_modules/@lezer/highlight/dist/index.cjs");
var styleMod = __webpack_require__(/*! style-mod */ "./node_modules/style-mod/dist/style-mod.cjs");

var _a;
/**
Node prop stored in a parser's top syntax node to provide the
facet that stores language-specific data for that language.
*/
const languageDataProp = new common.NodeProp();
/**
Helper function to define a facet (to be added to the top syntax
node(s) for a language via
[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be
used to associate language data with the language. You
probably only need this when subclassing
[`Language`](https://codemirror.net/6/docs/ref/#language.Language).
*/
function defineLanguageFacet(baseData) {
    return state.Facet.define({
        combine: baseData ? values => values.concat(baseData) : undefined
    });
}
/**
Syntax node prop used to register sublanguages. Should be added to
the top level node type for the language.
*/
const sublanguageProp = new common.NodeProp();
/**
A language object manages parsing and per-language
[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is
managed as a [Lezer](https://lezer.codemirror.net) tree. The class
can be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)
subclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or
via the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass
for stream parsers.
*/
class Language {
    /**
    Construct a language object. If you need to invoke this
    directly, first define a data facet with
    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
    to the language's outer syntax node.
    */
    constructor(
    /**
    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet
    used for this language.
    */
    data, parser, extraExtensions = [], 
    /**
    A language name.
    */
    name = "") {
        this.data = data;
        this.name = name;
        // Kludge to define EditorState.tree as a debugging helper,
        // without the EditorState package actually knowing about
        // languages and lezer trees.
        if (!state.EditorState.prototype.hasOwnProperty("tree"))
            Object.defineProperty(state.EditorState.prototype, "tree", { get() { return syntaxTree(this); } });
        this.parser = parser;
        this.extension = [
            language.of(this),
            state.EditorState.languageData.of((state, pos, side) => {
                let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);
                if (!data)
                    return [];
                let base = state.facet(data), sub = top.type.prop(sublanguageProp);
                if (sub) {
                    let innerNode = top.resolve(pos - top.from, side);
                    for (let sublang of sub)
                        if (sublang.test(innerNode, state)) {
                            let data = state.facet(sublang.facet);
                            return sublang.type == "replace" ? data : data.concat(base);
                        }
                }
                return base;
            })
        ].concat(extraExtensions);
    }
    /**
    Query whether this language is active at the given position.
    */
    isActiveAt(state, pos, side = -1) {
        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
    }
    /**
    Find the document regions that were parsed using this language.
    The returned regions will _include_ any nested languages rooted
    in this language, when those exist.
    */
    findRegions(state) {
        let lang = state.facet(language);
        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
            return [{ from: 0, to: state.doc.length }];
        if (!lang || !lang.allowsNesting)
            return [];
        let result = [];
        let explore = (tree, from) => {
            if (tree.prop(languageDataProp) == this.data) {
                result.push({ from, to: from + tree.length });
                return;
            }
            let mount = tree.prop(common.NodeProp.mounted);
            if (mount) {
                if (mount.tree.prop(languageDataProp) == this.data) {
                    if (mount.overlay)
                        for (let r of mount.overlay)
                            result.push({ from: r.from + from, to: r.to + from });
                    else
                        result.push({ from: from, to: from + tree.length });
                    return;
                }
                else if (mount.overlay) {
                    let size = result.length;
                    explore(mount.tree, mount.overlay[0].from + from);
                    if (result.length > size)
                        return;
                }
            }
            for (let i = 0; i < tree.children.length; i++) {
                let ch = tree.children[i];
                if (ch instanceof common.Tree)
                    explore(ch, tree.positions[i] + from);
            }
        };
        explore(syntaxTree(state), 0);
        return result;
    }
    /**
    Indicates whether this language allows nested languages. The
    default implementation returns true.
    */
    get allowsNesting() { return true; }
}
/**
@internal
*/
Language.setState = state.StateEffect.define();
function topNodeAt(state, pos, side) {
    let topLang = state.facet(language), tree = syntaxTree(state).topNode;
    if (!topLang || topLang.allowsNesting) {
        for (let node = tree; node; node = node.enter(pos, side, common.IterMode.ExcludeBuffers))
            if (node.type.isTop)
                tree = node;
    }
    return tree;
}
/**
A subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer
[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)
parsers.
*/
class LRLanguage extends Language {
    constructor(data, parser, name) {
        super(data, parser, [], name);
        this.parser = parser;
    }
    /**
    Define a language from a parser.
    */
    static define(spec) {
        let data = defineLanguageFacet(spec.languageData);
        return new LRLanguage(data, spec.parser.configure({
            props: [languageDataProp.add(type => type.isTop ? data : undefined)]
        }), spec.name);
    }
    /**
    Create a new instance of this language with a reconfigured
    version of its parser and optionally a new name.
    */
    configure(options, name) {
        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);
    }
    get allowsNesting() { return this.parser.hasWrappers(); }
}
/**
Get the syntax tree for a state, which is the current (possibly
incomplete) parse tree of the active
[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no
language available.
*/
function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : common.Tree.empty;
}
/**
Try to get a parse tree that spans at least up to `upto`. The
method will do at most `timeout` milliseconds of work to parse
up to that point if the tree isn't already available.
*/
function ensureSyntaxTree(state, upto, timeout = 50) {
    var _a;
    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;
    if (!parse)
        return null;
    let oldVieport = parse.viewport;
    parse.updateViewport({ from: 0, to: upto });
    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;
    parse.updateViewport(oldVieport);
    return result;
}
/**
Queries whether there is a full syntax tree available up to the
given document position. If there isn't, the background parse
process _might_ still be working and update the tree further, but
there is no guarantee of that—the parser will [stop
working](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a
certain amount of time or has moved beyond the visible viewport.
Always returns false if no language has been enabled.
*/
function syntaxTreeAvailable(state, upto = state.doc.length) {
    var _a;
    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;
}
/**
Move parsing forward, and update the editor state afterwards to
reflect the new tree. Will work for at most `timeout`
milliseconds. Returns true if the parser managed get to the given
position in that time.
*/
function forceParsing(view, upto = view.viewport.to, timeout = 100) {
    let success = ensureSyntaxTree(view.state, upto, timeout);
    if (success != syntaxTree(view.state))
        view.dispatch({});
    return !!success;
}
/**
Tells you whether the language parser is planning to do more
parsing work (in a `requestIdleCallback` pseudo-thread) or has
stopped running, either because it parsed the entire document,
because it spent too much time and was cut off, or because there
is no language parser enabled.
*/
function syntaxParserRunning(view) {
    var _a;
    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;
}
/**
Lezer-style
[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)
object for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.
*/
class DocInput {
    /**
    Create an input object for the given document.
    */
    constructor(doc) {
        this.doc = doc;
        this.cursorPos = 0;
        this.string = "";
        this.cursor = doc.iter();
    }
    get length() { return this.doc.length; }
    syncTo(pos) {
        this.string = this.cursor.next(pos - this.cursorPos).value;
        this.cursorPos = pos + this.string.length;
        return this.cursorPos - this.string.length;
    }
    chunk(pos) {
        this.syncTo(pos);
        return this.string;
    }
    get lineChunks() { return true; }
    read(from, to) {
        let stringStart = this.cursorPos - this.string.length;
        if (from < stringStart || to >= this.cursorPos)
            return this.doc.sliceString(from, to);
        else
            return this.string.slice(from - stringStart, to - stringStart);
    }
}
let currentContext = null;
/**
A parse context provided to parsers working on the editor content.
*/
class ParseContext {
    constructor(parser, 
    /**
    The current editor state.
    */
    state, 
    /**
    Tree fragments that can be reused by incremental re-parses.
    */
    fragments = [], 
    /**
    @internal
    */
    tree, 
    /**
    @internal
    */
    treeLen, 
    /**
    The current editor viewport (or some overapproximation
    thereof). Intended to be used for opportunistically avoiding
    work (in which case
    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)
    should be called to make sure the parser is restarted when the
    skipped region becomes visible).
    */
    viewport, 
    /**
    @internal
    */
    skipped, 
    /**
    This is where skipping parsers can register a promise that,
    when resolved, will schedule a new parse. It is cleared when
    the parse worker picks up the promise. @internal
    */
    scheduleOn) {
        this.parser = parser;
        this.state = state;
        this.fragments = fragments;
        this.tree = tree;
        this.treeLen = treeLen;
        this.viewport = viewport;
        this.skipped = skipped;
        this.scheduleOn = scheduleOn;
        this.parse = null;
        /**
        @internal
        */
        this.tempSkipped = [];
    }
    /**
    @internal
    */
    static create(parser, state, viewport) {
        return new ParseContext(parser, state, [], common.Tree.empty, 0, viewport, [], null);
    }
    startParse() {
        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    /**
    @internal
    */
    work(until, upto) {
        if (upto != null && upto >= this.state.doc.length)
            upto = undefined;
        if (this.tree != common.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
            this.takeTree();
            return true;
        }
        return this.withContext(() => {
            var _a;
            if (typeof until == "number") {
                let endTime = Date.now() + until;
                until = () => Date.now() > endTime;
            }
            if (!this.parse)
                this.parse = this.startParse();
            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) &&
                upto < this.state.doc.length)
                this.parse.stopAt(upto);
            for (;;) {
                let done = this.parse.advance();
                if (done) {
                    this.fragments = this.withoutTempSkipped(common.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;
                    this.tree = done;
                    this.parse = null;
                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
                        this.parse = this.startParse();
                    else
                        return true;
                }
                if (until())
                    return false;
            }
        });
    }
    /**
    @internal
    */
    takeTree() {
        let pos, tree;
        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
                this.parse.stopAt(pos);
            this.withContext(() => { while (!(tree = this.parse.advance())) { } });
            this.treeLen = pos;
            this.tree = tree;
            this.fragments = this.withoutTempSkipped(common.TreeFragment.addTree(this.tree, this.fragments, true));
            this.parse = null;
        }
    }
    withContext(f) {
        let prev = currentContext;
        currentContext = this;
        try {
            return f();
        }
        finally {
            currentContext = prev;
        }
    }
    withoutTempSkipped(fragments) {
        for (let r; r = this.tempSkipped.pop();)
            fragments = cutFragments(fragments, r.from, r.to);
        return fragments;
    }
    /**
    @internal
    */
    changes(changes, newState) {
        let { fragments, tree, treeLen, viewport, skipped } = this;
        this.takeTree();
        if (!changes.empty) {
            let ranges = [];
            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
            fragments = common.TreeFragment.applyChanges(fragments, ranges);
            tree = common.Tree.empty;
            treeLen = 0;
            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
            if (this.skipped.length) {
                skipped = [];
                for (let r of this.skipped) {
                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
                    if (from < to)
                        skipped.push({ from, to });
                }
            }
        }
        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    /**
    @internal
    */
    updateViewport(viewport) {
        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
            return false;
        this.viewport = viewport;
        let startLen = this.skipped.length;
        for (let i = 0; i < this.skipped.length; i++) {
            let { from, to } = this.skipped[i];
            if (from < viewport.to && to > viewport.from) {
                this.fragments = cutFragments(this.fragments, from, to);
                this.skipped.splice(i--, 1);
            }
        }
        if (this.skipped.length >= startLen)
            return false;
        this.reset();
        return true;
    }
    /**
    @internal
    */
    reset() {
        if (this.parse) {
            this.takeTree();
            this.parse = null;
        }
    }
    /**
    Notify the parse scheduler that the given region was skipped
    because it wasn't in view, and the parse should be restarted
    when it comes into view.
    */
    skipUntilInView(from, to) {
        this.skipped.push({ from, to });
    }
    /**
    Returns a parser intended to be used as placeholder when
    asynchronously loading a nested parser. It'll skip its input and
    mark it as not-really-parsed, so that the next update will parse
    it again.
    
    When `until` is given, a reparse will be scheduled when that
    promise resolves.
    */
    static getSkippingParser(until) {
        return new class extends common.Parser {
            createParse(input, fragments, ranges) {
                let from = ranges[0].from, to = ranges[ranges.length - 1].to;
                let parser = {
                    parsedPos: from,
                    advance() {
                        let cx = currentContext;
                        if (cx) {
                            for (let r of ranges)
                                cx.tempSkipped.push(r);
                            if (until)
                                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                        }
                        this.parsedPos = to;
                        return new common.Tree(common.NodeType.none, [], [], to - from);
                    },
                    stoppedAt: null,
                    stopAt() { }
                };
                return parser;
            }
        };
    }
    /**
    @internal
    */
    isDone(upto) {
        upto = Math.min(upto, this.state.doc.length);
        let frags = this.fragments;
        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    /**
    Get the context for the current parse, or `null` if no editor
    parse is in progress.
    */
    static get() { return currentContext; }
}
function cutFragments(fragments, from, to) {
    return common.TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
class LanguageState {
    constructor(
    // A mutable parse state that is used to preserve work done during
    // the lifetime of a state when moving to the next state.
    context) {
        this.context = context;
        this.tree = context.tree;
    }
    apply(tr) {
        if (!tr.docChanged && this.tree == this.context.tree)
            return this;
        let newCx = this.context.changes(tr.changes, tr.state);
        // If the previous parse wasn't done, go forward only up to its
        // end position or the end of the viewport, to avoid slowing down
        // state updates with parse work beyond the viewport.
        let upto = this.context.treeLen == tr.startState.doc.length ? undefined
            : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
        if (!newCx.work(20 /* Work.Apply */, upto))
            newCx.takeTree();
        return new LanguageState(newCx);
    }
    static init(state) {
        let vpTo = Math.min(3000 /* Work.InitViewport */, state.doc.length);
        let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
        if (!parseState.work(20 /* Work.Apply */, vpTo))
            parseState.takeTree();
        return new LanguageState(parseState);
    }
}
Language.state = state.StateField.define({
    create: LanguageState.init,
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(Language.setState))
                return e.value;
        if (tr.startState.facet(language) != tr.state.facet(language))
            return LanguageState.init(tr.state);
        return value.apply(tr);
    }
});
let requestIdle = (callback) => {
    let timeout = setTimeout(() => callback(), 500 /* Work.MaxPause */);
    return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
        let idle = -1, timeout = setTimeout(() => {
            idle = requestIdleCallback(callback, { timeout: 500 /* Work.MaxPause */ - 100 /* Work.MinPause */ });
        }, 100 /* Work.MinPause */);
        return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending)
    ? () => navigator.scheduling.isInputPending() : null;
const parseWorker = view.ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
        this.view = view;
        this.working = null;
        this.workScheduled = 0;
        // End of the current time chunk
        this.chunkEnd = -1;
        // Milliseconds of budget left for this chunk
        this.chunkBudget = -1;
        this.work = this.work.bind(this);
        this.scheduleWork();
    }
    update(update) {
        let cx = this.view.state.field(Language.state).context;
        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
            this.scheduleWork();
        if (update.docChanged || update.selectionSet) {
            if (this.view.hasFocus)
                this.chunkBudget += 50 /* Work.ChangeBonus */;
            this.scheduleWork();
        }
        this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
        if (this.working)
            return;
        let { state } = this.view, field = state.field(Language.state);
        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
            this.working = requestIdle(this.work);
    }
    work(deadline) {
        this.working = null;
        let now = Date.now();
        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) { // Start a new chunk
            this.chunkEnd = now + 30000 /* Work.ChunkTime */;
            this.chunkBudget = 3000 /* Work.ChunkBudget */;
        }
        if (this.chunkBudget <= 0)
            return; // No more budget
        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */))
            return;
        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */, deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */, deadline.timeRemaining() - 5) : 1e9);
        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;
        let done = field.context.work(() => {
            return isInputPending && isInputPending() || Date.now() > endTime;
        }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */));
        this.chunkBudget -= Date.now() - now;
        if (done || this.chunkBudget <= 0) {
            field.context.takeTree();
            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
        }
        if (this.chunkBudget > 0 && !(done && !viewportFirst))
            this.scheduleWork();
        this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
        if (cx.scheduleOn) {
            this.workScheduled++;
            cx.scheduleOn
                .then(() => this.scheduleWork())
                .catch(err => view.logException(this.view.state, err))
                .then(() => this.workScheduled--);
            cx.scheduleOn = null;
        }
    }
    destroy() {
        if (this.working)
            this.working();
    }
    isWorking() {
        return !!(this.working || this.workScheduled > 0);
    }
}, {
    eventHandlers: { focus() { this.scheduleWork(); } }
});
/**
The facet used to associate a language with an editor state. Used
by `Language` object's `extension` property (so you don't need to
manually wrap your languages in this). Can be used to access the
current language on a state.
*/
const language = state.Facet.define({
    combine(languages) { return languages.length ? languages[0] : null; },
    enables: language => [
        Language.state,
        parseWorker,
        view.EditorView.contentAttributes.compute([language], state => {
            let lang = state.facet(language);
            return lang && lang.name ? { "data-language": lang.name } : {};
        })
    ]
});
/**
This class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an
optional set of supporting extensions. Language packages are
encouraged to export a function that optionally takes a
configuration object and returns a `LanguageSupport` instance, as
the main way for client code to use the package.
*/
class LanguageSupport {
    /**
    Create a language support object.
    */
    constructor(
    /**
    The language object.
    */
    language, 
    /**
    An optional set of supporting extensions. When nesting a
    language in another language, the outer language is encouraged
    to include the supporting extensions for its inner languages
    in its own set of support extensions.
    */
    support = []) {
        this.language = language;
        this.support = support;
        this.extension = [language, support];
    }
}
/**
Language descriptions are used to store metadata about languages
and to dynamically load them. Their main role is finding the
appropriate language for a filename or dynamically loading nested
parsers.
*/
class LanguageDescription {
    constructor(
    /**
    The name of this language.
    */
    name, 
    /**
    Alternative names for the mode (lowercased, includes `this.name`).
    */
    alias, 
    /**
    File extensions associated with this language.
    */
    extensions, 
    /**
    Optional filename pattern that should be associated with this
    language.
    */
    filename, loadFunc, 
    /**
    If the language has been loaded, this will hold its value.
    */
    support = undefined) {
        this.name = name;
        this.alias = alias;
        this.extensions = extensions;
        this.filename = filename;
        this.loadFunc = loadFunc;
        this.support = support;
        this.loading = null;
    }
    /**
    Start loading the the language. Will return a promise that
    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
    object when the language successfully loads.
    */
    load() {
        return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => { this.loading = null; throw err; }));
    }
    /**
    Create a language description.
    */
    static of(spec) {
        let { load, support } = spec;
        if (!load) {
            if (!support)
                throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
            load = () => Promise.resolve(support);
        }
        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);
    }
    /**
    Look for a language in the given array of descriptions that
    matches the filename. Will first match
    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
    and return the first language that matches.
    */
    static matchFilename(descs, filename) {
        for (let d of descs)
            if (d.filename && d.filename.test(filename))
                return d;
        let ext = /\.([^.]+)$/.exec(filename);
        if (ext)
            for (let d of descs)
                if (d.extensions.indexOf(ext[1]) > -1)
                    return d;
        return null;
    }
    /**
    Look for a language whose name or alias matches the the given
    name (case-insensitively). If `fuzzy` is true, and no direct
    matchs is found, this'll also search for a language whose name
    or alias occurs in the string (for names shorter than three
    characters, only when surrounded by non-word characters).
    */
    static matchLanguageName(descs, name, fuzzy = true) {
        name = name.toLowerCase();
        for (let d of descs)
            if (d.alias.some(a => a == name))
                return d;
        if (fuzzy)
            for (let d of descs)
                for (let a of d.alias) {
                    let found = name.indexOf(a);
                    if (found > -1 && (a.length > 2 || !/\w/.test(name[found - 1]) && !/\w/.test(name[found + a.length])))
                        return d;
                }
        return null;
    }
}

/**
Facet that defines a way to provide a function that computes the
appropriate indentation depth, as a column number (see
[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given
line. A return value of `null` indicates no indentation can be
determined, and the line should inherit the indentation of the one
above it. A return value of `undefined` defers to the next indent
service.
*/
const indentService = state.Facet.define();
/**
Facet for overriding the unit by which indentation happens. Should
be a string consisting either entirely of the same whitespace
character. When not set, this defaults to 2 spaces.
*/
const indentUnit = state.Facet.define({
    combine: values => {
        if (!values.length)
            return "  ";
        let unit = values[0];
        if (!unit || /\S/.test(unit) || Array.from(unit).some(e => e != unit[0]))
            throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
        return unit;
    }
});
/**
Return the _column width_ of an indent unit in the state.
Determined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)
facet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that
contains tabs.
*/
function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
/**
Create an indentation string that covers columns 0 to `cols`.
Will use tabs for as much of the columns as possible when the
[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains
tabs.
*/
function indentString(state, cols) {
    let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
    if (ch == "\t") {
        while (cols >= ts) {
            result += "\t";
            cols -= ts;
        }
        ch = " ";
    }
    for (let i = 0; i < cols; i++)
        result += ch;
    return result;
}
/**
Get the indentation, as a column number, at the given position.
Will first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)
that are registered, and if none of those return an indentation,
this will check the syntax tree for the [indent node
prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a
number when an indentation could be determined, and null
otherwise.
*/
function getIndentation(context, pos) {
    if (context instanceof state.EditorState)
        context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
        let result = service(context, pos);
        if (result !== undefined)
            return result;
    }
    let tree = syntaxTree(context.state);
    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
/**
Create a change set that auto-indents all lines touched by the
given document range.
*/
function indentRange(state, from, to) {
    let updated = Object.create(null);
    let context = new IndentContext(state, { overrideIndentation: start => { var _a; return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1; } });
    let changes = [];
    for (let pos = from; pos <= to;) {
        let line = state.doc.lineAt(pos);
        pos = line.to + 1;
        let indent = getIndentation(context, line.from);
        if (indent == null)
            continue;
        if (!/\S/.test(line.text))
            indent = 0;
        let cur = /^\s*/.exec(line.text)[0];
        let norm = indentString(state, indent);
        if (cur != norm) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
    }
    return state.changes(changes);
}
/**
Indentation contexts are used when calling [indentation
services](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities
useful in indentation logic, and can selectively override the
indentation reported for some lines.
*/
class IndentContext {
    /**
    Create an indent context.
    */
    constructor(
    /**
    The editor state.
    */
    state, 
    /**
    @internal
    */
    options = {}) {
        this.state = state;
        this.options = options;
        this.unit = getIndentUnit(state);
    }
    /**
    Get a description of the line at the given position, taking
    [simulated line
    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    into account. If there is such a break at `pos`, the `bias`
    argument determines whether the part of the line line before or
    after the break is used.
    */
    lineAt(pos, bias = 1) {
        let line = this.state.doc.lineAt(pos);
        let { simulateBreak, simulateDoubleBreak } = this.options;
        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
            if (simulateDoubleBreak && simulateBreak == pos)
                return { text: "", from: pos };
            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
                return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
            else
                return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
        }
        return line;
    }
    /**
    Get the text directly after `pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    textAfterPos(pos, bias = 1) {
        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
            return "";
        let { text, from } = this.lineAt(pos, bias);
        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    /**
    Find the column for the given position.
    */
    column(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias);
        let result = this.countColumn(text, pos - from);
        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
        if (override > -1)
            result += override - this.countColumn(text, text.search(/\S|$/));
        return result;
    }
    /**
    Find the column position (taking tabs into account) of the given
    position in the given string.
    */
    countColumn(line, pos = line.length) {
        return state.countColumn(line, this.state.tabSize, pos);
    }
    /**
    Find the indentation column of the line at the given point.
    */
    lineIndent(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias);
        let override = this.options.overrideIndentation;
        if (override) {
            let overriden = override(from);
            if (overriden > -1)
                return overriden;
        }
        return this.countColumn(text, text.search(/\S|$/));
    }
    /**
    Returns the [simulated line
    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    for this context, if any.
    */
    get simulatedBreak() {
        return this.options.simulateBreak || null;
    }
}
/**
A syntax tree node prop used to associate indentation strategies
with node types. Such a strategy is a function from an indentation
context to a column number (see also
[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null
indicates that no definitive indentation can be determined.
*/
const indentNodeProp = new common.NodeProp();
// Compute the indentation for a given position from the syntax tree.
function syntaxIndentation(cx, ast, pos) {
    let stack = ast.resolveStack(pos);
    let inner = stack.node.enterUnfinishedNodesBefore(pos);
    if (inner != stack.node) {
        let add = [];
        for (let cur = inner; cur != stack.node; cur = cur.parent)
            add.push(cur);
        for (let i = add.length - 1; i >= 0; i--)
            stack = { node: add[i], next: stack };
    }
    return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
    for (let cur = stack; cur; cur = cur.next) {
        let strategy = indentStrategy(cur.node);
        if (strategy)
            return strategy(TreeIndentContext.create(cx, pos, cur));
    }
    return 0;
}
function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
        return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(common.NodeProp.closedBy))) {
        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);
    }
    return tree.parent == null ? topIndent : null;
}
function topIndent() { return 0; }
/**
Objects of this type provide context information and helper
methods to indentation functions registered on syntax nodes.
*/
class TreeIndentContext extends IndentContext {
    constructor(base, 
    /**
    The position at which indentation is being computed.
    */
    pos, 
    /**
    @internal
    */
    context) {
        super(base.state, base.options);
        this.base = base;
        this.pos = pos;
        this.context = context;
    }
    /**
    The syntax tree node to which the indentation strategy
    applies.
    */
    get node() { return this.context.node; }
    /**
    @internal
    */
    static create(base, pos, context) {
        return new TreeIndentContext(base, pos, context);
    }
    /**
    Get the text directly after `this.pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    get textAfter() {
        return this.textAfterPos(this.pos);
    }
    /**
    Get the indentation at the reference line for `this.node`, which
    is the line on which it starts, unless there is a node that is
    _not_ a parent of this node covering the start of that line. If
    so, the line at the start of that node is tried, again skipping
    on if it is covered by another such node.
    */
    get baseIndent() {
        return this.baseIndentFor(this.node);
    }
    /**
    Get the indentation for the reference line of the given node
    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
    */
    baseIndentFor(node) {
        let line = this.state.doc.lineAt(node.from);
        // Skip line starts that are covered by a sibling (or cousin, etc)
        for (;;) {
            let atBreak = node.resolve(line.from);
            while (atBreak.parent && atBreak.parent.from == atBreak.from)
                atBreak = atBreak.parent;
            if (isParent(atBreak, node))
                break;
            line = this.state.doc.lineAt(atBreak.from);
        }
        return this.lineIndent(line.from);
    }
    /**
    Continue looking for indentations in the node's parent nodes,
    and return the result of that.
    */
    continue() {
        return indentFor(this.context.next, this.base, this.pos);
    }
}
function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
        if (parent == cur)
            return true;
    return false;
}
// Check whether a delimited node is aligned (meaning there are
// non-skipped nodes on the same line as the opening delimiter). And
// if so, return the opening token.
function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken)
        return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to;;) {
        let next = tree.childAfter(pos);
        if (!next || next == last)
            return null;
        if (!next.type.isSkipped) {
            if (next.from >= lineEnd)
                return null;
            let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
            return { from: openToken.from, to: openToken.to + space };
        }
        pos = next.to;
    }
}
/**
An indentation strategy for delimited (usually bracketed) nodes.
Will, by default, indent one unit more than the parent's base
indent unless the line starts with a closing token. When `align`
is true and there are non-skipped nodes on the node's opening
line, the content of the node will be aligned with the end of the
opening node, like this:

    foo(bar,
        baz)
*/
function delimitedIndent({ closing, align = true, units = 1 }) {
    return (context) => delimitedStrategy(context, align, units, closing);
}
function delimitedStrategy(context, align, units, closing, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
        return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
}
/**
An indentation strategy that aligns a node's content to its base
indentation.
*/
const flatIndent = (context) => context.baseIndent;
/**
Creates an indentation strategy that, by default, indents
continued lines one unit more than the node's base indentation.
You can provide `except` to prevent indentation of lines that
match a pattern (for example `/^else\b/` in `if`/`else`
constructs), and you can change the amount of units used with the
`units` option.
*/
function continuedIndent({ except, units = 1 } = {}) {
    return (context) => {
        let matchExcept = except && except.test(context.textAfter);
        return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
}
const DontIndentBeyond = 200;
/**
Enables reindentation on input. When a language defines an
`indentOnInput` field in its [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular
expression, the line at the cursor will be reindented whenever new
text is typed and the input from the start of the line up to the
cursor matches that regexp.

To avoid unneccesary reindents, it is recommended to start the
regexp with `^` (usually followed by `\s*`), and end it with `$`.
For example, `/^\s*\}$/` will reindent when a closing brace is
added at the start of a line.
*/
function indentOnInput() {
    return state.EditorState.transactionFilter.of(tr => {
        if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
            return tr;
        let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
        if (!rules.length)
            return tr;
        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);
        if (head > line.from + DontIndentBeyond)
            return tr;
        let lineStart = doc.sliceString(line.from, head);
        if (!rules.some(r => r.test(lineStart)))
            return tr;
        let { state } = tr, last = -1, changes = [];
        for (let { head } of state.selection.ranges) {
            let line = state.doc.lineAt(head);
            if (line.from == last)
                continue;
            last = line.from;
            let indent = getIndentation(state, line.from);
            if (indent == null)
                continue;
            let cur = /^\s*/.exec(line.text)[0];
            let norm = indentString(state, indent);
            if (cur != norm)
                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
        return changes.length ? [tr, { changes, sequential: true }] : tr;
    });
}

/**
A facet that registers a code folding service. When called with
the extent of a line, such a function should return a foldable
range that starts on that line (but continues beyond it), if one
can be found.
*/
const foldService = state.Facet.define();
/**
This node prop is used to associate folding information with
syntax node types. Given a syntax node, it should check whether
that tree is foldable and return the range that can be collapsed
when it is.
*/
const foldNodeProp = new common.NodeProp();
/**
[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but
the first and the last child of a syntax node. Useful for nodes
that start and end with delimiters.
*/
function foldInside(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
}
function syntaxFolding(state, start, end) {
    let tree = syntaxTree(state);
    if (tree.length < end)
        return null;
    let stack = tree.resolveStack(end, 1);
    let found = null;
    for (let iter = stack; iter; iter = iter.next) {
        let cur = iter.node;
        if (cur.to <= end || cur.from > end)
            continue;
        if (found && cur.from < start)
            break;
        let prop = cur.type.prop(foldNodeProp);
        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {
            let value = prop(cur, state);
            if (value && value.from <= end && value.from >= start && value.to > end)
                found = value;
        }
    }
    return found;
}
function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
}
/**
Check whether the given line is foldable. First asks any fold
services registered through
[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return
a result, tries to query the [fold node
prop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end
of the line.
*/
function foldable(state, lineStart, lineEnd) {
    for (let service of state.facet(foldService)) {
        let result = service(state, lineStart, lineEnd);
        if (result)
            return result;
    }
    return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range, mapping) {
    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from >= to ? undefined : { from, to };
}
/**
State effect that can be attached to a transaction to fold the
given range. (You probably only need this in exceptional
circumstances—usually you'll just want to let
[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold
gutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)
*/
const foldEffect = state.StateEffect.define({ map: mapRange });
/**
State effect that unfolds the given range (if it was folded).
*/
const unfoldEffect = state.StateEffect.define({ map: mapRange });
function selectedLines(view) {
    let lines = [];
    for (let { head } of view.state.selection.ranges) {
        if (lines.some(l => l.from <= head && l.to >= head))
            continue;
        lines.push(view.lineBlockAt(head));
    }
    return lines;
}
/**
The state field that stores the folded ranges (as a [decoration
set](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to
[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and
[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold
state.
*/
const foldState = state.StateField.define({
    create() {
        return view.Decoration.none;
    },
    update(folded, tr) {
        folded = folded.map(tr.changes);
        for (let e of tr.effects) {
            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
                let { preparePlaceholder } = tr.state.facet(foldConfig);
                let widget = !preparePlaceholder ? foldWidget :
                    view.Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value)) });
                folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });
            }
            else if (e.is(unfoldEffect)) {
                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,
                    filterFrom: e.value.from, filterTo: e.value.to });
            }
        }
        // Clear folded ranges that cover the selection head
        if (tr.selection) {
            let onSelection = false, { head } = tr.selection.main;
            folded.between(head, head, (a, b) => { if (a < head && b > head)
                onSelection = true; });
            if (onSelection)
                folded = folded.update({
                    filterFrom: head,
                    filterTo: head,
                    filter: (a, b) => b <= head || a >= head
                });
        }
        return folded;
    },
    provide: f => view.EditorView.decorations.from(f),
    toJSON(folded, state) {
        let ranges = [];
        folded.between(0, state.doc.length, (from, to) => { ranges.push(from, to); });
        return ranges;
    },
    fromJSON(value) {
        if (!Array.isArray(value) || value.length % 2)
            throw new RangeError("Invalid JSON for fold state");
        let ranges = [];
        for (let i = 0; i < value.length;) {
            let from = value[i++], to = value[i++];
            if (typeof from != "number" || typeof to != "number")
                throw new RangeError("Invalid JSON for fold state");
            ranges.push(foldWidget.range(from, to));
        }
        return view.Decoration.set(ranges, true);
    }
});
/**
Get a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges
in the given state.
*/
function foldedRanges(state$1) {
    return state$1.field(foldState, false) || state.RangeSet.empty;
}
function findFold(state, from, to) {
    var _a;
    let found = null;
    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {
        if (!found || found.from > from)
            found = { from, to };
    });
    return found;
}
function foldExists(folded, from, to) {
    let found = false;
    folded.between(from, from, (a, b) => { if (a == from && b == to)
        found = true; });
    return found;
}
function maybeEnable(state$1, other) {
    return state$1.field(foldState, false) ? other : other.concat(state.StateEffect.appendConfig.of(codeFolding()));
}
/**
Fold the lines that are selected, if possible.
*/
const foldCode = view => {
    for (let line of selectedLines(view)) {
        let range = foldable(view.state, line.from, line.to);
        if (range) {
            view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
            return true;
        }
    }
    return false;
};
/**
Unfold folded ranges on selected lines.
*/
const unfoldCode = view => {
    if (!view.state.field(foldState, false))
        return false;
    let effects = [];
    for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length)
        view.dispatch({ effects });
    return effects.length > 0;
};
function announceFold(view$1, range, fold = true) {
    let lineFrom = view$1.state.doc.lineAt(range.from).number, lineTo = view$1.state.doc.lineAt(range.to).number;
    return view.EditorView.announce.of(`${view$1.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view$1.state.phrase("to")} ${lineTo}.`);
}
/**
Fold all top-level foldable ranges. Note that, in most cases,
folding information will depend on the [syntax
tree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work
reliably when the document hasn't been fully parsed (either
because the editor state was only just initialized, or because the
document is so big that the parser decided not to parse it
entirely).
*/
const foldAll = view => {
    let { state } = view, effects = [];
    for (let pos = 0; pos < state.doc.length;) {
        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
        if (range)
            effects.push(foldEffect.of(range));
        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
    }
    if (effects.length)
        view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
};
/**
Unfold all folded code.
*/
const unfoldAll = view => {
    let field = view.state.field(foldState, false);
    if (!field || !field.size)
        return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });
    view.dispatch({ effects });
    return true;
};
// Find the foldable region containing the given line, if one exists
function foldableContainer(view, lineBlock) {
    // Look backwards through line blocks until we find a foldable region that
    // intersects with the line
    for (let line = lineBlock;;) {
        let foldableRegion = foldable(view.state, line.from, line.to);
        if (foldableRegion && foldableRegion.to > lineBlock.from)
            return foldableRegion;
        if (!line.from)
            return null;
        line = view.lineBlockAt(line.from - 1);
    }
}
/**
Toggle folding at cursors. Unfolds if there is an existing fold
starting in that line, tries to find a foldable range around it
otherwise.
*/
const toggleFold = (view) => {
    let effects = [];
    for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to);
        if (folded) {
            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
        }
        else {
            let foldRange = foldableContainer(view, line);
            if (foldRange)
                effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));
        }
    }
    if (effects.length > 0)
        view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
};
/**
Default fold-related key bindings.

 - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).
 - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).
 - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).
 - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).
*/
const foldKeymap = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
    { key: "Ctrl-Alt-[", run: foldAll },
    { key: "Ctrl-Alt-]", run: unfoldAll }
];
const defaultConfig = {
    placeholderDOM: null,
    preparePlaceholder: null,
    placeholderText: "…"
};
const foldConfig = state.Facet.define({
    combine(values) { return state.combineConfig(values, defaultConfig); }
});
/**
Create an extension that configures code folding.
*/
function codeFolding(config) {
    let result = [foldState, baseTheme$1];
    if (config)
        result.push(foldConfig.of(config));
    return result;
}
function widgetToDOM(view, prepared) {
    let { state } = view, conf = state.facet(foldConfig);
    let onclick = (event) => {
        let line = view.lineBlockAt(view.posAtDOM(event.target));
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
            view.dispatch({ effects: unfoldEffect.of(folded) });
        event.preventDefault();
    };
    if (conf.placeholderDOM)
        return conf.placeholderDOM(view, onclick, prepared);
    let element = document.createElement("span");
    element.textContent = conf.placeholderText;
    element.setAttribute("aria-label", state.phrase("folded code"));
    element.title = state.phrase("unfold");
    element.className = "cm-foldPlaceholder";
    element.onclick = onclick;
    return element;
}
const foldWidget = view.Decoration.replace({ widget: new class extends view.WidgetType {
        toDOM(view) { return widgetToDOM(view, null); }
    } });
class PreparedFoldWidget extends view.WidgetType {
    constructor(value) {
        super();
        this.value = value;
    }
    eq(other) { return this.value == other.value; }
    toDOM(view) { return widgetToDOM(view, this.value); }
}
const foldGutterDefaults = {
    openText: "⌄",
    closedText: "›",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
};
class FoldMarker extends view.GutterMarker {
    constructor(config, open) {
        super();
        this.config = config;
        this.open = open;
    }
    eq(other) { return this.config == other.config && this.open == other.open; }
    toDOM(view) {
        if (this.config.markerDOM)
            return this.config.markerDOM(this.open);
        let span = document.createElement("span");
        span.textContent = this.open ? this.config.openText : this.config.closedText;
        span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
        return span;
    }
}
/**
Create an extension that registers a fold gutter, which shows a
fold status indicator before foldable lines (which can be clicked
to fold or unfold the line).
*/
function foldGutter(config = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = view.ViewPlugin.fromClass(class {
        constructor(view) {
            this.from = view.viewport.from;
            this.markers = this.buildMarkers(view);
        }
        update(update) {
            if (update.docChanged || update.viewportChanged ||
                update.startState.facet(language) != update.state.facet(language) ||
                update.startState.field(foldState, false) != update.state.field(foldState, false) ||
                syntaxTree(update.startState) != syntaxTree(update.state) ||
                fullConfig.foldingChanged(update))
                this.markers = this.buildMarkers(update.view);
        }
        buildMarkers(view) {
            let builder = new state.RangeSetBuilder();
            for (let line of view.viewportLineBlocks) {
                let mark = findFold(view.state, line.from, line.to) ? canUnfold
                    : foldable(view.state, line.from, line.to) ? canFold : null;
                if (mark)
                    builder.add(line.from, line.from, mark);
            }
            return builder.finish();
        }
    });
    let { domEventHandlers } = fullConfig;
    return [
        markers,
        view.gutter({
            class: "cm-foldGutter",
            markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || state.RangeSet.empty; },
            initialSpacer() {
                return new FoldMarker(fullConfig, false);
            },
            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {
                    if (domEventHandlers.click && domEventHandlers.click(view, line, event))
                        return true;
                    let folded = findFold(view.state, line.from, line.to);
                    if (folded) {
                        view.dispatch({ effects: unfoldEffect.of(folded) });
                        return true;
                    }
                    let range = foldable(view.state, line.from, line.to);
                    if (range) {
                        view.dispatch({ effects: foldEffect.of(range) });
                        return true;
                    }
                    return false;
                } })
        }),
        codeFolding()
    ];
}
const baseTheme$1 = view.EditorView.baseTheme({
    ".cm-foldPlaceholder": {
        backgroundColor: "#eee",
        border: "1px solid #ddd",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
    },
    ".cm-foldGutter span": {
        padding: "0 1px",
        cursor: "pointer"
    }
});

/**
A highlight style associates CSS styles with higlighting
[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).
*/
class HighlightStyle {
    constructor(
    /**
    The tag styles used to create this highlight style.
    */
    specs, options) {
        this.specs = specs;
        let modSpec;
        function def(spec) {
            let cls = styleMod.StyleModule.newName();
            (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
            return cls;
        }
        const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : undefined;
        const scopeOpt = options.scope;
        this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data
            : scopeOpt ? (type) => type == scopeOpt : undefined;
        this.style = highlight.tagHighlighter(specs.map(style => ({
            tag: style.tag,
            class: style.class || def(Object.assign({}, style, { tag: null }))
        })), {
            all,
        }).style;
        this.module = modSpec ? new styleMod.StyleModule(modSpec) : null;
        this.themeType = options.themeType;
    }
    /**
    Create a highlighter style that associates the given styles to
    the given tags. The specs must be objects that hold a style tag
    or array of tags in their `tag` property, and either a single
    `class` property providing a static CSS class (for highlighter
    that rely on external styling), or a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
    set of CSS properties (which define the styling for those tags).
    
    The CSS rules created for a highlighter will be emitted in the
    order of the spec's properties. That means that for elements that
    have multiple tags associated with them, styles defined further
    down in the list will have a higher CSS precedence than styles
    defined earlier.
    */
    static define(specs, options) {
        return new HighlightStyle(specs, options || {});
    }
}
const highlighterFacet = state.Facet.define();
const fallbackHighlighter = state.Facet.define({
    combine(values) { return values.length ? [values[0]] : null; }
});
function getHighlighters(state) {
    let main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
}
/**
Wrap a highlighter in an editor extension that uses it to apply
syntax highlighting to the editor content.

When multiple (non-fallback) styles are provided, the styling
applied is the union of the classes they emit.
*/
function syntaxHighlighting(highlighter, options) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
        if (highlighter.module)
            ext.push(view.EditorView.styleModule.of(highlighter.module));
        themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback)
        ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
        ext.push(highlighterFacet.computeN([view.EditorView.darkTheme], state => {
            return state.facet(view.EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
        }));
    else
        ext.push(highlighterFacet.of(highlighter));
    return ext;
}
/**
Returns the CSS classes (if any) that the highlighters active in
the state would assign to the given style
[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and
(optional) language
[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).
*/
function highlightingFor(state, tags, scope) {
    let highlighters = getHighlighters(state);
    let result = null;
    if (highlighters)
        for (let highlighter of highlighters) {
            if (!highlighter.scope || scope && highlighter.scope(scope)) {
                let cls = highlighter.style(tags);
                if (cls)
                    result = result ? result + " " + cls : cls;
            }
        }
    return result;
}
class TreeHighlighter {
    constructor(view) {
        this.markCache = Object.create(null);
        this.tree = syntaxTree(view.state);
        this.decorations = this.buildDeco(view, getHighlighters(view.state));
        this.decoratedTo = view.viewport.to;
    }
    update(update) {
        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
        let styleChange = highlighters != getHighlighters(update.startState);
        let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
        if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
            this.decorations = this.decorations.map(update.changes);
            this.decoratedTo = decoratedToMapped;
        }
        else if (tree != this.tree || update.viewportChanged || styleChange) {
            this.tree = tree;
            this.decorations = this.buildDeco(update.view, highlighters);
            this.decoratedTo = viewport.to;
        }
    }
    buildDeco(view$1, highlighters) {
        if (!highlighters || !this.tree.length)
            return view.Decoration.none;
        let builder = new state.RangeSetBuilder();
        for (let { from, to } of view$1.visibleRanges) {
            highlight.highlightTree(this.tree, highlighters, (from, to, style) => {
                builder.add(from, to, this.markCache[style] || (this.markCache[style] = view.Decoration.mark({ class: style })));
            }, from, to);
        }
        return builder.finish();
    }
}
const treeHighlighter = state.Prec.high(view.ViewPlugin.fromClass(TreeHighlighter, {
    decorations: v => v.decorations
}));
/**
A default highlight style (works well with light themes).
*/
const defaultHighlightStyle = HighlightStyle.define([
    { tag: highlight.tags.meta,
        color: "#404740" },
    { tag: highlight.tags.link,
        textDecoration: "underline" },
    { tag: highlight.tags.heading,
        textDecoration: "underline",
        fontWeight: "bold" },
    { tag: highlight.tags.emphasis,
        fontStyle: "italic" },
    { tag: highlight.tags.strong,
        fontWeight: "bold" },
    { tag: highlight.tags.strikethrough,
        textDecoration: "line-through" },
    { tag: highlight.tags.keyword,
        color: "#708" },
    { tag: [highlight.tags.atom, highlight.tags.bool, highlight.tags.url, highlight.tags.contentSeparator, highlight.tags.labelName],
        color: "#219" },
    { tag: [highlight.tags.literal, highlight.tags.inserted],
        color: "#164" },
    { tag: [highlight.tags.string, highlight.tags.deleted],
        color: "#a11" },
    { tag: [highlight.tags.regexp, highlight.tags.escape, highlight.tags.special(highlight.tags.string)],
        color: "#e40" },
    { tag: highlight.tags.definition(highlight.tags.variableName),
        color: "#00f" },
    { tag: highlight.tags.local(highlight.tags.variableName),
        color: "#30a" },
    { tag: [highlight.tags.typeName, highlight.tags.namespace],
        color: "#085" },
    { tag: highlight.tags.className,
        color: "#167" },
    { tag: [highlight.tags.special(highlight.tags.variableName), highlight.tags.macroName],
        color: "#256" },
    { tag: highlight.tags.definition(highlight.tags.propertyName),
        color: "#00c" },
    { tag: highlight.tags.comment,
        color: "#940" },
    { tag: highlight.tags.invalid,
        color: "#f00" }
]);

const baseTheme = view.EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
const DefaultScanDist = 10000, DefaultBrackets = "()[]{}";
const bracketMatchingConfig = state.Facet.define({
    combine(configs) {
        return state.combineConfig(configs, {
            afterCursor: true,
            brackets: DefaultBrackets,
            maxScanDistance: DefaultScanDist,
            renderMatch: defaultRenderMatch
        });
    }
});
const matchingMark = view.Decoration.mark({ class: "cm-matchingBracket" }), nonmatchingMark = view.Decoration.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match) {
    let decorations = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations.push(mark.range(match.start.from, match.start.to));
    if (match.end)
        decorations.push(mark.range(match.end.from, match.end.to));
    return decorations;
}
const bracketMatchingState = state.StateField.define({
    create() { return view.Decoration.none; },
    update(deco, tr) {
        if (!tr.docChanged && !tr.selection)
            return deco;
        let decorations = [];
        let config = tr.state.facet(bracketMatchingConfig);
        for (let range of tr.state.selection.ranges) {
            if (!range.empty)
                continue;
            let match = matchBrackets(tr.state, range.head, -1, config)
                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))
                || (config.afterCursor &&
                    (matchBrackets(tr.state, range.head, 1, config) ||
                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));
            if (match)
                decorations = decorations.concat(config.renderMatch(match, tr.state));
        }
        return view.Decoration.set(decorations, true);
    },
    provide: f => view.EditorView.decorations.from(f)
});
const bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme
];
/**
Create an extension that enables bracket matching. Whenever the
cursor is next to a bracket, that bracket and the one it matches
are highlighted. Or, when no matching bracket is found, another
highlighting style is used to indicate this.
*/
function bracketMatching(config = {}) {
    return [bracketMatchingConfig.of(config), bracketMatchingUnique];
}
/**
When larger syntax nodes, such as HTML tags, are marked as
opening/closing, it can be a bit messy to treat the whole node as
a matchable bracket. This node prop allows you to define, for such
a node, a ‘handle’—the part of the node that is highlighted, and
that the cursor must be on to activate highlighting in the first
place.
*/
const bracketMatchingHandle = new common.NodeProp();
function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? common.NodeProp.openedBy : common.NodeProp.closedBy);
    if (byProp)
        return byProp;
    if (node.name.length == 1) {
        let index = brackets.indexOf(node.name);
        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
            return [brackets[index + dir]];
    }
    return null;
}
function findHandle(node) {
    let hasHandle = node.type.prop(bracketMatchingHandle);
    return hasHandle ? hasHandle(node.node) : node;
}
/**
Find the matching bracket for the token at `pos`, scanning
direction `dir`. Only the `brackets` and `maxScanDistance`
properties are used from `config`, if given. Returns null if no
bracket was found at `pos`, or a match result otherwise.
*/
function matchBrackets(state, pos, dir, config = {}) {
    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur = node; cur; cur = cur.parent) {
        let matches = matchingNodes(cur.type, dir, brackets);
        if (matches && cur.from < cur.to) {
            let handle = findHandle(cur);
            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
                return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);
        }
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
    let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
        do {
            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
                if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
                    let endHandle = findHandle(cursor);
                    return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : undefined, matched: true };
                }
                else if (matchingNodes(cursor.type, dir, brackets)) {
                    depth++;
                }
                else if (matchingNodes(cursor.type, -dir, brackets)) {
                    if (depth == 0) {
                        let endHandle = findHandle(cursor);
                        return {
                            start: firstToken,
                            end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : undefined,
                            matched: false
                        };
                    }
                    depth--;
                }
            }
        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket = brackets.indexOf(startCh);
    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))
        return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {
        let text = iter.value;
        if (dir < 0)
            distance += text.length;
        let basePos = pos + distance * dir;
        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {
            let found = brackets.indexOf(text[pos]);
            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType)
                continue;
            if ((found % 2 == 0) == (dir > 0)) {
                depth++;
            }
            else if (depth == 1) { // Closing
                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };
            }
            else {
                depth--;
            }
        }
        if (dir > 0)
            distance += text.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
}

// Counts the column offset in a string, taking tabs into account.
// Used mostly to find indentation.
function countCol(string, end, tabSize, startIndex = 0, startValue = 0) {
    if (end == null) {
        end = string.search(/[^\s\u00a0]/);
        if (end == -1)
            end = string.length;
    }
    let n = startValue;
    for (let i = startIndex; i < end; i++) {
        if (string.charCodeAt(i) == 9)
            n += tabSize - (n % tabSize);
        else
            n++;
    }
    return n;
}
/**
Encapsulates a single line of input. Given to stream syntax code,
which uses it to tokenize the content.
*/
class StringStream {
    /**
    Create a stream.
    */
    constructor(
    /**
    The line.
    */
    string, tabSize, 
    /**
    The current indent unit size.
    */
    indentUnit, overrideIndent) {
        this.string = string;
        this.tabSize = tabSize;
        this.indentUnit = indentUnit;
        this.overrideIndent = overrideIndent;
        /**
        The current position on the line.
        */
        this.pos = 0;
        /**
        The start position of the current token.
        */
        this.start = 0;
        this.lastColumnPos = 0;
        this.lastColumnValue = 0;
    }
    /**
    True if we are at the end of the line.
    */
    eol() { return this.pos >= this.string.length; }
    /**
    True if we are at the start of the line.
    */
    sol() { return this.pos == 0; }
    /**
    Get the next code unit after the current position, or undefined
    if we're at the end of the line.
    */
    peek() { return this.string.charAt(this.pos) || undefined; }
    /**
    Read the next code unit and advance `this.pos`.
    */
    next() {
        if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
    }
    /**
    Match the next character against the given string, regular
    expression, or predicate. Consume and return it if it matches.
    */
    eat(match) {
        let ch = this.string.charAt(this.pos);
        let ok;
        if (typeof match == "string")
            ok = ch == match;
        else
            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));
        if (ok) {
            ++this.pos;
            return ch;
        }
    }
    /**
    Continue matching characters that match the given string,
    regular expression, or predicate function. Return true if any
    characters were consumed.
    */
    eatWhile(match) {
        let start = this.pos;
        while (this.eat(match)) { }
        return this.pos > start;
    }
    /**
    Consume whitespace ahead of `this.pos`. Return true if any was
    found.
    */
    eatSpace() {
        let start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
        return this.pos > start;
    }
    /**
    Move to the end of the line.
    */
    skipToEnd() { this.pos = this.string.length; }
    /**
    Move to directly before the given character, if found on the
    current line.
    */
    skipTo(ch) {
        let found = this.string.indexOf(ch, this.pos);
        if (found > -1) {
            this.pos = found;
            return true;
        }
    }
    /**
    Move back `n` characters.
    */
    backUp(n) { this.pos -= n; }
    /**
    Get the column position at `this.pos`.
    */
    column() {
        if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
        }
        return this.lastColumnValue;
    }
    /**
    Get the indentation column of the current line.
    */
    indentation() {
        var _a;
        return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);
    }
    /**
    Match the input against the given string or regular expression
    (which should start with a `^`). Return true or the regexp match
    if it matches.
    
    Unless `consume` is set to `false`, this will move `this.pos`
    past the matched text.
    
    When matching a string `caseInsensitive` can be set to true to
    make the match case-insensitive.
    */
    match(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;
            let substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
                if (consume !== false)
                    this.pos += pattern.length;
                return true;
            }
            else
                return null;
        }
        else {
            let match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0)
                return null;
            if (match && consume !== false)
                this.pos += match[0].length;
            return match;
        }
    }
    /**
    Get the current token.
    */
    current() { return this.string.slice(this.start, this.pos); }
}

function fullParser(spec) {
    return {
        name: spec.name || "",
        token: spec.token,
        blankLine: spec.blankLine || (() => { }),
        startState: spec.startState || (() => true),
        copyState: spec.copyState || defaultCopyState,
        indent: spec.indent || (() => null),
        languageData: spec.languageData || {},
        tokenTable: spec.tokenTable || noTokens
    };
}
function defaultCopyState(state) {
    if (typeof state != "object")
        return state;
    let newState = {};
    for (let prop in state) {
        let val = state[prop];
        newState[prop] = (val instanceof Array ? val.slice() : val);
    }
    return newState;
}
const IndentedFrom = new WeakMap();
/**
A [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror
5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).
*/
class StreamLanguage extends Language {
    constructor(parser) {
        let data = defineLanguageFacet(parser.languageData);
        let p = fullParser(parser), self;
        let impl = new class extends common.Parser {
            createParse(input, fragments, ranges) {
                return new Parse(self, input, fragments, ranges);
            }
        };
        super(data, impl, [], parser.name);
        this.topNode = docID(data, this);
        self = this;
        this.streamParser = p;
        this.stateAfter = new common.NodeProp({ perNode: true });
        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;
    }
    /**
    Define a stream language.
    */
    static define(spec) { return new StreamLanguage(spec); }
    /**
    @internal
    */
    getIndent(cx) {
        let from = undefined;
        let { overrideIndentation } = cx.options;
        if (overrideIndentation) {
            from = IndentedFrom.get(cx.state);
            if (from != null && from < cx.pos - 1e4)
                from = undefined;
        }
        let start = findState(this, cx.node.tree, 0, cx.node.from, from !== null && from !== void 0 ? from : cx.pos), statePos, state;
        if (start) {
            state = start.state;
            statePos = start.pos + 1;
        }
        else {
            state = this.streamParser.startState(cx.unit);
            statePos = 0;
        }
        if (cx.pos - statePos > 10000 /* C.MaxIndentScanDist */)
            return null;
        while (statePos < cx.pos) {
            let line = cx.state.doc.lineAt(statePos), end = Math.min(cx.pos, line.to);
            if (line.length) {
                let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;
                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);
                while (stream.pos < end - line.from)
                    readToken(this.streamParser.token, stream, state);
            }
            else {
                this.streamParser.blankLine(state, cx.unit);
            }
            if (end == cx.pos)
                break;
            statePos = line.to + 1;
        }
        let line = cx.lineAt(cx.pos);
        if (overrideIndentation && from == null)
            IndentedFrom.set(cx.state, line.from);
        return this.streamParser.indent(state, /^\s*(.*)/.exec(line.text)[1], cx);
    }
    get allowsNesting() { return false; }
}
function findState(lang, tree, off, startPos, before) {
    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);
    if (state)
        return { state: lang.streamParser.copyState(state), pos: off + tree.length };
    for (let i = tree.children.length - 1; i >= 0; i--) {
        let child = tree.children[i], pos = off + tree.positions[i];
        let found = child instanceof common.Tree && pos < before && findState(lang, child, pos, startPos, before);
        if (found)
            return found;
    }
    return null;
}
function cutTree(lang, tree, from, to, inside) {
    if (inside && from <= 0 && to >= tree.length)
        return tree;
    if (!inside && from == 0 && tree.type == lang.topNode)
        inside = true;
    for (let i = tree.children.length - 1; i >= 0; i--) {
        let pos = tree.positions[i], child = tree.children[i], inner;
        if (pos < to && child instanceof common.Tree) {
            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))
                break;
            return !inside ? inner
                : new common.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);
        }
    }
    return null;
}
function findStartInFragments(lang, fragments, startPos, endPos, editorState) {
    for (let f of fragments) {
        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);
        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;
        if (found && found.pos <= endPos && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))
            return { state: found.state, tree };
    }
    return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: common.Tree.empty };
}
class Parse {
    constructor(lang, input, fragments, ranges) {
        this.lang = lang;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.stoppedAt = null;
        this.chunks = [];
        this.chunkPos = [];
        this.chunk = [];
        this.chunkReused = undefined;
        this.rangeIndex = 0;
        this.to = ranges[ranges.length - 1].to;
        let context = ParseContext.get(), from = ranges[0].from;
        let { state, tree } = findStartInFragments(lang, fragments, from, this.to, context === null || context === void 0 ? void 0 : context.state);
        this.state = state;
        this.parsedPos = this.chunkStart = from + tree.length;
        for (let i = 0; i < tree.children.length; i++) {
            this.chunks.push(tree.children[i]);
            this.chunkPos.push(tree.positions[i]);
        }
        if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */ &&
            ranges.some(r => r.from <= context.viewport.from && r.to >= context.viewport.from)) {
            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));
            context.skipUntilInView(this.parsedPos, context.viewport.from);
            this.parsedPos = context.viewport.from;
        }
        this.moveRangeIndex();
    }
    advance() {
        let context = ParseContext.get();
        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);
        let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */);
        if (context)
            end = Math.min(end, context.viewport.to);
        while (this.parsedPos < end)
            this.parseLine(context);
        if (this.chunkStart < this.parsedPos)
            this.finishChunk();
        if (this.parsedPos >= parseEnd)
            return this.finish();
        if (context && this.parsedPos >= context.viewport.to) {
            context.skipUntilInView(this.parsedPos, parseEnd);
            return this.finish();
        }
        return null;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
    }
    lineAfter(pos) {
        let chunk = this.input.chunk(pos);
        if (!this.input.lineChunks) {
            let eol = chunk.indexOf("\n");
            if (eol > -1)
                chunk = chunk.slice(0, eol);
        }
        else if (chunk == "\n") {
            chunk = "";
        }
        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);
    }
    nextLine() {
        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;
        for (let index = this.rangeIndex;;) {
            let rangeEnd = this.ranges[index].to;
            if (rangeEnd >= end)
                break;
            line = line.slice(0, rangeEnd - (end - line.length));
            index++;
            if (index == this.ranges.length)
                break;
            let rangeStart = this.ranges[index].from;
            let after = this.lineAfter(rangeStart);
            line += after;
            end = rangeStart + after.length;
        }
        return { line, end };
    }
    skipGapsTo(pos, offset, side) {
        for (;;) {
            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;
            if (side > 0 ? end > offPos : end >= offPos)
                break;
            let start = this.ranges[++this.rangeIndex].from;
            offset += start - end;
        }
        return offset;
    }
    moveRangeIndex() {
        while (this.ranges[this.rangeIndex].to < this.parsedPos)
            this.rangeIndex++;
    }
    emitToken(id, from, to, offset) {
        let size = 4;
        if (this.ranges.length > 1) {
            offset = this.skipGapsTo(from, offset, 1);
            from += offset;
            let len0 = this.chunk.length;
            offset = this.skipGapsTo(to, offset, -1);
            to += offset;
            size += this.chunk.length - len0;
        }
        let last = this.chunk.length - 4;
        if (size == 4 && last >= 0 && this.chunk[last] == id && this.chunk[last + 2] == from)
            this.chunk[last + 2] = to;
        else
            this.chunk.push(id, from, to, size);
        return offset;
    }
    parseLine(context) {
        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;
        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);
        if (stream.eol()) {
            streamParser.blankLine(this.state, stream.indentUnit);
        }
        else {
            while (!stream.eol()) {
                let token = readToken(streamParser.token, stream, this.state);
                if (token)
                    offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, offset);
                if (stream.start > 10000 /* C.MaxLineLength */)
                    break;
            }
        }
        this.parsedPos = end;
        this.moveRangeIndex();
        if (this.parsedPos < this.to)
            this.parsedPos++;
    }
    finishChunk() {
        let tree = common.Tree.build({
            buffer: this.chunk,
            start: this.chunkStart,
            length: this.parsedPos - this.chunkStart,
            nodeSet,
            topID: 0,
            maxBufferLength: 2048 /* C.ChunkSize */,
            reused: this.chunkReused
        });
        tree = new common.Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);
        this.chunks.push(tree);
        this.chunkPos.push(this.chunkStart - this.ranges[0].from);
        this.chunk = [];
        this.chunkReused = undefined;
        this.chunkStart = this.parsedPos;
    }
    finish() {
        return new common.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
    }
}
function readToken(token, stream, state) {
    stream.start = stream.pos;
    for (let i = 0; i < 10; i++) {
        let result = token(stream, state);
        if (stream.pos > stream.start)
            return result;
    }
    throw new Error("Stream parser failed to advance stream.");
}
const noTokens = Object.create(null);
const typeArray = [common.NodeType.none];
const nodeSet = new common.NodeSet(typeArray);
const warned = [];
// Cache of node types by name and tags
const byTag = Object.create(null);
const defaultTable = Object.create(null);
for (let [legacyName, name] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
])
    defaultTable[legacyName] = createTokenType(noTokens, name);
class TokenTable {
    constructor(extra) {
        this.extra = extra;
        this.table = Object.assign(Object.create(null), defaultTable);
    }
    resolve(tag) {
        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
    }
}
const defaultTokenTable = new TokenTable(noTokens);
function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
        return;
    warned.push(part);
    console.warn(msg);
}
function createTokenType(extra, tagStr) {
    let tags = [];
    for (let name of tagStr.split(" ")) {
        let found = [];
        for (let part of name.split(".")) {
            let value = (extra[part] || highlight.tags[part]);
            if (!value) {
                warnForPart(part, `Unknown highlighting tag ${part}`);
            }
            else if (typeof value == "function") {
                if (!found.length)
                    warnForPart(part, `Modifier ${part} used at start of tag`);
                else
                    found = found.map(value);
            }
            else {
                if (found.length)
                    warnForPart(part, `Tag ${part} used as modifier`);
                else
                    found = Array.isArray(value) ? value : [value];
            }
        }
        for (let tag of found)
            tags.push(tag);
    }
    if (!tags.length)
        return 0;
    let name = tagStr.replace(/ /g, "_"), key = name + " " + tags.map(t => t.id);
    let known = byTag[key];
    if (known)
        return known.id;
    let type = byTag[key] = common.NodeType.define({
        id: typeArray.length,
        name,
        props: [highlight.styleTags({ [name]: tags })]
    });
    typeArray.push(type);
    return type.id;
}
function docID(data, lang) {
    let type = common.NodeType.define({ id: typeArray.length, name: "Document", props: [
            languageDataProp.add(() => data),
            indentNodeProp.add(() => cx => lang.getIndent(cx))
        ], top: true });
    typeArray.push(type);
    return type;
}

function buildForLine(line) {
    return line.length <= 4096 && /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/.test(line);
}
function textHasRTL(text) {
    for (let i = text.iter(); !i.next().done;)
        if (buildForLine(i.value))
            return true;
    return false;
}
function changeAddsRTL(change) {
    let added = false;
    change.iterChanges((fA, tA, fB, tB, ins) => {
        if (!added && textHasRTL(ins))
            added = true;
    });
    return added;
}
const alwaysIsolate = state.Facet.define({ combine: values => values.some(x => x) });
/**
Make sure nodes
[marked](https://lezer.codemirror.net/docs/ref/#common.NodeProp^isolate)
as isolating for bidirectional text are rendered in a way that
isolates them from the surrounding text.
*/
function bidiIsolates(options = {}) {
    let extensions = [isolateMarks];
    if (options.alwaysIsolate)
        extensions.push(alwaysIsolate.of(true));
    return extensions;
}
const isolateMarks = view.ViewPlugin.fromClass(class {
    constructor(view$1) {
        this.always = view$1.state.facet(alwaysIsolate) ||
            view$1.textDirection != view.Direction.LTR ||
            view$1.state.facet(view.EditorView.perLineTextDirection);
        this.hasRTL = !this.always && textHasRTL(view$1.state.doc);
        this.tree = syntaxTree(view$1.state);
        this.decorations = this.always || this.hasRTL ? buildDeco(view$1, this.tree, this.always) : view.Decoration.none;
    }
    update(update) {
        let always = update.state.facet(alwaysIsolate) ||
            update.view.textDirection != view.Direction.LTR ||
            update.state.facet(view.EditorView.perLineTextDirection);
        if (!always && !this.hasRTL && changeAddsRTL(update.changes))
            this.hasRTL = true;
        if (!always && !this.hasRTL)
            return;
        let tree = syntaxTree(update.state);
        if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {
            this.tree = tree;
            this.always = always;
            this.decorations = buildDeco(update.view, tree, always);
        }
    }
}, {
    provide: plugin => {
        function access(view$1) {
            var _a, _b;
            return (_b = (_a = view$1.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : view.Decoration.none;
        }
        return [view.EditorView.outerDecorations.of(access),
            state.Prec.lowest(view.EditorView.bidiIsolatedRanges.of(access))];
    }
});
function buildDeco(view, tree, always) {
    let deco = new state.RangeSetBuilder();
    let ranges = view.visibleRanges;
    if (!always)
        ranges = clipRTLLines(ranges, view.state.doc);
    for (let { from, to } of ranges) {
        tree.iterate({
            enter: node => {
                let iso = node.type.prop(common.NodeProp.isolate);
                if (iso)
                    deco.add(node.from, node.to, marks[iso]);
            },
            from, to
        });
    }
    return deco.finish();
}
function clipRTLLines(ranges, doc) {
    let cur = doc.iter(), pos = 0, result = [], last = null;
    for (let { from, to } of ranges) {
        if (last && last.to > from) {
            from = last.to;
            if (from >= to)
                continue;
        }
        if (pos + cur.value.length < from) {
            cur.next(from - (pos + cur.value.length));
            pos = from;
        }
        for (;;) {
            let start = pos, end = pos + cur.value.length;
            if (!cur.lineBreak && buildForLine(cur.value)) {
                if (last && last.to > start - 10)
                    last.to = Math.min(to, end);
                else
                    result.push(last = { from: start, to: Math.min(to, end) });
            }
            if (end >= to)
                break;
            pos = end;
            cur.next();
        }
    }
    return result;
}
const marks = {
    rtl: view.Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: view.Direction.RTL }),
    ltr: view.Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: view.Direction.LTR }),
    auto: view.Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
};

exports.DocInput = DocInput;
exports.HighlightStyle = HighlightStyle;
exports.IndentContext = IndentContext;
exports.LRLanguage = LRLanguage;
exports.Language = Language;
exports.LanguageDescription = LanguageDescription;
exports.LanguageSupport = LanguageSupport;
exports.ParseContext = ParseContext;
exports.StreamLanguage = StreamLanguage;
exports.StringStream = StringStream;
exports.TreeIndentContext = TreeIndentContext;
exports.bidiIsolates = bidiIsolates;
exports.bracketMatching = bracketMatching;
exports.bracketMatchingHandle = bracketMatchingHandle;
exports.codeFolding = codeFolding;
exports.continuedIndent = continuedIndent;
exports.defaultHighlightStyle = defaultHighlightStyle;
exports.defineLanguageFacet = defineLanguageFacet;
exports.delimitedIndent = delimitedIndent;
exports.ensureSyntaxTree = ensureSyntaxTree;
exports.flatIndent = flatIndent;
exports.foldAll = foldAll;
exports.foldCode = foldCode;
exports.foldEffect = foldEffect;
exports.foldGutter = foldGutter;
exports.foldInside = foldInside;
exports.foldKeymap = foldKeymap;
exports.foldNodeProp = foldNodeProp;
exports.foldService = foldService;
exports.foldState = foldState;
exports.foldable = foldable;
exports.foldedRanges = foldedRanges;
exports.forceParsing = forceParsing;
exports.getIndentUnit = getIndentUnit;
exports.getIndentation = getIndentation;
exports.highlightingFor = highlightingFor;
exports.indentNodeProp = indentNodeProp;
exports.indentOnInput = indentOnInput;
exports.indentRange = indentRange;
exports.indentService = indentService;
exports.indentString = indentString;
exports.indentUnit = indentUnit;
exports.language = language;
exports.languageDataProp = languageDataProp;
exports.matchBrackets = matchBrackets;
exports.sublanguageProp = sublanguageProp;
exports.syntaxHighlighting = syntaxHighlighting;
exports.syntaxParserRunning = syntaxParserRunning;
exports.syntaxTree = syntaxTree;
exports.syntaxTreeAvailable = syntaxTreeAvailable;
exports.toggleFold = toggleFold;
exports.unfoldAll = unfoldAll;
exports.unfoldCode = unfoldCode;
exports.unfoldEffect = unfoldEffect;


/***/ }),

/***/ "./node_modules/@codemirror/lint/dist/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/lint/dist/index.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var view = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.cjs");
var state = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.cjs");
var elt = __webpack_require__(/*! crelt */ "./node_modules/crelt/dist/index.cjs");

class SelectedDiagnostic {
    constructor(from, to, diagnostic) {
        this.from = from;
        this.to = to;
        this.diagnostic = diagnostic;
    }
}
class LintState {
    constructor(diagnostics, panel, selected) {
        this.diagnostics = diagnostics;
        this.panel = panel;
        this.selected = selected;
    }
    static init(diagnostics, panel, state$1) {
        // Filter the list of diagnostics for which to create markers
        let markedDiagnostics = diagnostics;
        let diagnosticFilter = state$1.facet(lintConfig).markerFilter;
        if (diagnosticFilter)
            markedDiagnostics = diagnosticFilter(markedDiagnostics, state$1);
        let sorted = diagnostics.slice().sort((a, b) => a.from - b.from || a.to - b.to);
        let deco = new state.RangeSetBuilder(), active = [], pos = 0;
        for (let i = 0;;) {
            let next = i == sorted.length ? null : sorted[i];
            if (!next && !active.length)
                break;
            let from, to;
            if (active.length) {
                from = pos;
                to = active.reduce((p, d) => Math.min(p, d.to), next && next.from > from ? next.from : 1e8);
            }
            else {
                from = next.from;
                to = next.to;
                active.push(next);
                i++;
            }
            while (i < sorted.length) {
                let next = sorted[i];
                if (next.from == from && (next.to > next.from || next.to == from)) {
                    active.push(next);
                    i++;
                    to = Math.min(next.to, to);
                }
                else {
                    to = Math.min(next.from, to);
                    break;
                }
            }
            let sev = maxSeverity(active);
            if (active.some(d => d.from == d.to || (d.from == d.to - 1 && state$1.doc.lineAt(d.from).to == d.from))) {
                deco.add(from, from, view.Decoration.widget({
                    widget: new DiagnosticWidget(sev),
                    diagnostics: active.slice()
                }));
            }
            else {
                let markClass = active.reduce((c, d) => d.markClass ? c + " " + d.markClass : c, "");
                deco.add(from, to, view.Decoration.mark({
                    class: "cm-lintRange cm-lintRange-" + sev + markClass,
                    diagnostics: active.slice(),
                    inclusiveEnd: active.some(a => a.to > to)
                }));
            }
            pos = to;
            for (let i = 0; i < active.length; i++)
                if (active[i].to <= pos)
                    active.splice(i--, 1);
        }
        let set = deco.finish();
        return new LintState(set, panel, findDiagnostic(set));
    }
}
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from, to, { spec }) => {
        if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0)
            return;
        if (!found)
            found = new SelectedDiagnostic(from, to, diagnostic || spec.diagnostics[0]);
        else if (spec.diagnostics.indexOf(found.diagnostic) < 0)
            return false;
        else
            found = new SelectedDiagnostic(found.from, to, found.diagnostic);
    });
    return found;
}
function hideTooltip(tr, tooltip) {
    let from = tooltip.pos, to = tooltip.end || from;
    let result = tr.state.facet(lintConfig).hideOn(tr, from, to);
    if (result != null)
        return result;
    let line = tr.startState.doc.lineAt(tooltip.pos);
    return !!(tr.effects.some(e => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));
}
function maybeEnableLint(state$1, effects) {
    return state$1.field(lintState, false) ? effects : effects.concat(state.StateEffect.appendConfig.of(lintExtensions));
}
/**
Returns a transaction spec which updates the current set of
diagnostics, and enables the lint extension if if wasn't already
active.
*/
function setDiagnostics(state, diagnostics) {
    return {
        effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
    };
}
/**
The state effect that updates the set of active diagnostics. Can
be useful when writing an extension that needs to track these.
*/
const setDiagnosticsEffect = state.StateEffect.define();
const togglePanel = state.StateEffect.define();
const movePanelSelection = state.StateEffect.define();
const lintState = state.StateField.define({
    create() {
        return new LintState(view.Decoration.none, null, null);
    },
    update(value, tr) {
        if (tr.docChanged && value.diagnostics.size) {
            let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;
            if (value.selected) {
                let selPos = tr.changes.mapPos(value.selected.from, 1);
                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
            }
            if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
                panel = null;
            value = new LintState(mapped, panel, selected);
        }
        for (let effect of tr.effects) {
            if (effect.is(setDiagnosticsEffect)) {
                let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
                value = LintState.init(effect.value, panel, tr.state);
            }
            else if (effect.is(togglePanel)) {
                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
            }
            else if (effect.is(movePanelSelection)) {
                value = new LintState(value.diagnostics, value.panel, effect.value);
            }
        }
        return value;
    },
    provide: f => [view.showPanel.from(f, val => val.panel),
        view.EditorView.decorations.from(f, s => s.diagnostics)]
});
/**
Returns the number of active lint diagnostics in the given state.
*/
function diagnosticCount(state) {
    let lint = state.field(lintState, false);
    return lint ? lint.diagnostics.size : 0;
}
const activeMark = view.Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
    let { diagnostics } = view.state.field(lintState);
    let found, start = -1, end = -1;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
        if (pos >= from && pos <= to &&
            (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {
            found = spec.diagnostics;
            start = from;
            end = to;
            return false;
        }
    });
    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (found && diagnosticFilter)
        found = diagnosticFilter(found, view.state);
    if (!found)
        return null;
    return {
        pos: start,
        end: end,
        above: view.state.doc.lineAt(start).to < end,
        create() {
            return { dom: diagnosticsTooltip(view, found) };
        }
    };
}
function diagnosticsTooltip(view, diagnostics) {
    return elt("ul", { class: "cm-tooltip-lint" }, diagnostics.map(d => renderDiagnostic(view, d, false)));
}
/**
Command to open and focus the lint panel.
*/
const openLintPanel = (view$1) => {
    let field = view$1.state.field(lintState, false);
    if (!field || !field.panel)
        view$1.dispatch({ effects: maybeEnableLint(view$1.state, [togglePanel.of(true)]) });
    let panel = view.getPanel(view$1, LintPanel.open);
    if (panel)
        panel.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
};
/**
Command to close the lint panel, when open.
*/
const closeLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
        return false;
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
};
/**
Move the selection to the next diagnostic.
*/
const nextDiagnostic = (view) => {
    let field = view.state.field(lintState, false);
    if (!field)
        return false;
    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
        next = field.diagnostics.iter(0);
        if (!next.value || next.from == sel.from && next.to == sel.to)
            return false;
    }
    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
    return true;
};
/**
Move the selection to the previous diagnostic.
*/
const previousDiagnostic = (view) => {
    let { state } = view, field = state.field(lintState, false);
    if (!field)
        return false;
    let sel = state.selection.main;
    let prevFrom, prevTo, lastFrom, lastTo;
    field.diagnostics.between(0, state.doc.length, (from, to) => {
        if (to < sel.to && (prevFrom == null || prevFrom < from)) {
            prevFrom = from;
            prevTo = to;
        }
        if (lastFrom == null || from > lastFrom) {
            lastFrom = from;
            lastTo = to;
        }
    });
    if (lastFrom == null || prevFrom == null && lastFrom == sel.from)
        return false;
    view.dispatch({ selection: { anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom, head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo }, scrollIntoView: true });
    return true;
};
/**
A set of default key bindings for the lint functionality.

- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)
- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)
*/
const lintKeymap = [
    { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
    { key: "F8", run: nextDiagnostic }
];
const lintPlugin = view.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.timeout = -1;
        this.set = true;
        let { delay } = view.state.facet(lintConfig);
        this.lintTime = Date.now() + delay;
        this.run = this.run.bind(this);
        this.timeout = setTimeout(this.run, delay);
    }
    run() {
        clearTimeout(this.timeout);
        let now = Date.now();
        if (now < this.lintTime - 10) {
            this.timeout = setTimeout(this.run, this.lintTime - now);
        }
        else {
            this.set = false;
            let { state } = this.view, { sources } = state.facet(lintConfig);
            if (sources.length)
                batchResults(sources.map(s => Promise.resolve(s(this.view))), annotations => {
                    if (this.view.state.doc == state.doc)
                        this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a, b) => a.concat(b))));
                }, error => { view.logException(this.view.state, error); });
        }
    }
    update(update) {
        let config = update.state.facet(lintConfig);
        if (update.docChanged || config != update.startState.facet(lintConfig) ||
            config.needsRefresh && config.needsRefresh(update)) {
            this.lintTime = Date.now() + config.delay;
            if (!this.set) {
                this.set = true;
                this.timeout = setTimeout(this.run, config.delay);
            }
        }
    }
    force() {
        if (this.set) {
            this.lintTime = Date.now();
            this.run();
        }
    }
    destroy() {
        clearTimeout(this.timeout);
    }
});
function batchResults(promises, sink, error) {
    let collected = [], timeout = -1;
    for (let p of promises)
        p.then(value => {
            collected.push(value);
            clearTimeout(timeout);
            if (collected.length == promises.length)
                sink(collected);
            else
                timeout = setTimeout(() => sink(collected), 200);
        }, error);
}
const lintConfig = state.Facet.define({
    combine(input) {
        return Object.assign({ sources: input.map(i => i.source).filter(x => x != null) }, state.combineConfig(input.map(i => i.config), {
            delay: 750,
            markerFilter: null,
            tooltipFilter: null,
            needsRefresh: null,
            hideOn: () => null,
        }, {
            needsRefresh: (a, b) => !a ? b : !b ? a : u => a(u) || b(u)
        }));
    }
});
/**
Given a diagnostic source, this function returns an extension that
enables linting with that source. It will be called whenever the
editor is idle (after its content changed). If `null` is given as
source, this only configures the lint extension.
*/
function linter(source, config = {}) {
    return [
        lintConfig.of({ source, config }),
        lintPlugin,
        lintExtensions
    ];
}
/**
Forces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the
editor is idle to run right away.
*/
function forceLinting(view) {
    let plugin = view.plugin(lintPlugin);
    if (plugin)
        plugin.force();
}
function assignKeys(actions) {
    let assigned = [];
    if (actions)
        actions: for (let { name } of actions) {
            for (let i = 0; i < name.length; i++) {
                let ch = name[i];
                if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {
                    assigned.push(ch);
                    continue actions;
                }
            }
            assigned.push("");
        }
    return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
    var _a;
    let keys = inPanel ? assignKeys(diagnostic.actions) : [];
    return elt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, elt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {
        let fired = false, click = (e) => {
            e.preventDefault();
            if (fired)
                return;
            fired = true;
            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
            if (found)
                action.apply(view, found.from, found.to);
        };
        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;
        let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex),
            elt("u", name.slice(keyIndex, keyIndex + 1)),
            name.slice(keyIndex + 1)];
        return elt("button", {
            type: "button",
            class: "cm-diagnosticAction",
            onclick: click,
            onmousedown: click,
            "aria-label": ` Action: ${name}${keyIndex < 0 ? "" : ` (access key "${keys[i]})"`}.`
        }, nameElt);
    }), diagnostic.source && elt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
class DiagnosticWidget extends view.WidgetType {
    constructor(sev) {
        super();
        this.sev = sev;
    }
    eq(other) { return other.sev == this.sev; }
    toDOM() {
        return elt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
    }
}
class PanelItem {
    constructor(view, diagnostic) {
        this.diagnostic = diagnostic;
        this.id = "item_" + Math.floor(Math.random() * 0xffffffff).toString(16);
        this.dom = renderDiagnostic(view, diagnostic, true);
        this.dom.id = this.id;
        this.dom.setAttribute("role", "option");
    }
}
class LintPanel {
    constructor(view) {
        this.view = view;
        this.items = [];
        let onkeydown = (event) => {
            if (event.keyCode == 27) { // Escape
                closeLintPanel(this.view);
                this.view.focus();
            }
            else if (event.keyCode == 38 || event.keyCode == 33) { // ArrowUp, PageUp
                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
            }
            else if (event.keyCode == 40 || event.keyCode == 34) { // ArrowDown, PageDown
                this.moveSelection((this.selectedIndex + 1) % this.items.length);
            }
            else if (event.keyCode == 36) { // Home
                this.moveSelection(0);
            }
            else if (event.keyCode == 35) { // End
                this.moveSelection(this.items.length - 1);
            }
            else if (event.keyCode == 13) { // Enter
                this.view.focus();
            }
            else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) { // A-Z
                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
                for (let i = 0; i < keys.length; i++)
                    if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
                        let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
                        if (found)
                            diagnostic.actions[i].apply(view, found.from, found.to);
                    }
            }
            else {
                return;
            }
            event.preventDefault();
        };
        let onclick = (event) => {
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i].dom.contains(event.target))
                    this.moveSelection(i);
            }
        };
        this.list = elt("ul", {
            tabIndex: 0,
            role: "listbox",
            "aria-label": this.view.state.phrase("Diagnostics"),
            onkeydown,
            onclick
        });
        this.dom = elt("div", { class: "cm-panel-lint" }, this.list, elt("button", {
            type: "button",
            name: "close",
            "aria-label": this.view.state.phrase("close"),
            onclick: () => closeLintPanel(this.view)
        }, "×"));
        this.update();
    }
    get selectedIndex() {
        let selected = this.view.state.field(lintState).selected;
        if (!selected)
            return -1;
        for (let i = 0; i < this.items.length; i++)
            if (this.items[i].diagnostic == selected.diagnostic)
                return i;
        return -1;
    }
    update() {
        let { diagnostics, selected } = this.view.state.field(lintState);
        let i = 0, needsSync = false, newSelectedItem = null;
        let seen = new Set();
        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
            for (let diagnostic of spec.diagnostics) {
                if (seen.has(diagnostic))
                    continue;
                seen.add(diagnostic);
                let found = -1, item;
                for (let j = i; j < this.items.length; j++)
                    if (this.items[j].diagnostic == diagnostic) {
                        found = j;
                        break;
                    }
                if (found < 0) {
                    item = new PanelItem(this.view, diagnostic);
                    this.items.splice(i, 0, item);
                    needsSync = true;
                }
                else {
                    item = this.items[found];
                    if (found > i) {
                        this.items.splice(i, found - i);
                        needsSync = true;
                    }
                }
                if (selected && item.diagnostic == selected.diagnostic) {
                    if (!item.dom.hasAttribute("aria-selected")) {
                        item.dom.setAttribute("aria-selected", "true");
                        newSelectedItem = item;
                    }
                }
                else if (item.dom.hasAttribute("aria-selected")) {
                    item.dom.removeAttribute("aria-selected");
                }
                i++;
            }
        });
        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
            needsSync = true;
            this.items.pop();
        }
        if (this.items.length == 0) {
            this.items.push(new PanelItem(this.view, {
                from: -1, to: -1,
                severity: "info",
                message: this.view.state.phrase("No diagnostics")
            }));
            needsSync = true;
        }
        if (newSelectedItem) {
            this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
            this.view.requestMeasure({
                key: this,
                read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
                write: ({ sel, panel }) => {
                    let scaleY = panel.height / this.list.offsetHeight;
                    if (sel.top < panel.top)
                        this.list.scrollTop -= (panel.top - sel.top) / scaleY;
                    else if (sel.bottom > panel.bottom)
                        this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
                }
            });
        }
        else if (this.selectedIndex < 0) {
            this.list.removeAttribute("aria-activedescendant");
        }
        if (needsSync)
            this.sync();
    }
    sync() {
        let domPos = this.list.firstChild;
        function rm() {
            let prev = domPos;
            domPos = prev.nextSibling;
            prev.remove();
        }
        for (let item of this.items) {
            if (item.dom.parentNode == this.list) {
                while (domPos != item.dom)
                    rm();
                domPos = item.dom.nextSibling;
            }
            else {
                this.list.insertBefore(item.dom, domPos);
            }
        }
        while (domPos)
            rm();
    }
    moveSelection(selectedIndex) {
        if (this.selectedIndex < 0)
            return;
        let field = this.view.state.field(lintState);
        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
        if (!selection)
            return;
        this.view.dispatch({
            selection: { anchor: selection.from, head: selection.to },
            scrollIntoView: true,
            effects: movePanelSelection.of(selection)
        });
    }
    static open(view) { return new LintPanel(view); }
}
function svg(content, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content)}</svg>')`;
}
function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
const baseTheme = view.EditorView.baseTheme({
    ".cm-diagnostic": {
        padding: "3px 6px 3px 8px",
        marginLeft: "-1px",
        display: "block",
        whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
    ".cm-diagnosticAction": {
        font: "inherit",
        border: "none",
        padding: "2px 4px",
        backgroundColor: "#444",
        color: "white",
        borderRadius: "3px",
        marginLeft: "8px",
        cursor: "pointer"
    },
    ".cm-diagnosticSource": {
        fontSize: "70%",
        opacity: .7
    },
    ".cm-lintRange": {
        backgroundPosition: "left bottom",
        backgroundRepeat: "repeat-x",
        paddingBottom: "0.7px",
    },
    ".cm-lintRange-error": { backgroundImage: underline("#d11") },
    ".cm-lintRange-warning": { backgroundImage: underline("orange") },
    ".cm-lintRange-info": { backgroundImage: underline("#999") },
    ".cm-lintRange-hint": { backgroundImage: underline("#66d") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-tooltip-lint": {
        padding: 0,
        margin: 0
    },
    ".cm-lintPoint": {
        position: "relative",
        "&:after": {
            content: '""',
            position: "absolute",
            bottom: 0,
            left: "-2px",
            borderLeft: "3px solid transparent",
            borderRight: "3px solid transparent",
            borderBottom: "4px solid #d11"
        }
    },
    ".cm-lintPoint-warning": {
        "&:after": { borderBottomColor: "orange" }
    },
    ".cm-lintPoint-info": {
        "&:after": { borderBottomColor: "#999" }
    },
    ".cm-lintPoint-hint": {
        "&:after": { borderBottomColor: "#66d" }
    },
    ".cm-panel.cm-panel-lint": {
        position: "relative",
        "& ul": {
            maxHeight: "100px",
            overflowY: "auto",
            "& [aria-selected]": {
                backgroundColor: "#ddd",
                "& u": { textDecoration: "underline" }
            },
            "&:focus [aria-selected]": {
                background_fallback: "#bdf",
                backgroundColor: "Highlight",
                color_fallback: "white",
                color: "HighlightText"
            },
            "& u": { textDecoration: "none" },
            padding: 0,
            margin: 0
        },
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "2px",
            background: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        }
    }
});
function severityWeight(sev) {
    return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
function maxSeverity(diagnostics) {
    let sev = "hint", weight = 1;
    for (let d of diagnostics) {
        let w = severityWeight(d.severity);
        if (w > weight) {
            weight = w;
            sev = d.severity;
        }
    }
    return sev;
}
class LintGutterMarker extends view.GutterMarker {
    constructor(diagnostics) {
        super();
        this.diagnostics = diagnostics;
        this.severity = maxSeverity(diagnostics);
    }
    toDOM(view) {
        let elt = document.createElement("div");
        elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
        let diagnostics = this.diagnostics;
        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
        if (diagnosticsFilter)
            diagnostics = diagnosticsFilter(diagnostics, view.state);
        if (diagnostics.length)
            elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
        return elt;
    }
}
function trackHoverOn(view, marker) {
    let mousemove = (event) => {
        let rect = marker.getBoundingClientRect();
        if (event.clientX > rect.left - 10 /* Hover.Margin */ && event.clientX < rect.right + 10 /* Hover.Margin */ &&
            event.clientY > rect.top - 10 /* Hover.Margin */ && event.clientY < rect.bottom + 10 /* Hover.Margin */)
            return;
        for (let target = event.target; target; target = target.parentNode) {
            if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
                return;
        }
        window.removeEventListener("mousemove", mousemove);
        if (view.state.field(lintGutterTooltip))
            view.dispatch({ effects: setLintGutterTooltip.of(null) });
    };
    window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
    function hovered() {
        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
        const linePos = view.coordsAtPos(line.from);
        if (linePos) {
            view.dispatch({ effects: setLintGutterTooltip.of({
                    pos: line.from,
                    above: false,
                    clip: false,
                    create() {
                        return {
                            dom: diagnosticsTooltip(view, diagnostics),
                            getCoords: () => marker.getBoundingClientRect()
                        };
                    }
                }) });
        }
        marker.onmouseout = marker.onmousemove = null;
        trackHoverOn(view, marker);
    }
    let { hoverTime } = view.state.facet(lintGutterConfig);
    let hoverTimeout = setTimeout(hovered, hoverTime);
    marker.onmouseout = () => {
        clearTimeout(hoverTimeout);
        marker.onmouseout = marker.onmousemove = null;
    };
    marker.onmousemove = () => {
        clearTimeout(hoverTimeout);
        hoverTimeout = setTimeout(hovered, hoverTime);
    };
}
function markersForDiagnostics(doc, diagnostics) {
    let byLine = Object.create(null);
    for (let diagnostic of diagnostics) {
        let line = doc.lineAt(diagnostic.from);
        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
    }
    let markers = [];
    for (let line in byLine) {
        markers.push(new LintGutterMarker(byLine[line]).range(+line));
    }
    return state.RangeSet.of(markers, true);
}
const lintGutterExtension = view.gutter({
    class: "cm-gutter-lint",
    markers: view => view.state.field(lintGutterMarkers),
    widgetMarker: (view, widget, block) => {
        let diagnostics = [];
        view.state.field(lintGutterMarkers).between(block.from, block.to, (from, to, value) => {
            if (from > block.from && from < block.to)
                diagnostics.push(...value.diagnostics);
        });
        return diagnostics.length ? new LintGutterMarker(diagnostics) : null;
    }
});
const lintGutterMarkers = state.StateField.define({
    create() {
        return state.RangeSet.empty;
    },
    update(markers, tr) {
        markers = markers.map(tr.changes);
        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;
        for (let effect of tr.effects) {
            if (effect.is(setDiagnosticsEffect)) {
                let diagnostics = effect.value;
                if (diagnosticFilter)
                    diagnostics = diagnosticFilter(diagnostics || [], tr.state);
                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));
            }
        }
        return markers;
    }
});
const setLintGutterTooltip = state.StateEffect.define();
const lintGutterTooltip = state.StateField.define({
    create() { return null; },
    update(tooltip, tr) {
        if (tooltip && tr.docChanged)
            tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });
        return tr.effects.reduce((t, e) => e.is(setLintGutterTooltip) ? e.value : t, tooltip);
    },
    provide: field => view.showTooltip.from(field)
});
const lintGutterTheme = view.EditorView.baseTheme({
    ".cm-gutter-lint": {
        width: "1.4em",
        "& .cm-gutterElement": {
            padding: ".2em"
        }
    },
    ".cm-lint-marker": {
        width: "1em",
        height: "1em"
    },
    ".cm-lint-marker-info": {
        content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
    },
    ".cm-lint-marker-warning": {
        content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`),
    },
    ".cm-lint-marker-error": {
        content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
    },
});
const lintExtensions = [
    lintState,
    view.EditorView.decorations.compute([lintState], state => {
        let { selected, panel } = state.field(lintState);
        return !selected || !panel || selected.from == selected.to ? view.Decoration.none : view.Decoration.set([
            activeMark.range(selected.from, selected.to)
        ]);
    }),
    view.hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
    baseTheme
];
const lintGutterConfig = state.Facet.define({
    combine(configs) {
        return state.combineConfig(configs, {
            hoverTime: 300 /* Hover.Time */,
            markerFilter: null,
            tooltipFilter: null
        });
    }
});
/**
Returns an extension that installs a gutter showing markers for
each line that has diagnostics, which can be hovered over to see
the diagnostics.
*/
function lintGutter(config = {}) {
    return [lintGutterConfig.of(config), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];
}
/**
Iterate over the marked diagnostics for the given editor state,
calling `f` for each of them. Note that, if the document changed
since the diagnostics were created, the `Diagnostic` object will
hold the original outdated position, whereas the `to` and `from`
arguments hold the diagnostic's current position.
*/
function forEachDiagnostic(state$1, f) {
    let lState = state$1.field(lintState, false);
    if (lState && lState.diagnostics.size) {
        let pending = [], pendingStart = [], lastEnd = -1;
        for (let iter = state.RangeSet.iter([lState.diagnostics]);; iter.next()) {
            for (let i = 0; i < pending.length; i++)
                if (!iter.value || iter.value.spec.diagnostics.indexOf(pending[i]) < 0) {
                    f(pending[i], pendingStart[i], lastEnd);
                    pending.splice(i, 1);
                    pendingStart.splice(i--, 1);
                }
            if (!iter.value)
                break;
            for (let d of iter.value.spec.diagnostics)
                if (pending.indexOf(d) < 0) {
                    pending.push(d);
                    pendingStart.push(iter.from);
                }
            lastEnd = iter.to;
        }
    }
}

exports.closeLintPanel = closeLintPanel;
exports.diagnosticCount = diagnosticCount;
exports.forEachDiagnostic = forEachDiagnostic;
exports.forceLinting = forceLinting;
exports.lintGutter = lintGutter;
exports.lintKeymap = lintKeymap;
exports.linter = linter;
exports.nextDiagnostic = nextDiagnostic;
exports.openLintPanel = openLintPanel;
exports.previousDiagnostic = previousDiagnostic;
exports.setDiagnostics = setDiagnostics;
exports.setDiagnosticsEffect = setDiagnosticsEffect;


/***/ }),

/***/ "./node_modules/@codemirror/search/dist/index.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var view = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.cjs");
var state = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.cjs");
var elt = __webpack_require__(/*! crelt */ "./node_modules/crelt/dist/index.cjs");

const basicNormalize = typeof String.prototype.normalize == "function"
    ? x => x.normalize("NFKD") : x => x;
/**
A search cursor provides an iterator over text matches in a
document.
*/
class SearchCursor {
    /**
    Create a text cursor. The query is the search string, `from` to
    `to` provides the region to search.
    
    When `normalize` is given, it will be called, on both the query
    string and the content it is matched against, before comparing.
    You can, for example, create a case-insensitive search by
    passing `s => s.toLowerCase()`.
    
    Text is always normalized with
    [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
    (when supported).
    */
    constructor(text, query, from = 0, to = text.length, normalize, test) {
        this.test = test;
        /**
        The current match (only holds a meaningful value after
        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when
        `done` is false).
        */
        this.value = { from: 0, to: 0 };
        /**
        Whether the end of the iterated region has been reached.
        */
        this.done = false;
        this.matches = [];
        this.buffer = "";
        this.bufferPos = 0;
        this.iter = text.iterRange(from, to);
        this.bufferStart = from;
        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;
        this.query = this.normalize(query);
    }
    peek() {
        if (this.bufferPos == this.buffer.length) {
            this.bufferStart += this.buffer.length;
            this.iter.next();
            if (this.iter.done)
                return -1;
            this.bufferPos = 0;
            this.buffer = this.iter.value;
        }
        return state.codePointAt(this.buffer, this.bufferPos);
    }
    /**
    Look for the next match. Updates the iterator's
    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
    at least once before using the cursor.
    */
    next() {
        while (this.matches.length)
            this.matches.pop();
        return this.nextOverlapping();
    }
    /**
    The `next` method will ignore matches that partially overlap a
    previous match. This method behaves like `next`, but includes
    such matches.
    */
    nextOverlapping() {
        for (;;) {
            let next = this.peek();
            if (next < 0) {
                this.done = true;
                return this;
            }
            let str = state.fromCodePoint(next), start = this.bufferStart + this.bufferPos;
            this.bufferPos += state.codePointSize(next);
            let norm = this.normalize(str);
            if (norm.length)
                for (let i = 0, pos = start;; i++) {
                    let code = norm.charCodeAt(i);
                    let match = this.match(code, pos, this.bufferPos + this.bufferStart);
                    if (i == norm.length - 1) {
                        if (match) {
                            this.value = match;
                            return this;
                        }
                        break;
                    }
                    if (pos == start && i < str.length && str.charCodeAt(i) == code)
                        pos++;
                }
        }
    }
    match(code, pos, end) {
        let match = null;
        for (let i = 0; i < this.matches.length; i += 2) {
            let index = this.matches[i], keep = false;
            if (this.query.charCodeAt(index) == code) {
                if (index == this.query.length - 1) {
                    match = { from: this.matches[i + 1], to: end };
                }
                else {
                    this.matches[i]++;
                    keep = true;
                }
            }
            if (!keep) {
                this.matches.splice(i, 2);
                i -= 2;
            }
        }
        if (this.query.charCodeAt(0) == code) {
            if (this.query.length == 1)
                match = { from: pos, to: end };
            else
                this.matches.push(1, pos);
        }
        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))
            match = null;
        return match;
    }
}
if (typeof Symbol != "undefined")
    SearchCursor.prototype[Symbol.iterator] = function () { return this; };

const empty = { from: -1, to: -1, match: /.*/.exec("") };
const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
/**
This class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)
but searches for a regular expression pattern instead of a plain
string.
*/
class RegExpCursor {
    /**
    Create a cursor that will search the given range in the given
    document. `query` should be the raw pattern (as you'd pass it to
    `new RegExp`).
    */
    constructor(text, query, options, from = 0, to = text.length) {
        this.text = text;
        this.to = to;
        this.curLine = "";
        /**
        Set to `true` when the cursor has reached the end of the search
        range.
        */
        this.done = false;
        /**
        Will contain an object with the extent of the match and the
        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)
        sucessfully finds a match.
        */
        this.value = empty;
        if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
            return new MultilineRegExpCursor(text, query, options, from, to);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.iter = text.iter();
        let startLine = text.lineAt(from);
        this.curLineStart = startLine.from;
        this.matchPos = toCharEnd(text, from);
        this.getLine(this.curLineStart);
    }
    getLine(skip) {
        this.iter.next(skip);
        if (this.iter.lineBreak) {
            this.curLine = "";
        }
        else {
            this.curLine = this.iter.value;
            if (this.curLineStart + this.curLine.length > this.to)
                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
            this.iter.next();
        }
    }
    nextLine() {
        this.curLineStart = this.curLineStart + this.curLine.length + 1;
        if (this.curLineStart > this.to)
            this.curLine = "";
        else
            this.getLine(0);
    }
    /**
    Move to the next match, if there is one.
    */
    next() {
        for (let off = this.matchPos - this.curLineStart;;) {
            this.re.lastIndex = off;
            let match = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (match) {
                let from = this.curLineStart + match.index, to = from + match[0].length;
                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                if (from == this.curLineStart + this.curLine.length)
                    this.nextLine();
                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
                    this.value = { from, to, match };
                    return this;
                }
                off = this.matchPos - this.curLineStart;
            }
            else if (this.curLineStart + this.curLine.length < this.to) {
                this.nextLine();
                off = 0;
            }
            else {
                this.done = true;
                return this;
            }
        }
    }
}
const flattened = new WeakMap();
// Reusable (partially) flattened document strings
class FlattenedDoc {
    constructor(from, text) {
        this.from = from;
        this.text = text;
    }
    get to() { return this.from + this.text.length; }
    static get(doc, from, to) {
        let cached = flattened.get(doc);
        if (!cached || cached.from >= to || cached.to <= from) {
            let flat = new FlattenedDoc(from, doc.sliceString(from, to));
            flattened.set(doc, flat);
            return flat;
        }
        if (cached.from == from && cached.to == to)
            return cached;
        let { text, from: cachedFrom } = cached;
        if (cachedFrom > from) {
            text = doc.sliceString(from, cachedFrom) + text;
            cachedFrom = from;
        }
        if (cached.to < to)
            text += doc.sliceString(cached.to, to);
        flattened.set(doc, new FlattenedDoc(cachedFrom, text));
        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
    }
}
class MultilineRegExpCursor {
    constructor(text, query, options, from, to) {
        this.text = text;
        this.to = to;
        this.done = false;
        this.value = empty;
        this.matchPos = toCharEnd(text, from);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));
    }
    chunkEnd(pos) {
        return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
        for (;;) {
            let off = this.re.lastIndex = this.matchPos - this.flat.from;
            let match = this.re.exec(this.flat.text);
            // Skip empty matches directly after the last match
            if (match && !match[0] && match.index == off) {
                this.re.lastIndex = off + 1;
                match = this.re.exec(this.flat.text);
            }
            if (match) {
                let from = this.flat.from + match.index, to = from + match[0].length;
                // If a match goes almost to the end of a noncomplete chunk, try
                // again, since it'll likely be able to match more
                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&
                    (!this.test || this.test(from, to, match))) {
                    this.value = { from, to, match };
                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                    return this;
                }
            }
            if (this.flat.to == this.to) {
                this.done = true;
                return this;
            }
            // Grow the flattened doc
            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
        }
    }
}
if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =
        function () { return this; };
}
function validRegExp(source) {
    try {
        new RegExp(source, baseFlags);
        return true;
    }
    catch (_a) {
        return false;
    }
}
function toCharEnd(text, pos) {
    if (pos >= text.length)
        return pos;
    let line = text.lineAt(pos), next;
    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)
        pos++;
    return pos;
}

function createLineDialog(view$1) {
    let line = String(view$1.state.doc.lineAt(view$1.state.selection.main.head).number);
    let input = elt("input", { class: "cm-textfield", name: "line", value: line });
    let dom = elt("form", {
        class: "cm-gotoLine",
        onkeydown: (event) => {
            if (event.keyCode == 27) { // Escape
                event.preventDefault();
                view$1.dispatch({ effects: dialogEffect.of(false) });
                view$1.focus();
            }
            else if (event.keyCode == 13) { // Enter
                event.preventDefault();
                go();
            }
        },
        onsubmit: (event) => {
            event.preventDefault();
            go();
        }
    }, elt("label", view$1.state.phrase("Go to line"), ": ", input), " ", elt("button", { class: "cm-button", type: "submit" }, view$1.state.phrase("go")));
    function go() {
        let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
        if (!match)
            return;
        let { state: state$1 } = view$1, startLine = state$1.doc.lineAt(state$1.selection.main.head);
        let [, sign, ln, cl, percent] = match;
        let col = cl ? +cl.slice(1) : 0;
        let line = ln ? +ln : startLine.number;
        if (ln && percent) {
            let pc = line / 100;
            if (sign)
                pc = pc * (sign == "-" ? -1 : 1) + (startLine.number / state$1.doc.lines);
            line = Math.round(state$1.doc.lines * pc);
        }
        else if (ln && sign) {
            line = line * (sign == "-" ? -1 : 1) + startLine.number;
        }
        let docLine = state$1.doc.line(Math.max(1, Math.min(state$1.doc.lines, line)));
        let selection = state.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
        view$1.dispatch({
            effects: [dialogEffect.of(false), view.EditorView.scrollIntoView(selection.from, { y: 'center' })],
            selection,
        });
        view$1.focus();
    }
    return { dom };
}
const dialogEffect = state.StateEffect.define();
const dialogField = state.StateField.define({
    create() { return true; },
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(dialogEffect))
                value = e.value;
        return value;
    },
    provide: f => view.showPanel.from(f, val => val ? createLineDialog : null)
});
/**
Command that shows a dialog asking the user for a line number, and
when a valid position is provided, moves the cursor to that line.

Supports line numbers, relative line offsets prefixed with `+` or
`-`, document percentages suffixed with `%`, and an optional
column position by adding `:` and a second number after the line
number.
*/
const gotoLine = view$1 => {
    let panel = view.getPanel(view$1, createLineDialog);
    if (!panel) {
        let effects = [dialogEffect.of(true)];
        if (view$1.state.field(dialogField, false) == null)
            effects.push(state.StateEffect.appendConfig.of([dialogField, baseTheme$1]));
        view$1.dispatch({ effects });
        panel = view.getPanel(view$1, createLineDialog);
    }
    if (panel)
        panel.dom.querySelector("input").select();
    return true;
};
const baseTheme$1 = view.EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
        padding: "2px 6px 4px",
        "& label": { fontSize: "80%" }
    }
});

const defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
};
const highlightConfig = state.Facet.define({
    combine(options) {
        return state.combineConfig(options, defaultHighlightOptions, {
            highlightWordAroundCursor: (a, b) => a || b,
            minSelectionLength: Math.min,
            maxMatches: Math.min
        });
    }
});
/**
This extension highlights text that matches the selection. It uses
the `"cm-selectionMatch"` class for the highlighting. When
`highlightWordAroundCursor` is enabled, the word at the cursor
itself will be highlighted with `"cm-selectionMatch-main"`.
*/
function highlightSelectionMatches(options) {
    let ext = [defaultTheme, matchHighlighter];
    if (options)
        ext.push(highlightConfig.of(options));
    return ext;
}
const matchDeco = view.Decoration.mark({ class: "cm-selectionMatch" });
const mainMatchDeco = view.Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
// Whether the characters directly outside the given positions are non-word characters
function insideWordBoundaries(check, state$1, from, to) {
    return (from == 0 || check(state$1.sliceDoc(from - 1, from)) != state.CharCategory.Word) &&
        (to == state$1.doc.length || check(state$1.sliceDoc(to, to + 1)) != state.CharCategory.Word);
}
// Whether the characters directly at the given positions are word characters
function insideWord(check, state$1, from, to) {
    return check(state$1.sliceDoc(from, from + 1)) == state.CharCategory.Word
        && check(state$1.sliceDoc(to - 1, to)) == state.CharCategory.Word;
}
const matchHighlighter = view.ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.selectionSet || update.docChanged || update.viewportChanged)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view$1) {
        let conf = view$1.state.facet(highlightConfig);
        let { state } = view$1, sel = state.selection;
        if (sel.ranges.length > 1)
            return view.Decoration.none;
        let range = sel.main, query, check = null;
        if (range.empty) {
            if (!conf.highlightWordAroundCursor)
                return view.Decoration.none;
            let word = state.wordAt(range.head);
            if (!word)
                return view.Decoration.none;
            check = state.charCategorizer(range.head);
            query = state.sliceDoc(word.from, word.to);
        }
        else {
            let len = range.to - range.from;
            if (len < conf.minSelectionLength || len > 200)
                return view.Decoration.none;
            if (conf.wholeWords) {
                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?
                check = state.charCategorizer(range.head);
                if (!(insideWordBoundaries(check, state, range.from, range.to) &&
                    insideWord(check, state, range.from, range.to)))
                    return view.Decoration.none;
            }
            else {
                query = state.sliceDoc(range.from, range.to);
                if (!query)
                    return view.Decoration.none;
            }
        }
        let deco = [];
        for (let part of view$1.visibleRanges) {
            let cursor = new SearchCursor(state.doc, query, part.from, part.to);
            while (!cursor.next().done) {
                let { from, to } = cursor.value;
                if (!check || insideWordBoundaries(check, state, from, to)) {
                    if (range.empty && from <= range.from && to >= range.to)
                        deco.push(mainMatchDeco.range(from, to));
                    else if (from >= range.to || to <= range.from)
                        deco.push(matchDeco.range(from, to));
                    if (deco.length > conf.maxMatches)
                        return view.Decoration.none;
                }
            }
        }
        return view.Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});
const defaultTheme = view.EditorView.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
// Select the words around the cursors.
const selectWord = ({ state: state$1, dispatch }) => {
    let { selection } = state$1;
    let newSel = state.EditorSelection.create(selection.ranges.map(range => state$1.wordAt(range.head) || state.EditorSelection.cursor(range.head)), selection.mainIndex);
    if (newSel.eq(selection))
        return false;
    dispatch(state$1.update({ selection: newSel }));
    return true;
};
// Find next occurrence of query relative to last cursor. Wrap around
// the document if there are no more matches.
function findNextOccurrence(state, query) {
    let { main, ranges } = state.selection;
    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {
        cursor.next();
        if (cursor.done) {
            if (cycled)
                return null;
            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
            cycled = true;
        }
        else {
            if (cycled && ranges.some(r => r.from == cursor.value.from))
                continue;
            if (fullWord) {
                let word = state.wordAt(cursor.value.from);
                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)
                    continue;
            }
            return cursor.value;
        }
    }
}
/**
Select next occurrence of the current selection. Expand selection
to the surrounding word when the selection is empty.
*/
const selectNextOccurrence = ({ state: state$1, dispatch }) => {
    let { ranges } = state$1.selection;
    if (ranges.some(sel => sel.from === sel.to))
        return selectWord({ state: state$1, dispatch });
    let searchedText = state$1.sliceDoc(ranges[0].from, ranges[0].to);
    if (state$1.selection.ranges.some(r => state$1.sliceDoc(r.from, r.to) != searchedText))
        return false;
    let range = findNextOccurrence(state$1, searchedText);
    if (!range)
        return false;
    dispatch(state$1.update({
        selection: state$1.selection.addRange(state.EditorSelection.range(range.from, range.to), false),
        effects: view.EditorView.scrollIntoView(range.to)
    }));
    return true;
};

const searchConfigFacet = state.Facet.define({
    combine(configs) {
        return state.combineConfig(configs, {
            top: false,
            caseSensitive: false,
            literal: false,
            regexp: false,
            wholeWord: false,
            createPanel: view => new SearchPanel(view),
            scrollToMatch: range => view.EditorView.scrollIntoView(range)
        });
    }
});
/**
Add search state to the editor configuration, and optionally
configure the search extension.
([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically
enable this if it isn't already on).
*/
function search(config) {
    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;
}
/**
A search query. Part of the editor's search state.
*/
class SearchQuery {
    /**
    Create a query object.
    */
    constructor(config) {
        this.search = config.search;
        this.caseSensitive = !!config.caseSensitive;
        this.literal = !!config.literal;
        this.regexp = !!config.regexp;
        this.replace = config.replace || "";
        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
        this.unquoted = this.unquote(this.search);
        this.wholeWord = !!config.wholeWord;
    }
    /**
    @internal
    */
    unquote(text) {
        return this.literal ? text :
            text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "\t" : "\\");
    }
    /**
    Compare this query to another query.
    */
    eq(other) {
        return this.search == other.search && this.replace == other.replace &&
            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&
            this.wholeWord == other.wholeWord;
    }
    /**
    @internal
    */
    create() {
        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    /**
    Get a search cursor for this query, searching through the given
    range in the given state.
    */
    getCursor(state$1, from = 0, to) {
        let st = state$1.doc ? state$1 : state.EditorState.create({ doc: state$1 });
        if (to == null)
            to = st.doc.length;
        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
    }
}
class QueryType {
    constructor(spec) {
        this.spec = spec;
    }
}
function stringCursor(spec, state, from, to) {
    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);
}
function stringWordTest(doc, categorizer) {
    return (from, to, buf, bufPos) => {
        if (bufPos > from || bufPos + buf.length < to) {
            bufPos = Math.max(0, from - 2);
            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));
        }
        return (categorizer(charBefore(buf, from - bufPos)) != state.CharCategory.Word ||
            categorizer(charAfter(buf, from - bufPos)) != state.CharCategory.Word) &&
            (categorizer(charAfter(buf, to - bufPos)) != state.CharCategory.Word ||
                categorizer(charBefore(buf, to - bufPos)) != state.CharCategory.Word);
    };
}
class StringQuery extends QueryType {
    constructor(spec) {
        super(spec);
    }
    nextMatch(state, curFrom, curTo) {
        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
        if (cursor.done) {
            let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
            cursor = stringCursor(this.spec, state, 0, end).nextOverlapping();
        }
        return cursor.done || cursor.value.from == curFrom && cursor.value.to == curTo ? null : cursor.value;
    }
    // Searching in reverse is, rather than implementing an inverted search
    // cursor, done by scanning chunk after chunk forward.
    prevMatchInRange(state, from, to) {
        for (let pos = to;;) {
            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);
            let cursor = stringCursor(this.spec, state, start, pos), range = null;
            while (!cursor.nextOverlapping().done)
                range = cursor.value;
            if (range)
                return range;
            if (start == from)
                return null;
            pos -= 10000 /* FindPrev.ChunkSize */;
        }
    }
    prevMatch(state, curFrom, curTo) {
        let found = this.prevMatchInRange(state, 0, curFrom);
        if (!found)
            found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
        return found && (found.from != curFrom || found.to != curTo) ? found : null;
    }
    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }
    matchAll(state, limit) {
        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor.next().done) {
            if (ranges.length >= limit)
                return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(state, from, to, add) {
        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
        while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
    }
}
function regexpCursor(spec, state, from, to) {
    return new RegExpCursor(state.doc, spec.search, {
        ignoreCase: !spec.caseSensitive,
        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined
    }, from, to);
}
function charBefore(str, index) {
    return str.slice(state.findClusterBreak(str, index, false), index);
}
function charAfter(str, index) {
    return str.slice(index, state.findClusterBreak(str, index));
}
function regexpWordTest(categorizer) {
    return (_from, _to, match) => !match[0].length ||
        (categorizer(charBefore(match.input, match.index)) != state.CharCategory.Word ||
            categorizer(charAfter(match.input, match.index)) != state.CharCategory.Word) &&
            (categorizer(charAfter(match.input, match.index + match[0].length)) != state.CharCategory.Word ||
                categorizer(charBefore(match.input, match.index + match[0].length)) != state.CharCategory.Word);
}
class RegExpQuery extends QueryType {
    nextMatch(state, curFrom, curTo) {
        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
        if (cursor.done)
            cursor = regexpCursor(this.spec, state, 0, curFrom).next();
        return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(state, from, to) {
        for (let size = 1;; size++) {
            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);
            let cursor = regexpCursor(this.spec, state, start, to), range = null;
            while (!cursor.next().done)
                range = cursor.value;
            if (range && (start == from || range.from > start + 10))
                return range;
            if (start == from)
                return null;
        }
    }
    prevMatch(state, curFrom, curTo) {
        return this.prevMatchInRange(state, 0, curFrom) ||
            this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(result) {
        return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$"
            : i == "&" ? result.match[0]
                : i != "0" && +i < result.match.length ? result.match[i]
                    : m);
    }
    matchAll(state, limit) {
        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor.next().done) {
            if (ranges.length >= limit)
                return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(state, from, to, add) {
        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));
        while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
    }
}
/**
A state effect that updates the current search query. Note that
this only has an effect if the search state has been initialized
(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or
by running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least
once).
*/
const setSearchQuery = state.StateEffect.define();
const togglePanel = state.StateEffect.define();
const searchState = state.StateField.define({
    create(state) {
        return new SearchState(defaultQuery(state).create(), null);
    },
    update(value, tr) {
        for (let effect of tr.effects) {
            if (effect.is(setSearchQuery))
                value = new SearchState(effect.value.create(), value.panel);
            else if (effect.is(togglePanel))
                value = new SearchState(value.query, effect.value ? createSearchPanel : null);
        }
        return value;
    },
    provide: f => view.showPanel.from(f, val => val.panel)
});
/**
Get the current search query from an editor state.
*/
function getSearchQuery(state) {
    let curState = state.field(searchState, false);
    return curState ? curState.query.spec : defaultQuery(state);
}
/**
Query whether the search panel is open in the given editor state.
*/
function searchPanelOpen(state) {
    var _a;
    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;
}
class SearchState {
    constructor(query, panel) {
        this.query = query;
        this.panel = panel;
    }
}
const matchMark = view.Decoration.mark({ class: "cm-searchMatch" }), selectedMatchMark = view.Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
const searchHighlighter = view.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update) {
        let state = update.state.field(searchState);
        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
            this.decorations = this.highlight(state);
    }
    highlight({ query, panel }) {
        if (!panel || !query.spec.valid)
            return view.Decoration.none;
        let { view: view$1 } = this;
        let builder = new state.RangeSetBuilder();
        for (let i = 0, ranges = view$1.visibleRanges, l = ranges.length; i < l; i++) {
            let { from, to } = ranges[i];
            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)
                to = ranges[++i].to;
            query.highlight(view$1.state, from, to, (from, to) => {
                let selected = view$1.state.selection.ranges.some(r => r.from == from && r.to == to);
                builder.add(from, to, selected ? selectedMatchMark : matchMark);
            });
        }
        return builder.finish();
    }
}, {
    decorations: v => v.decorations
});
function searchCommand(f) {
    return view => {
        let state = view.state.field(searchState, false);
        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
    };
}
/**
Open the search panel if it isn't already open, and move the
selection to the first match after the current main selection.
Will wrap around to the start of the document when it reaches the
end.
*/
const findNext = searchCommand((view, { query }) => {
    let { to } = view.state.selection.main;
    let next = query.nextMatch(view.state, to, to);
    if (!next)
        return false;
    let selection = state.EditorSelection.single(next.from, next.to);
    let config = view.state.facet(searchConfigFacet);
    view.dispatch({
        selection,
        effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],
        userEvent: "select.search"
    });
    selectSearchInput(view);
    return true;
});
/**
Move the selection to the previous instance of the search query,
before the current main selection. Will wrap past the start
of the document to start searching at the end again.
*/
const findPrevious = searchCommand((view, { query }) => {
    let { state: state$1 } = view, { from } = state$1.selection.main;
    let prev = query.prevMatch(state$1, from, from);
    if (!prev)
        return false;
    let selection = state.EditorSelection.single(prev.from, prev.to);
    let config = view.state.facet(searchConfigFacet);
    view.dispatch({
        selection,
        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],
        userEvent: "select.search"
    });
    selectSearchInput(view);
    return true;
});
/**
Select all instances of the search query.
*/
const selectMatches = searchCommand((view, { query }) => {
    let ranges = query.matchAll(view.state, 1000);
    if (!ranges || !ranges.length)
        return false;
    view.dispatch({
        selection: state.EditorSelection.create(ranges.map(r => state.EditorSelection.range(r.from, r.to))),
        userEvent: "select.search.matches"
    });
    return true;
});
/**
Select all instances of the currently selected text.
*/
const selectSelectionMatches = ({ state: state$1, dispatch }) => {
    let sel = state$1.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
        return false;
    let { from, to } = sel.main;
    let ranges = [], main = 0;
    for (let cur = new SearchCursor(state$1.doc, state$1.sliceDoc(from, to)); !cur.next().done;) {
        if (ranges.length > 1000)
            return false;
        if (cur.value.from == from)
            main = ranges.length;
        ranges.push(state.EditorSelection.range(cur.value.from, cur.value.to));
    }
    dispatch(state$1.update({
        selection: state.EditorSelection.create(ranges, main),
        userEvent: "select.search.matches"
    }));
    return true;
};
/**
Replace the current match of the search query.
*/
const replaceNext = searchCommand((view$1, { query }) => {
    let { state: state$1 } = view$1, { from, to } = state$1.selection.main;
    if (state$1.readOnly)
        return false;
    let match = query.nextMatch(state$1, from, from);
    if (!match)
        return false;
    let next = match;
    let changes = [], selection, replacement;
    let effects = [];
    if (next.from == from && next.to == to) {
        replacement = state$1.toText(query.getReplacement(next));
        changes.push({ from: next.from, to: next.to, insert: replacement });
        next = query.nextMatch(state$1, next.from, next.to);
        effects.push(view.EditorView.announce.of(state$1.phrase("replaced match on line $", state$1.doc.lineAt(from).number) + "."));
    }
    if (next) {
        let off = changes.length == 0 || changes[0].from >= match.to ? 0 : match.to - match.from - replacement.length;
        selection = state.EditorSelection.single(next.from - off, next.to - off);
        effects.push(announceMatch(view$1, next));
        effects.push(state$1.facet(searchConfigFacet).scrollToMatch(selection.main, view$1));
    }
    view$1.dispatch({
        changes, selection, effects,
        userEvent: "input.replace"
    });
    return true;
});
/**
Replace all instances of the search query with the given
replacement.
*/
const replaceAll = searchCommand((view$1, { query }) => {
    if (view$1.state.readOnly)
        return false;
    let changes = query.matchAll(view$1.state, 1e9).map(match => {
        let { from, to } = match;
        return { from, to, insert: query.getReplacement(match) };
    });
    if (!changes.length)
        return false;
    let announceText = view$1.state.phrase("replaced $ matches", changes.length) + ".";
    view$1.dispatch({
        changes,
        effects: view.EditorView.announce.of(announceText),
        userEvent: "input.replace.all"
    });
    return true;
});
function createSearchPanel(view) {
    return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
    var _a, _b, _c, _d, _e;
    let sel = state.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
    if (fallback && !selText)
        return fallback;
    let config = state.facet(searchConfigFacet);
    return new SearchQuery({
        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,
        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,
        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,
        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord
    });
}
function getSearchInput(view$1) {
    let panel = view.getPanel(view$1, createSearchPanel);
    return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
    let input = getSearchInput(view);
    if (input && input == view.root.activeElement)
        input.select();
}
/**
Make sure the search panel is open and focused.
*/
const openSearchPanel = view => {
    let state$1 = view.state.field(searchState, false);
    if (state$1 && state$1.panel) {
        let searchInput = getSearchInput(view);
        if (searchInput && searchInput != view.root.activeElement) {
            let query = defaultQuery(view.state, state$1.query.spec);
            if (query.valid)
                view.dispatch({ effects: setSearchQuery.of(query) });
            searchInput.focus();
            searchInput.select();
        }
    }
    else {
        view.dispatch({ effects: [
                togglePanel.of(true),
                state$1 ? setSearchQuery.of(defaultQuery(view.state, state$1.query.spec)) : state.StateEffect.appendConfig.of(searchExtensions)
            ] });
    }
    return true;
};
/**
Close the search panel.
*/
const closeSearchPanel = view$1 => {
    let state = view$1.state.field(searchState, false);
    if (!state || !state.panel)
        return false;
    let panel = view.getPanel(view$1, createSearchPanel);
    if (panel && panel.dom.contains(view$1.root.activeElement))
        view$1.focus();
    view$1.dispatch({ effects: togglePanel.of(false) });
    return true;
};
/**
Default search-related key bindings.

 - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)
 - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)
 - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)
 - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)
 - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)
*/
const searchKeymap = [
    { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
    { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: selectSelectionMatches },
    { key: "Mod-Alt-g", run: gotoLine },
    { key: "Mod-d", run: selectNextOccurrence, preventDefault: true },
];
class SearchPanel {
    constructor(view) {
        this.view = view;
        let query = this.query = view.state.field(searchState).query.spec;
        this.commit = this.commit.bind(this);
        this.searchField = elt("input", {
            value: query.search,
            placeholder: phrase(view, "Find"),
            "aria-label": phrase(view, "Find"),
            class: "cm-textfield",
            name: "search",
            form: "",
            "main-field": "true",
            onchange: this.commit,
            onkeyup: this.commit
        });
        this.replaceField = elt("input", {
            value: query.replace,
            placeholder: phrase(view, "Replace"),
            "aria-label": phrase(view, "Replace"),
            class: "cm-textfield",
            name: "replace",
            form: "",
            onchange: this.commit,
            onkeyup: this.commit
        });
        this.caseField = elt("input", {
            type: "checkbox",
            name: "case",
            form: "",
            checked: query.caseSensitive,
            onchange: this.commit
        });
        this.reField = elt("input", {
            type: "checkbox",
            name: "re",
            form: "",
            checked: query.regexp,
            onchange: this.commit
        });
        this.wordField = elt("input", {
            type: "checkbox",
            name: "word",
            form: "",
            checked: query.wholeWord,
            onchange: this.commit
        });
        function button(name, onclick, content) {
            return elt("button", { class: "cm-button", name, onclick, type: "button" }, content);
        }
        this.dom = elt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
            this.searchField,
            button("next", () => findNext(view), [phrase(view, "next")]),
            button("prev", () => findPrevious(view), [phrase(view, "previous")]),
            button("select", () => selectMatches(view), [phrase(view, "all")]),
            elt("label", null, [this.caseField, phrase(view, "match case")]),
            elt("label", null, [this.reField, phrase(view, "regexp")]),
            elt("label", null, [this.wordField, phrase(view, "by word")]),
            ...view.state.readOnly ? [] : [
                elt("br"),
                this.replaceField,
                button("replace", () => replaceNext(view), [phrase(view, "replace")]),
                button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
            ],
            elt("button", {
                name: "close",
                onclick: () => closeSearchPanel(view),
                "aria-label": phrase(view, "close"),
                type: "button"
            }, ["×"])
        ]);
    }
    commit() {
        let query = new SearchQuery({
            search: this.searchField.value,
            caseSensitive: this.caseField.checked,
            regexp: this.reField.checked,
            wholeWord: this.wordField.checked,
            replace: this.replaceField.value,
        });
        if (!query.eq(this.query)) {
            this.query = query;
            this.view.dispatch({ effects: setSearchQuery.of(query) });
        }
    }
    keydown(e) {
        if (view.runScopeHandlers(this.view, e, "search-panel")) {
            e.preventDefault();
        }
        else if (e.keyCode == 13 && e.target == this.searchField) {
            e.preventDefault();
            (e.shiftKey ? findPrevious : findNext)(this.view);
        }
        else if (e.keyCode == 13 && e.target == this.replaceField) {
            e.preventDefault();
            replaceNext(this.view);
        }
    }
    update(update) {
        for (let tr of update.transactions)
            for (let effect of tr.effects) {
                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
                    this.setQuery(effect.value);
            }
    }
    setQuery(query) {
        this.query = query;
        this.searchField.value = query.search;
        this.replaceField.value = query.replace;
        this.caseField.checked = query.caseSensitive;
        this.reField.checked = query.regexp;
        this.wordField.checked = query.wholeWord;
    }
    mount() {
        this.searchField.select();
    }
    get pos() { return 80; }
    get top() { return this.view.state.facet(searchConfigFacet).top; }
}
function phrase(view, phrase) { return view.state.phrase(phrase); }
const AnnounceMargin = 30;
const Break = /[\s\.,:;?!]/;
function announceMatch(view$1, { from, to }) {
    let line = view$1.state.doc.lineAt(from), lineEnd = view$1.state.doc.lineAt(to).to;
    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
    let text = view$1.state.sliceDoc(start, end);
    if (start != line.from) {
        for (let i = 0; i < AnnounceMargin; i++)
            if (!Break.test(text[i + 1]) && Break.test(text[i])) {
                text = text.slice(i);
                break;
            }
    }
    if (end != lineEnd) {
        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
            if (!Break.test(text[i - 1]) && Break.test(text[i])) {
                text = text.slice(0, i);
                break;
            }
    }
    return view.EditorView.announce.of(`${view$1.state.phrase("current match")}. ${text} ${view$1.state.phrase("on line")} ${line.number}.`);
}
const baseTheme = view.EditorView.baseTheme({
    ".cm-panel.cm-search": {
        padding: "2px 6px 4px",
        position: "relative",
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        },
        "& input, & button, & label": {
            margin: ".2em .6em .2em 0"
        },
        "& input[type=checkbox]": {
            marginRight: ".2em"
        },
        "& label": {
            fontSize: "80%",
            whiteSpace: "pre"
        }
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
const searchExtensions = [
    searchState,
    state.Prec.low(searchHighlighter),
    baseTheme
];

exports.RegExpCursor = RegExpCursor;
exports.SearchCursor = SearchCursor;
exports.SearchQuery = SearchQuery;
exports.closeSearchPanel = closeSearchPanel;
exports.findNext = findNext;
exports.findPrevious = findPrevious;
exports.getSearchQuery = getSearchQuery;
exports.gotoLine = gotoLine;
exports.highlightSelectionMatches = highlightSelectionMatches;
exports.openSearchPanel = openSearchPanel;
exports.replaceAll = replaceAll;
exports.replaceNext = replaceNext;
exports.search = search;
exports.searchKeymap = searchKeymap;
exports.searchPanelOpen = searchPanelOpen;
exports.selectMatches = selectMatches;
exports.selectNextOccurrence = selectNextOccurrence;
exports.selectSelectionMatches = selectSelectionMatches;
exports.setSearchQuery = setSearchQuery;


/***/ }),

/***/ "./node_modules/@codemirror/state/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
The data structure for documents. @nonabstract
*/
class Text {
    /**
    Get the line description around the given position.
    */
    lineAt(pos) {
        if (pos < 0 || pos > this.length)
            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
        return this.lineInner(pos, false, 1, 0);
    }
    /**
    Get the description for the given (1-based) line number.
    */
    line(n) {
        if (n < 1 || n > this.lines)
            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
        return this.lineInner(n, true, 1, 0);
    }
    /**
    Replace a range of the text with the given content.
    */
    replace(from, to, text) {
        [from, to] = clip(this, from, to);
        let parts = [];
        this.decompose(0, from, parts, 2 /* Open.To */);
        if (text.length)
            text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);
        this.decompose(to, this.length, parts, 1 /* Open.From */);
        return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    /**
    Append another document to this one.
    */
    append(other) {
        return this.replace(this.length, this.length, other);
    }
    /**
    Retrieve the text between the given points.
    */
    slice(from, to = this.length) {
        [from, to] = clip(this, from, to);
        let parts = [];
        this.decompose(from, to, parts, 0);
        return TextNode.from(parts, to - from);
    }
    /**
    Test whether this text is equal to another instance.
    */
    eq(other) {
        if (other == this)
            return true;
        if (other.length != this.length || other.lines != this.lines)
            return false;
        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
        let a = new RawTextCursor(this), b = new RawTextCursor(other);
        for (let skip = start, pos = start;;) {
            a.next(skip);
            b.next(skip);
            skip = 0;
            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
                return false;
            pos += a.value.length;
            if (a.done || pos >= end)
                return true;
        }
    }
    /**
    Iterate over the text. When `dir` is `-1`, iteration happens
    from end to start. This will return lines and the breaks between
    them as separate strings.
    */
    iter(dir = 1) { return new RawTextCursor(this, dir); }
    /**
    Iterate over a range of the text. When `from` > `to`, the
    iterator will run in reverse.
    */
    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }
    /**
    Return a cursor that iterates over the given range of lines,
    _without_ returning the line breaks between, and yielding empty
    strings for empty lines.
    
    When `from` and `to` are given, they should be 1-based line numbers.
    */
    iterLines(from, to) {
        let inner;
        if (from == null) {
            inner = this.iter();
        }
        else {
            if (to == null)
                to = this.lines + 1;
            let start = this.line(from).from;
            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
        }
        return new LineCursor(inner);
    }
    /**
    Return the document as a string, using newline characters to
    separate lines.
    */
    toString() { return this.sliceString(0); }
    /**
    Convert the document to an array of lines (which can be
    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
    */
    toJSON() {
        let lines = [];
        this.flatten(lines);
        return lines;
    }
    /**
    @internal
    */
    constructor() { }
    /**
    Create a `Text` instance for the given array of lines.
    */
    static of(text) {
        if (text.length == 0)
            throw new RangeError("A document must have at least one line");
        if (text.length == 1 && !text[0])
            return Text.empty;
        return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
}
// Leaves store an array of line strings. There are always line breaks
// between these strings. Leaves are limited in size and have to be
// contained in TextNode instances for bigger documents.
class TextLeaf extends Text {
    constructor(text, length = textLength(text)) {
        super();
        this.text = text;
        this.length = length;
    }
    get lines() { return this.text.length; }
    get children() { return null; }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let string = this.text[i], end = offset + string.length;
            if ((isLine ? line : end) >= target)
                return new Line(offset, end, line, string);
            offset = end + 1;
            line++;
        }
    }
    decompose(from, to, target, open) {
        let text = from <= 0 && to >= this.length ? this
            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
        if (open & 1 /* Open.From */) {
            let prev = target.pop();
            let joined = appendText(text.text, prev.text.slice(), 0, text.length);
            if (joined.length <= 32 /* Tree.Branch */) {
                target.push(new TextLeaf(joined, prev.length + text.length));
            }
            else {
                let mid = joined.length >> 1;
                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
            }
        }
        else {
            target.push(text);
        }
    }
    replace(from, to, text) {
        if (!(text instanceof TextLeaf))
            return super.replace(from, to, text);
        [from, to] = clip(this, from, to);
        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
        let newLen = this.length + text.length - (to - from);
        if (lines.length <= 32 /* Tree.Branch */)
            return new TextLeaf(lines, newLen);
        return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        [from, to] = clip(this, from, to);
        let result = "";
        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
            let line = this.text[i], end = pos + line.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += line.slice(Math.max(0, from - pos), to - pos);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let line of this.text)
            target.push(line);
    }
    scanIdentical() { return 0; }
    static split(text, target) {
        let part = [], len = -1;
        for (let line of text) {
            part.push(line);
            len += line.length + 1;
            if (part.length == 32 /* Tree.Branch */) {
                target.push(new TextLeaf(part, len));
                part = [];
                len = -1;
            }
        }
        if (len > -1)
            target.push(new TextLeaf(part, len));
        return target;
    }
}
// Nodes provide the tree structure of the `Text` type. They store a
// number of other nodes or leaves, taking care to balance themselves
// on changes. There are implied line breaks _between_ the children of
// a node (but not before the first or after the last child).
class TextNode extends Text {
    constructor(children, length) {
        super();
        this.children = children;
        this.length = length;
        this.lines = 0;
        for (let child of children)
            this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
            if ((isLine ? endLine : end) >= target)
                return child.lineInner(target, isLine, line, offset);
            offset = end + 1;
            line = endLine + 1;
        }
    }
    decompose(from, to, target, open) {
        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (from <= end && to >= pos) {
                let childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));
                if (pos >= from && end <= to && !childOpen)
                    target.push(child);
                else
                    child.decompose(from - pos, to - pos, target, childOpen);
            }
            pos = end + 1;
        }
    }
    replace(from, to, text) {
        [from, to] = clip(this, from, to);
        if (text.lines < this.lines)
            for (let i = 0, pos = 0; i < this.children.length; i++) {
                let child = this.children[i], end = pos + child.length;
                // Fast path: if the change only affects one child and the
                // child's size remains in the acceptable range, only update
                // that child
                if (from >= pos && to <= end) {
                    let updated = child.replace(from - pos, to - pos, text);
                    let totalLines = this.lines - child.lines + updated.lines;
                    if (updated.lines < (totalLines >> (5 /* Tree.BranchShift */ - 1)) &&
                        updated.lines > (totalLines >> (5 /* Tree.BranchShift */ + 1))) {
                        let copy = this.children.slice();
                        copy[i] = updated;
                        return new TextNode(copy, this.length - (to - from) + text.length);
                    }
                    return super.replace(pos, end, updated);
                }
                pos = end + 1;
            }
        return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        [from, to] = clip(this, from, to);
        let result = "";
        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += child.sliceString(from - pos, to - pos, lineSep);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let child of this.children)
            child.flatten(target);
    }
    scanIdentical(other, dir) {
        if (!(other instanceof TextNode))
            return 0;
        let length = 0;
        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length]
            : [this.children.length - 1, other.children.length - 1, -1, -1];
        for (;; iA += dir, iB += dir) {
            if (iA == eA || iB == eB)
                return length;
            let chA = this.children[iA], chB = other.children[iB];
            if (chA != chB)
                return length + chA.scanIdentical(chB, dir);
            length += chA.length + 1;
        }
    }
    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
        let lines = 0;
        for (let ch of children)
            lines += ch.lines;
        if (lines < 32 /* Tree.Branch */) {
            let flat = [];
            for (let ch of children)
                ch.flatten(flat);
            return new TextLeaf(flat, length);
        }
        let chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;
        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
        function add(child) {
            let last;
            if (child.lines > maxChunk && child instanceof TextNode) {
                for (let node of child.children)
                    add(node);
            }
            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
                flush();
                chunked.push(child);
            }
            else if (child instanceof TextLeaf && currentLines &&
                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&
                child.lines + last.lines <= 32 /* Tree.Branch */) {
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
            }
            else {
                if (currentLines + child.lines > chunk)
                    flush();
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk.push(child);
            }
        }
        function flush() {
            if (currentLines == 0)
                return;
            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
            currentLen = -1;
            currentLines = currentChunk.length = 0;
        }
        for (let child of children)
            add(child);
        flush();
        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
}
Text.empty = new TextLeaf([""], 0);
function textLength(text) {
    let length = -1;
    for (let line of text)
        length += line.length + 1;
    return length;
}
function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
        let line = text[i], end = pos + line.length;
        if (end >= from) {
            if (end > to)
                line = line.slice(0, to - pos);
            if (pos < from)
                line = line.slice(from - pos);
            if (first) {
                target[target.length - 1] += line;
                first = false;
            }
            else
                target.push(line);
        }
        pos = end + 1;
    }
    return target;
}
function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
}
class RawTextCursor {
    constructor(text, dir = 1) {
        this.dir = dir;
        this.done = false;
        this.lineBreak = false;
        this.value = "";
        this.nodes = [text];
        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip, dir) {
        this.done = this.lineBreak = false;
        for (;;) {
            let last = this.nodes.length - 1;
            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
            let size = top instanceof TextLeaf ? top.text.length : top.children.length;
            if (offset == (dir > 0 ? size : 0)) {
                if (last == 0) {
                    this.done = true;
                    this.value = "";
                    return this;
                }
                if (dir > 0)
                    this.offsets[last - 1]++;
                this.nodes.pop();
                this.offsets.pop();
            }
            else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
                this.offsets[last] += dir;
                if (skip == 0) {
                    this.lineBreak = true;
                    this.value = "\n";
                    return this;
                }
                skip--;
            }
            else if (top instanceof TextLeaf) {
                // Move to the next string
                let next = top.text[offset + (dir < 0 ? -1 : 0)];
                this.offsets[last] += dir;
                if (next.length > Math.max(0, skip)) {
                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
                    return this;
                }
                skip -= next.length;
            }
            else {
                let next = top.children[offset + (dir < 0 ? -1 : 0)];
                if (skip > next.length) {
                    skip -= next.length;
                    this.offsets[last] += dir;
                }
                else {
                    if (dir < 0)
                        this.offsets[last]--;
                    this.nodes.push(next);
                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
                }
            }
        }
    }
    next(skip = 0) {
        if (skip < 0) {
            this.nextInner(-skip, (-this.dir));
            skip = this.value.length;
        }
        return this.nextInner(skip, this.dir);
    }
}
class PartialTextCursor {
    constructor(text, start, end) {
        this.value = "";
        this.done = false;
        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
        this.pos = start > end ? text.length : 0;
        this.from = Math.min(start, end);
        this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
            this.value = "";
            this.done = true;
            return this;
        }
        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
        if (skip > limit)
            skip = limit;
        limit -= skip;
        let { value } = this.cursor.next(skip);
        this.pos += (value.length + skip) * dir;
        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
        this.done = !this.value;
        return this;
    }
    next(skip = 0) {
        if (skip < 0)
            skip = Math.max(skip, this.from - this.pos);
        else if (skip > 0)
            skip = Math.min(skip, this.to - this.pos);
        return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() { return this.cursor.lineBreak && this.value != ""; }
}
class LineCursor {
    constructor(inner) {
        this.inner = inner;
        this.afterBreak = true;
        this.value = "";
        this.done = false;
    }
    next(skip = 0) {
        let { done, lineBreak, value } = this.inner.next(skip);
        if (done && this.afterBreak) {
            this.value = "";
            this.afterBreak = false;
        }
        else if (done) {
            this.done = true;
            this.value = "";
        }
        else if (lineBreak) {
            if (this.afterBreak) {
                this.value = "";
            }
            else {
                this.afterBreak = true;
                this.next();
            }
        }
        else {
            this.value = value;
            this.afterBreak = false;
        }
        return this;
    }
    get lineBreak() { return false; }
}
if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function () { return this.iter(); };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =
        LineCursor.prototype[Symbol.iterator] = function () { return this; };
}
/**
This type describes a line in the document. It is created
on-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).
*/
class Line {
    /**
    @internal
    */
    constructor(
    /**
    The position of the start of the line.
    */
    from, 
    /**
    The position at the end of the line (_before_ the line break,
    or at the end of document for the last line).
    */
    to, 
    /**
    This line's line number (1-based).
    */
    number, 
    /**
    The line's content.
    */
    text) {
        this.from = from;
        this.to = to;
        this.number = number;
        this.text = text;
    }
    /**
    The length of the line (not including any line break after it).
    */
    get length() { return this.to - this.from; }
}
function clip(text, from, to) {
    from = Math.max(0, Math.min(text.length, from));
    return [from, Math.max(from, Math.min(text.length, to))];
}

// Compressed representation of the Grapheme_Cluster_Break=Extend
// information from
// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.
// Each pair of elements represents a range, as an offet from the
// previous range and a length. Numbers are in base-36, with the empty
// string being a shorthand for 1.
let extend = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(s => s ? parseInt(s, 36) : 1);
// Convert offsets into absolute values
for (let i = 1; i < extend.length; i++)
    extend[i] += extend[i - 1];
function isExtendingChar(code) {
    for (let i = 1; i < extend.length; i += 2)
        if (extend[i] > code)
            return extend[i - 1] <= code;
    return false;
}
function isRegionalIndicator(code) {
    return code >= 0x1F1E6 && code <= 0x1F1FF;
}
const ZWJ = 0x200d;
/**
Returns a next grapheme cluster break _after_ (not equal to)
`pos`, if `forward` is true, or before otherwise. Returns `pos`
itself if no further cluster break is available in the string.
Moves across surrogate pairs, extending characters (when
`includeExtending` is true), characters joined with zero-width
joiners, and flag emoji.
*/
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
        return pos;
    // If pos is in the middle of a surrogate pair, move to its start
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
        pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
        let next = codePointAt(str, pos);
        if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
            pos += codePointSize(next);
            prev = next;
        }
        else if (isRegionalIndicator(next)) {
            let countBefore = 0, i = pos - 2;
            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
                countBefore++;
                i -= 2;
            }
            if (countBefore % 2 == 0)
                break;
            else
                pos += 2;
        }
        else {
            break;
        }
    }
    return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
        let found = nextClusterBreak(str, pos - 2, includeExtending);
        if (found < pos)
            return found;
        pos--;
    }
    return 0;
}
function surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }
function surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }
/**
Find the code point at the given position in a string (like the
[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
string method).
*/
function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
        return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
        return code0;
    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;
}
/**
Given a Unicode codepoint, return the JavaScript string that
respresents it (like
[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).
*/
function fromCodePoint(code) {
    if (code <= 0xffff)
        return String.fromCharCode(code);
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);
}
/**
The amount of positions a character takes up a JavaScript string.
*/
function codePointSize(code) { return code < 0x10000 ? 1 : 2; }

const DefaultSplit = /\r\n?|\n/;
/**
Distinguishes different ways in which positions can be mapped.
*/
exports.MapMode = void 0;
(function (MapMode) {
    /**
    Map a position to a valid new position, even when its context
    was deleted.
    */
    MapMode[MapMode["Simple"] = 0] = "Simple";
    /**
    Return null if deletion happens across the position.
    */
    MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
    /**
    Return null if the character _before_ the position is deleted.
    */
    MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
    /**
    Return null if the character _after_ the position is deleted.
    */
    MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
})(exports.MapMode || (exports.MapMode = {}));
/**
A change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)
that doesn't store the inserted text. As such, it can't be
applied, but is cheaper to store and manipulate.
*/
class ChangeDesc {
    // Sections are encoded as pairs of integers. The first is the
    // length in the current document, and the second is -1 for
    // unaffected sections, and the length of the replacement content
    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
    // 0), and a replacement two positive numbers.
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    sections) {
        this.sections = sections;
    }
    /**
    The length of the document before the change.
    */
    get length() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2)
            result += this.sections[i];
        return result;
    }
    /**
    The length of the document after the change.
    */
    get newLength() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2) {
            let ins = this.sections[i + 1];
            result += ins < 0 ? this.sections[i] : ins;
        }
        return result;
    }
    /**
    False when there are actual changes in this set.
    */
    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }
    /**
    Iterate over the unchanged parts left by these changes. `posA`
    provides the position of the range in the old document, `posB`
    the new position in the changed document.
    */
    iterGaps(f) {
        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0) {
                f(posA, posB, len);
                posB += len;
            }
            else {
                posB += ins;
            }
            posA += len;
        }
    }
    /**
    Iterate over the ranges changed by these changes. (See
    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
    variant that also provides you with the inserted text.)
    `fromA`/`toA` provides the extent of the change in the starting
    document, `fromB`/`toB` the extent of the replacement in the
    changed document.
    
    When `individual` is true, adjacent changes (which are kept
    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
    reported separately.
    */
    iterChangedRanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    /**
    Get a description of the inverted form of these changes.
    */
    get invertedDesc() {
        let sections = [];
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0)
                sections.push(len, ins);
            else
                sections.push(ins, len);
        }
        return new ChangeDesc(sections);
    }
    /**
    Compute the combined effect of applying another set of changes
    after this one. The length of the document after this set should
    match the length before `other`.
    */
    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }
    /**
    Map this description, which should start with the same document
    as `other`, over another set of changes, so that it can be
    applied after it. When `before` is true, map as if the changes
    in `other` happened before the ones in `this`.
    */
    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }
    mapPos(pos, assoc = -1, mode = exports.MapMode.Simple) {
        let posA = 0, posB = 0;
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
            if (ins < 0) {
                if (endA > pos)
                    return posB + (pos - posA);
                posB += len;
            }
            else {
                if (mode != exports.MapMode.Simple && endA >= pos &&
                    (mode == exports.MapMode.TrackDel && posA < pos && endA > pos ||
                        mode == exports.MapMode.TrackBefore && posA < pos ||
                        mode == exports.MapMode.TrackAfter && endA > pos))
                    return null;
                if (endA > pos || endA == pos && assoc < 0 && !len)
                    return pos == posA || assoc < 0 ? posB : posB + ins;
                posB += ins;
            }
            posA = endA;
        }
        if (pos > posA)
            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
        return posB;
    }
    /**
    Check whether these changes touch a given range. When one of the
    changes entirely covers the range, the string `"cover"` is
    returned.
    */
    touchesRange(from, to = from) {
        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {
            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
            if (ins >= 0 && pos <= to && end >= from)
                return pos < from && end > to ? "cover" : true;
            pos = end;
        }
        return false;
    }
    /**
    @internal
    */
    toString() {
        let result = "";
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
        }
        return result;
    }
    /**
    Serialize this change desc to a JSON-representable value.
    */
    toJSON() { return this.sections; }
    /**
    Create a change desc from its JSON representation (as produced
    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
    */
    static fromJSON(json) {
        if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != "number"))
            throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new ChangeDesc(json);
    }
    /**
    @internal
    */
    static create(sections) { return new ChangeDesc(sections); }
}
/**
A change set represents a group of modifications to a document. It
stores the document length, and can only be applied to documents
with exactly that length.
*/
class ChangeSet extends ChangeDesc {
    constructor(sections, 
    /**
    @internal
    */
    inserted) {
        super(sections);
        this.inserted = inserted;
    }
    /**
    Apply the changes to a document, returning the modified
    document.
    */
    apply(doc) {
        if (this.length != doc.length)
            throw new RangeError("Applying change set to a document with the wrong length");
        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
        return doc;
    }
    mapDesc(other, before = false) { return mapSet(this, other, before, true); }
    /**
    Given the document as it existed _before_ the changes, return a
    change set that represents the inverse of this set, which could
    be used to go from the document created by the changes back to
    the document as it existed before the changes.
    */
    invert(doc) {
        let sections = this.sections.slice(), inserted = [];
        for (let i = 0, pos = 0; i < sections.length; i += 2) {
            let len = sections[i], ins = sections[i + 1];
            if (ins >= 0) {
                sections[i] = ins;
                sections[i + 1] = len;
                let index = i >> 1;
                while (inserted.length < index)
                    inserted.push(Text.empty);
                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
            }
            pos += len;
        }
        return new ChangeSet(sections, inserted);
    }
    /**
    Combine two subsequent change sets into a single set. `other`
    must start in the document produced by `this`. If `this` goes
    `docA` → `docB` and `other` represents `docB` → `docC`, the
    returned value will represent the change `docA` → `docC`.
    */
    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }
    /**
    Given another change set starting in the same document, maps this
    change set over the other, producing a new change set that can be
    applied to the document produced by applying `other`. When
    `before` is `true`, order changes as if `this` comes before
    `other`, otherwise (the default) treat `other` as coming first.
    
    Given two changes `A` and `B`, `A.compose(B.map(A))` and
    `B.compose(A.map(B, true))` will produce the same document. This
    provides a basic form of [operational
    transformation](https://en.wikipedia.org/wiki/Operational_transformation),
    and can be used for collaborative editing.
    */
    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }
    /**
    Iterate over the changed ranges in the document, calling `f` for
    each, with the range in the original document (`fromA`-`toA`)
    and the range that replaces it in the new document
    (`fromB`-`toB`).
    
    When `individual` is true, adjacent changes are reported
    separately.
    */
    iterChanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    /**
    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
    set.
    */
    get desc() { return ChangeDesc.create(this.sections); }
    /**
    @internal
    */
    filter(ranges) {
        let resultSections = [], resultInserted = [], filteredSections = [];
        let iter = new SectionIter(this);
        done: for (let i = 0, pos = 0;;) {
            let next = i == ranges.length ? 1e9 : ranges[i++];
            while (pos < next || pos == next && iter.len == 0) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, next - pos);
                addSection(filteredSections, len, -1);
                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
                addSection(resultSections, len, ins);
                if (ins > 0)
                    addInsert(resultInserted, resultSections, iter.text);
                iter.forward(len);
                pos += len;
            }
            let end = ranges[i++];
            while (pos < end) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, end - pos);
                addSection(resultSections, len, -1);
                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
                iter.forward(len);
                pos += len;
            }
        }
        return { changes: new ChangeSet(resultSections, resultInserted),
            filtered: ChangeDesc.create(filteredSections) };
    }
    /**
    Serialize this change set to a JSON-representable value.
    */
    toJSON() {
        let parts = [];
        for (let i = 0; i < this.sections.length; i += 2) {
            let len = this.sections[i], ins = this.sections[i + 1];
            if (ins < 0)
                parts.push(len);
            else if (ins == 0)
                parts.push([len]);
            else
                parts.push([len].concat(this.inserted[i >> 1].toJSON()));
        }
        return parts;
    }
    /**
    Create a change set for the given changes, for a document of the
    given length, using `lineSep` as line separator.
    */
    static of(changes, length, lineSep) {
        let sections = [], inserted = [], pos = 0;
        let total = null;
        function flush(force = false) {
            if (!force && !sections.length)
                return;
            if (pos < length)
                addSection(sections, length - pos, -1);
            let set = new ChangeSet(sections, inserted);
            total = total ? total.compose(set.map(total)) : set;
            sections = [];
            inserted = [];
            pos = 0;
        }
        function process(spec) {
            if (Array.isArray(spec)) {
                for (let sub of spec)
                    process(sub);
            }
            else if (spec instanceof ChangeSet) {
                if (spec.length != length)
                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
                flush();
                total = total ? total.compose(spec.map(total)) : spec;
            }
            else {
                let { from, to = from, insert } = spec;
                if (from > to || from < 0 || to > length)
                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
                let insText = !insert ? Text.empty : typeof insert == "string" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;
                let insLen = insText.length;
                if (from == to && insLen == 0)
                    return;
                if (from < pos)
                    flush();
                if (from > pos)
                    addSection(sections, from - pos, -1);
                addSection(sections, to - from, insLen);
                addInsert(inserted, sections, insText);
                pos = to;
            }
        }
        process(changes);
        flush(!total);
        return total;
    }
    /**
    Create an empty changeset of the given length.
    */
    static empty(length) {
        return new ChangeSet(length ? [length, -1] : [], []);
    }
    /**
    Create a changeset from its JSON representation (as produced by
    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
    */
    static fromJSON(json) {
        if (!Array.isArray(json))
            throw new RangeError("Invalid JSON representation of ChangeSet");
        let sections = [], inserted = [];
        for (let i = 0; i < json.length; i++) {
            let part = json[i];
            if (typeof part == "number") {
                sections.push(part, -1);
            }
            else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i) => i && typeof e != "string")) {
                throw new RangeError("Invalid JSON representation of ChangeSet");
            }
            else if (part.length == 1) {
                sections.push(part[0], 0);
            }
            else {
                while (inserted.length < i)
                    inserted.push(Text.empty);
                inserted[i] = Text.of(part.slice(1));
                sections.push(part[0], inserted[i].length);
            }
        }
        return new ChangeSet(sections, inserted);
    }
    /**
    @internal
    */
    static createSet(sections, inserted) {
        return new ChangeSet(sections, inserted);
    }
}
function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
        return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1])
        sections[last] += len;
    else if (len == 0 && sections[last] == 0)
        sections[last + 1] += ins;
    else if (forceJoin) {
        sections[last] += len;
        sections[last + 1] += ins;
    }
    else
        sections.push(len, ins);
}
function addInsert(values, sections, value) {
    if (value.length == 0)
        return;
    let index = (sections.length - 2) >> 1;
    if (index < values.length) {
        values[values.length - 1] = values[values.length - 1].append(value);
    }
    else {
        while (values.length < index)
            values.push(Text.empty);
        values.push(value);
    }
}
function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {
        let len = desc.sections[i++], ins = desc.sections[i++];
        if (ins < 0) {
            posA += len;
            posB += len;
        }
        else {
            let endA = posA, endB = posB, text = Text.empty;
            for (;;) {
                endA += len;
                endB += ins;
                if (ins && inserted)
                    text = text.append(inserted[(i - 2) >> 1]);
                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
                    break;
                len = desc.sections[i++];
                ins = desc.sections[i++];
            }
            f(posA, endA, posB, endB, text);
            posA = endA;
            posB = endB;
        }
    }
}
function mapSet(setA, setB, before, mkSet = false) {
    // Produce a copy of setA that applies to the document after setB
    // has been applied (assuming both start at the same document).
    let sections = [], insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    // Iterate over both sets in parallel. inserted tracks, for changes
    // in A that have to be processed piece-by-piece, whether their
    // content has been inserted already, and refers to the section
    // index.
    for (let inserted = -1;;) {
        if (a.ins == -1 && b.ins == -1) {
            // Move across ranges skipped by both sets.
            let len = Math.min(a.len, b.len);
            addSection(sections, len, -1);
            a.forward(len);
            b.forward(len);
        }
        else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
            // If there's a change in B that comes before the next change in
            // A (ordered by start pos, then len, then before flag), skip
            // that (and process any changes in A it covers).
            let len = b.len;
            addSection(sections, b.ins, -1);
            while (len) {
                let piece = Math.min(a.len, len);
                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
                    addSection(sections, 0, a.ins);
                    if (insert)
                        addInsert(insert, sections, a.text);
                    inserted = a.i;
                }
                a.forward(piece);
                len -= piece;
            }
            b.next();
        }
        else if (a.ins >= 0) {
            // Process the part of a change in A up to the start of the next
            // non-deletion change in B (if overlapping).
            let len = 0, left = a.len;
            while (left) {
                if (b.ins == -1) {
                    let piece = Math.min(left, b.len);
                    len += piece;
                    left -= piece;
                    b.forward(piece);
                }
                else if (b.ins == 0 && b.len < left) {
                    left -= b.len;
                    b.next();
                }
                else {
                    break;
                }
            }
            addSection(sections, len, inserted < a.i ? a.ins : 0);
            if (insert && inserted < a.i)
                addInsert(insert, sections, a.text);
            inserted = a.i;
            a.forward(a.len - left);
        }
        else if (a.done && b.done) {
            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
        }
        else {
            throw new Error("Mismatched change set lengths");
        }
    }
}
function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false;;) {
        if (a.done && b.done) {
            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
        }
        else if (a.ins == 0) { // Deletion in A
            addSection(sections, a.len, 0, open);
            a.next();
        }
        else if (b.len == 0 && !b.done) { // Insertion in B
            addSection(sections, 0, b.ins, open);
            if (insert)
                addInsert(insert, sections, b.text);
            b.next();
        }
        else if (a.done || b.done) {
            throw new Error("Mismatched change set lengths");
        }
        else {
            let len = Math.min(a.len2, b.len), sectionLen = sections.length;
            if (a.ins == -1) {
                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
                addSection(sections, len, insB, open);
                if (insert && insB)
                    addInsert(insert, sections, b.text);
            }
            else if (b.ins == -1) {
                addSection(sections, a.off ? 0 : a.len, len, open);
                if (insert)
                    addInsert(insert, sections, a.textBit(len));
            }
            else {
                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
                if (insert && !b.off)
                    addInsert(insert, sections, b.text);
            }
            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
            a.forward2(len);
            b.forward(len);
        }
    }
}
class SectionIter {
    constructor(set) {
        this.set = set;
        this.i = 0;
        this.next();
    }
    next() {
        let { sections } = this.set;
        if (this.i < sections.length) {
            this.len = sections[this.i++];
            this.ins = sections[this.i++];
        }
        else {
            this.len = 0;
            this.ins = -2;
        }
        this.off = 0;
    }
    get done() { return this.ins == -2; }
    get len2() { return this.ins < 0 ? this.len : this.ins; }
    get text() {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length && !len ? Text.empty
            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
    }
    forward(len) {
        if (len == this.len)
            this.next();
        else {
            this.len -= len;
            this.off += len;
        }
    }
    forward2(len) {
        if (this.ins == -1)
            this.forward(len);
        else if (len == this.ins)
            this.next();
        else {
            this.ins -= len;
            this.off += len;
        }
    }
}

/**
A single selection range. When
[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
is enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold
multiple ranges. By default, selections hold exactly one range.
*/
class SelectionRange {
    constructor(
    /**
    The lower boundary of the range.
    */
    from, 
    /**
    The upper boundary of the range.
    */
    to, flags) {
        this.from = from;
        this.to = to;
        this.flags = flags;
    }
    /**
    The anchor of the range—the side that doesn't move when you
    extend it.
    */
    get anchor() { return this.flags & 32 /* RangeFlag.Inverted */ ? this.to : this.from; }
    /**
    The head of the range, which is moved when the range is
    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
    */
    get head() { return this.flags & 32 /* RangeFlag.Inverted */ ? this.from : this.to; }
    /**
    True when `anchor` and `head` are at the same position.
    */
    get empty() { return this.from == this.to; }
    /**
    If this is a cursor that is explicitly associated with the
    character on one of its sides, this returns the side. -1 means
    the character before its position, 1 the character after, and 0
    means no association.
    */
    get assoc() { return this.flags & 8 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 16 /* RangeFlag.AssocAfter */ ? 1 : 0; }
    /**
    The bidirectional text level associated with this cursor, if
    any.
    */
    get bidiLevel() {
        let level = this.flags & 7 /* RangeFlag.BidiLevelMask */;
        return level == 7 ? null : level;
    }
    /**
    The goal column (stored vertical offset) associated with a
    cursor. This is used to preserve the vertical position when
    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
    lines of different length.
    */
    get goalColumn() {
        let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */;
        return value == 16777215 /* RangeFlag.NoGoalColumn */ ? undefined : value;
    }
    /**
    Map this range through a change, producing a valid range in the
    updated document.
    */
    map(change, assoc = -1) {
        let from, to;
        if (this.empty) {
            from = to = change.mapPos(this.from, assoc);
        }
        else {
            from = change.mapPos(this.from, 1);
            to = change.mapPos(this.to, -1);
        }
        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    /**
    Extend this range to cover at least `from` to `to`.
    */
    extend(from, to = from) {
        if (from <= this.anchor && to >= this.anchor)
            return EditorSelection.range(from, to);
        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
        return EditorSelection.range(this.anchor, head);
    }
    /**
    Compare this range to another range.
    */
    eq(other, includeAssoc = false) {
        return this.anchor == other.anchor && this.head == other.head &&
            (!includeAssoc || !this.empty || this.assoc == other.assoc);
    }
    /**
    Return a JSON-serializable object representing the range.
    */
    toJSON() { return { anchor: this.anchor, head: this.head }; }
    /**
    Convert a JSON representation of a range to a `SelectionRange`
    instance.
    */
    static fromJSON(json) {
        if (!json || typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid JSON representation for SelectionRange");
        return EditorSelection.range(json.anchor, json.head);
    }
    /**
    @internal
    */
    static create(from, to, flags) {
        return new SelectionRange(from, to, flags);
    }
}
/**
An editor selection holds one or more selection ranges.
*/
class EditorSelection {
    constructor(
    /**
    The ranges in the selection, sorted by position. Ranges cannot
    overlap (but they may touch, if they aren't empty).
    */
    ranges, 
    /**
    The index of the _main_ range in the selection (which is
    usually the range that was added last).
    */
    mainIndex) {
        this.ranges = ranges;
        this.mainIndex = mainIndex;
    }
    /**
    Map a selection through a change. Used to adjust the selection
    position for changes.
    */
    map(change, assoc = -1) {
        if (change.empty)
            return this;
        return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);
    }
    /**
    Compare this selection to another selection. By default, ranges
    are compared only by position. When `includeAssoc` is true,
    cursor ranges must also have the same
    [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
    */
    eq(other, includeAssoc = false) {
        if (this.ranges.length != other.ranges.length ||
            this.mainIndex != other.mainIndex)
            return false;
        for (let i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].eq(other.ranges[i], includeAssoc))
                return false;
        return true;
    }
    /**
    Get the primary selection range. Usually, you should make sure
    your code applies to _all_ ranges, by using methods like
    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
    */
    get main() { return this.ranges[this.mainIndex]; }
    /**
    Make sure the selection only has one range. Returns a selection
    holding only the main range from this selection.
    */
    asSingle() {
        return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    /**
    Extend this selection with an extra range.
    */
    addRange(range, main = true) {
        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    /**
    Replace a given range with another range, and then normalize the
    selection to merge and sort ranges if necessary.
    */
    replaceRange(range, which = this.mainIndex) {
        let ranges = this.ranges.slice();
        ranges[which] = range;
        return EditorSelection.create(ranges, this.mainIndex);
    }
    /**
    Convert this selection to an object that can be serialized to
    JSON.
    */
    toJSON() {
        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };
    }
    /**
    Create a selection from a JSON representation.
    */
    static fromJSON(json) {
        if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
            throw new RangeError("Invalid JSON representation for EditorSelection");
        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    /**
    Create a selection holding a single range.
    */
    static single(anchor, head = anchor) {
        return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    /**
    Sort and merge the given set of ranges, creating a valid
    selection.
    */
    static create(ranges, mainIndex = 0) {
        if (ranges.length == 0)
            throw new RangeError("A selection needs at least one range");
        for (let pos = 0, i = 0; i < ranges.length; i++) {
            let range = ranges[i];
            if (range.empty ? range.from <= pos : range.from < pos)
                return EditorSelection.normalized(ranges.slice(), mainIndex);
            pos = range.to;
        }
        return new EditorSelection(ranges, mainIndex);
    }
    /**
    Create a cursor selection range at the given position. You can
    safely ignore the optional arguments in most situations.
    */
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 /* RangeFlag.AssocBefore */ : 16 /* RangeFlag.AssocAfter */) |
            (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) |
            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */));
    }
    /**
    Create a selection range.
    */
    static range(anchor, head, goalColumn, bidiLevel) {
        let flags = ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */) |
            (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
        return head < anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */ | 16 /* RangeFlag.AssocAfter */ | flags)
            : SelectionRange.create(anchor, head, (head > anchor ? 8 /* RangeFlag.AssocBefore */ : 0) | flags);
    }
    /**
    @internal
    */
    static normalized(ranges, mainIndex = 0) {
        let main = ranges[mainIndex];
        ranges.sort((a, b) => a.from - b.from);
        mainIndex = ranges.indexOf(main);
        for (let i = 1; i < ranges.length; i++) {
            let range = ranges[i], prev = ranges[i - 1];
            if (range.empty ? range.from <= prev.to : range.from < prev.to) {
                let from = prev.from, to = Math.max(range.to, prev.to);
                if (i <= mainIndex)
                    mainIndex--;
                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
            }
        }
        return new EditorSelection(ranges, mainIndex);
    }
}
function checkSelection(selection, docLength) {
    for (let range of selection.ranges)
        if (range.to > docLength)
            throw new RangeError("Selection points outside of document");
}

let nextID = 0;
/**
A facet is a labeled value that is associated with an editor
state. It takes inputs from any number of extensions, and combines
those into a single output value.

Examples of uses of facets are the [tab
size](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor
attributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update
listeners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).

Note that `Facet` instances can be used anywhere where
[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.
*/
class Facet {
    constructor(
    /**
    @internal
    */
    combine, 
    /**
    @internal
    */
    compareInput, 
    /**
    @internal
    */
    compare, isStatic, enables) {
        this.combine = combine;
        this.compareInput = compareInput;
        this.compare = compare;
        this.isStatic = isStatic;
        /**
        @internal
        */
        this.id = nextID++;
        this.default = combine([]);
        this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    /**
    Returns a facet reader for this facet, which can be used to
    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
    */
    get reader() { return this; }
    /**
    Define a new facet.
    */
    static define(config = {}) {
        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
    }
    /**
    Returns an extension that adds the given value to this facet.
    */
    of(value) {
        return new FacetProvider([], this, 0 /* Provider.Static */, value);
    }
    /**
    Create an extension that computes a value for the facet from a
    state. You must take care to declare the parts of the state that
    this value depends on, since your function is only called again
    for a new state when one of those parts changed.
    
    In cases where your value depends only on a single field, you'll
    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
    */
    compute(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 1 /* Provider.Single */, get);
    }
    /**
    Create an extension that computes zero or more values for this
    facet from a state.
    */
    computeN(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);
    }
    from(field, get) {
        if (!get)
            get = x => x;
        return this.compute([field], state => get(state.field(field)));
    }
}
function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
class FacetProvider {
    constructor(dependencies, facet, type, value) {
        this.dependencies = dependencies;
        this.facet = facet;
        this.type = type;
        this.value = value;
        this.id = nextID++;
    }
    dynamicSlot(addresses) {
        var _a;
        let getter = this.value;
        let compare = this.facet.compareInput;
        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */;
        let depDoc = false, depSel = false, depAddrs = [];
        for (let dep of this.dependencies) {
            if (dep == "doc")
                depDoc = true;
            else if (dep == "selection")
                depSel = true;
            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
                depAddrs.push(addresses[dep.id]);
        }
        return {
            create(state) {
                state.values[idx] = getter(state);
                return 1 /* SlotStatus.Changed */;
            },
            update(state, tr) {
                if ((depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {
                    let newVal = getter(state);
                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {
                        state.values[idx] = newVal;
                        return 1 /* SlotStatus.Changed */;
                    }
                }
                return 0;
            },
            reconfigure: (state, oldState) => {
                let newVal, oldAddr = oldState.config.address[id];
                if (oldAddr != null) {
                    let oldVal = getAddr(oldState, oldAddr);
                    if (this.dependencies.every(dep => {
                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) :
                            dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {
                        state.values[idx] = oldVal;
                        return 0;
                    }
                }
                else {
                    newVal = getter(state);
                }
                state.values[idx] = newVal;
                return 1 /* SlotStatus.Changed */;
            }
        };
    }
}
function compareArray(a, b, compare) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!compare(a[i], b[i]))
            return false;
    return true;
}
function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
        if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */)
            changed = true;
    return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map(p => addresses[p.id]);
    let providerTypes = providers.map(p => p.type);
    let dynamic = providerAddrs.filter(p => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get(state) {
        let values = [];
        for (let i = 0; i < providerAddrs.length; i++) {
            let value = getAddr(state, providerAddrs[i]);
            if (providerTypes[i] == 2 /* Provider.Multi */)
                for (let val of value)
                    values.push(val);
            else
                values.push(value);
        }
        return facet.combine(values);
    }
    return {
        create(state) {
            for (let addr of providerAddrs)
                ensureAddr(state, addr);
            state.values[idx] = get(state);
            return 1 /* SlotStatus.Changed */;
        },
        update(state, tr) {
            if (!ensureAll(state, dynamic))
                return 0;
            let value = get(state);
            if (facet.compare(value, state.values[idx]))
                return 0;
            state.values[idx] = value;
            return 1 /* SlotStatus.Changed */;
        },
        reconfigure(state, oldState) {
            let depChanged = ensureAll(state, providerAddrs);
            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
                state.values[idx] = oldValue;
                return 0;
            }
            let value = get(state);
            if (facet.compare(value, oldValue)) {
                state.values[idx] = oldValue;
                return 0;
            }
            state.values[idx] = value;
            return 1 /* SlotStatus.Changed */;
        }
    };
}
const initField = Facet.define({ static: true });
/**
Fields can store additional information in an editor state, and
keep it in sync with the rest of the state.
*/
class StateField {
    constructor(
    /**
    @internal
    */
    id, createF, updateF, compareF, 
    /**
    @internal
    */
    spec) {
        this.id = id;
        this.createF = createF;
        this.updateF = updateF;
        this.compareF = compareF;
        this.spec = spec;
        /**
        @internal
        */
        this.provides = undefined;
    }
    /**
    Define a state field.
    */
    static define(config) {
        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
        if (config.provide)
            field.provides = config.provide(field);
        return field;
    }
    create(state) {
        let init = state.facet(initField).find(i => i.field == this);
        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    /**
    @internal
    */
    slot(addresses) {
        let idx = addresses[this.id] >> 1;
        return {
            create: (state) => {
                state.values[idx] = this.create(state);
                return 1 /* SlotStatus.Changed */;
            },
            update: (state, tr) => {
                let oldVal = state.values[idx];
                let value = this.updateF(oldVal, tr);
                if (this.compareF(oldVal, value))
                    return 0;
                state.values[idx] = value;
                return 1 /* SlotStatus.Changed */;
            },
            reconfigure: (state, oldState) => {
                if (oldState.config.address[this.id] != null) {
                    state.values[idx] = oldState.field(this);
                    return 0;
                }
                state.values[idx] = this.create(state);
                return 1 /* SlotStatus.Changed */;
            }
        };
    }
    /**
    Returns an extension that enables this field and overrides the
    way it is initialized. Can be useful when you need to provide a
    non-default starting value for the field.
    */
    init(create) {
        return [this, initField.of({ field: this, create })];
    }
    /**
    State field instances can be used as
    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
    given state.
    */
    get extension() { return this; }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
    return (ext) => new PrecExtension(ext, value);
}
/**
By default extensions are registered in the order they are found
in the flattened form of nested array that was provided.
Individual extension values can be assigned a precedence to
override this. Extensions that do not have a precedence set get
the precedence of the nearest parent with a precedence, or
[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The
final ordering of extensions is determined by first sorting by
precedence and then by order within each precedence.
*/
const Prec = {
    /**
    The highest precedence level, for extensions that should end up
    near the start of the precedence ordering.
    */
    highest: prec(Prec_.highest),
    /**
    A higher-than-default precedence, for extensions that should
    come before those with default precedence.
    */
    high: prec(Prec_.high),
    /**
    The default precedence, which is also used for extensions
    without an explicit precedence.
    */
    default: prec(Prec_.default),
    /**
    A lower-than-default precedence.
    */
    low: prec(Prec_.low),
    /**
    The lowest precedence level. Meant for things that should end up
    near the end of the extension order.
    */
    lowest: prec(Prec_.lowest)
};
class PrecExtension {
    constructor(inner, prec) {
        this.inner = inner;
        this.prec = prec;
    }
}
/**
Extension compartments can be used to make a configuration
dynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your
configuration in a compartment, you can later
[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a
transaction.
*/
class Compartment {
    /**
    Create an instance of this compartment to add to your [state
    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
    */
    of(ext) { return new CompartmentInstance(this, ext); }
    /**
    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
    reconfigures this compartment.
    */
    reconfigure(content) {
        return Compartment.reconfigure.of({ compartment: this, extension: content });
    }
    /**
    Get the current content of the compartment in the state, or
    `undefined` if it isn't present.
    */
    get(state) {
        return state.config.compartments.get(this);
    }
}
class CompartmentInstance {
    constructor(compartment, inner) {
        this.compartment = compartment;
        this.inner = inner;
    }
}
class Configuration {
    constructor(base, compartments, dynamicSlots, address, staticValues, facets) {
        this.base = base;
        this.compartments = compartments;
        this.dynamicSlots = dynamicSlots;
        this.address = address;
        this.staticValues = staticValues;
        this.facets = facets;
        this.statusTemplate = [];
        while (this.statusTemplate.length < dynamicSlots.length)
            this.statusTemplate.push(0 /* SlotStatus.Unresolved */);
    }
    staticFacet(facet) {
        let addr = this.address[facet.id];
        return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base, compartments, oldState) {
        let fields = [];
        let facets = Object.create(null);
        let newCompartments = new Map();
        for (let ext of flatten(base, compartments, newCompartments)) {
            if (ext instanceof StateField)
                fields.push(ext);
            else
                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
        }
        let address = Object.create(null);
        let staticValues = [];
        let dynamicSlots = [];
        for (let field of fields) {
            address[field.id] = dynamicSlots.length << 1;
            dynamicSlots.push(a => field.slot(a));
        }
        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
        for (let id in facets) {
            let providers = facets[id], facet = providers[0].facet;
            let oldProviders = oldFacets && oldFacets[id] || [];
            if (providers.every(p => p.type == 0 /* Provider.Static */)) {
                address[facet.id] = (staticValues.length << 1) | 1;
                if (sameArray(oldProviders, providers)) {
                    staticValues.push(oldState.facet(facet));
                }
                else {
                    let value = facet.combine(providers.map(p => p.value));
                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
                }
            }
            else {
                for (let p of providers) {
                    if (p.type == 0 /* Provider.Static */) {
                        address[p.id] = (staticValues.length << 1) | 1;
                        staticValues.push(p.value);
                    }
                    else {
                        address[p.id] = dynamicSlots.length << 1;
                        dynamicSlots.push(a => p.dynamicSlot(a));
                    }
                }
                address[facet.id] = dynamicSlots.length << 1;
                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));
            }
        }
        let dynamic = dynamicSlots.map(f => f(address));
        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);
    }
}
function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = new Map();
    function inner(ext, prec) {
        let known = seen.get(ext);
        if (known != null) {
            if (known <= prec)
                return;
            let found = result[known].indexOf(ext);
            if (found > -1)
                result[known].splice(found, 1);
            if (ext instanceof CompartmentInstance)
                newCompartments.delete(ext.compartment);
        }
        seen.set(ext, prec);
        if (Array.isArray(ext)) {
            for (let e of ext)
                inner(e, prec);
        }
        else if (ext instanceof CompartmentInstance) {
            if (newCompartments.has(ext.compartment))
                throw new RangeError(`Duplicate use of compartment in extensions`);
            let content = compartments.get(ext.compartment) || ext.inner;
            newCompartments.set(ext.compartment, content);
            inner(content, prec);
        }
        else if (ext instanceof PrecExtension) {
            inner(ext.inner, ext.prec);
        }
        else if (ext instanceof StateField) {
            result[prec].push(ext);
            if (ext.provides)
                inner(ext.provides, prec);
        }
        else if (ext instanceof FacetProvider) {
            result[prec].push(ext);
            if (ext.facet.extensions)
                inner(ext.facet.extensions, Prec_.default);
        }
        else {
            let content = ext.extension;
            if (!content)
                throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
            inner(content, prec);
        }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
    if (addr & 1)
        return 2 /* SlotStatus.Computed */;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4 /* SlotStatus.Computing */)
        throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2 /* SlotStatus.Computed */)
        return status;
    state.status[idx] = 4 /* SlotStatus.Computing */;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;
}
function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}

const languageData = Facet.define();
const allowMultipleSelections = Facet.define({
    combine: values => values.some(v => v),
    static: true
});
const lineSeparator = Facet.define({
    combine: values => values.length ? values[0] : undefined,
    static: true
});
const changeFilter = Facet.define();
const transactionFilter = Facet.define();
const transactionExtender = Facet.define();
const readOnly = Facet.define({
    combine: values => values.length ? values[0] : false
});

/**
Annotations are tagged values that are used to add metadata to
transactions in an extensible way. They should be used to model
things that effect the entire transaction (such as its [time
stamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its
[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen
_alongside_ the other changes made by the transaction, [state
effects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.
*/
class Annotation {
    /**
    @internal
    */
    constructor(
    /**
    The annotation type.
    */
    type, 
    /**
    The value of this annotation.
    */
    value) {
        this.type = type;
        this.value = value;
    }
    /**
    Define a new type of annotation.
    */
    static define() { return new AnnotationType(); }
}
/**
Marker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).
*/
class AnnotationType {
    /**
    Create an instance of this annotation.
    */
    of(value) { return new Annotation(this, value); }
}
/**
Representation of a type of state effect. Defined with
[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).
*/
class StateEffectType {
    /**
    @internal
    */
    constructor(
    // The `any` types in these function types are there to work
    // around TypeScript issue #37631, where the type guard on
    // `StateEffect.is` mysteriously stops working when these properly
    // have type `Value`.
    /**
    @internal
    */
    map) {
        this.map = map;
    }
    /**
    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
    type.
    */
    of(value) { return new StateEffect(this, value); }
}
/**
State effects can be used to represent additional effects
associated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They
are often useful to model changes to custom [state
fields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in
document or selection changes.
*/
class StateEffect {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    type, 
    /**
    The value of this effect.
    */
    value) {
        this.type = type;
        this.value = value;
    }
    /**
    Map this effect through a position mapping. Will return
    `undefined` when that ends up deleting the effect.
    */
    map(mapping) {
        let mapped = this.type.map(this.value, mapping);
        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    /**
    Tells you whether this effect object is of a given
    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
    */
    is(type) { return this.type == type; }
    /**
    Define a new effect type. The type parameter indicates the type
    of values that his effect holds. It should be a type that
    doesn't include `undefined`, since that is used in
    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
    removed.
    */
    static define(spec = {}) {
        return new StateEffectType(spec.map || (v => v));
    }
    /**
    Map an array of effects through a change set.
    */
    static mapEffects(effects, mapping) {
        if (!effects.length)
            return effects;
        let result = [];
        for (let effect of effects) {
            let mapped = effect.map(mapping);
            if (mapped)
                result.push(mapped);
        }
        return result;
    }
}
/**
This effect can be used to reconfigure the root extensions of
the editor. Doing this will discard any extensions
[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset
the content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)
compartments.
*/
StateEffect.reconfigure = StateEffect.define();
/**
Append extensions to the top-level configuration of the editor.
*/
StateEffect.appendConfig = StateEffect.define();
/**
Changes to the editor state are grouped into transactions.
Typically, a user action creates a single transaction, which may
contain any number of document changes, may change the selection,
or have other effects. Create a transaction by calling
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately
dispatch one by calling
[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).
*/
class Transaction {
    constructor(
    /**
    The state from which the transaction starts.
    */
    startState, 
    /**
    The document changes made by this transaction.
    */
    changes, 
    /**
    The selection set by this transaction, or undefined if it
    doesn't explicitly set a selection.
    */
    selection, 
    /**
    The effects added to the transaction.
    */
    effects, 
    /**
    @internal
    */
    annotations, 
    /**
    Whether the selection should be scrolled into view after this
    transaction is dispatched.
    */
    scrollIntoView) {
        this.startState = startState;
        this.changes = changes;
        this.selection = selection;
        this.effects = effects;
        this.annotations = annotations;
        this.scrollIntoView = scrollIntoView;
        /**
        @internal
        */
        this._doc = null;
        /**
        @internal
        */
        this._state = null;
        if (selection)
            checkSelection(selection, changes.newLength);
        if (!annotations.some((a) => a.type == Transaction.time))
            this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    /**
    @internal
    */
    static create(startState, changes, selection, effects, annotations, scrollIntoView) {
        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);
    }
    /**
    The new document produced by the transaction. Contrary to
    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
    force the entire new state to be computed right away, so it is
    recommended that [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
    when they need to look at the new document.
    */
    get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    /**
    The new selection produced by the transaction. If
    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
    current selection through the changes made by the transaction.
    */
    get newSelection() {
        return this.selection || this.startState.selection.map(this.changes);
    }
    /**
    The new state created by the transaction. Computed on demand
    (but retained for subsequent access), so it is recommended not to
    access it in [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
    */
    get state() {
        if (!this._state)
            this.startState.applyTransaction(this);
        return this._state;
    }
    /**
    Get the value of the given annotation type, if any.
    */
    annotation(type) {
        for (let ann of this.annotations)
            if (ann.type == type)
                return ann.value;
        return undefined;
    }
    /**
    Indicates whether the transaction changed the document.
    */
    get docChanged() { return !this.changes.empty; }
    /**
    Indicates whether this transaction reconfigures the state
    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
    with a top-level configuration
    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
    */
    get reconfigured() { return this.startState.config != this.state.config; }
    /**
    Returns true if the transaction has a [user
    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
    or more specific than `event`. For example, if the transaction
    has `"select.pointer"` as user event, `"select"` and
    `"select.pointer"` will match it.
    */
    isUserEvent(event) {
        let e = this.annotation(Transaction.userEvent);
        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
    }
}
/**
Annotation used to store transaction timestamps. Automatically
added to every transaction, holding `Date.now()`.
*/
Transaction.time = Annotation.define();
/**
Annotation used to associate a transaction with a user interface
event. Holds a string identifying the event, using a
dot-separated format to support attaching more specific
information. The events used by the core libraries are:

 - `"input"` when content is entered
   - `"input.type"` for typed input
     - `"input.type.compose"` for composition
   - `"input.paste"` for pasted input
   - `"input.drop"` when adding content with drag-and-drop
   - `"input.complete"` when autocompleting
 - `"delete"` when the user deletes content
   - `"delete.selection"` when deleting the selection
   - `"delete.forward"` when deleting forward from the selection
   - `"delete.backward"` when deleting backward from the selection
   - `"delete.cut"` when cutting to the clipboard
 - `"move"` when content is moved
   - `"move.drop"` when content is moved within the editor through drag-and-drop
 - `"select"` when explicitly changing the selection
   - `"select.pointer"` when selecting with a mouse or other pointing device
 - `"undo"` and `"redo"` for history actions

Use [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check
whether the annotation matches a given event.
*/
Transaction.userEvent = Annotation.define();
/**
Annotation indicating whether a transaction should be added to
the undo history or not.
*/
Transaction.addToHistory = Annotation.define();
/**
Annotation indicating (when present and true) that a transaction
represents a change made by some other actor, not the user. This
is used, for example, to tag other people's changes in
collaborative editing.
*/
Transaction.remote = Annotation.define();
function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0;;) {
        let from, to;
        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
            from = a[iA++];
            to = a[iA++];
        }
        else if (iB < b.length) {
            from = b[iB++];
            to = b[iB++];
        }
        else
            return result;
        if (!result.length || result[result.length - 1] < from)
            result.push(from, to);
        else if (result[result.length - 1] < to)
            result[result.length - 1] = to;
    }
}
function mergeTransaction(a, b, sequential) {
    var _a;
    let mapForA, mapForB, changes;
    if (sequential) {
        mapForA = b.changes;
        mapForB = ChangeSet.empty(b.changes.length);
        changes = a.changes.compose(b.changes);
    }
    else {
        mapForA = b.changes.map(a.changes);
        mapForB = a.changes.mapDesc(b.changes, true);
        changes = a.changes.compose(mapForA);
    }
    return {
        changes,
        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
        scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
}
function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
        annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
        changes: spec.changes instanceof ChangeSet ? spec.changes
            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
        effects: asArray(spec.effects),
        annotations,
        scrollIntoView: !!spec.scrollIntoView
    };
}
function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
        filter = false;
    for (let i = 1; i < specs.length; i++) {
        if (specs[i].filter === false)
            filter = false;
        let seq = !!specs[i].sequential;
        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
}
// Finish a transaction by applying filters if necessary.
function filterTransaction(tr) {
    let state = tr.startState;
    // Change filters
    let result = true;
    for (let filter of state.facet(changeFilter)) {
        let value = filter(tr);
        if (value === false) {
            result = false;
            break;
        }
        if (Array.isArray(value))
            result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
        let changes, back;
        if (result === false) {
            back = tr.changes.invertedDesc;
            changes = ChangeSet.empty(state.doc.length);
        }
        else {
            let filtered = tr.changes.filter(result);
            changes = filtered.changes;
            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
        }
        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    // Transaction filters
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
        let filtered = filters[i](tr);
        if (filtered instanceof Transaction)
            tr = filtered;
        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
            tr = filtered[0];
        else
            tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
}
function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
        let extension = extenders[i](tr);
        if (extension && Object.keys(extension).length)
            spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none = [];
function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
}

/**
The categories produced by a [character
categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used
do things like selecting by word.
*/
exports.CharCategory = void 0;
(function (CharCategory) {
    /**
    Word characters.
    */
    CharCategory[CharCategory["Word"] = 0] = "Word";
    /**
    Whitespace.
    */
    CharCategory[CharCategory["Space"] = 1] = "Space";
    /**
    Anything else.
    */
    CharCategory[CharCategory["Other"] = 2] = "Other";
})(exports.CharCategory || (exports.CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
    wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
}
catch (_) { }
function hasWordChar(str) {
    if (wordChar)
        return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
        let ch = str[i];
        if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
            return true;
    }
    return false;
}
function makeCategorizer(wordChars) {
    return (char) => {
        if (!/\S/.test(char))
            return exports.CharCategory.Space;
        if (hasWordChar(char))
            return exports.CharCategory.Word;
        for (let i = 0; i < wordChars.length; i++)
            if (char.indexOf(wordChars[i]) > -1)
                return exports.CharCategory.Word;
        return exports.CharCategory.Other;
    };
}

/**
The editor state class is a persistent (immutable) data structure.
To update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a
[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state
instance, without modifying the original object.

As such, _never_ mutate properties of a state directly. That'll
just break things.
*/
class EditorState {
    constructor(
    /**
    @internal
    */
    config, 
    /**
    The current document.
    */
    doc, 
    /**
    The current selection.
    */
    selection, 
    /**
    @internal
    */
    values, computeSlot, tr) {
        this.config = config;
        this.doc = doc;
        this.selection = selection;
        this.values = values;
        this.status = config.statusTemplate.slice();
        this.computeSlot = computeSlot;
        // Fill in the computed state immediately, so that further queries
        // for it made during the update return this state
        if (tr)
            tr._state = this;
        for (let i = 0; i < this.config.dynamicSlots.length; i++)
            ensureAddr(this, i << 1);
        this.computeSlot = null;
    }
    field(field, require = true) {
        let addr = this.config.address[field.id];
        if (addr == null) {
            if (require)
                throw new RangeError("Field is not present in this state");
            return undefined;
        }
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /**
    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
    can be passed. Unless
    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
    are assumed to start in the _current_ document (not the document
    produced by previous specs), and its
    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
    to the document created by its _own_ changes. The resulting
    transaction contains the combined effect of all the different
    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
    specs take precedence over earlier ones.
    */
    update(...specs) {
        return resolveTransaction(this, specs, true);
    }
    /**
    @internal
    */
    applyTransaction(tr) {
        let conf = this.config, { base, compartments } = conf;
        for (let effect of tr.effects) {
            if (effect.is(Compartment.reconfigure)) {
                if (conf) {
                    compartments = new Map;
                    conf.compartments.forEach((val, key) => compartments.set(key, val));
                    conf = null;
                }
                compartments.set(effect.value.compartment, effect.value.extension);
            }
            else if (effect.is(StateEffect.reconfigure)) {
                conf = null;
                base = effect.value;
            }
            else if (effect.is(StateEffect.appendConfig)) {
                conf = null;
                base = asArray(base).concat(effect.value);
            }
        }
        let startValues;
        if (!conf) {
            conf = Configuration.resolve(base, compartments, this);
            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
            startValues = intermediateState.values;
        }
        else {
            startValues = tr.startState.values.slice();
        }
        let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
        new EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    /**
    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
    replaces every selection range with the given content.
    */
    replaceSelection(text) {
        if (typeof text == "string")
            text = this.toText(text);
        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },
            range: EditorSelection.cursor(range.from + text.length) }));
    }
    /**
    Create a set of changes and a new selection by running the given
    function for each range in the active selection. The function
    can return an optional set of changes (in the coordinate space
    of the start document), plus an updated range (in the coordinate
    space of the document produced by the call's own changes). This
    method will merge all the changes and ranges into a single
    changeset and selection, and return it as a [transaction
    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
    */
    changeByRange(f) {
        let sel = this.selection;
        let result1 = f(sel.ranges[0]);
        let changes = this.changes(result1.changes), ranges = [result1.range];
        let effects = asArray(result1.effects);
        for (let i = 1; i < sel.ranges.length; i++) {
            let result = f(sel.ranges[i]);
            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
            for (let j = 0; j < i; j++)
                ranges[j] = ranges[j].map(newMapped);
            let mapBy = changes.mapDesc(newChanges, true);
            ranges.push(result.range.map(mapBy));
            changes = changes.compose(newMapped);
            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
        }
        return {
            changes,
            selection: EditorSelection.create(ranges, sel.mainIndex),
            effects
        };
    }
    /**
    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
    description, taking the state's document length and line
    separator into account.
    */
    changes(spec = []) {
        if (spec instanceof ChangeSet)
            return spec;
        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    /**
    Using the state's [line
    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
    */
    toText(string) {
        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    /**
    Return the given range of the document as a string.
    */
    sliceDoc(from = 0, to = this.doc.length) {
        return this.doc.sliceString(from, to, this.lineBreak);
    }
    /**
    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
    */
    facet(facet) {
        let addr = this.config.address[facet.id];
        if (addr == null)
            return facet.default;
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /**
    Convert this state to a JSON-serializable object. When custom
    fields should be serialized, you can pass them in as an object
    mapping property names (in the resulting object, which should
    not use `doc` or `selection`) to fields.
    */
    toJSON(fields) {
        let result = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
        };
        if (fields)
            for (let prop in fields) {
                let value = fields[prop];
                if (value instanceof StateField && this.config.address[value.id] != null)
                    result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
            }
        return result;
    }
    /**
    Deserialize a state from its JSON representation. When custom
    fields should be deserialized, pass the same object you passed
    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
    third argument.
    */
    static fromJSON(json, config = {}, fields) {
        if (!json || typeof json.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
        let fieldInit = [];
        if (fields)
            for (let prop in fields) {
                if (Object.prototype.hasOwnProperty.call(json, prop)) {
                    let field = fields[prop], value = json[prop];
                    fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));
                }
            }
        return EditorState.create({
            doc: json.doc,
            selection: EditorSelection.fromJSON(json.selection),
            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
        });
    }
    /**
    Create a new state. You'll usually only need this when
    initializing an editor—updated states are created by applying
    transactions.
    */
    static create(config = {}) {
        let configuration = Configuration.resolve(config.extensions || [], new Map);
        let doc = config.doc instanceof Text ? config.doc
            : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
        let selection = !config.selection ? EditorSelection.single(0)
            : config.selection instanceof EditorSelection ? config.selection
                : EditorSelection.single(config.selection.anchor, config.selection.head);
        checkSelection(selection, doc.length);
        if (!configuration.staticFacet(allowMultipleSelections))
            selection = selection.asSingle();
        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    /**
    The size (in columns) of a tab in the document, determined by
    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
    */
    get tabSize() { return this.facet(EditorState.tabSize); }
    /**
    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
    string for this state.
    */
    get lineBreak() { return this.facet(EditorState.lineSeparator) || "\n"; }
    /**
    Returns true when the editor is
    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
    */
    get readOnly() { return this.facet(readOnly); }
    /**
    Look up a translation for the given phrase (via the
    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
    original string if no translation is found.
    
    If additional arguments are passed, they will be inserted in
    place of markers like `$1` (for the first value) and `$2`, etc.
    A single `$` is equivalent to `$1`, and `$$` will produce a
    literal dollar sign.
    */
    phrase(phrase, ...insert) {
        for (let map of this.facet(EditorState.phrases))
            if (Object.prototype.hasOwnProperty.call(map, phrase)) {
                phrase = map[phrase];
                break;
            }
        if (insert.length)
            phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
                if (i == "$")
                    return "$";
                let n = +(i || 1);
                return !n || n > insert.length ? m : insert[n - 1];
            });
        return phrase;
    }
    /**
    Find the values for a given language data field, provided by the
    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
    
    Examples of language data fields are...
    
    - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
      comment syntax.
    - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
      for providing language-specific completion sources.
    - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
      characters that should be considered part of words in this
      language.
    - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
      bracket closing behavior.
    */
    languageDataAt(name, pos, side = -1) {
        let values = [];
        for (let provider of this.facet(languageData)) {
            for (let result of provider(this, pos, side)) {
                if (Object.prototype.hasOwnProperty.call(result, name))
                    values.push(result[name]);
            }
        }
        return values;
    }
    /**
    Return a function that can categorize strings (expected to
    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
    into one of:
    
     - Word (contains an alphanumeric character or a character
       explicitly listed in the local language's `"wordChars"`
       language data, which should be a string)
     - Space (contains only whitespace)
     - Other (anything else)
    */
    charCategorizer(at) {
        return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    /**
    Find the word at the given position, meaning the range
    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
    around it. If no word characters are adjacent to the position,
    this returns null.
    */
    wordAt(pos) {
        let { text, from, length } = this.doc.lineAt(pos);
        let cat = this.charCategorizer(pos);
        let start = pos - from, end = pos - from;
        while (start > 0) {
            let prev = findClusterBreak(text, start, false);
            if (cat(text.slice(prev, start)) != exports.CharCategory.Word)
                break;
            start = prev;
        }
        while (end < length) {
            let next = findClusterBreak(text, end);
            if (cat(text.slice(end, next)) != exports.CharCategory.Word)
                break;
            end = next;
        }
        return start == end ? null : EditorSelection.range(start + from, end + from);
    }
}
/**
A facet that, when enabled, causes the editor to allow multiple
ranges to be selected. Be careful though, because by default the
editor relies on the native DOM selection, which cannot handle
multiple selections. An extension like
[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make
secondary selections visible to the user.
*/
EditorState.allowMultipleSelections = allowMultipleSelections;
/**
Configures the tab size to use in this state. The first
(highest-precedence) value of the facet is used. If no value is
given, this defaults to 4.
*/
EditorState.tabSize = Facet.define({
    combine: values => values.length ? values[0] : 4
});
/**
The line separator to use. By default, any of `"\n"`, `"\r\n"`
and `"\r"` is treated as a separator when splitting lines, and
lines are joined with `"\n"`.

When you configure a value here, only that precise separator
will be used, allowing you to round-trip documents through the
editor without normalizing line separators.
*/
EditorState.lineSeparator = lineSeparator;
/**
This facet controls the value of the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is
consulted by commands and extensions that implement editing
functionality to determine whether they should apply. It
defaults to false, but when its highest-precedence value is
`true`, such functionality disables itself.

Not to be confused with
[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which
controls whether the editor's DOM is set to be editable (and
thus focusable).
*/
EditorState.readOnly = readOnly;
/**
Registers translation phrases. The
[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through
all objects registered with this facet to find translations for
its argument.
*/
EditorState.phrases = Facet.define({
    compare(a, b) {
        let kA = Object.keys(a), kB = Object.keys(b);
        return kA.length == kB.length && kA.every(k => a[k] == b[k]);
    }
});
/**
A facet used to register [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.
*/
EditorState.languageData = languageData;
/**
Facet used to register change filters, which are called for each
transaction (unless explicitly
[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress
part of the transaction's changes.

Such a function can return `true` to indicate that it doesn't
want to do anything, `false` to completely stop the changes in
the transaction, or a set of ranges in which changes should be
suppressed. Such ranges are represented as an array of numbers,
with each pair of two numbers indicating the start and end of a
range. So for example `[10, 20, 100, 110]` suppresses changes
between 10 and 20, and between 100 and 110.
*/
EditorState.changeFilter = changeFilter;
/**
Facet used to register a hook that gets a chance to update or
replace transaction specs before they are applied. This will
only be applied for transactions that don't have
[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You
can either return a single transaction spec (possibly the input
transaction), or an array of specs (which will be combined in
the same way as the arguments to
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).

When possible, it is recommended to avoid accessing
[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,
since it will force creation of a state that will then be
discarded again, if the transaction is actually filtered.

(This functionality should be used with care. Indiscriminately
modifying transaction is likely to break something or degrade
the user experience.)
*/
EditorState.transactionFilter = transactionFilter;
/**
This is a more limited form of
[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),
which can only add
[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and
[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type
of filter runs even if the transaction has disabled regular
[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable
for effects that don't need to touch the changes or selection,
but do want to process every transaction.

Extenders run _after_ filters, when both are present.
*/
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = StateEffect.define();

/**
Utility function for combining behaviors to fill in a config
object from an array of provided configs. `defaults` should hold
default values for all optional fields in `Config`.

The function will, by default, error
when a field gets two values that aren't `===`-equal, but you can
provide combine functions per field to do something else.
*/
function combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that
combine = {}) {
    let result = {};
    for (let config of configs)
        for (let key of Object.keys(config)) {
            let value = config[key], current = result[key];
            if (current === undefined)
                result[key] = value;
            else if (current === value || value === undefined) ; // No conflict
            else if (Object.hasOwnProperty.call(combine, key))
                result[key] = combine[key](current, value);
            else
                throw new Error("Config merge conflict for field " + key);
        }
    for (let key in defaults)
        if (result[key] === undefined)
            result[key] = defaults[key];
    return result;
}

/**
Each range is associated with a value, which must inherit from
this class.
*/
class RangeValue {
    /**
    Compare this value with another value. Used when comparing
    rangesets. The default implementation compares by identity.
    Unless you are only creating a fixed number of unique instances
    of your value type, it is a good idea to implement this
    properly.
    */
    eq(other) { return this == other; }
    /**
    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
    */
    range(from, to = from) { return Range.create(from, to, this); }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = exports.MapMode.TrackDel;
/**
A range associates a value with a range of positions.
*/
class Range {
    constructor(
    /**
    The range's start position.
    */
    from, 
    /**
    Its end position.
    */
    to, 
    /**
    The value associated with this range.
    */
    value) {
        this.from = from;
        this.to = to;
        this.value = value;
    }
    /**
    @internal
    */
    static create(from, to, value) {
        return new Range(from, to, value);
    }
}
function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
}
class Chunk {
    constructor(from, to, value, 
    // Chunks are marked with the largest point that occurs
    // in them (or -1 for no points), so that scans that are
    // only interested in points (such as the
    // heightmap-related logic) can skip range-only chunks.
    maxPoint) {
        this.from = from;
        this.to = to;
        this.value = value;
        this.maxPoint = maxPoint;
    }
    get length() { return this.to[this.to.length - 1]; }
    // Find the index of the given position and side. Use the ranges'
    // `from` pos when `end == false`, `to` when `end == true`.
    findIndex(pos, side, end, startAt = 0) {
        let arr = end ? this.to : this.from;
        for (let lo = startAt, hi = arr.length;;) {
            if (lo == hi)
                return lo;
            let mid = (lo + hi) >> 1;
            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
            if (mid == lo)
                return diff >= 0 ? lo : hi;
            if (diff >= 0)
                hi = mid;
            else
                lo = mid + 1;
        }
    }
    between(offset, from, to, f) {
        for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i < e; i++)
            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
                return false;
    }
    map(offset, changes) {
        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
        for (let i = 0; i < this.value.length; i++) {
            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
            if (curFrom == curTo) {
                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
                if (mapped == null)
                    continue;
                newFrom = newTo = mapped;
                if (val.startSide != val.endSide) {
                    newTo = changes.mapPos(curFrom, val.endSide);
                    if (newTo < newFrom)
                        continue;
                }
            }
            else {
                newFrom = changes.mapPos(curFrom, val.startSide);
                newTo = changes.mapPos(curTo, val.endSide);
                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
                    continue;
            }
            if ((newTo - newFrom || val.endSide - val.startSide) < 0)
                continue;
            if (newPos < 0)
                newPos = newFrom;
            if (val.point)
                maxPoint = Math.max(maxPoint, newTo - newFrom);
            value.push(val);
            from.push(newFrom - newPos);
            to.push(newTo - newPos);
        }
        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
}
/**
A range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a
way that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and
[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data
structure.
*/
class RangeSet {
    constructor(
    /**
    @internal
    */
    chunkPos, 
    /**
    @internal
    */
    chunk, 
    /**
    @internal
    */
    nextLayer, 
    /**
    @internal
    */
    maxPoint) {
        this.chunkPos = chunkPos;
        this.chunk = chunk;
        this.nextLayer = nextLayer;
        this.maxPoint = maxPoint;
    }
    /**
    @internal
    */
    static create(chunkPos, chunk, nextLayer, maxPoint) {
        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    /**
    @internal
    */
    get length() {
        let last = this.chunk.length - 1;
        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    /**
    The number of ranges in the set.
    */
    get size() {
        if (this.isEmpty)
            return 0;
        let size = this.nextLayer.size;
        for (let chunk of this.chunk)
            size += chunk.value.length;
        return size;
    }
    /**
    @internal
    */
    chunkEnd(index) {
        return this.chunkPos[index] + this.chunk[index].length;
    }
    /**
    Update the range set, optionally adding new ranges or filtering
    out existing ones.
    
    (Note: The type parameter is just there as a kludge to work
    around TypeScript variance issues that prevented `RangeSet<X>`
    from being a subtype of `RangeSet<Y>` when `X` is a subtype of
    `Y`.)
    */
    update(updateSpec) {
        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
        let filter = updateSpec.filter;
        if (add.length == 0 && !filter)
            return this;
        if (sort)
            add = add.slice().sort(cmpRange);
        if (this.isEmpty)
            return add.length ? RangeSet.of(add) : this;
        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
        let builder = new RangeSetBuilder();
        while (cur.value || i < add.length) {
            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
                let range = add[i++];
                if (!builder.addInner(range.from, range.to, range.value))
                    spill.push(range);
            }
            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&
                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&
                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&
                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
                cur.nextChunk();
            }
            else {
                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
                    if (!builder.addInner(cur.from, cur.to, cur.value))
                        spill.push(Range.create(cur.from, cur.to, cur.value));
                }
                cur.next();
            }
        }
        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty
            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    /**
    Map this range set through a set of changes, return the new set.
    */
    map(changes) {
        if (changes.empty || this.isEmpty)
            return this;
        let chunks = [], chunkPos = [], maxPoint = -1;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            let touch = changes.touchesRange(start, start + chunk.length);
            if (touch === false) {
                maxPoint = Math.max(maxPoint, chunk.maxPoint);
                chunks.push(chunk);
                chunkPos.push(changes.mapPos(start));
            }
            else if (touch === true) {
                let { mapped, pos } = chunk.map(start, changes);
                if (mapped) {
                    maxPoint = Math.max(maxPoint, mapped.maxPoint);
                    chunks.push(mapped);
                    chunkPos.push(pos);
                }
            }
        }
        let next = this.nextLayer.map(changes);
        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    /**
    Iterate over the ranges that touch the region `from` to `to`,
    calling `f` for each. There is no guarantee that the ranges will
    be reported in any specific order. When the callback returns
    `false`, iteration stops.
    */
    between(from, to, f) {
        if (this.isEmpty)
            return;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            if (to >= start && from <= start + chunk.length &&
                chunk.between(start, from - start, to - start, f) === false)
                return;
        }
        this.nextLayer.between(from, to, f);
    }
    /**
    Iterate over the ranges in this set, in order, including all
    ranges that end at or after `from`.
    */
    iter(from = 0) {
        return HeapCursor.from([this]).goto(from);
    }
    /**
    @internal
    */
    get isEmpty() { return this.nextLayer == this; }
    /**
    Iterate over the ranges in a collection of sets, in order,
    starting from `from`.
    */
    static iter(sets, from = 0) {
        return HeapCursor.from(sets).goto(from);
    }
    /**
    Iterate over two groups of sets, calling methods on `comparator`
    to notify it of possible differences.
    */
    static compare(oldSets, newSets, 
    /**
    This indicates how the underlying data changed between these
    ranges, and is needed to synchronize the iteration.
    */
    textDiff, comparator, 
    /**
    Can be used to ignore all non-point ranges, and points below
    the given size. When -1, all ranges are compared.
    */
    minPointSize = -1) {
        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let sharedChunks = findSharedChunks(a, b, textDiff);
        let sideA = new SpanCursor(a, sharedChunks, minPointSize);
        let sideB = new SpanCursor(b, sharedChunks, minPointSize);
        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
        if (textDiff.empty && textDiff.length == 0)
            compare(sideA, 0, sideB, 0, 0, comparator);
    }
    /**
    Compare the contents of two groups of range sets, returning true
    if they are equivalent in the given range.
    */
    static eq(oldSets, newSets, from = 0, to) {
        if (to == null)
            to = 1000000000 /* C.Far */ - 1;
        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);
        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);
        if (a.length != b.length)
            return false;
        if (!a.length)
            return true;
        let sharedChunks = findSharedChunks(a, b);
        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
        for (;;) {
            if (sideA.to != sideB.to ||
                !sameValues(sideA.active, sideB.active) ||
                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
                return false;
            if (sideA.to > to)
                return true;
            sideA.next();
            sideB.next();
        }
    }
    /**
    Iterate over a group of range sets at the same time, notifying
    the iterator about the ranges covering every given piece of
    content. Returns the open count (see
    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
    of the iteration.
    */
    static spans(sets, from, to, iterator, 
    /**
    When given and greater than -1, only points of at least this
    size are taken into account.
    */
    minPointSize = -1) {
        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
        let openRanges = cursor.openStart;
        for (;;) {
            let curTo = Math.min(cursor.to, to);
            if (cursor.point) {
                let active = cursor.activeForPoint(cursor.to);
                let openCount = cursor.pointFrom < from ? active.length + 1
                    : cursor.point.startSide < 0 ? active.length
                        : Math.min(active.length, openRanges);
                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
                openRanges = Math.min(cursor.openEnd(curTo), active.length);
            }
            else if (curTo > pos) {
                iterator.span(pos, curTo, cursor.active, openRanges);
                openRanges = cursor.openEnd(curTo);
            }
            if (cursor.to > to)
                return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
            pos = cursor.to;
            cursor.next();
        }
    }
    /**
    Create a range set for the given range or array of ranges. By
    default, this expects the ranges to be _sorted_ (by start
    position and, if two start at the same position,
    `value.startSide`). You can pass `true` as second argument to
    cause the method to sort them.
    */
    static of(ranges, sort = false) {
        let build = new RangeSetBuilder();
        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
            build.add(range.from, range.to, range.value);
        return build.finish();
    }
    /**
    Join an array of range sets into a single set.
    */
    static join(sets) {
        if (!sets.length)
            return RangeSet.empty;
        let result = sets[sets.length - 1];
        for (let i = sets.length - 2; i >= 0; i--) {
            for (let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)
                result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));
        }
        return result;
    }
}
/**
The empty set of ranges.
*/
RangeSet.empty = new RangeSet([], [], null, -1);
function lazySort(ranges) {
    if (ranges.length > 1)
        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
            let cur = ranges[i];
            if (cmpRange(prev, cur) > 0)
                return ranges.slice().sort(cmpRange);
            prev = cur;
        }
    return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
/**
A range set builder is a data structure that helps build up a
[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating
an array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.
*/
class RangeSetBuilder {
    finishChunk(newArrays) {
        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
        this.chunkPos.push(this.chunkStart);
        this.chunkStart = -1;
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
        this.maxPoint = -1;
        if (newArrays) {
            this.from = [];
            this.to = [];
            this.value = [];
        }
    }
    /**
    Create an empty builder.
    */
    constructor() {
        this.chunks = [];
        this.chunkPos = [];
        this.chunkStart = -1;
        this.last = null;
        this.lastFrom = -1000000000 /* C.Far */;
        this.lastTo = -1000000000 /* C.Far */;
        this.from = [];
        this.to = [];
        this.value = [];
        this.maxPoint = -1;
        this.setMaxPoint = -1;
        this.nextLayer = null;
    }
    /**
    Add a range. Ranges should be added in sorted (by `from` and
    `value.startSide`) order.
    */
    add(from, to, value) {
        if (!this.addInner(from, to, value))
            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);
    }
    /**
    @internal
    */
    addInner(from, to, value) {
        let diff = from - this.lastTo || value.startSide - this.last.endSide;
        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
            throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        if (diff < 0)
            return false;
        if (this.from.length == 250 /* C.ChunkSize */)
            this.finishChunk(true);
        if (this.chunkStart < 0)
            this.chunkStart = from;
        this.from.push(from - this.chunkStart);
        this.to.push(to - this.chunkStart);
        this.last = value;
        this.lastFrom = from;
        this.lastTo = to;
        this.value.push(value);
        if (value.point)
            this.maxPoint = Math.max(this.maxPoint, to - from);
        return true;
    }
    /**
    @internal
    */
    addChunk(from, chunk) {
        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
            return false;
        if (this.from.length)
            this.finishChunk(true);
        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
        this.chunks.push(chunk);
        this.chunkPos.push(from);
        let last = chunk.value.length - 1;
        this.last = chunk.value[last];
        this.lastFrom = chunk.from[last] + from;
        this.lastTo = chunk.to[last] + from;
        return true;
    }
    /**
    Finish the range set. Returns the new set. The builder can't be
    used anymore after this has been called.
    */
    finish() { return this.finishInner(RangeSet.empty); }
    /**
    @internal
    */
    finishInner(next) {
        if (this.from.length)
            this.finishChunk(false);
        if (this.chunks.length == 0)
            return next;
        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
        this.from = null; // Make sure further `add` calls produce errors
        return result;
    }
}
function findSharedChunks(a, b, textDiff) {
    let inA = new Map();
    for (let set of a)
        for (let i = 0; i < set.chunk.length; i++)
            if (set.chunk[i].maxPoint <= 0)
                inA.set(set.chunk[i], set.chunkPos[i]);
    let shared = new Set();
    for (let set of b)
        for (let i = 0; i < set.chunk.length; i++) {
            let known = inA.get(set.chunk[i]);
            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&
                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
                shared.add(set.chunk[i]);
        }
    return shared;
}
class LayerCursor {
    constructor(layer, skip, minPoint, rank = 0) {
        this.layer = layer;
        this.skip = skip;
        this.minPoint = minPoint;
        this.rank = rank;
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    get endSide() { return this.value ? this.value.endSide : 0; }
    goto(pos, side = -1000000000 /* C.Far */) {
        this.chunkIndex = this.rangeIndex = 0;
        this.gotoInner(pos, side, false);
        return this;
    }
    gotoInner(pos, side, forward) {
        while (this.chunkIndex < this.layer.chunk.length) {
            let next = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(next) ||
                this.layer.chunkEnd(this.chunkIndex) < pos ||
                next.maxPoint < this.minPoint))
                break;
            this.chunkIndex++;
            forward = false;
        }
        if (this.chunkIndex < this.layer.chunk.length) {
            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
            if (!forward || this.rangeIndex < rangeIndex)
                this.setRangeIndex(rangeIndex);
        }
        this.next();
    }
    forward(pos, side) {
        if ((this.to - pos || this.endSide - side) < 0)
            this.gotoInner(pos, side, true);
    }
    next() {
        for (;;) {
            if (this.chunkIndex == this.layer.chunk.length) {
                this.from = this.to = 1000000000 /* C.Far */;
                this.value = null;
                break;
            }
            else {
                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
                let from = chunkPos + chunk.from[this.rangeIndex];
                this.from = from;
                this.to = chunkPos + chunk.to[this.rangeIndex];
                this.value = chunk.value[this.rangeIndex];
                this.setRangeIndex(this.rangeIndex + 1);
                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                    break;
            }
        }
    }
    setRangeIndex(index) {
        if (index == this.layer.chunk[this.chunkIndex].value.length) {
            this.chunkIndex++;
            if (this.skip) {
                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
                    this.chunkIndex++;
            }
            this.rangeIndex = 0;
        }
        else {
            this.rangeIndex = index;
        }
    }
    nextChunk() {
        this.chunkIndex++;
        this.rangeIndex = 0;
        this.next();
    }
    compare(other) {
        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||
            this.to - other.to || this.endSide - other.endSide;
    }
}
class HeapCursor {
    constructor(heap) {
        this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
        let heap = [];
        for (let i = 0; i < sets.length; i++) {
            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
                if (cur.maxPoint >= minPoint)
                    heap.push(new LayerCursor(cur, skip, minPoint, i));
            }
        }
        return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    goto(pos, side = -1000000000 /* C.Far */) {
        for (let cur of this.heap)
            cur.goto(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        this.next();
        return this;
    }
    forward(pos, side) {
        for (let cur of this.heap)
            cur.forward(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        if ((this.to - pos || this.value.endSide - side) < 0)
            this.next();
    }
    next() {
        if (this.heap.length == 0) {
            this.from = this.to = 1000000000 /* C.Far */;
            this.value = null;
            this.rank = -1;
        }
        else {
            let top = this.heap[0];
            this.from = top.from;
            this.to = top.to;
            this.value = top.value;
            this.rank = top.rank;
            if (top.value)
                top.next();
            heapBubble(this.heap, 0);
        }
    }
}
function heapBubble(heap, index) {
    for (let cur = heap[index];;) {
        let childIndex = (index << 1) + 1;
        if (childIndex >= heap.length)
            break;
        let child = heap[childIndex];
        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
            child = heap[childIndex + 1];
            childIndex++;
        }
        if (cur.compare(child) < 0)
            break;
        heap[childIndex] = cur;
        heap[index] = child;
        index = childIndex;
    }
}
class SpanCursor {
    constructor(sets, skip, minPoint) {
        this.minPoint = minPoint;
        this.active = [];
        this.activeTo = [];
        this.activeRank = [];
        this.minActive = -1;
        // A currently active point range, if any
        this.point = null;
        this.pointFrom = 0;
        this.pointRank = 0;
        this.to = -1000000000 /* C.Far */;
        this.endSide = 0;
        // The amount of open active ranges at the start of the iterator.
        // Not including points.
        this.openStart = -1;
        this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1000000000 /* C.Far */) {
        this.cursor.goto(pos, side);
        this.active.length = this.activeTo.length = this.activeRank.length = 0;
        this.minActive = -1;
        this.to = pos;
        this.endSide = side;
        this.openStart = -1;
        this.next();
        return this;
    }
    forward(pos, side) {
        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
            this.removeActive(this.minActive);
        this.cursor.forward(pos, side);
    }
    removeActive(index) {
        remove(this.active, index);
        remove(this.activeTo, index);
        remove(this.activeRank, index);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
        let i = 0, { value, to, rank } = this.cursor;
        // Organize active marks by rank first, then by size
        while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)
            i++;
        insert(this.active, i, value);
        insert(this.activeTo, i, to);
        insert(this.activeRank, i, rank);
        if (trackOpen)
            insert(trackOpen, i, this.cursor.from);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    // After calling this, if `this.point` != null, the next range is a
    // point. Otherwise, it's a regular range, covered by `this.active`.
    next() {
        let from = this.to, wasPoint = this.point;
        this.point = null;
        let trackOpen = this.openStart < 0 ? [] : null;
        for (;;) {
            let a = this.minActive;
            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
                if (this.activeTo[a] > from) {
                    this.to = this.activeTo[a];
                    this.endSide = this.active[a].endSide;
                    break;
                }
                this.removeActive(a);
                if (trackOpen)
                    remove(trackOpen, a);
            }
            else if (!this.cursor.value) {
                this.to = this.endSide = 1000000000 /* C.Far */;
                break;
            }
            else if (this.cursor.from > from) {
                this.to = this.cursor.from;
                this.endSide = this.cursor.startSide;
                break;
            }
            else {
                let nextVal = this.cursor.value;
                if (!nextVal.point) { // Opening a range
                    this.addActive(trackOpen);
                    this.cursor.next();
                }
                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
                    // Ignore any non-empty points that end precisely at the end of the prev point
                    this.cursor.next();
                }
                else { // New point
                    this.point = nextVal;
                    this.pointFrom = this.cursor.from;
                    this.pointRank = this.cursor.rank;
                    this.to = this.cursor.to;
                    this.endSide = nextVal.endSide;
                    this.cursor.next();
                    this.forward(this.to, this.endSide);
                    break;
                }
            }
        }
        if (trackOpen) {
            this.openStart = 0;
            for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
                this.openStart++;
        }
    }
    activeForPoint(to) {
        if (!this.active.length)
            return this.active;
        let active = [];
        for (let i = this.active.length - 1; i >= 0; i--) {
            if (this.activeRank[i] < this.pointRank)
                break;
            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
                active.push(this.active[i]);
        }
        return active.reverse();
    }
    openEnd(to) {
        let open = 0;
        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
            open++;
        return open;
    }
}
function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (;;) {
        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;
        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
        if (a.point || b.point) {
            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&
                sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
                comparator.comparePoint(pos, clipEnd, a.point, b.point);
        }
        else {
            if (clipEnd > pos && !sameValues(a.active, b.active))
                comparator.compareRange(pos, clipEnd, a.active, b.active);
        }
        if (end > endB)
            break;
        pos = end;
        if (diff <= 0)
            a.next();
        if (diff >= 0)
            b.next();
    }
}
function sameValues(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (a[i] != b[i] && !a[i].eq(b[i]))
            return false;
    return true;
}
function remove(array, index) {
    for (let i = index, e = array.length - 1; i < e; i++)
        array[i] = array[i + 1];
    array.pop();
}
function insert(array, index, value) {
    for (let i = array.length - 1; i >= index; i--)
        array[i + 1] = array[i];
    array[index] = value;
}
function findMinIndex(value, array) {
    let found = -1, foundPos = 1000000000 /* C.Far */;
    for (let i = 0; i < array.length; i++)
        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
            found = i;
            foundPos = array[i];
        }
    return found;
}

/**
Count the column position at the given offset into the string,
taking extending characters and tab size into account.
*/
function countColumn(string, tabSize, to = string.length) {
    let n = 0;
    for (let i = 0; i < to;) {
        if (string.charCodeAt(i) == 9) {
            n += tabSize - (n % tabSize);
            i++;
        }
        else {
            n++;
            i = findClusterBreak(string, i);
        }
    }
    return n;
}
/**
Find the offset that corresponds to the given column position in a
string, taking extending characters and tab size into account. By
default, the string length is returned when it is too short to
reach the column. Pass `strict` true to make it return -1 in that
situation.
*/
function findColumn(string, col, tabSize, strict) {
    for (let i = 0, n = 0;;) {
        if (n >= col)
            return i;
        if (i == string.length)
            break;
        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;
        i = findClusterBreak(string, i);
    }
    return strict === true ? -1 : string.length;
}

exports.Annotation = Annotation;
exports.AnnotationType = AnnotationType;
exports.ChangeDesc = ChangeDesc;
exports.ChangeSet = ChangeSet;
exports.Compartment = Compartment;
exports.EditorSelection = EditorSelection;
exports.EditorState = EditorState;
exports.Facet = Facet;
exports.Line = Line;
exports.Prec = Prec;
exports.Range = Range;
exports.RangeSet = RangeSet;
exports.RangeSetBuilder = RangeSetBuilder;
exports.RangeValue = RangeValue;
exports.SelectionRange = SelectionRange;
exports.StateEffect = StateEffect;
exports.StateEffectType = StateEffectType;
exports.StateField = StateField;
exports.Text = Text;
exports.Transaction = Transaction;
exports.codePointAt = codePointAt;
exports.codePointSize = codePointSize;
exports.combineConfig = combineConfig;
exports.countColumn = countColumn;
exports.findClusterBreak = findClusterBreak;
exports.findColumn = findColumn;
exports.fromCodePoint = fromCodePoint;


/***/ }),

/***/ "./node_modules/@codemirror/view/dist/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var state = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.cjs");
var styleMod = __webpack_require__(/*! style-mod */ "./node_modules/style-mod/dist/style-mod.cjs");
var w3cKeyname = __webpack_require__(/*! w3c-keyname */ "./node_modules/w3c-keyname/index.cjs");

function getSelection(root) {
    let target;
    // Browsers differ on whether shadow roots have a getSelection
    // method. If it exists, use that, otherwise, call it on the
    // document.
    if (root.nodeType == 11) { // Shadow root
        target = root.getSelection ? root : root.ownerDocument;
    }
    else {
        target = root;
    }
    return target.getSelection();
}
function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection) {
    if (!selection.anchorNode)
        return false;
    try {
        // Firefox will raise 'permission denied' errors when accessing
        // properties of `sel.anchorNode` when it's in a generated CSS
        // element.
        return contains(dom, selection.anchorNode);
    }
    catch (_) {
        return false;
    }
}
function clientRectsFor(dom) {
    if (dom.nodeType == 3)
        return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
        return dom.getClientRects();
    else
        return [];
}
// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||
        scanFor(node, off, targetNode, targetOff, 1)) : false;
}
function domIndex(node) {
    for (var index = 0;; index++) {
        node = node.previousSibling;
        if (!node)
            return index;
    }
}
function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
    for (;;) {
        if (node == targetNode && off == targetOff)
            return true;
        if (off == (dir < 0 ? 0 : maxOffset(node))) {
            if (node.nodeName == "DIV")
                return false;
            let parent = node.parentNode;
            if (!parent || parent.nodeType != 1)
                return false;
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
        }
        else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            if (node.nodeType == 1 && node.contentEditable == "false")
                return false;
            off = dir < 0 ? maxOffset(node) : 0;
        }
        else {
            return false;
        }
    }
}
function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
    let vp = win.visualViewport;
    if (vp)
        return {
            left: 0, right: vp.width,
            top: 0, bottom: vp.height
        };
    return { left: 0, right: win.innerWidth,
        top: 0, bottom: win.innerHeight };
}
function getScale(elt, rect) {
    let scaleX = rect.width / elt.offsetWidth;
    let scaleY = rect.height / elt.offsetHeight;
    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
        scaleX = 1;
    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
        scaleY = 1;
    return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    for (let cur = dom, stop = false; cur && !stop;) {
        if (cur.nodeType == 1) { // Element
            let bounding, top = cur == doc.body;
            let scaleX = 1, scaleY = 1;
            if (top) {
                bounding = windowRect(win);
            }
            else {
                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
                    stop = true;
                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
                    cur = cur.assignedSlot || cur.parentNode;
                    continue;
                }
                let rect = cur.getBoundingClientRect();
                ({ scaleX, scaleY } = getScale(cur, rect));
                // Make sure scrollbar width isn't included in the rectangle
                bounding = { left: rect.left, right: rect.left + cur.clientWidth * scaleX,
                    top: rect.top, bottom: rect.top + cur.clientHeight * scaleY };
            }
            let moveX = 0, moveY = 0;
            if (y == "nearest") {
                if (rect.top < bounding.top) {
                    moveY = -(bounding.top - rect.top + yMargin);
                    if (side > 0 && rect.bottom > bounding.bottom + moveY)
                        moveY = rect.bottom - bounding.bottom + moveY + yMargin;
                }
                else if (rect.bottom > bounding.bottom) {
                    moveY = rect.bottom - bounding.bottom + yMargin;
                    if (side < 0 && (rect.top - moveY) < bounding.top)
                        moveY = -(bounding.top + moveY - rect.top + yMargin);
                }
            }
            else {
                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
                let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 :
                    y == "start" || y == "center" && side < 0 ? rect.top - yMargin :
                        rect.bottom - boundingHeight + yMargin;
                moveY = targetTop - bounding.top;
            }
            if (x == "nearest") {
                if (rect.left < bounding.left) {
                    moveX = -(bounding.left - rect.left + xMargin);
                    if (side > 0 && rect.right > bounding.right + moveX)
                        moveX = rect.right - bounding.right + moveX + xMargin;
                }
                else if (rect.right > bounding.right) {
                    moveX = rect.right - bounding.right + xMargin;
                    if (side < 0 && rect.left < bounding.left + moveX)
                        moveX = -(bounding.left + moveX - rect.left + xMargin);
                }
            }
            else {
                let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 :
                    (x == "start") == ltr ? rect.left - xMargin :
                        rect.right - (bounding.right - bounding.left) + xMargin;
                moveX = targetLeft - bounding.left;
            }
            if (moveX || moveY) {
                if (top) {
                    win.scrollBy(moveX, moveY);
                }
                else {
                    let movedX = 0, movedY = 0;
                    if (moveY) {
                        let start = cur.scrollTop;
                        cur.scrollTop += moveY / scaleY;
                        movedY = (cur.scrollTop - start) * scaleY;
                    }
                    if (moveX) {
                        let start = cur.scrollLeft;
                        cur.scrollLeft += moveX / scaleX;
                        movedX = (cur.scrollLeft - start) * scaleX;
                    }
                    rect = { left: rect.left - movedX, top: rect.top - movedY,
                        right: rect.right - movedX, bottom: rect.bottom - movedY };
                    if (movedX && Math.abs(movedX - moveX) < 1)
                        x = "nearest";
                    if (movedY && Math.abs(movedY - moveY) < 1)
                        y = "nearest";
                }
            }
            if (top)
                break;
            cur = cur.assignedSlot || cur.parentNode;
        }
        else if (cur.nodeType == 11) { // A shadow root
            cur = cur.host;
        }
        else {
            break;
        }
    }
}
function scrollableParents(dom) {
    let doc = dom.ownerDocument, x, y;
    for (let cur = dom.parentNode; cur;) {
        if (cur == doc.body || (x && y)) {
            break;
        }
        else if (cur.nodeType == 1) {
            if (!y && cur.scrollHeight > cur.clientHeight)
                y = cur;
            if (!x && cur.scrollWidth > cur.clientWidth)
                x = cur;
            cur = cur.assignedSlot || cur.parentNode;
        }
        else if (cur.nodeType == 11) {
            cur = cur.host;
        }
        else {
            break;
        }
    }
    return { x, y };
}
class DOMSelectionState {
    constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
    }
    eq(domSel) {
        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&
            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
        let { anchorNode, focusNode } = range;
        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)
        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchorNode = anchorNode;
        this.anchorOffset = anchorOffset;
        this.focusNode = focusNode;
        this.focusOffset = focusOffset;
    }
}
let preventScrollSupported = null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom) {
    if (dom.setActive)
        return dom.setActive(); // in IE
    if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
        stack.push(cur, cur.scrollTop, cur.scrollLeft);
        if (cur == cur.ownerDocument)
            break;
    }
    dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
            preventScrollSupported = { preventScroll: true };
            return true;
        }
    } : undefined);
    if (!preventScrollSupported) {
        preventScrollSupported = false;
        for (let i = 0; i < stack.length;) {
            let elt = stack[i++], top = stack[i++], left = stack[i++];
            if (elt.scrollTop != top)
                elt.scrollTop = top;
            if (elt.scrollLeft != left)
                elt.scrollLeft = left;
        }
    }
}
let scratchRange;
function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
}
function dispatchKey(elt, name, code, mods) {
    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };
    if (mods)
        ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
    while (node) {
        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
            return node;
        node = node.assignedSlot || node.parentNode;
    }
    return null;
}
function clearAttributes(node) {
    while (node.attributes.length)
        node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc, selection) {
    let node = selection.focusNode, offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
        return false;
    // Safari can report bogus offsets (#1152)
    offset = Math.min(offset, maxOffset(node));
    for (;;) {
        if (offset) {
            if (node.nodeType != 1)
                return false;
            let prev = node.childNodes[offset - 1];
            if (prev.contentEditable == "false")
                offset--;
            else {
                node = prev;
                offset = maxOffset(node);
            }
        }
        else if (node == doc) {
            return true;
        }
        else {
            offset = domIndex(node);
            node = node.parentNode;
        }
    }
}
function isScrolledToBottom(elt) {
    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
    for (let node = startNode, offset = startOffset;;) {
        if (node.nodeType == 3 && offset > 0) {
            return { node: node, offset: offset };
        }
        else if (node.nodeType == 1 && offset > 0) {
            if (node.contentEditable == "false")
                return null;
            node = node.childNodes[offset - 1];
            offset = maxOffset(node);
        }
        else if (node.parentNode && !isBlockElement(node)) {
            offset = domIndex(node);
            node = node.parentNode;
        }
        else {
            return null;
        }
    }
}
function textNodeAfter(startNode, startOffset) {
    for (let node = startNode, offset = startOffset;;) {
        if (node.nodeType == 3 && offset < node.nodeValue.length) {
            return { node: node, offset: offset };
        }
        else if (node.nodeType == 1 && offset < node.childNodes.length) {
            if (node.contentEditable == "false")
                return null;
            node = node.childNodes[offset];
            offset = 0;
        }
        else if (node.parentNode && !isBlockElement(node)) {
            offset = domIndex(node) + 1;
            node = node.parentNode;
        }
        else {
            return null;
        }
    }
}

class DOMPos {
    constructor(node, offset, precise = true) {
        this.node = node;
        this.offset = offset;
        this.precise = precise;
    }
    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }
    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }
}
const noChildren = [];
class ContentView {
    constructor() {
        this.parent = null;
        this.dom = null;
        this.flags = 2 /* ViewFlag.NodeDirty */;
    }
    get overrideDOMText() { return null; }
    get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
        return this.posAtStart + this.length;
    }
    posBefore(view) {
        let pos = this.posAtStart;
        for (let child of this.children) {
            if (child == view)
                return pos;
            pos += child.length + child.breakAfter;
        }
        throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
        return this.posBefore(view) + view.length;
    }
    sync(view, track) {
        if (this.flags & 2 /* ViewFlag.NodeDirty */) {
            let parent = this.dom;
            let prev = null, next;
            for (let child of this.children) {
                if (child.flags & 7 /* ViewFlag.Dirty */) {
                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                        let contentView = ContentView.get(next);
                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                            child.reuseDOM(next);
                    }
                    child.sync(view, track);
                    child.flags &= ~7 /* ViewFlag.Dirty */;
                }
                next = prev ? prev.nextSibling : parent.firstChild;
                if (track && !track.written && track.node == parent && next != child.dom)
                    track.written = true;
                if (child.dom.parentNode == parent) {
                    while (next && next != child.dom)
                        next = rm$1(next);
                }
                else {
                    parent.insertBefore(child.dom, next);
                }
                prev = child.dom;
            }
            next = prev ? prev.nextSibling : parent.firstChild;
            if (next && track && track.node == parent)
                track.written = true;
            while (next)
                next = rm$1(next);
        }
        else if (this.flags & 1 /* ViewFlag.ChildDirty */) {
            for (let child of this.children)
                if (child.flags & 7 /* ViewFlag.Dirty */) {
                    child.sync(view, track);
                    child.flags &= ~7 /* ViewFlag.Dirty */;
                }
        }
    }
    reuseDOM(_dom) { }
    localPosFromDOM(node, offset) {
        let after;
        if (node == this.dom) {
            after = this.dom.childNodes[offset];
        }
        else {
            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
            for (;;) {
                let parent = node.parentNode;
                if (parent == this.dom)
                    break;
                if (bias == 0 && parent.firstChild != parent.lastChild) {
                    if (node == parent.firstChild)
                        bias = -1;
                    else
                        bias = 1;
                }
                node = parent;
            }
            if (bias < 0)
                after = node;
            else
                after = node.nextSibling;
        }
        if (after == this.dom.firstChild)
            return 0;
        while (after && !ContentView.get(after))
            after = after.nextSibling;
        if (!after)
            return this.length;
        for (let i = 0, pos = 0;; i++) {
            let child = this.children[i];
            if (child.dom == after)
                return pos;
            pos += child.length + child.breakAfter;
        }
    }
    domBoundsAround(from, to, offset = 0) {
        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
        for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos < from && end > to)
                return child.domBoundsAround(from, to, pos);
            if (end >= from && fromI == -1) {
                fromI = i;
                fromStart = pos;
            }
            if (pos > to && child.dom.parentNode == this.dom) {
                toI = i;
                toEnd = prevEnd;
                break;
            }
            prevEnd = end;
            pos = end + child.breakAfter;
        }
        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd,
            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null };
    }
    markDirty(andParent = false) {
        this.flags |= 2 /* ViewFlag.NodeDirty */;
        this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
        for (let parent = this.parent; parent; parent = parent.parent) {
            if (childList)
                parent.flags |= 2 /* ViewFlag.NodeDirty */;
            if (parent.flags & 1 /* ViewFlag.ChildDirty */)
                return;
            parent.flags |= 1 /* ViewFlag.ChildDirty */;
            childList = false;
        }
    }
    setParent(parent) {
        if (this.parent != parent) {
            this.parent = parent;
            if (this.flags & 7 /* ViewFlag.Dirty */)
                this.markParentsDirty(true);
        }
    }
    setDOM(dom) {
        if (this.dom == dom)
            return;
        if (this.dom)
            this.dom.cmView = null;
        this.dom = dom;
        dom.cmView = this;
    }
    get rootView() {
        for (let v = this;;) {
            let parent = v.parent;
            if (!parent)
                return v;
            v = parent;
        }
    }
    replaceChildren(from, to, children = noChildren) {
        this.markDirty();
        for (let i = from; i < to; i++) {
            let child = this.children[i];
            if (child.parent == this && children.indexOf(child) < 0)
                child.destroy();
        }
        if (children.length < 250)
            this.children.splice(from, to - from, ...children);
        else
            this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));
        for (let i = 0; i < children.length; i++)
            children[i].setParent(this);
    }
    ignoreMutation(_rec) { return false; }
    ignoreEvent(_event) { return false; }
    childCursor(pos = this.length) {
        return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
        return this.childCursor().findPos(pos, bias);
    }
    toString() {
        let name = this.constructor.name.replace("View", "");
        return name + (this.children.length ? "(" + this.children.join() + ")" :
            this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") +
            (this.breakAfter ? "#" : "");
    }
    static get(node) { return node.cmView; }
    get isEditable() { return true; }
    get isWidget() { return false; }
    get isHidden() { return false; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        return false;
    }
    become(other) { return false; }
    canReuseDOM(other) {
        return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
    }
    // When this is a zero-length view with a side, this should return a
    // number <= 0 to indicate it is before its position, or a
    // number > 0 when after its position.
    getSide() { return 0; }
    destroy() {
        for (let child of this.children)
            if (child.parent == this)
                child.destroy();
        this.parent = null;
    }
}
ContentView.prototype.breakAfter = 0;
// Remove a DOM node and return its next sibling.
function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
}
class ChildCursor {
    constructor(children, pos, i) {
        this.children = children;
        this.pos = pos;
        this.i = i;
        this.off = 0;
    }
    findPos(pos, bias = 1) {
        for (;;) {
            if (pos > this.pos || pos == this.pos &&
                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
                this.off = pos - this.pos;
                return this;
            }
            let next = this.children[--this.i];
            this.pos -= next.length + next.breakAfter;
        }
    }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert.length ? insert[insert.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    // Change within a single child
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 &&
        before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))
        return;
    if (toI < children.length) {
        let after = children[toI];
        // Make sure the end of the child after the update is preserved in `after`
        if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
            // If we're splitting a child, separate part of it to avoid that
            // being mangled when updating the child before the update.
            if (fromI == toI) {
                after = after.split(toOff);
                toOff = 0;
            }
            // If the element after the replacement should be merged with
            // the last replacing element, update `content`
            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
                insert[insert.length - 1] = after;
            }
            else {
                // Remove the start of the after element, if necessary, and
                // add it to `content`.
                if (toOff || after.children.length && !after.children[0].length)
                    after.merge(0, toOff, null, false, 0, openEnd);
                insert.push(after);
            }
        }
        else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
            // The element at `toI` is entirely covered by this range.
            // Preserve its line break, if any.
            if (last)
                last.breakAfter = 1;
            else
                breakAtStart = 1;
        }
        // Since we've handled the next element from the current elements
        // now, make sure `toI` points after that.
        toI++;
    }
    if (before) {
        before.breakAfter = breakAtStart;
        if (fromOff > 0) {
            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
                before.breakAfter = insert.shift().breakAfter;
            }
            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
                before.merge(fromOff, before.length, null, false, openStart, 0);
            }
            fromI++;
        }
    }
    // Try to merge widgets on the boundaries of the replacement
    while (fromI < toI && insert.length) {
        if (children[toI - 1].become(insert[insert.length - 1])) {
            toI--;
            insert.pop();
            openEnd = insert.length ? 0 : openStart;
        }
        else if (children[fromI].become(insert[0])) {
            fromI++;
            insert.shift();
            openStart = insert.length ? 0 : openEnd;
        }
        else {
            break;
        }
    }
    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter &&
        children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
        fromI--;
    if (fromI < toI || insert.length)
        parent.replaceChildren(fromI, toI, insert);
}
function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert)
        dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
}

let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /MSIE \d/.test(nav.userAgent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie && /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie && /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !ie && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
    mac: ios || /Mac/.test(nav.platform),
    windows: /Win/.test(nav.platform),
    linux: /Linux|X11/.test(nav.platform),
    ie,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};

const MaxJoinLen = 256;
class TextView extends ContentView {
    constructor(text) {
        super();
        this.text = text;
    }
    get length() { return this.text.length; }
    createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view, track) {
        if (!this.dom)
            this.createDOM();
        if (this.dom.nodeValue != this.text) {
            if (track && track.node == this.dom)
                track.written = true;
            this.dom.nodeValue = this.text;
        }
    }
    reuseDOM(dom) {
        if (dom.nodeType == 3)
            this.createDOM(dom);
    }
    merge(from, to, source) {
        if ((this.flags & 8 /* ViewFlag.Composition */) ||
            source && (!(source instanceof TextView) ||
                this.length - (to - from) + source.length > MaxJoinLen ||
                (source.flags & 8 /* ViewFlag.Composition */)))
            return false;
        this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = new TextView(this.text.slice(from));
        this.text = this.text.slice(0, from);
        this.markDirty();
        result.flags |= this.flags & 8 /* ViewFlag.Composition */;
        return result;
    }
    localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) { return new DOMPos(this.dom, pos); }
    domBoundsAround(_from, _to, offset) {
        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
        return textCoords(this.dom, pos, side);
    }
}
class MarkView extends ContentView {
    constructor(mark, children = [], length = 0) {
        super();
        this.mark = mark;
        this.children = children;
        this.length = length;
        for (let ch of children)
            ch.setParent(this);
    }
    setAttrs(dom) {
        clearAttributes(dom);
        if (this.mark.class)
            dom.className = this.mark.class;
        if (this.mark.attrs)
            for (let name in this.mark.attrs)
                dom.setAttribute(name, this.mark.attrs[name]);
        return dom;
    }
    canReuseDOM(other) {
        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
    }
    reuseDOM(node) {
        if (node.nodeName == this.mark.tagName.toUpperCase()) {
            this.setDOM(node);
            this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
        }
    }
    sync(view, track) {
        if (!this.dom)
            this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
        else if (this.flags & 4 /* ViewFlag.AttrsDirty */)
            this.setAttrs(this.dom);
        super.sync(view, track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||
            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))
            return false;
        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = [], off = 0, detachFrom = -1, i = 0;
        for (let elt of this.children) {
            let end = off + elt.length;
            if (end > from)
                result.push(off < from ? elt.split(from - off) : elt);
            if (detachFrom < 0 && off >= from)
                detachFrom = i;
            off = end;
            i++;
        }
        let length = this.length - from;
        this.length = from;
        if (detachFrom > -1) {
            this.children.length = detachFrom;
            this.markDirty();
        }
        return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
    }
}
function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
        pos = length;
    let from = pos, to = pos, flatten = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
        if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges
            if (pos) {
                from--;
                flatten = 1;
            } // FIXME this is wrong in RTL text
            else if (to < length) {
                to++;
                flatten = -1;
            }
        }
    }
    else {
        if (side < 0)
            from--;
        else if (to < length)
            to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
        return null;
    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten && rect.width == 0)
        rect = Array.prototype.find.call(rects, r => r.width) || rect;
    return flatten ? flattenRect(rect, flatten < 0) : rect || null;
}
// Also used for collapsed ranges that don't have a placeholder widget!
class WidgetView extends ContentView {
    static create(widget, length, side) {
        return new WidgetView(widget, length, side);
    }
    constructor(widget, length, side) {
        super();
        this.widget = widget;
        this.length = length;
        this.side = side;
        this.prevWidget = null;
    }
    split(from) {
        let result = WidgetView.create(this.widget, this.length - from, this.side);
        this.length -= from;
        return result;
    }
    sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            if (!this.widget.editable)
                this.dom.contentEditable = "false";
        }
    }
    getSide() { return this.side; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    become(other) {
        if (other instanceof WidgetView && other.side == this.side &&
            this.widget.constructor == other.widget.constructor) {
            if (!this.widget.compare(other.widget))
                this.markDirty(true);
            if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get overrideDOMText() {
        if (this.length == 0)
            return state.Text.empty;
        let top = this;
        while (top.parent)
            top = top.parent;
        let { view } = top, text = view && view.state.doc, start = this.posAtStart;
        return text ? text.slice(start, start + this.length) : state.Text.empty;
    }
    domAtPos(pos) {
        return (this.length ? pos == 0 : this.side > 0)
            ? DOMPos.before(this.dom)
            : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() { return null; }
    coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
            return custom;
        let rects = this.dom.getClientRects(), rect = null;
        if (!rects.length)
            return null;
        let fromBack = this.side ? this.side < 0 : pos > 0;
        for (let i = fromBack ? rects.length - 1 : 0;; i += (fromBack ? -1 : 1)) {
            rect = rects[i];
            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
                break;
        }
        return flattenRect(rect, !fromBack);
    }
    get isEditable() { return false; }
    get isWidget() { return true; }
    get isHidden() { return this.widget.isHidden; }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
}
// These are drawn around uneditable widgets to avoid a number of
// browser bugs that show up when the cursor is directly next to
// uneditable inline content.
class WidgetBufferView extends ContentView {
    constructor(side) {
        super();
        this.side = side;
    }
    get length() { return 0; }
    merge() { return false; }
    become(other) {
        return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() { return new WidgetBufferView(this.side); }
    sync() {
        if (!this.dom) {
            let dom = document.createElement("img");
            dom.className = "cm-widgetBuffer";
            dom.setAttribute("aria-hidden", "true");
            this.setDOM(dom);
        }
    }
    getSide() { return this.side; }
    domAtPos(pos) { return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom); }
    localPosFromDOM() { return 0; }
    domBoundsAround() { return null; }
    coordsAt(pos) {
        return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
        return state.Text.empty;
    }
    get isHidden() { return true; }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children } = parent, i = 0;
    for (let off = 0; i < children.length; i++) {
        let child = children[i], end = off + child.length;
        if (end == off && child.getSide() <= 0)
            continue;
        if (pos > off && pos < end && child.dom.parentNode == dom)
            return child.domAtPos(pos - off);
        if (pos <= off)
            break;
        off = end;
    }
    for (let j = i; j > 0; j--) {
        let prev = children[j - 1];
        if (prev.dom.parentNode == dom)
            return prev.domAtPos(prev.length);
    }
    for (let j = i; j < children.length; j++) {
        let next = children[j];
        if (next.dom.parentNode == dom)
            return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
}
// Assumes `view`, if a mark view, has precisely 1 child.
function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length &&
        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
        joinInlineInto(last, view.children[0], open - 1);
    }
    else {
        children.push(view);
        view.setParent(parent);
    }
    parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view, pos) {
        for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {
            let child = view.children[i], end = off + child.length;
            if (end >= pos) {
                if (child.children.length) {
                    scan(child, pos - off);
                }
                else if ((!after || after.isHidden && side > 0) &&
                    (end > pos || off == end && child.getSide() > 0)) {
                    after = child;
                    afterPos = pos - off;
                }
                else if (off < pos || (off == end && child.getSide() < 0) && !child.isHidden) {
                    before = child;
                    beforePos = pos - off;
                }
            }
            off = end;
        }
    }
    scan(view, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
        return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
}
function fallbackRect(view) {
    let last = view.dom.lastChild;
    if (!last)
        return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
}

function combineAttrs(source, target) {
    for (let name in source) {
        if (name == "class" && target.class)
            target.class += " " + source.class;
        else if (name == "style" && target.style)
            target.style += ";" + source.style;
        else
            target[name] = source[name];
    }
    return target;
}
const noAttrs = Object.create(null);
function attrsEq(a, b, ignore) {
    if (a == b)
        return true;
    if (!a)
        a = noAttrs;
    if (!b)
        b = noAttrs;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) !=
        keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
        return false;
    for (let key of keysA) {
        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
            return false;
    }
    return true;
}
function updateAttrs(dom, prev, attrs) {
    let changed = false;
    if (prev)
        for (let name in prev)
            if (!(attrs && name in attrs)) {
                changed = true;
                if (name == "style")
                    dom.style.cssText = "";
                else
                    dom.removeAttribute(name);
            }
    if (attrs)
        for (let name in attrs)
            if (!(prev && prev[name] == attrs[name])) {
                changed = true;
                if (name == "style")
                    dom.style.cssText = attrs[name];
                else
                    dom.setAttribute(name, attrs[name]);
            }
    return changed;
}
function getAttrs(dom) {
    let attrs = Object.create(null);
    for (let i = 0; i < dom.attributes.length; i++) {
        let attr = dom.attributes[i];
        attrs[attr.name] = attr.value;
    }
    return attrs;
}

/**
Widgets added to the content are described by subclasses of this
class. Using a description object like that makes it possible to
delay creating of the DOM structure for a widget until it is
needed, and to avoid redrawing widgets even if the decorations
that define them are recreated.
*/
class WidgetType {
    /**
    Compare this instance to another instance of the same type.
    (TypeScript can't express this, but only instances of the same
    specific class will be passed to this method.) This is used to
    avoid redrawing widgets when they are replaced by a new
    decoration of the same type. The default implementation just
    returns `false`, which will cause new instances of the widget to
    always be redrawn.
    */
    eq(widget) { return false; }
    /**
    Update a DOM element created by a widget of the same type (but
    different, non-`eq` content) to reflect this widget. May return
    true to indicate that it could update, false to indicate it
    couldn't (in which case the widget will be redrawn). The default
    implementation just returns false.
    */
    updateDOM(dom, view) { return false; }
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    The estimated height this widget will have, to be used when
    estimating the height of content that hasn't been drawn. May
    return -1 to indicate you don't know. The default implementation
    returns -1.
    */
    get estimatedHeight() { return -1; }
    /**
    For inline widgets that are displayed inline (as opposed to
    `inline-block`) and introduce line breaks (through `<br>` tags
    or textual newlines), this must indicate the amount of line
    breaks they introduce. Defaults to 0.
    */
    get lineBreaks() { return 0; }
    /**
    Can be used to configure which kinds of events inside the widget
    should be ignored by the editor. The default is to ignore all
    events.
    */
    ignoreEvent(event) { return true; }
    /**
    Override the way screen coordinates for positions at/in the
    widget are found. `pos` will be the offset into the widget, and
    `side` the side of the position that is being queried—less than
    zero for before, greater than zero for after, and zero for
    directly at that position.
    */
    coordsAt(dom, pos, side) { return null; }
    /**
    @internal
    */
    get isHidden() { return false; }
    /**
    @internal
    */
    get editable() { return false; }
    /**
    This is called when the an instance of the widget is removed
    from the editor view.
    */
    destroy(dom) { }
}
/**
The different types of blocks that can occur in an editor view.
*/
exports.BlockType = void 0;
(function (BlockType) {
    /**
    A line of text.
    */
    BlockType[BlockType["Text"] = 0] = "Text";
    /**
    A block widget associated with the position after it.
    */
    BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
    /**
    A block widget associated with the position before it.
    */
    BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
    /**
    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.
    */
    BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
})(exports.BlockType || (exports.BlockType = {}));
/**
A decoration provides information on how to draw or style a piece
of content. You'll usually use it wrapped in a
[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.
@nonabstract
*/
class Decoration extends state.RangeValue {
    constructor(
    /**
    @internal
    */
    startSide, 
    /**
    @internal
    */
    endSide, 
    /**
    @internal
    */
    widget, 
    /**
    The config object used to create this decoration. You can
    include additional properties in there to store metadata about
    your decoration.
    */
    spec) {
        super();
        this.startSide = startSide;
        this.endSide = endSide;
        this.widget = widget;
        this.spec = spec;
    }
    /**
    @internal
    */
    get heightRelevant() { return false; }
    /**
    Create a mark decoration, which influences the styling of the
    content in its range. Nested mark decorations will cause nested
    DOM elements to be created. Nesting order is determined by
    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
    the higher-precedence decorations creating the inner DOM nodes.
    Such elements are split on line boundaries and on the boundaries
    of lower-precedence decorations.
    */
    static mark(spec) {
        return new MarkDecoration(spec);
    }
    /**
    Create a widget decoration, which displays a DOM element at the
    given position.
    */
    static widget(spec) {
        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;
        side += (block && !spec.inlineOrder)
            ? (side > 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */)
            : (side > 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */);
        return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    /**
    Create a replace decoration which replaces the given range with
    a widget, or simply hides it.
    */
    static replace(spec) {
        let block = !!spec.block, startSide, endSide;
        if (spec.isBlockGap) {
            startSide = -500000000 /* Side.GapStart */;
            endSide = 400000000 /* Side.GapEnd */;
        }
        else {
            let { start, end } = getInclusive(spec, block);
            startSide = (start ? (block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */) : 500000000 /* Side.NonIncStart */) - 1;
            endSide = (end ? (block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */) : -600000000 /* Side.NonIncEnd */) + 1;
        }
        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    /**
    Create a line decoration, which can add DOM attributes to the
    line starting at the given position.
    */
    static line(spec) {
        return new LineDecoration(spec);
    }
    /**
    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
    decorated range or ranges. If the ranges aren't already sorted,
    pass `true` for `sort` to make the library sort them for you.
    */
    static set(of, sort = false) {
        return state.RangeSet.of(of, sort);
    }
    /**
    @internal
    */
    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }
}
/**
The empty set of decorations.
*/
Decoration.none = state.RangeSet.empty;
class MarkDecoration extends Decoration {
    constructor(spec) {
        let { start, end } = getInclusive(spec);
        super(start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);
        this.tagName = spec.tagName || "span";
        this.class = spec.class || "";
        this.attrs = spec.attributes || null;
    }
    eq(other) {
        var _a, _b;
        return this == other ||
            other instanceof MarkDecoration &&
                this.tagName == other.tagName &&
                (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) &&
                attrsEq(this.attrs, other.attrs, "class");
    }
    range(from, to = from) {
        if (from >= to)
            throw new RangeError("Mark decorations may not be empty");
        return super.range(from, to);
    }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
    constructor(spec) {
        super(-200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);
    }
    eq(other) {
        return other instanceof LineDecoration &&
            this.spec.class == other.spec.class &&
            attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
        if (to != from)
            throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(from, to);
    }
}
LineDecoration.prototype.mapMode = state.MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
        super(startSide, endSide, widget, spec);
        this.block = block;
        this.isReplace = isReplace;
        this.mapMode = !block ? state.MapMode.TrackDel : startSide <= 0 ? state.MapMode.TrackBefore : state.MapMode.TrackAfter;
    }
    // Only relevant when this.block == true
    get type() {
        return this.startSide != this.endSide ? exports.BlockType.WidgetRange
            : this.startSide <= 0 ? exports.BlockType.WidgetBefore : exports.BlockType.WidgetAfter;
    }
    get heightRelevant() {
        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(other) {
        return other instanceof PointDecoration &&
            widgetsEq(this.widget, other.widget) &&
            this.block == other.block &&
            this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide <= 0)))
            throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && to != from)
            throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(from, to);
    }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null)
        start = spec.inclusive;
    if (end == null)
        end = spec.inclusive;
    return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from)
        ranges[last] = Math.max(ranges[last], to);
    else
        ranges.push(from, to);
}

class LineView extends ContentView {
    constructor() {
        super(...arguments);
        this.children = [];
        this.length = 0;
        this.prevAttrs = undefined;
        this.attrs = null;
        this.breakAfter = 0;
    }
    // Consumes source
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source) {
            if (!(source instanceof LineView))
                return false;
            if (!this.dom)
                source.transferDOM(this); // Reuse source.dom when appropriate
        }
        if (hasStart)
            this.setDeco(source ? source.attrs : null);
        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);
        return true;
    }
    split(at) {
        let end = new LineView;
        end.breakAfter = this.breakAfter;
        if (this.length == 0)
            return end;
        let { i, off } = this.childPos(at);
        if (off) {
            end.append(this.children[i].split(off), 0);
            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
            i++;
        }
        for (let j = i; j < this.children.length; j++)
            end.append(this.children[j], 0);
        while (i > 0 && this.children[i - 1].length == 0)
            this.children[--i].destroy();
        this.children.length = i;
        this.markDirty();
        this.length = at;
        return end;
    }
    transferDOM(other) {
        if (!this.dom)
            return;
        this.markDirty();
        other.setDOM(this.dom);
        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
        this.prevAttrs = undefined;
        this.dom = null;
    }
    setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
            if (this.dom) {
                this.prevAttrs = this.attrs;
                this.markDirty();
            }
            this.attrs = attrs;
        }
    }
    append(child, openStart) {
        joinInlineInto(this, child, openStart);
    }
    // Only called when building a line view in ContentBuilder
    addLineDeco(deco) {
        let attrs = deco.spec.attributes, cls = deco.spec.class;
        if (attrs)
            this.attrs = combineAttrs(attrs, this.attrs || {});
        if (cls)
            this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
        if (node.nodeName == "DIV") {
            this.setDOM(node);
            this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
        }
    }
    sync(view, track) {
        var _a;
        if (!this.dom) {
            this.setDOM(document.createElement("div"));
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        else if (this.flags & 4 /* ViewFlag.AttrsDirty */) {
            clearAttributes(this.dom);
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        if (this.prevAttrs !== undefined) {
            updateAttrs(this.dom, this.prevAttrs, this.attrs);
            this.dom.classList.add("cm-line");
            this.prevAttrs = undefined;
        }
        super.sync(view, track);
        let last = this.dom.lastChild;
        while (last && ContentView.get(last) instanceof MarkView)
            last = last.lastChild;
        if (!last || !this.length ||
            last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false &&
                (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {
            let hack = document.createElement("BR");
            hack.cmIgnore = true;
            this.dom.appendChild(hack);
        }
    }
    measureTextSize() {
        if (this.children.length == 0 || this.length > 20)
            return null;
        let totalWidth = 0, textHeight;
        for (let child of this.children) {
            if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
                return null;
            let rects = clientRectsFor(child.dom);
            if (rects.length != 1)
                return null;
            totalWidth += rects[0].width;
            textHeight = rects[0].height;
        }
        return !totalWidth ? null : {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: totalWidth / this.length,
            textHeight
        };
    }
    coordsAt(pos, side) {
        let rect = coordsInChildren(this, pos, side);
        // Correct rectangle height for empty lines when the returned
        // height is larger than the text height.
        if (!this.children.length && rect && this.parent) {
            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
                let dist = (height - heightOracle.textHeight) / 2;
                return { top: rect.top + dist, bottom: rect.bottom - dist, left: rect.left, right: rect.left };
            }
        }
        return rect;
    }
    become(other) {
        return other instanceof LineView && this.children.length == 0 && other.children.length == 0 &&
            attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
    }
    covers() { return true; }
    static find(docView, pos) {
        for (let i = 0, off = 0; i < docView.children.length; i++) {
            let block = docView.children[i], end = off + block.length;
            if (end >= pos) {
                if (block instanceof LineView)
                    return block;
                if (end > pos)
                    break;
            }
            off = end + block.breakAfter;
        }
        return null;
    }
}
class BlockWidgetView extends ContentView {
    constructor(widget, length, deco) {
        super();
        this.widget = widget;
        this.length = length;
        this.deco = deco;
        this.breakAfter = 0;
        this.prevWidget = null;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
        let len = this.length - at;
        this.length = at;
        let end = new BlockWidgetView(this.widget, len, this.deco);
        end.breakAfter = this.breakAfter;
        return end;
    }
    get children() { return noChildren; }
    sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            if (!this.widget.editable)
                this.dom.contentEditable = "false";
        }
    }
    get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : state.Text.empty;
    }
    domBoundsAround() { return null; }
    become(other) {
        if (other instanceof BlockWidgetView &&
            other.widget.constructor == this.widget.constructor) {
            if (!other.widget.compare(this.widget))
                this.markDirty(true);
            if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            this.deco = other.deco;
            this.breakAfter = other.breakAfter;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get isEditable() { return false; }
    get isWidget() { return true; }
    coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
            return custom;
        if (this.widget instanceof BlockGapWidget)
            return null;
        return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
    }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
    covers(side) {
        let { startSide, endSide } = this.deco;
        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
    }
}
class BlockGapWidget extends WidgetType {
    constructor(height) {
        super();
        this.height = height;
    }
    toDOM() {
        let elt = document.createElement("div");
        elt.className = "cm-gap";
        this.updateDOM(elt);
        return elt;
    }
    eq(other) { return other.height == this.height; }
    updateDOM(elt) {
        elt.style.height = this.height + "px";
        return true;
    }
    get editable() { return true; }
    get estimatedHeight() { return this.height; }
    ignoreEvent() { return false; }
}

class ContentBuilder {
    constructor(doc, pos, end, disallowBlockEffectsFor) {
        this.doc = doc;
        this.pos = pos;
        this.end = end;
        this.disallowBlockEffectsFor = disallowBlockEffectsFor;
        this.content = [];
        this.curLine = null;
        this.breakAtStart = 0;
        this.pendingBuffer = 0 /* Buf.No */;
        this.bufferMarks = [];
        // Set to false directly after a widget that covers the position after it
        this.atCursorPos = true;
        this.openStart = -1;
        this.openEnd = -1;
        this.text = "";
        this.textOff = 0;
        this.cursor = doc.iter();
        this.skip = pos;
    }
    posCovered() {
        if (this.content.length == 0)
            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let last = this.content[this.content.length - 1];
        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
    }
    getLine() {
        if (!this.curLine) {
            this.content.push(this.curLine = new LineView);
            this.atCursorPos = true;
        }
        return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
        if (this.pendingBuffer) {
            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
            this.pendingBuffer = 0 /* Buf.No */;
        }
    }
    addBlockWidget(view) {
        this.flushBuffer();
        this.curLine = null;
        this.content.push(view);
    }
    finish(openEnd) {
        if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
            this.flushBuffer();
        else
            this.pendingBuffer = 0 /* Buf.No */;
        if (!this.posCovered() &&
            !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
            this.getLine();
    }
    buildText(length, active, openStart) {
        while (length > 0) {
            if (this.textOff == this.text.length) {
                let { value, lineBreak, done } = this.cursor.next(this.skip);
                this.skip = 0;
                if (done)
                    throw new Error("Ran out of text content when drawing inline views");
                if (lineBreak) {
                    if (!this.posCovered())
                        this.getLine();
                    if (this.content.length)
                        this.content[this.content.length - 1].breakAfter = 1;
                    else
                        this.breakAtStart = 1;
                    this.flushBuffer();
                    this.curLine = null;
                    this.atCursorPos = true;
                    length--;
                    continue;
                }
                else {
                    this.text = value;
                    this.textOff = 0;
                }
            }
            let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);
            this.flushBuffer(active.slice(active.length - openStart));
            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
            this.atCursorPos = true;
            this.textOff += take;
            length -= take;
            openStart = 0;
        }
    }
    span(from, to, active, openStart) {
        this.buildText(to - from, active, openStart);
        this.pos = to;
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
            if (deco.block)
                throw new RangeError("Block decorations may not be specified via plugins");
            if (to > this.doc.lineAt(this.pos).to)
                throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
        }
        let len = to - from;
        if (deco instanceof PointDecoration) {
            if (deco.block) {
                if (deco.startSide > 0 && !this.posCovered())
                    this.getLine();
                this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
            }
            else {
                let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length &&
                    (from < to || deco.startSide > 0);
                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
                let line = this.getLine();
                if (this.pendingBuffer == 2 /* Buf.IfCursor */ && !cursorBefore && !view.isEditable)
                    this.pendingBuffer = 0 /* Buf.No */;
                this.flushBuffer(active);
                if (cursorBefore) {
                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
                    openStart = active.length + Math.max(0, openStart - active.length);
                }
                line.append(wrapMarks(view, active), openStart);
                this.atCursorPos = cursorAfter;
                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from < to || openStart > active.length ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;
                if (this.pendingBuffer)
                    this.bufferMarks = active.slice();
            }
        }
        else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration
            this.getLine().addLineDeco(deco);
        }
        if (len) {
            // Advance the iterator past the replaced content
            if (this.textOff + len <= this.text.length) {
                this.textOff += len;
            }
            else {
                this.skip += len - (this.text.length - this.textOff);
                this.text = "";
                this.textOff = 0;
            }
            this.pos = to;
        }
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    static build(text, from, to, decorations, dynamicDecorationMap) {
        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
        builder.openEnd = state.RangeSet.spans(decorations, from, to, builder);
        if (builder.openStart < 0)
            builder.openStart = builder.openEnd;
        builder.finish(builder.openEnd);
        return builder;
    }
}
function wrapMarks(view, active) {
    for (let mark of active)
        view = new MarkView(mark, [view], view.length);
    return view;
}
class NullWidget extends WidgetType {
    constructor(tag) {
        super();
        this.tag = tag;
    }
    eq(other) { return other.tag == this.tag; }
    toDOM() { return document.createElement(this.tag); }
    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }
    get isHidden() { return true; }
}
NullWidget.inline = new NullWidget("span");
NullWidget.block = new NullWidget("div");

/**
Used to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
*/
exports.Direction = void 0;
(function (Direction) {
    // (These are chosen to match the base levels, in bidi algorithm
    // terms, of spans in that direction.)
    /**
    Left-to-right.
    */
    Direction[Direction["LTR"] = 0] = "LTR";
    /**
    Right-to-left.
    */
    Direction[Direction["RTL"] = 1] = "RTL";
})(exports.Direction || (exports.Direction = {}));
const LTR = exports.Direction.LTR, RTL = exports.Direction.RTL;
// Decode a string with each type encoded as log2(type)
function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
        result.push(1 << +str[i]);
    return result;
}
// Character types for codepoints 0 to 0xf8
const LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
// Character types for codepoints 0x600 to 0x6f9
const ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = Object.create(null), BracketStack = [];
// There's a lot more in
// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,
// which are left out to keep code size down.
for (let p of ["()", "[]", "{}"]) {
    let l = p.charCodeAt(0), r = p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
}
function charType(ch) {
    return ch <= 0xf7 ? LowTypes[ch] :
        0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */ :
            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :
                0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */ :
                    0x2000 <= ch && ch <= 0x200c ? 256 /* T.NI */ :
                        0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */ : 1 /* T.L */;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
/**
Represents a contiguous range of text that has a single direction
(as in left-to-right or right-to-left).
*/
class BidiSpan {
    /**
    The direction of this span.
    */
    get dir() { return this.level % 2 ? RTL : LTR; }
    /**
    @internal
    */
    constructor(
    /**
    The start of the span (relative to the start of the line).
    */
    from, 
    /**
    The end of the span.
    */
    to, 
    /**
    The ["bidi
    level"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)
    of the span (in this context, 0 means
    left-to-right, 1 means right-to-left, 2 means left-to-right
    number inside right-to-left text).
    */
    level) {
        this.from = from;
        this.to = to;
        this.level = level;
    }
    /**
    @internal
    */
    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }
    /**
    @internal
    */
    forward(forward, dir) { return forward == (this.dir == dir); }
    /**
    @internal
    */
    static find(order, index, level, assoc) {
        let maybe = -1;
        for (let i = 0; i < order.length; i++) {
            let span = order[i];
            if (span.from <= index && span.to >= index) {
                if (span.level == level)
                    return i;
                // When multiple spans match, if assoc != 0, take the one that
                // covers that side, otherwise take the one with the minimum
                // level.
                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))
                    maybe = i;
            }
        }
        if (maybe < 0)
            throw new RangeError("Index out of range");
        return maybe;
    }
}
function isolatesEq(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        let iA = a[i], iB = b[i];
        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
            return false;
    }
    return true;
}
// Reused array of character types
const types = [];
// Fill in the character types (in `types`) from `from` to `to` and
// apply W normalization rules.
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
    for (let iI = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        let prevType = iI ? 256 /* T.NI */ : outerType;
        // W1. Examine each non-spacing mark (NSM) in the level run, and
        // change the type of the NSM to the type of the previous
        // character. If the NSM is at the start of the level run, it will
        // get the type of sor.
        // W2. Search backwards from each instance of a European number
        // until the first strong type (R, L, AL, or sor) is found. If an
        // AL is found, change the type of the European number to Arabic
        // number.
        // W3. Change all ALs to R.
        // (Left after this: L, R, EN, AN, ET, CS, NI)
        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
            let type = charType(line.charCodeAt(i));
            if (type == 512 /* T.NSM */)
                type = prev;
            else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */)
                type = 16 /* T.AN */;
            types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;
            if (type & 7 /* T.Strong */)
                prevStrong = type;
            prev = type;
        }
        // W5. A sequence of European terminators adjacent to European
        // numbers changes to all European numbers.
        // W6. Otherwise, separators and terminators change to Other
        // Neutral.
        // W7. Search backwards from each instance of a European number
        // until the first strong type (R, L, or sor) is found. If an L is
        // found, then change the type of the European number to L.
        // (Left after this: L, R, EN+AN, NI)
        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
            let type = types[i];
            if (type == 128 /* T.CS */) {
                if (i < to - 1 && prev == types[i + 1] && (prev & 24 /* T.Num */))
                    type = types[i] = prev;
                else
                    types[i] = 256 /* T.NI */;
            }
            else if (type == 64 /* T.ET */) {
                let end = i + 1;
                while (end < to && types[end] == 64 /* T.ET */)
                    end++;
                let replace = (i && prev == 8 /* T.EN */) || (end < rTo && types[end] == 8 /* T.EN */) ? (prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */) : 256 /* T.NI */;
                for (let j = i; j < end; j++)
                    types[j] = replace;
                i = end - 1;
            }
            else if (type == 8 /* T.EN */ && prevStrong == 1 /* T.L */) {
                types[i] = 1 /* T.L */;
            }
            prev = type;
            if (type & 7 /* T.Strong */)
                prevStrong = type;
        }
    }
}
// Process brackets throughout a run sequence.
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
    let oppositeType = outerType == 1 /* T.L */ ? 2 /* T.R */ : 1 /* T.L */;
    for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        // N0. Process bracket pairs in an isolating run sequence
        // sequentially in the logical order of the text positions of the
        // opening paired brackets using the logic given below. Within this
        // scope, bidirectional types EN and AN are treated as R.
        for (let i = from, ch, br, type; i < to; i++) {
            // Keeps [startIndex, type, strongSeen] triples for each open
            // bracket on BracketStack.
            if (br = Brackets[ch = line.charCodeAt(i)]) {
                if (br < 0) { // Closing bracket
                    for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                        if (BracketStack[sJ + 1] == -br) {
                            let flags = BracketStack[sJ + 2];
                            let type = (flags & 2 /* Bracketed.EmbedInside */) ? outerType :
                                !(flags & 4 /* Bracketed.OppositeInside */) ? 0 :
                                    (flags & 1 /* Bracketed.OppositeBefore */) ? oppositeType : outerType;
                            if (type)
                                types[i] = types[BracketStack[sJ]] = type;
                            sI = sJ;
                            break;
                        }
                    }
                }
                else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {
                    break;
                }
                else {
                    BracketStack[sI++] = i;
                    BracketStack[sI++] = ch;
                    BracketStack[sI++] = context;
                }
            }
            else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {
                let embed = type == outerType;
                context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;
                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                    let cur = BracketStack[sJ + 2];
                    if (cur & 2 /* Bracketed.EmbedInside */)
                        break;
                    if (embed) {
                        BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */;
                    }
                    else {
                        if (cur & 4 /* Bracketed.OppositeInside */)
                            break;
                        BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */;
                    }
                }
            }
        }
    }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        // N1. A sequence of neutrals takes the direction of the
        // surrounding strong text if the text on both sides has the same
        // direction. European and Arabic numbers act as if they were R in
        // terms of their influence on neutrals. Start-of-level-run (sor)
        // and end-of-level-run (eor) are used at level run boundaries.
        // N2. Any remaining neutrals take the embedding direction.
        // (Left after this: L, R, EN+AN)
        for (let i = from; i < to;) {
            let type = types[i];
            if (type == 256 /* T.NI */) {
                let end = i + 1;
                for (;;) {
                    if (end == to) {
                        if (iI == isolates.length)
                            break;
                        end = isolates[iI++].to;
                        to = iI < isolates.length ? isolates[iI].from : rTo;
                    }
                    else if (types[end] == 256 /* T.NI */) {
                        end++;
                    }
                    else {
                        break;
                    }
                }
                let beforeL = prev == 1 /* T.L */;
                let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */;
                let replace = beforeL == afterL ? (beforeL ? 1 /* T.L */ : 2 /* T.R */) : outerType;
                for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;) {
                    if (j == fromJ) {
                        j = isolates[--jI].from;
                        fromJ = jI ? isolates[jI - 1].to : rFrom;
                    }
                    types[--j] = replace;
                }
                i = end;
            }
            else {
                prev = type;
                i++;
            }
        }
    }
}
// Find the contiguous ranges of character types in a given range, and
// emit spans for them. Flip the order of the spans as appropriate
// based on the level, and call through to compute the spans for
// isolates at the proper point.
function emitSpans(line, from, to, level, baseLevel, isolates, order) {
    let ourType = level % 2 ? 2 /* T.R */ : 1 /* T.L */;
    if ((level % 2) == (baseLevel % 2)) { // Same dir as base direction, don't flip
        for (let iCh = from, iI = 0; iCh < to;) {
            // Scan a section of characters in direction ourType, unless
            // there's another type of char right after iCh, in which case
            // we scan a section of other characters (which, if ourType ==
            // T.L, may contain both T.R and T.AN chars).
            let sameDir = true, isNum = false;
            if (iI == isolates.length || iCh < isolates[iI].from) {
                let next = types[iCh];
                if (next != ourType) {
                    sameDir = false;
                    isNum = next == 16 /* T.AN */;
                }
            }
            // Holds an array of isolates to pass to a recursive call if we
            // must recurse (to distinguish T.AN inside an RTL section in
            // LTR text), null if we can emit directly
            let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run: for (;;) {
                if (iI < isolates.length && iScan == isolates[iI].from) {
                    if (isNum)
                        break run;
                    let iso = isolates[iI];
                    // Scan ahead to verify that there is another char in this dir after the isolate(s)
                    if (!sameDir)
                        for (let upto = iso.to, jI = iI + 1;;) {
                            if (upto == to)
                                break run;
                            if (jI < isolates.length && isolates[jI].from == upto)
                                upto = isolates[jI++].to;
                            else if (types[upto] == ourType)
                                break run;
                            else
                                break;
                        }
                    iI++;
                    if (recurse) {
                        recurse.push(iso);
                    }
                    else {
                        if (iso.from > iCh)
                            order.push(new BidiSpan(iCh, iso.from, localLevel));
                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                        iCh = iso.to;
                    }
                    iScan = iso.to;
                }
                else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
                    break;
                }
                else {
                    iScan++;
                }
            }
            if (recurse)
                emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
            else if (iCh < iScan)
                order.push(new BidiSpan(iCh, iScan, localLevel));
            iCh = iScan;
        }
    }
    else {
        // Iterate in reverse to flip the span order. Same code again, but
        // going from the back of the section to the front
        for (let iCh = to, iI = isolates.length; iCh > from;) {
            let sameDir = true, isNum = false;
            if (!iI || iCh > isolates[iI - 1].to) {
                let next = types[iCh - 1];
                if (next != ourType) {
                    sameDir = false;
                    isNum = next == 16 /* T.AN */;
                }
            }
            let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run: for (;;) {
                if (iI && iScan == isolates[iI - 1].to) {
                    if (isNum)
                        break run;
                    let iso = isolates[--iI];
                    // Scan ahead to verify that there is another char in this dir after the isolate(s)
                    if (!sameDir)
                        for (let upto = iso.from, jI = iI;;) {
                            if (upto == from)
                                break run;
                            if (jI && isolates[jI - 1].to == upto)
                                upto = isolates[--jI].from;
                            else if (types[upto - 1] == ourType)
                                break run;
                            else
                                break;
                        }
                    if (recurse) {
                        recurse.push(iso);
                    }
                    else {
                        if (iso.to < iCh)
                            order.push(new BidiSpan(iso.to, iCh, localLevel));
                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                        iCh = iso.from;
                    }
                    iScan = iso.from;
                }
                else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
                    break;
                }
                else {
                    iScan--;
                }
            }
            if (recurse)
                emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
            else if (iScan < iCh)
                order.push(new BidiSpan(iScan, iCh, localLevel));
            iCh = iScan;
        }
    }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
    let outerType = (level % 2 ? 2 /* T.R */ : 1 /* T.L */);
    computeCharTypes(line, from, to, isolates, outerType);
    processBracketPairs(line, from, to, isolates, outerType);
    processNeutrals(from, to, isolates, outerType);
    emitSpans(line, from, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
    if (!line)
        return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
    if (direction == LTR && !isolates.length && !BidiRE.test(line))
        return trivialOrder(line.length);
    if (isolates.length)
        while (line.length > types.length)
            types[types.length] = 256 /* T.NI */; // Make sure types array has no gaps
    let order = [], level = direction == LTR ? 0 : 1;
    computeSectionOrder(line, level, level, isolates, 0, line.length, order);
    return order;
}
function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
// This implementation moves strictly visually, without concern for a
// traversal visiting every logical position in the string. It will
// still do so for simple input, but situations like multiple isolates
// with the same level next to each other, or text going against the
// main dir at the end of the line, will make some positions
// unreachable with this motion. Each visible cursor position will
// correspond to the lower-level bidi span that touches it.
//
// The alternative would be to solve an order globally for a given
// line, making sure that it includes every position, but that would
// require associating non-canonical (higher bidi span level)
// positions with a given visual position, which is likely to confuse
// people. (And would generally be a lot more complicated.)
function moveVisually(line, order, dir, start, forward) {
    var _a;
    let startIndex = start.head - line.from;
    let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
    let span = order[spanI], spanEnd = span.side(forward, dir);
    // End of span
    if (startIndex == spanEnd) {
        let nextI = spanI += forward ? 1 : -1;
        if (nextI < 0 || nextI >= order.length)
            return null;
        span = order[spanI = nextI];
        startIndex = span.side(!forward, dir);
        spanEnd = span.side(forward, dir);
    }
    let nextIndex = state.findClusterBreak(line.text, startIndex, span.forward(forward, dir));
    if (nextIndex < span.from || nextIndex > span.to)
        nextIndex = spanEnd;
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
        return state.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
    return state.EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from, to) {
    for (let i = from; i < to; i++) {
        let type = charType(text.charCodeAt(i));
        if (type == 1 /* T.L */)
            return LTR;
        if (type == 2 /* T.R */ || type == 4 /* T.AL */)
            return RTL;
    }
    return LTR;
}

const clickAddsSelectionRange = state.Facet.define();
const dragMovesSelection$1 = state.Facet.define();
const mouseSelectionStyle = state.Facet.define();
const exceptionSink = state.Facet.define();
const updateListener = state.Facet.define();
const inputHandler = state.Facet.define();
const focusChangeEffect = state.Facet.define();
const clipboardInputFilter = state.Facet.define();
const clipboardOutputFilter = state.Facet.define();
const perLineTextDirection = state.Facet.define({
    combine: values => values.some(x => x)
});
const nativeSelectionHidden = state.Facet.define({
    combine: values => values.some(x => x)
});
const scrollHandler = state.Facet.define();
class ScrollTarget {
    constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, 
    // This data structure is abused to also store precise scroll
    // snapshots, instead of a `scrollIntoView` request. When this
    // flag is `true`, `range` points at a position in the reference
    // line, `yMargin` holds the difference between the top of that
    // line and the top of the editor, and `xMargin` holds the
    // editor's `scrollLeft`.
    isSnapshot = false) {
        this.range = range;
        this.y = y;
        this.x = x;
        this.yMargin = yMargin;
        this.xMargin = xMargin;
        this.isSnapshot = isSnapshot;
    }
    map(changes) {
        return changes.empty ? this :
            new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(state$1) {
        return this.range.to <= state$1.doc.length ? this :
            new ScrollTarget(state.EditorSelection.cursor(state$1.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
}
const scrollIntoView = state.StateEffect.define({ map: (t, ch) => t.map(ch) });
const setEditContextFormatting = state.StateEffect.define();
/**
Log or report an unhandled exception in client code. Should
probably only be used by extension code that allows client code to
provide functions, and calls those functions in a context where an
exception can't be propagated to calling code in a reasonable way
(for example when in an event handler).

Either calls a handler registered with
[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),
`window.onerror`, if defined, or `console.error` (in which case
it'll pass `context`, when given, as first argument).
*/
function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
        handler[0](exception);
    else if (window.onerror)
        window.onerror(String(exception), context, undefined, undefined, exception);
    else if (context)
        console.error(context + ":", exception);
    else
        console.error(exception);
}
const editable = state.Facet.define({ combine: values => values.length ? values[0] : true });
let nextPluginID = 0;
const viewPlugin = state.Facet.define();
/**
View plugins associate stateful values with a view. They can
influence the way the content is drawn, and are notified of things
that happen in the view.
*/
class ViewPlugin {
    constructor(
    /**
    @internal
    */
    id, 
    /**
    @internal
    */
    create, 
    /**
    @internal
    */
    domEventHandlers, 
    /**
    @internal
    */
    domEventObservers, buildExtensions) {
        this.id = id;
        this.create = create;
        this.domEventHandlers = domEventHandlers;
        this.domEventObservers = domEventObservers;
        this.extension = buildExtensions(this);
    }
    /**
    Define a plugin from a constructor function that creates the
    plugin's value, given an editor view.
    */
    static define(create, spec) {
        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
        return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, plugin => {
            let ext = [viewPlugin.of(plugin)];
            if (deco)
                ext.push(decorations.of(view => {
                    let pluginInst = view.plugin(plugin);
                    return pluginInst ? deco(pluginInst) : Decoration.none;
                }));
            if (provide)
                ext.push(provide(plugin));
            return ext;
        });
    }
    /**
    Create a plugin for a class whose constructor takes a single
    editor view as argument.
    */
    static fromClass(cls, spec) {
        return ViewPlugin.define(view => new cls(view), spec);
    }
}
class PluginInstance {
    constructor(spec) {
        this.spec = spec;
        // When starting an update, all plugins have this field set to the
        // update object, indicating they need to be updated. When finished
        // updating, it is set to `false`. Retrieving a plugin that needs to
        // be updated with `view.plugin` forces an eager update.
        this.mustUpdate = null;
        // This is null when the plugin is initially created, but
        // initialized on the first update.
        this.value = null;
    }
    update(view) {
        if (!this.value) {
            if (this.spec) {
                try {
                    this.value = this.spec.create(view);
                }
                catch (e) {
                    logException(view.state, e, "CodeMirror plugin crashed");
                    this.deactivate();
                }
            }
        }
        else if (this.mustUpdate) {
            let update = this.mustUpdate;
            this.mustUpdate = null;
            if (this.value.update) {
                try {
                    this.value.update(update);
                }
                catch (e) {
                    logException(update.state, e, "CodeMirror plugin crashed");
                    if (this.value.destroy)
                        try {
                            this.value.destroy();
                        }
                        catch (_) { }
                    this.deactivate();
                }
            }
        }
        return this;
    }
    destroy(view) {
        var _a;
        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
            try {
                this.value.destroy();
            }
            catch (e) {
                logException(view.state, e, "CodeMirror plugin crashed");
            }
        }
    }
    deactivate() {
        this.spec = this.value = null;
    }
}
const editorAttributes = state.Facet.define();
const contentAttributes = state.Facet.define();
// Provide decorations
const decorations = state.Facet.define();
const outerDecorations = state.Facet.define();
const atomicRanges = state.Facet.define();
const bidiIsolatedRanges = state.Facet.define();
function getIsolatedRanges(view, line) {
    let isolates = view.state.facet(bidiIsolatedRanges);
    if (!isolates.length)
        return isolates;
    let sets = isolates.map(i => i instanceof Function ? i(view) : i);
    let result = [];
    state.RangeSet.spans(sets, line.from, line.to, {
        point() { },
        span(fromDoc, toDoc, active, open) {
            let from = fromDoc - line.from, to = toDoc - line.from;
            let level = result;
            for (let i = active.length - 1; i >= 0; i--, open--) {
                let direction = active[i].spec.bidiIsolate, update;
                if (direction == null)
                    direction = autoDirection(line.text, from, to);
                if (open > 0 && level.length &&
                    (update = level[level.length - 1]).to == from && update.direction == direction) {
                    update.to = to;
                    level = update.inner;
                }
                else {
                    let add = { from, to, direction, inner: [] };
                    level.push(add);
                    level = add.inner;
                }
            }
        }
    });
    return result;
}
const scrollMargins = state.Facet.define();
function getScrollMargins(view) {
    let left = 0, right = 0, top = 0, bottom = 0;
    for (let source of view.state.facet(scrollMargins)) {
        let m = source(view);
        if (m) {
            if (m.left != null)
                left = Math.max(left, m.left);
            if (m.right != null)
                right = Math.max(right, m.right);
            if (m.top != null)
                top = Math.max(top, m.top);
            if (m.bottom != null)
                bottom = Math.max(bottom, m.bottom);
        }
    }
    return { left, right, top, bottom };
}
const styleModule = state.Facet.define();
class ChangedRange {
    constructor(fromA, toA, fromB, toB) {
        this.fromA = fromA;
        this.toA = toA;
        this.fromB = fromB;
        this.toB = toB;
    }
    join(other) {
        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
        let i = set.length, me = this;
        for (; i > 0; i--) {
            let range = set[i - 1];
            if (range.fromA > me.toA)
                continue;
            if (range.toA < me.fromA)
                break;
            me = me.join(range);
            set.splice(i - 1, 1);
        }
        set.splice(i, 0, me);
        return set;
    }
    static extendWithRanges(diff, ranges) {
        if (ranges.length == 0)
            return diff;
        let result = [];
        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {
            let next = dI == diff.length ? null : diff[dI], off = posA - posB;
            let end = next ? next.fromB : 1e9;
            while (rI < ranges.length && ranges[rI] < end) {
                let from = ranges[rI], to = ranges[rI + 1];
                let fromB = Math.max(posB, from), toB = Math.min(end, to);
                if (fromB <= toB)
                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
                if (to > end)
                    break;
                else
                    rI += 2;
            }
            if (!next)
                return result;
            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
            posA = next.toA;
            posB = next.toB;
        }
    }
}
/**
View [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this
class, which describe what happened, whenever the view is updated.
*/
class ViewUpdate {
    constructor(
    /**
    The editor view that the update is associated with.
    */
    view, 
    /**
    The new editor state.
    */
    state$1, 
    /**
    The transactions involved in the update. May be empty.
    */
    transactions) {
        this.view = view;
        this.state = state$1;
        this.transactions = transactions;
        /**
        @internal
        */
        this.flags = 0;
        this.startState = view.state;
        this.changes = state.ChangeSet.empty(this.startState.doc.length);
        for (let tr of transactions)
            this.changes = this.changes.compose(tr.changes);
        let changedRanges = [];
        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
        this.changedRanges = changedRanges;
    }
    /**
    @internal
    */
    static create(view, state, transactions) {
        return new ViewUpdate(view, state, transactions);
    }
    /**
    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
    update.
    */
    get viewportChanged() {
        return (this.flags & 4 /* UpdateFlag.Viewport */) > 0;
    }
    /**
    Indicates whether the height of a block element in the editor
    changed in this update.
    */
    get heightChanged() {
        return (this.flags & 2 /* UpdateFlag.Height */) > 0;
    }
    /**
    Returns true when the document was modified or the size of the
    editor, or elements within the editor, changed.
    */
    get geometryChanged() {
        return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) > 0;
    }
    /**
    True when this update indicates a focus change.
    */
    get focusChanged() {
        return (this.flags & 1 /* UpdateFlag.Focus */) > 0;
    }
    /**
    Whether the document changed in this update.
    */
    get docChanged() {
        return !this.changes.empty;
    }
    /**
    Whether the selection was explicitly set in this update.
    */
    get selectionSet() {
        return this.transactions.some(tr => tr.selection);
    }
    /**
    @internal
    */
    get empty() { return this.flags == 0 && this.transactions.length == 0; }
}

class DocView extends ContentView {
    get length() { return this.view.state.doc.length; }
    constructor(view) {
        super();
        this.view = view;
        this.decorations = [];
        this.dynamicDecorationMap = [false];
        this.domChanged = null;
        this.hasComposition = null;
        this.markedForComposition = new Set;
        this.editContextFormatting = Decoration.none;
        this.lastCompositionAfterCursor = false;
        // Track a minimum width for the editor. When measuring sizes in
        // measureVisibleLineHeights, this is updated to point at the width
        // of a given element and its extent in the document. When a change
        // happens in that range, these are reset. That way, once we've seen
        // a line/element of a given length, we keep the editor wide enough
        // to fit at least that element, until it is changed, at which point
        // we forget it again.
        this.minWidth = 0;
        this.minWidthFrom = 0;
        this.minWidthTo = 0;
        // Track whether the DOM selection was set in a lossy way, so that
        // we don't mess it up when reading it back it
        this.impreciseAnchor = null;
        this.impreciseHead = null;
        this.forceSelection = false;
        // Used by the resize observer to ignore resizes that we caused
        // ourselves
        this.lastUpdate = Date.now();
        this.setDOM(view.contentDOM);
        this.children = [new LineView];
        this.children[0].setParent(this);
        this.updateDeco();
        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
    }
    // Update the document view to a given state.
    update(update) {
        var _a;
        let changedRanges = update.changedRanges;
        if (this.minWidth > 0 && changedRanges.length) {
            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
            }
            else {
                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
            }
        }
        this.updateEditContextFormatting(update);
        let readCompositionAt = -1;
        if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel)
                readCompositionAt = this.domChanged.newSel.head;
            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
                readCompositionAt = update.state.selection.main.head;
        }
        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
        this.domChanged = null;
        if (this.hasComposition) {
            this.markedForComposition.clear();
            let { from, to } = this.hasComposition;
            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1))
                .addToSet(changedRanges.slice());
        }
        this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
        // When the DOM nodes around the selection are moved to another
        // parent, Chrome sometimes reports a different selection through
        // getSelection than the one that it actually shows to the user.
        // This forces a selection update when lines are joined to work
        // around that. Issue #54
        if ((browser.ie || browser.chrome) && !composition && update &&
            update.state.doc.lines != update.startState.doc.lines)
            this.forceSelection = true;
        let prevDeco = this.decorations, deco = this.updateDeco();
        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
        if (!(this.flags & 7 /* ViewFlag.Dirty */) && changedRanges.length == 0) {
            return false;
        }
        else {
            this.updateInner(changedRanges, update.startState.doc.length, composition);
            if (update.transactions.length)
                this.lastUpdate = Date.now();
            return true;
        }
    }
    // Used by update and the constructor do perform the actual DOM
    // update
    updateInner(changes, oldLength, composition) {
        this.view.viewState.mustMeasureContent = true;
        this.updateChildren(changes, oldLength, composition);
        let { observer } = this.view;
        observer.ignore(() => {
            // Lock the height during redrawing, since Chrome sometimes
            // messes with the scroll position during DOM mutation (though
            // no relayout is triggered and I cannot imagine how it can
            // recompute the scroll position without a layout)
            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
            this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
            // Chrome will sometimes, when DOM mutations occur directly
            // around the selection, get confused and report a different
            // selection from the one it displays (issue #218). This tries
            // to detect that situation.
            let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : undefined;
            this.sync(this.view, track);
            this.flags &= ~7 /* ViewFlag.Dirty */;
            if (track && (track.written || observer.selectionRange.focusNode != track.node))
                this.forceSelection = true;
            this.dom.style.height = "";
        });
        this.markedForComposition.forEach(cView => cView.flags &= ~8 /* ViewFlag.Composition */);
        let gaps = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
            for (let child of this.children)
                if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
                    gaps.push(child.dom);
        observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength, composition) {
        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
        let cursor = this.childCursor(oldLength);
        for (let i = ranges.length - 1;; i--) {
            let next = i >= 0 ? ranges[i] : null;
            if (!next)
                break;
            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;
            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
                let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
                let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
                breakAtStart = before.breakAtStart;
                openStart = before.openStart;
                openEnd = after.openEnd;
                let compLine = this.compositionView(composition);
                if (after.breakAtStart) {
                    compLine.breakAfter = 1;
                }
                else if (after.content.length &&
                    compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
                    compLine.breakAfter = after.content[0].breakAfter;
                    after.content.shift();
                }
                if (before.content.length &&
                    compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
                    before.content.pop();
                }
                content = before.content.concat(compLine).concat(after.content);
            }
            else {
                ({ content, breakAtStart, openStart, openEnd } =
                    ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
            }
            let { i: toI, off: toOff } = cursor.findPos(toA, 1);
            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
        }
        if (composition)
            this.fixCompositionDOM(composition);
    }
    updateEditContextFormatting(update) {
        this.editContextFormatting = this.editContextFormatting.map(update.changes);
        for (let tr of update.transactions)
            for (let effect of tr.effects)
                if (effect.is(setEditContextFormatting)) {
                    this.editContextFormatting = effect.value;
                }
    }
    compositionView(composition) {
        let cur = new TextView(composition.text.nodeValue);
        cur.flags |= 8 /* ViewFlag.Composition */;
        for (let { deco } of composition.marks)
            cur = new MarkView(deco, [cur], cur.length);
        let line = new LineView;
        line.append(cur, 0);
        return line;
    }
    fixCompositionDOM(composition) {
        let fix = (dom, cView) => {
            cView.flags |= 8 /* ViewFlag.Composition */ | (cView.children.some(c => c.flags & 7 /* ViewFlag.Dirty */) ? 1 /* ViewFlag.ChildDirty */ : 0);
            this.markedForComposition.add(cView);
            let prev = ContentView.get(dom);
            if (prev && prev != cView)
                prev.dom = null;
            cView.setDOM(dom);
        };
        let pos = this.childPos(composition.range.fromB, 1);
        let cView = this.children[pos.i];
        fix(composition.line, cView);
        for (let i = composition.marks.length - 1; i >= -1; i--) {
            pos = cView.childPos(pos.off, 1);
            cView = cView.children[pos.i];
            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
        }
    }
    // Sync the DOM selection to this.state.selection
    updateSelection(mustRead = false, fromPointer = false) {
        if (mustRead || !this.view.observer.selectionRange.focusNode)
            this.view.observer.readSelectionRange();
        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
        let selectionNotFocus = !focused &&
            hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
        if (!(focused || fromPointer || selectionNotFocus))
            return;
        let force = this.forceSelection;
        this.forceSelection = false;
        let main = this.view.state.selection.main;
        let anchor = this.moveToLine(this.domAtPos(main.anchor));
        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
        // Always reset on Firefox when next to an uneditable node to
        // avoid invisible cursor bugs (#111)
        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
            let dummy = document.createTextNode("");
            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
            anchor = head = new DOMPos(dummy, 0);
            force = true;
        }
        let domSel = this.view.observer.selectionRange;
        // If the selection is already here, or in an equivalent position, don't touch it
        if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||
            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
            this.view.observer.ignore(() => {
                // Chrome Android will hide the virtual keyboard when tapping
                // inside an uneditable node, and not bring it back when we
                // move the cursor to its proper position. This tries to
                // restore the keyboard by cycling focus.
                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) &&
                    inUneditable(domSel.focusNode, this.dom)) {
                    this.dom.blur();
                    this.dom.focus({ preventScroll: true });
                }
                let rawSel = getSelection(this.view.root);
                if (!rawSel) ;
                else if (main.empty) {
                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076
                    if (browser.gecko) {
                        let nextTo = nextToUneditable(anchor.node, anchor.offset);
                        if (nextTo && nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {
                            let text = (nextTo == 1 /* NextTo.Before */ ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                            if (text)
                                anchor = new DOMPos(text.node, text.offset);
                        }
                    }
                    rawSel.collapse(anchor.node, anchor.offset);
                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined)
                        rawSel.caretBidiLevel = main.bidiLevel;
                }
                else if (rawSel.extend) {
                    // Selection.extend can be used to create an 'inverted' selection
                    // (one where the focus is before the anchor), but not all
                    // browsers support it yet.
                    rawSel.collapse(anchor.node, anchor.offset);
                    // Safari will ignore the call above when the editor is
                    // hidden, and then raise an error on the call to extend
                    // (#940).
                    try {
                        rawSel.extend(head.node, head.offset);
                    }
                    catch (_) { }
                }
                else {
                    // Primitive (IE) way
                    let range = document.createRange();
                    if (main.anchor > main.head)
                        [anchor, head] = [head, anchor];
                    range.setEnd(head.node, head.offset);
                    range.setStart(anchor.node, anchor.offset);
                    rawSel.removeAllRanges();
                    rawSel.addRange(range);
                }
                if (selectionNotFocus && this.view.root.activeElement == this.dom) {
                    this.dom.blur();
                    if (activeElt)
                        activeElt.focus();
                }
            });
            this.view.observer.setSelectionRange(anchor, head);
        }
        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    // If a zero-length widget is inserted next to the cursor during
    // composition, avoid moving it across it and disrupting the
    // composition.
    suppressWidgetCursorChange(sel, cursor) {
        return this.hasComposition && cursor.empty &&
            isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) &&
            this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
    }
    enforceCursorAssoc() {
        if (this.hasComposition)
            return;
        let { view } = this, cursor = view.state.selection.main;
        let sel = getSelection(view.root);
        let { anchorNode, anchorOffset } = view.observer.selectionRange;
        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
            return;
        let line = LineView.find(this, cursor.head);
        if (!line)
            return;
        let lineStart = line.posAtStart;
        if (cursor.head == lineStart || cursor.head == lineStart + line.length)
            return;
        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
        if (!before || !after || before.bottom > after.top)
            return;
        let dom = this.domAtPos(cursor.head + cursor.assoc);
        sel.collapse(dom.node, dom.offset);
        sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
        // This can go wrong in corner cases like single-character lines,
        // so check and reset if necessary.
        view.observer.readSelectionRange();
        let newRange = view.observer.selectionRange;
        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
            sel.collapse(anchorNode, anchorOffset);
    }
    // If a position is in/near a block widget, move it to a nearby text
    // line, since we don't want the cursor inside a block widget.
    moveToLine(pos) {
        // Block widgets will return positions before/after them, which
        // are thus directly in the document DOM element.
        let dom = this.dom, newPos;
        if (pos.node != dom)
            return pos;
        for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
                newPos = view.domAtPos(0);
        }
        for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
                newPos = view.domAtPos(view.length);
        }
        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
    }
    nearest(dom) {
        for (let cur = dom; cur;) {
            let domView = ContentView.get(cur);
            if (domView && domView.rootView == this)
                return domView;
            cur = cur.parentNode;
        }
        return null;
    }
    posFromDOM(node, offset) {
        let view = this.nearest(node);
        if (!view)
            throw new RangeError("Trying to find position for a DOM position outside of the document");
        return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
        let { i, off } = this.childCursor().findPos(pos, -1);
        for (; i < this.children.length - 1;) {
            let child = this.children[i];
            if (off < child.length || child instanceof LineView)
                break;
            i++;
            off = 0;
        }
        return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
        let best = null, bestPos = 0;
        for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
            let child = this.children[i], end = off - child.breakAfter, start = end - child.length;
            if (end < pos)
                break;
            if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) &&
                (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
                best = child;
                bestPos = start;
            }
            else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
                if (child.deco.startSide < 0)
                    break;
                else if (i)
                    best = null;
            }
            off = start;
        }
        return best ? best.coordsAt(pos - bestPos, side) : null;
    }
    coordsForChar(pos) {
        let { i, off } = this.childPos(pos, 1), child = this.children[i];
        if (!(child instanceof LineView))
            return null;
        while (child.children.length) {
            let { i, off: childOff } = child.childPos(off, 1);
            for (;; i++) {
                if (i == child.children.length)
                    return null;
                if ((child = child.children[i]).length)
                    break;
            }
            off = childOff;
        }
        if (!(child instanceof TextView))
            return null;
        let end = state.findClusterBreak(child.text, off);
        if (end == off)
            return null;
        let rects = textRange(child.dom, off, end).getClientRects();
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
                return rect;
        }
        return null;
    }
    measureVisibleLineHeights(viewport) {
        let result = [], { from, to } = viewport;
        let contentWidth = this.view.contentDOM.clientWidth;
        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
        let widest = -1, ltr = this.view.textDirection == exports.Direction.LTR;
        for (let pos = 0, i = 0; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (end > to)
                break;
            if (pos >= from) {
                let childRect = child.dom.getBoundingClientRect();
                result.push(childRect.height);
                if (isWider) {
                    let last = child.dom.lastChild;
                    let rects = last ? clientRectsFor(last) : [];
                    if (rects.length) {
                        let rect = rects[rects.length - 1];
                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                        if (width > widest) {
                            widest = width;
                            this.minWidth = contentWidth;
                            this.minWidthFrom = pos;
                            this.minWidthTo = end;
                        }
                    }
                }
            }
            pos = end + child.breakAfter;
        }
        return result;
    }
    textDirectionAt(pos) {
        let { i } = this.childPos(pos, 1);
        return getComputedStyle(this.children[i].dom).direction == "rtl" ? exports.Direction.RTL : exports.Direction.LTR;
    }
    measureTextSize() {
        for (let child of this.children) {
            if (child instanceof LineView) {
                let measure = child.measureTextSize();
                if (measure)
                    return measure;
            }
        }
        // If no workable line exists, force a layout of a measurable element
        let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
        dummy.className = "cm-line";
        dummy.style.width = "99999px";
        dummy.style.position = "absolute";
        dummy.textContent = "abc def ghi jkl mno pqr stu";
        this.view.observer.ignore(() => {
            this.dom.appendChild(dummy);
            let rect = clientRectsFor(dummy.firstChild)[0];
            lineHeight = dummy.getBoundingClientRect().height;
            charWidth = rect ? rect.width / 27 : 7;
            textHeight = rect ? rect.height : lineHeight;
            dummy.remove();
        });
        return { lineHeight, charWidth, textHeight };
    }
    childCursor(pos = this.length) {
        // Move back to start of last element when possible, so that
        // `ChildCursor.findPos` doesn't have to deal with the edge case
        // of being after the last element.
        let i = this.children.length;
        if (i)
            pos -= this.children[--i].length;
        return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
        let deco = [], vs = this.view.viewState;
        for (let pos = 0, i = 0;; i++) {
            let next = i == vs.viewports.length ? null : vs.viewports[i];
            let end = next ? next.from - 1 : this.length;
            if (end > pos) {
                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
                deco.push(Decoration.replace({
                    widget: new BlockGapWidget(height),
                    block: true,
                    inclusive: true,
                    isBlockGap: true,
                }).range(pos, end));
            }
            if (!next)
                break;
            pos = next.to + 1;
        }
        return Decoration.set(deco);
    }
    updateDeco() {
        let i = 1;
        let allDeco = this.view.state.facet(decorations).map(d => {
            let dynamic = this.dynamicDecorationMap[i++] = typeof d == "function";
            return dynamic ? d(this.view) : d;
        });
        let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i) => {
            let dynamic = typeof d == "function";
            if (dynamic)
                dynamicOuter = true;
            return dynamic ? d(this.view) : d;
        });
        if (outerDeco.length) {
            this.dynamicDecorationMap[i++] = dynamicOuter;
            allDeco.push(state.RangeSet.join(outerDeco));
        }
        this.decorations = [
            this.editContextFormatting,
            ...allDeco,
            this.computeBlockGapDeco(),
            this.view.viewState.lineGapDeco
        ];
        while (i < this.decorations.length)
            this.dynamicDecorationMap[i++] = false;
        return this.decorations;
    }
    scrollIntoView(target) {
        if (target.isSnapshot) {
            let ref = this.view.viewState.lineBlockAt(target.range.head);
            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
            this.view.scrollDOM.scrollLeft = target.xMargin;
            return;
        }
        for (let handler of this.view.state.facet(scrollHandler)) {
            try {
                if (handler(this.view, target.range, target))
                    return true;
            }
            catch (e) {
                logException(this.view.state, e, "scroll handler");
            }
        }
        let { range } = target;
        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
        if (!rect)
            return;
        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
            rect = { left: Math.min(rect.left, other.left), top: Math.min(rect.top, other.top),
                right: Math.max(rect.right, other.right), bottom: Math.max(rect.bottom, other.bottom) };
        let margins = getScrollMargins(this.view);
        let targetRect = {
            left: rect.left - margins.left, top: rect.top - margins.top,
            right: rect.right + margins.right, bottom: rect.bottom + margins.bottom
        };
        let { offsetWidth, offsetHeight } = this.view.scrollDOM;
        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == exports.Direction.LTR);
    }
}
function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild &&
        (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") &&
        (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
    let sel = view.observer.selectionRange;
    if (!sel.focusNode)
        return null;
    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
    let textNode = textBefore || textAfter;
    if (textAfter && textBefore && textAfter.node != textBefore.node) {
        let descAfter = ContentView.get(textAfter.node);
        if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
            textNode = textAfter;
        }
        else if (view.docView.lastCompositionAfterCursor) {
            let descBefore = ContentView.get(textBefore.node);
            if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
                textNode = textAfter;
        }
    }
    view.docView.lastCompositionAfterCursor = textNode != textBefore;
    if (!textNode)
        return null;
    let from = headPos - textNode.offset;
    return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
    let found = findCompositionNode(view, headPos);
    if (!found)
        return null;
    let { node: textNode, from, to } = found, text = textNode.nodeValue;
    // Don't try to preserve multi-line compositions
    if (/[\n\r]/.test(text))
        return null;
    if (view.state.doc.sliceString(found.from, found.to) != text)
        return null;
    let inv = changes.invertedDesc;
    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
    let marks = [];
    for (let parent = textNode.parentNode;; parent = parent.parentNode) {
        let parentView = ContentView.get(parent);
        if (parentView instanceof MarkView)
            marks.push({ node: parent, deco: parentView.mark });
        else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
            return { range, text: textNode, marks, line: parent };
        else if (parent != view.contentDOM)
            marks.push({ node: parent, deco: new MarkDecoration({
                    inclusive: true,
                    attributes: getAttrs(parent),
                    tagName: parent.tagName.toLowerCase()
                }) });
        else
            return null;
    }
}
function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
        return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 /* NextTo.Before */ : 0) |
        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 /* NextTo.After */ : 0);
}
let DecorationComparator$1 = class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange(from, to) { addRange(from, to, this.changes); }
    comparePoint(from, to) { addRange(from, to, this.changes); }
};
function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1;
    state.RangeSet.compare(a, b, diff, comp);
    return comp.changes;
}
function inUneditable(node, inside) {
    for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {
        if (cur.nodeType == 1 && cur.contentEditable == 'false') {
            return true;
        }
    }
    return false;
}
function touchesComposition(changes, composition) {
    let touched = false;
    if (composition)
        changes.iterChangedRanges((from, to) => {
            if (from < composition.to && to > composition.from)
                touched = true;
        });
    return touched;
}

function groupAt(state$1, pos, bias = 1) {
    let categorize = state$1.charCategorizer(pos);
    let line = state$1.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
        return state.EditorSelection.cursor(pos);
    if (linePos == 0)
        bias = 1;
    else if (linePos == line.length)
        bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
        from = state.findClusterBreak(line.text, linePos, false);
    else
        to = state.findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
        let prev = state.findClusterBreak(line.text, from, false);
        if (categorize(line.text.slice(prev, from)) != cat)
            break;
        from = prev;
    }
    while (to < line.length) {
        let next = state.findClusterBreak(line.text, to);
        if (categorize(line.text.slice(to, next)) != cat)
            break;
        to = next;
    }
    return state.EditorSelection.range(from + line.from, to + line.from);
}
// Search the DOM for the {node, offset} position closest to the given
// coordinates. Very inefficient and crude, but can usually be avoided
// by calling caret(Position|Range)FromPoint instead.
function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top) {
    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
        let rects = clientRectsFor(child);
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (closestRect && yOverlap(closestRect, rect))
                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
            let dx = getdx(x, rect), dy = getdy(y, rect);
            if (dx == 0 && dy == 0)
                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
            if (!closest || closestY > dy || closestY == dy && closestX > dx) {
                closest = child;
                closestRect = rect;
                closestX = dx;
                closestY = dy;
                let side = dy ? (y < rect.top ? -1 : 1) : dx ? (x < rect.left ? -1 : 1) : 0;
                closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
            }
            if (dx == 0) {
                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                    above = child;
                    aboveRect = rect;
                }
                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
                    below = child;
                    belowRect = rect;
                }
            }
            else if (aboveRect && yOverlap(aboveRect, rect)) {
                aboveRect = upBot(aboveRect, rect.bottom);
            }
            else if (belowRect && yOverlap(belowRect, rect)) {
                belowRect = upTop(belowRect, rect.top);
            }
        }
    }
    if (aboveRect && aboveRect.bottom >= y) {
        closest = above;
        closestRect = aboveRect;
    }
    else if (belowRect && belowRect.top <= y) {
        closest = below;
        closestRect = belowRect;
    }
    if (!closest)
        return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
        return domPosInText(closest, clipX, y);
    if (closestOverlap && closest.contentEditable != "false")
        return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +
        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
}
function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
        let rects = textRange(node, i, i + 1).getClientRects();
        for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (rect.top == rect.bottom)
                continue;
            if (!generalSide)
                generalSide = x - rect.left;
            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
                let right = x >= (rect.left + rect.right) / 2, after = right;
                if (browser.chrome || browser.gecko) {
                    // Check for RTL on browsers that support getting client
                    // rects for empty ranges.
                    let rectBefore = textRange(node, i).getBoundingClientRect();
                    if (rectBefore.left == rect.right)
                        after = !right;
                }
                if (dy <= 0)
                    return { node, offset: i + (after ? 1 : 0) };
                closestOffset = i + (after ? 1 : 0);
                closestDY = dy;
            }
        }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
    var _a, _b;
    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;
    let block, { docHeight } = view.viewState;
    let { x, y } = coords, yOffset = y - docTop;
    if (yOffset < 0)
        return 0;
    if (yOffset > docHeight)
        return view.state.doc.length;
    // Scan for a text block near the queried y position
    for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;) {
        block = view.elementAtHeight(yOffset);
        if (block.type == exports.BlockType.Text)
            break;
        for (;;) {
            // Move the y position out of this block
            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
            if (yOffset >= 0 && yOffset <= docHeight)
                break;
            // If the document consists entirely of replaced widgets, we
            // won't find a text block, so return 0
            if (bounced)
                return precise ? null : 0;
            bounced = true;
            bias = -bias;
        }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    // If this is outside of the rendered viewport, we can't determine a position
    if (lineStart < view.viewport.from)
        return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    if (lineStart > view.viewport.to)
        return view.viewport.to == view.state.doc.length ? view.state.doc.length :
            precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not
    let doc = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc;
    let element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
        element = null;
    // If the element is unexpected, clip x at the sides of the content area and try again
    if (!element) {
        x = Math.max(content.left + 1, Math.min(content.right - 1, x));
        element = root.elementFromPoint(x, y);
        if (element && !view.contentDOM.contains(element))
            element = null;
    }
    // There's visible editor content under the point, so we can try
    // using caret(Position|Range)FromPoint as a shortcut
    let node, offset = -1;
    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
        if (doc.caretPositionFromPoint) {
            let pos = doc.caretPositionFromPoint(x, y);
            if (pos)
                ({ offsetNode: node, offset } = pos);
        }
        else if (doc.caretRangeFromPoint) {
            let range = doc.caretRangeFromPoint(x, y);
            if (range) {
                ({ startContainer: node, startOffset: offset } = range);
                if (!view.contentDOM.contains(node) ||
                    browser.safari && isSuspiciousSafariCaretResult(node, offset, x) ||
                    browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
                    node = undefined;
            }
        }
        // Chrome will return offsets into <input> elements without child
        // nodes, which will lead to a null deref below, so clip the
        // offset to the node size.
        if (node)
            offset = Math.min(maxOffset(node), offset);
    }
    // No luck, do our own (potentially expensive) search
    if (!node || !view.docView.dom.contains(node)) {
        let line = LineView.find(view.docView, lineStart);
        if (!line)
            return yOffset > block.top + block.height / 2 ? block.to : block.from;
        ({ node, offset } = domPosAtCoords(line.dom, x, y));
    }
    let nearest = view.docView.nearest(node);
    if (!nearest)
        return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
        let rect = nearest.dom.getBoundingClientRect();
        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2
            ? nearest.posAtStart : nearest.posAtEnd;
    }
    else {
        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
    }
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
        let textHeight = view.viewState.heightOracle.textHeight;
        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
        into += line * view.viewState.heightOracle.lineLength;
    }
    let content = view.state.sliceDoc(block.from, block.to);
    return block.from + state.findColumn(content, into, view.state.tabSize);
}
// In case of a high line height, Safari's caretRangeFromPoint treats
// the space between lines as belonging to the last character of the
// line before. This is used to detect such a result so that it can be
// ignored (issue #401).
function isSuspiciousSafariCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
        return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
        if (next.nodeType != 1 || next.nodeName != "BR")
            return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
// Chrome will move positions between lines to the start of the next line
function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0)
        return false;
    for (let cur = node;;) {
        let parent = cur.parentNode;
        if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
            return false;
        if (parent.classList.contains("cm-line"))
            break;
        cur = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect()
        : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
}
function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
        for (let l of line.type) {
            if (l.to > pos || l.to == pos && (l.to == line.to || l.type == exports.BlockType.Text))
                return l;
        }
    return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = blockAt(view, start.head);
    let coords = !includeWrap || line.type != exports.BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null
        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
        let editorRect = view.dom.getBoundingClientRect();
        let direction = view.textDirectionAt(line.from);
        let pos = view.posAtCoords({ x: forward == (direction == exports.Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
            y: (coords.top + coords.bottom) / 2 });
        if (pos != null)
            return state.EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    return state.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur = start, check = null;;) {
        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
        if (!next) {
            if (line.number == (forward ? view.state.doc.lines : 1))
                return cur;
            char = "\n";
            line = view.state.doc.line(line.number + (forward ? 1 : -1));
            spans = view.bidiSpans(line);
            next = view.visualLineSide(line, !forward);
        }
        if (!check) {
            if (!by)
                return next;
            check = by(char);
        }
        else if (!check(char)) {
            return cur;
        }
        cur = next;
    }
}
function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
        let nextCat = categorize(next);
        if (cat == state.CharCategory.Space)
            cat = nextCat;
        return cat == nextCat;
    };
}
function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
        return state.EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
    if (startCoords) {
        if (goal == null)
            goal = startCoords.left - rect.left;
        startY = dir < 0 ? startCoords.top : startCoords.bottom;
    }
    else {
        let line = view.viewState.lineBlockAt(startPos);
        if (goal == null)
            goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
        startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : (view.viewState.heightOracle.textHeight >> 1);
    for (let extra = 0;; extra += 10) {
        let curY = startY + (dist + extra) * dir;
        let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
            let charRect = view.docView.coordsForChar(pos);
            let assoc = !charRect || curY < charRect.top ? -1 : 1;
            return state.EditorSelection.cursor(pos, assoc, undefined, goal);
        }
    }
}
function skipAtomicRanges(atoms, pos, bias) {
    for (;;) {
        let moved = 0;
        for (let set of atoms) {
            set.between(pos - 1, pos + 1, (from, to, value) => {
                if (pos > from && pos < to) {
                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);
                    pos = side < 0 ? from : to;
                    moved = side;
                }
            });
        }
        if (!moved)
            return pos;
    }
}
function skipAtoms(view, oldPos, pos) {
    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map(f => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : state.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}

const LineBreakPlaceholder = "\uffff";
class DOMReader {
    constructor(points, state$1) {
        this.points = points;
        this.text = "";
        this.lineSeparator = state$1.facet(state.EditorState.lineSeparator);
    }
    append(text) {
        this.text += text;
    }
    lineBreak() {
        this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
        if (!start)
            return this;
        let parent = start.parentNode;
        for (let cur = start;;) {
            this.findPointBefore(parent, cur);
            let oldLen = this.text.length;
            this.readNode(cur);
            let next = cur.nextSibling;
            if (next == end)
                break;
            let view = ContentView.get(cur), nextView = ContentView.get(next);
            if (view && nextView ? view.breakAfter :
                (view ? view.breakAfter : isBlockElement(cur)) ||
                    (isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen))
                this.lineBreak();
            cur = next;
        }
        this.findPointBefore(parent, end);
        return this;
    }
    readTextNode(node) {
        let text = node.nodeValue;
        for (let point of this.points)
            if (point.node == node)
                point.pos = this.text.length + Math.min(point.offset, text.length);
        for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g;;) {
            let nextBreak = -1, breakSize = 1, m;
            if (this.lineSeparator) {
                nextBreak = text.indexOf(this.lineSeparator, off);
                breakSize = this.lineSeparator.length;
            }
            else if (m = re.exec(text)) {
                nextBreak = m.index;
                breakSize = m[0].length;
            }
            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
            if (nextBreak < 0)
                break;
            this.lineBreak();
            if (breakSize > 1)
                for (let point of this.points)
                    if (point.node == node && point.pos > this.text.length)
                        point.pos -= breakSize - 1;
            off = nextBreak + breakSize;
        }
    }
    readNode(node) {
        if (node.cmIgnore)
            return;
        let view = ContentView.get(node);
        let fromView = view && view.overrideDOMText;
        if (fromView != null) {
            this.findPointInside(node, fromView.length);
            for (let i = fromView.iter(); !i.next().done;) {
                if (i.lineBreak)
                    this.lineBreak();
                else
                    this.append(i.value);
            }
        }
        else if (node.nodeType == 3) {
            this.readTextNode(node);
        }
        else if (node.nodeName == "BR") {
            if (node.nextSibling)
                this.lineBreak();
        }
        else if (node.nodeType == 1) {
            this.readRange(node.firstChild, null);
        }
    }
    findPointBefore(node, next) {
        for (let point of this.points)
            if (point.node == node && node.childNodes[point.offset] == next)
                point.pos = this.text.length;
    }
    findPointInside(node, length) {
        for (let point of this.points)
            if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
                point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
    }
}
function isAtEnd(parent, node, offset) {
    for (;;) {
        if (!node || offset < maxOffset(node))
            return false;
        if (node == parent)
            return true;
        offset = domIndex(node) + 1;
        node = node.parentNode;
    }
}
class DOMPoint {
    constructor(node, offset) {
        this.node = node;
        this.offset = offset;
        this.pos = -1;
    }
}

class DOMChange {
    constructor(view, start, end, typeOver) {
        this.typeOver = typeOver;
        this.bounds = null;
        this.text = "";
        this.domChanged = start > -1;
        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
        if (view.state.readOnly && start > -1) {
            // Ignore changes when the editor is read-only
            this.newSel = null;
        }
        else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
            let reader = new DOMReader(selPoints, view.state);
            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
            this.text = reader.text;
            this.newSel = selectionFromPoints(selPoints, this.bounds.from);
        }
        else {
            let domSel = view.observer.selectionRange;
            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ||
                !contains(view.contentDOM, domSel.focusNode)
                ? view.state.selection.main.head
                : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ||
                !contains(view.contentDOM, domSel.anchorNode)
                ? view.state.selection.main.anchor
                : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
            // iOS will refuse to select the block gaps when doing
            // select-all.
            // Chrome will put the selection *inside* them, confusing
            // posFromDOM
            let vp = view.viewport;
            if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor &&
                (vp.from > 0 || vp.to < view.state.doc.length)) {
                let from = Math.min(head, anchor), to = Math.max(head, anchor);
                let offFrom = vp.from - from, offTo = vp.to - to;
                if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
                    head = 0;
                    anchor = view.state.doc.length;
                }
            }
            this.newSel = state.EditorSelection.single(anchor, head);
        }
    }
}
function applyDOMChange(view, domChange) {
    let change;
    let { newSel } = domChange, sel = view.state.selection.main;
    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
        let { from, to } = domChange.bounds;
        let preferredPos = sel.from, preferredSide = null;
        // Prefer anchoring to end when Backspace is pressed (or, on
        // Android, when something was deleted)
        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
            preferredPos = sel.to;
            preferredSide = "end";
        }
        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
        if (diff) {
            // Chrome inserts two newlines when pressing shift-enter at the
            // end of a line. DomChange drops one of those.
            if (browser.chrome && lastKey == 13 &&
                diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
                diff.toB--;
            change = { from: from + diff.from, to: from + diff.toA,
                insert: state.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder)) };
        }
    }
    else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
        newSel = null;
    }
    if (!change && !newSel)
        return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
        // Heuristic to notice typing over a selected character
        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    }
    else if (change && change.from >= sel.from && change.to <= sel.to &&
        (change.from != sel.from || change.to != sel.to) &&
        (sel.to - sel.from) - (change.to - change.from) <= 4) {
        // If the change is inside the selection and covers most of it,
        // assume it is a selection replace (with identical characters at
        // the start/end not included in the diff)
        change = {
            from: sel.from, to: sel.to,
            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
        };
    }
    else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 &&
        /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
        // Detect insert-period-on-double-space Mac and Android behavior,
        // and transform it into a regular space insert.
        if (newSel && change.insert.length == 2)
            newSel = state.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: sel.from, to: sel.to, insert: state.Text.of([" "]) };
    }
    else if (browser.chrome && change && change.from == change.to && change.from == sel.head &&
        change.insert.toString() == "\n " && view.lineWrapping) {
        // In Chrome, if you insert a space at the start of a wrapped
        // line, it will actually insert a newline and a space, causing a
        // bogus new line to be created in CodeMirror (#968)
        if (newSel)
            newSel = state.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: sel.from, to: sel.to, insert: state.Text.of([" "]) };
    }
    if (change) {
        return applyDOMChangeInner(view, change, newSel, lastKey);
    }
    else if (newSel && !newSel.main.eq(sel)) {
        let scrollIntoView = false, userEvent = "select";
        if (view.inputState.lastSelectionTime > Date.now() - 50) {
            if (view.inputState.lastSelectionOrigin == "select")
                scrollIntoView = true;
            userEvent = view.inputState.lastSelectionOrigin;
        }
        view.dispatch({ selection: newSel, scrollIntoView, userEvent });
        return true;
    }
    else {
        return false;
    }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
    if (browser.ios && view.inputState.flushIOSKey(change))
        return true;
    let sel = view.state.selection.main;
    // Android browsers don't fire reasonable key events for enter,
    // backspace, or delete. So this detects changes that look like
    // they're caused by those keys, and reinterprets them as key
    // events. (Some of these keys are also handled by beforeinput
    // events and the pendingAndroidKey mechanism, but that's not
    // reliable in all situations.)
    if (browser.android &&
        ((change.to == sel.to &&
            // GBoard will sometimes remove a space it just inserted
            // after a completion when you press enter
            (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") &&
            change.insert.length == 1 && change.insert.lines == 2 &&
            dispatchKey(view.contentDOM, "Enter", 13)) ||
            ((change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 ||
                lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) &&
                dispatchKey(view.contentDOM, "Backspace", 8)) ||
            (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&
                dispatchKey(view.contentDOM, "Delete", 46))))
        return true;
    let text = change.insert.toString();
    if (view.inputState.composing >= 0)
        view.inputState.composing++;
    let defaultTr;
    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
    if (!view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text, defaultInsert)))
        view.dispatch(defaultInsert());
    return true;
}
function applyDefaultInsert(view, change, newSel) {
    let tr, startState = view.state, sel = startState.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 &&
        (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) &&
        view.inputState.composing < 0) {
        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
    }
    else {
        let changes = startState.changes(change);
        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;
        // Try to apply a composition change to all cursors
        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 &&
            change.to <= sel.to && change.to >= sel.to - 10) {
            let replaced = view.state.sliceDoc(change.from, change.to);
            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
            if (composition) {
                let dLen = change.insert.length - (change.to - change.from);
                compositionRange = { from: composition.from, to: composition.to - dLen };
            }
            else {
                compositionRange = view.state.doc.lineAt(sel.head);
            }
            let offset = sel.to - change.to, size = sel.to - sel.from;
            tr = startState.changeByRange(range => {
                if (range.from == sel.from && range.to == sel.to)
                    return { changes, range: mainSel || range.map(changes) };
                let to = range.to - offset, from = to - replaced.length;
                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||
                    // Unfortunately, there's no way to make multiple
                    // changes in the same node work without aborting
                    // composition, so cursors in the composition range are
                    // ignored.
                    range.to >= compositionRange.from && range.from <= compositionRange.to)
                    return { range };
                let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
                return {
                    changes: rangeChanges,
                    range: !mainSel ? range.map(rangeChanges) :
                        state.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
                };
            });
        }
        else {
            tr = {
                changes,
                selection: mainSel && startState.selection.replaceRange(mainSel)
            };
        }
    }
    let userEvent = "input.type";
    if (view.composing ||
        view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
        view.inputState.compositionPendingChange = false;
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
            userEvent += ".start";
            view.inputState.compositionFirstChange = false;
        }
    }
    return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
        from++;
    if (from == minLen && a.length == b.length)
        return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
        toA--;
        toB--;
    }
    if (preferredSide == "end") {
        let adjust = Math.max(0, from - Math.min(toA, toB));
        preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
        from -= move;
        toB = from + (toB - toA);
        toA = from;
    }
    else if (toB < from) {
        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
        from -= move;
        toA = from + (toA - toB);
        toB = from;
    }
    return { from, toA, toB };
}
function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
        return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
        result.push(new DOMPoint(anchorNode, anchorOffset));
        if (focusNode != anchorNode || focusOffset != anchorOffset)
            result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
}
function selectionFromPoints(points, base) {
    if (points.length == 0)
        return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? state.EditorSelection.single(anchor + base, head + base) : null;
}

class InputState {
    setSelectionOrigin(origin) {
        this.lastSelectionOrigin = origin;
        this.lastSelectionTime = Date.now();
    }
    constructor(view) {
        this.view = view;
        this.lastKeyCode = 0;
        this.lastKeyTime = 0;
        this.lastTouchTime = 0;
        this.lastFocusTime = 0;
        this.lastScrollTop = 0;
        this.lastScrollLeft = 0;
        // On iOS, some keys need to have their default behavior happen
        // (after which we retroactively handle them and reset the DOM) to
        // avoid messing up the virtual keyboard state.
        this.pendingIOSKey = undefined;
        /**
        When enabled (>-1), tab presses are not given to key handlers,
        leaving the browser's default behavior. If >0, the mode expires
        at that timestamp, and any other keypress clears it.
        Esc enables temporary tab focus mode for two seconds when not
        otherwise handled.
        */
        this.tabFocusMode = -1;
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastContextMenu = 0;
        this.scrollHandlers = [];
        this.handlers = Object.create(null);
        // -1 means not in a composition. Otherwise, this counts the number
        // of changes made during the composition. The count is used to
        // avoid treating the start state of the composition, before any
        // changes have been made, as part of the composition.
        this.composing = -1;
        // Tracks whether the next change should be marked as starting the
        // composition (null means no composition, true means next is the
        // first, false means first has already been marked for this
        // composition)
        this.compositionFirstChange = null;
        // End time of the previous composition
        this.compositionEndedAt = 0;
        // Used in a kludge to detect when an Enter keypress should be
        // considered part of the composition on Safari, which fires events
        // in the wrong order
        this.compositionPendingKey = false;
        // Used to categorize changes as part of a composition, even when
        // the mutation events fire shortly after the compositionend event
        this.compositionPendingChange = false;
        this.mouseSelection = null;
        // When a drag from the editor is active, this points at the range
        // being dragged.
        this.draggedContent = null;
        this.handleEvent = this.handleEvent.bind(this);
        this.notifiedFocused = view.hasFocus;
        // On Safari adding an input event handler somehow prevents an
        // issue where the composition vanishes when you press enter.
        if (browser.safari)
            view.contentDOM.addEventListener("input", () => null);
        if (browser.gecko)
            firefoxCopyCutHack(view.contentDOM.ownerDocument);
    }
    handleEvent(event) {
        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
            return;
        if (event.type == "keydown" && this.keydown(event))
            return;
        this.runHandlers(event.type, event);
    }
    runHandlers(type, event) {
        let handlers = this.handlers[type];
        if (handlers) {
            for (let observer of handlers.observers)
                observer(this.view, event);
            for (let handler of handlers.handlers) {
                if (event.defaultPrevented)
                    break;
                if (handler(this.view, event)) {
                    event.preventDefault();
                    break;
                }
            }
        }
    }
    ensureHandlers(plugins) {
        let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
        for (let type in handlers)
            if (type != "scroll") {
                let passive = !handlers[type].handlers.length;
                let exists = prev[type];
                if (exists && passive != !exists.handlers.length) {
                    dom.removeEventListener(type, this.handleEvent);
                    exists = null;
                }
                if (!exists)
                    dom.addEventListener(type, this.handleEvent, { passive });
            }
        for (let type in prev)
            if (type != "scroll" && !handlers[type])
                dom.removeEventListener(type, this.handleEvent);
        this.handlers = handlers;
    }
    keydown(event) {
        // Must always run, even if a custom handler handled the event
        this.lastKeyCode = event.keyCode;
        this.lastKeyTime = Date.now();
        if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
            return true;
        if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
            this.tabFocusMode = -1;
        // Chrome for Android usually doesn't fire proper key events, but
        // occasionally does, usually surrounded by a bunch of complicated
        // composition changes. When an enter or backspace key event is
        // seen, hold off on handling DOM events for a bit, and then
        // dispatch it.
        if (browser.android && browser.chrome && !event.synthetic &&
            (event.keyCode == 13 || event.keyCode == 8)) {
            this.view.observer.delayAndroidKey(event.key, event.keyCode);
            return true;
        }
        // Preventing the default behavior of Enter on iOS makes the
        // virtual keyboard get stuck in the wrong (lowercase)
        // state. So we let it go through, and then, in
        // applyDOMChange, notify key handlers of it and reset to
        // the state they produce.
        let pending;
        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey &&
            ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey ||
                EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
            this.pendingIOSKey = pending || event;
            setTimeout(() => this.flushIOSKey(), 250);
            return true;
        }
        if (event.keyCode != 229)
            this.view.observer.forceFlush();
        return false;
    }
    flushIOSKey(change) {
        let key = this.pendingIOSKey;
        if (!key)
            return false;
        // This looks like an autocorrection before Enter
        if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
            return false;
        this.pendingIOSKey = undefined;
        return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : undefined);
    }
    ignoreDuringComposition(event) {
        if (!/^key/.test(event.type))
            return false;
        if (this.composing > 0)
            return true;
        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
        // On some input method editors (IMEs), the Enter key is used to
        // confirm character selection. On Safari, when Enter is pressed,
        // compositionend and keydown events are sometimes emitted in the
        // wrong order. The key event should still be ignored, even when
        // it happens after the compositionend event.
        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
            this.compositionPendingKey = false;
            return true;
        }
        return false;
    }
    startMouseSelection(mouseSelection) {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
        this.mouseSelection = mouseSelection;
    }
    update(update) {
        this.view.observer.update(update);
        if (this.mouseSelection)
            this.mouseSelection.update(update);
        if (this.draggedContent && update.docChanged)
            this.draggedContent = this.draggedContent.map(update.changes);
        if (update.transactions.length)
            this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
    }
}
function bindHandler(plugin, handler) {
    return (view, event) => {
        try {
            return handler.call(plugin, event, view);
        }
        catch (e) {
            logException(view.state, e);
        }
    };
}
function computeHandlers(plugins) {
    let result = Object.create(null);
    function record(type) {
        return result[type] || (result[type] = { observers: [], handlers: [] });
    }
    for (let plugin of plugins) {
        let spec = plugin.spec;
        if (spec && spec.domEventHandlers)
            for (let type in spec.domEventHandlers) {
                let f = spec.domEventHandlers[type];
                if (f)
                    record(type).handlers.push(bindHandler(plugin.value, f));
            }
        if (spec && spec.domEventObservers)
            for (let type in spec.domEventObservers) {
                let f = spec.domEventObservers[type];
                if (f)
                    record(type).observers.push(bindHandler(plugin.value, f));
            }
    }
    for (let type in handlers)
        record(type).handlers.push(handlers[type]);
    for (let type in observers)
        record(type).observers.push(observers[type]);
    return result;
}
const PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const EmacsyPendingKeys = "dthko";
// Key codes for modifier keys
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
const dragScrollMargin = 6;
function dragScrollSpeed(dist) {
    return Math.max(0, dist) * 0.7 + 8;
}
function dist(a, b) {
    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
}
class MouseSelection {
    constructor(view, startEvent, style, mustSelect) {
        this.view = view;
        this.startEvent = startEvent;
        this.style = style;
        this.mustSelect = mustSelect;
        this.scrollSpeed = { x: 0, y: 0 };
        this.scrolling = -1;
        this.lastEvent = startEvent;
        this.scrollParents = scrollableParents(view.contentDOM);
        this.atoms = view.state.facet(atomicRanges).map(f => f(view));
        let doc = view.contentDOM.ownerDocument;
        doc.addEventListener("mousemove", this.move = this.move.bind(this));
        doc.addEventListener("mouseup", this.up = this.up.bind(this));
        this.extend = startEvent.shiftKey;
        this.multiple = view.state.facet(state.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event) {
        // When clicking outside of the selection, immediately apply the
        // effect of starting the selection
        if (this.dragging === false)
            this.select(event);
    }
    move(event) {
        if (event.buttons == 0)
            return this.destroy();
        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
            return;
        this.select(this.lastEvent = event);
        let sx = 0, sy = 0;
        let left = 0, top = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
        if (this.scrollParents.x)
            ({ left, right } = this.scrollParents.x.getBoundingClientRect());
        if (this.scrollParents.y)
            ({ top, bottom } = this.scrollParents.y.getBoundingClientRect());
        let margins = getScrollMargins(this.view);
        if (event.clientX - margins.left <= left + dragScrollMargin)
            sx = -dragScrollSpeed(left - event.clientX);
        else if (event.clientX + margins.right >= right - dragScrollMargin)
            sx = dragScrollSpeed(event.clientX - right);
        if (event.clientY - margins.top <= top + dragScrollMargin)
            sy = -dragScrollSpeed(top - event.clientY);
        else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
            sy = dragScrollSpeed(event.clientY - bottom);
        this.setScrollSpeed(sx, sy);
    }
    up(event) {
        if (this.dragging == null)
            this.select(this.lastEvent);
        if (!this.dragging)
            event.preventDefault();
        this.destroy();
    }
    destroy() {
        this.setScrollSpeed(0, 0);
        let doc = this.view.contentDOM.ownerDocument;
        doc.removeEventListener("mousemove", this.move);
        doc.removeEventListener("mouseup", this.up);
        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(sx, sy) {
        this.scrollSpeed = { x: sx, y: sy };
        if (sx || sy) {
            if (this.scrolling < 0)
                this.scrolling = setInterval(() => this.scroll(), 50);
        }
        else if (this.scrolling > -1) {
            clearInterval(this.scrolling);
            this.scrolling = -1;
        }
    }
    scroll() {
        let { x, y } = this.scrollSpeed;
        if (x && this.scrollParents.x) {
            this.scrollParents.x.scrollLeft += x;
            x = 0;
        }
        if (y && this.scrollParents.y) {
            this.scrollParents.y.scrollTop += y;
            y = 0;
        }
        if (x || y)
            this.view.win.scrollBy(x, y);
        if (this.dragging === false)
            this.select(this.lastEvent);
    }
    skipAtoms(sel) {
        let ranges = null;
        for (let i = 0; i < sel.ranges.length; i++) {
            let range = sel.ranges[i], updated = null;
            if (range.empty) {
                let pos = skipAtomicRanges(this.atoms, range.from, 0);
                if (pos != range.from)
                    updated = state.EditorSelection.cursor(pos, -1);
            }
            else {
                let from = skipAtomicRanges(this.atoms, range.from, -1);
                let to = skipAtomicRanges(this.atoms, range.to, 1);
                if (from != range.from || to != range.to)
                    updated = state.EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
            }
            if (updated) {
                if (!ranges)
                    ranges = sel.ranges.slice();
                ranges[i] = updated;
            }
        }
        return ranges ? state.EditorSelection.create(ranges, sel.mainIndex) : sel;
    }
    select(event) {
        let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
        if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false))
            this.view.dispatch({
                selection,
                userEvent: "select.pointer"
            });
        this.mustSelect = false;
    }
    update(update) {
        if (update.transactions.some(tr => tr.isUserEvent("input.type")))
            this.destroy();
        else if (this.style.update(update))
            setTimeout(() => this.select(this.lastEvent), 20);
    }
}
function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
    let { main } = view.state.selection;
    if (main.empty)
        return false;
    // On boundary clicks, check whether the coordinates are inside the
    // selection's client rectangles
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0)
        return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (rect.left <= event.clientX && rect.right >= event.clientX &&
            rect.top <= event.clientY && rect.bottom >= event.clientY)
            return true;
    }
    return false;
}
function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
        return true;
    if (event.defaultPrevented)
        return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))
            return false;
    return true;
}
const handlers = Object.create(null);
const observers = Object.create(null);
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
const brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||
    (browser.ios && browser.webkit_version < 604);
function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
        view.focus();
        target.remove();
        doPaste(view, target.value);
    }, 50);
}
function textFilter(state, facet, text) {
    for (let filter of state.facet(facet))
        text = filter(text, state);
    return text;
}
function doPaste(view, input) {
    input = textFilter(view.state, clipboardInputFilter, input);
    let { state: state$1 } = view, changes, i = 1, text = state$1.toText(input);
    let byLine = text.lines == state$1.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state$1.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
        let lastLine = -1;
        changes = state$1.changeByRange(range => {
            let line = state$1.doc.lineAt(range.from);
            if (line.from == lastLine)
                return { range };
            lastLine = line.from;
            let insert = state$1.toText((byLine ? text.line(i++).text : input) + state$1.lineBreak);
            return { changes: { from: line.from, insert },
                range: state.EditorSelection.cursor(range.from + insert.length) };
        });
    }
    else if (byLine) {
        changes = state$1.changeByRange(range => {
            let line = text.line(i++);
            return { changes: { from: range.from, to: range.to, insert: line.text },
                range: state.EditorSelection.cursor(range.from + line.length) };
        });
    }
    else {
        changes = state$1.replaceSelection(text);
    }
    view.dispatch(changes, {
        userEvent: "input.paste",
        scrollIntoView: true
    });
}
observers.scroll = view => {
    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
        view.inputState.tabFocusMode = Date.now() + 2000;
    return false;
};
observers.touchstart = (view, e) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = view => {
    view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2000)
        return false; // Ignore touch interaction
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
        style = makeStyle(view, event);
        if (style)
            break;
    }
    if (!style && event.button == 0)
        style = basicMouseSelection(view, event);
    if (style) {
        let mustFocus = !view.hasFocus;
        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
        if (mustFocus)
            view.observer.ignore(() => {
                focusPreventScroll(view.contentDOM);
                let active = view.root.activeElement;
                if (active && !active.contains(view.contentDOM))
                    active.blur();
            });
        let mouseSel = view.inputState.mouseSelection;
        if (mouseSel) {
            mouseSel.start(event);
            return mouseSel.dragging === false;
        }
    }
    return false;
};
function rangeForClick(view, pos, bias, type) {
    if (type == 1) { // Single click
        return state.EditorSelection.cursor(pos, bias);
    }
    else if (type == 2) { // Double click
        return groupAt(view.state, pos, bias);
    }
    else { // Triple click
        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
        if (to < view.state.doc.length && to == line.to)
            to++;
        return state.EditorSelection.range(from, to);
    }
}
let inside = (x, y, rect) => y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
// Try to determine, for the given coordinates, associated with the
// given position, whether they are related to the element before or
// the element after the position.
function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
        return 1;
    let off = pos - line.posAtStart;
    // Line boundaries point into the line
    if (off == 0)
        return 1;
    if (off == line.length)
        return -1;
    // Positions on top of an element point at that element
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
        return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
        return 1;
    // This is probably a line wrap point. Pick before if the point is
    // above its bottom.
    return before && before.bottom >= y ? -1 : 1;
}
function queryPos(view, event) {
    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event) {
    if (!BadMouseDetail)
        return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || (lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&
        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    return {
        update(update) {
            if (update.docChanged) {
                start.pos = update.changes.mapPos(start.pos);
                startSel = startSel.map(update.changes);
            }
        },
        get(event, extend, multiple) {
            let cur = queryPos(view, event), removed;
            let range = rangeForClick(view, cur.pos, cur.bias, type);
            if (start.pos != cur.pos && !extend) {
                let startRange = rangeForClick(view, start.pos, start.bias, type);
                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
                range = from < range.from ? state.EditorSelection.range(from, to) : state.EditorSelection.range(to, from);
            }
            if (extend)
                return startSel.replaceRange(startSel.main.extend(range.from, range.to));
            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
                return removed;
            else if (multiple)
                return startSel.addRange(range);
            else
                return state.EditorSelection.create([range]);
        }
    };
}
function removeRangeAround(sel, pos) {
    for (let i = 0; i < sel.ranges.length; i++) {
        let { from, to } = sel.ranges[i];
        if (from <= pos && to >= pos)
            return state.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
    return null;
}
handlers.dragstart = (view, event) => {
    let { selection: { main: range } } = view.state;
    if (event.target.draggable) {
        let cView = view.docView.nearest(event.target);
        if (cView && cView.isWidget) {
            let from = cView.posAtStart, to = from + cView.length;
            if (from >= range.to || to <= range.from)
                range = state.EditorSelection.range(from, to);
        }
    }
    let { inputState } = view;
    if (inputState.mouseSelection)
        inputState.mouseSelection.dragging = true;
    inputState.draggedContent = range;
    if (event.dataTransfer) {
        event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
        event.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
};
handlers.dragend = view => {
    view.inputState.draggedContent = null;
    return false;
};
function dropText(view, event, text, direct) {
    text = textFilter(view.state, clipboardInputFilter, text);
    if (!text)
        return;
    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let { draggedContent } = view.inputState;
    let del = direct && draggedContent && dragMovesSelection(view, event)
        ? { from: draggedContent.from, to: draggedContent.to } : null;
    let ins = { from: dropPos, insert: text };
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
        changes,
        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
        userEvent: del ? "move.drop" : "input.drop"
    });
    view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
    if (!event.dataTransfer)
        return false;
    if (view.state.readOnly)
        return true;
    let files = event.dataTransfer.files;
    if (files && files.length) { // For a file drop, read the file's text.
        let text = Array(files.length), read = 0;
        let finishFile = () => {
            if (++read == files.length)
                dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);
        };
        for (let i = 0; i < files.length; i++) {
            let reader = new FileReader;
            reader.onerror = finishFile;
            reader.onload = () => {
                if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
                    text[i] = reader.result;
                finishFile();
            };
            reader.readAsText(files[i]);
        }
        return true;
    }
    else {
        let text = event.dataTransfer.getData("Text");
        if (text) {
            dropText(view, event, text, true);
            return true;
        }
    }
    return false;
};
handlers.paste = (view, event) => {
    if (view.state.readOnly)
        return true;
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
        return true;
    }
    else {
        capturePaste(view);
        return false;
    }
};
function captureCopy(view, text) {
    // The extra wrapper is somehow necessary on IE/Edge to prevent the
    // content from being mangled when it is put onto the clipboard
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
        target.remove();
        view.focus();
    }, 50);
}
function copiedRange(state) {
    let content = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
        if (!range.empty) {
            content.push(state.sliceDoc(range.from, range.to));
            ranges.push(range);
        }
    if (!content.length) {
        // Nothing selected, do a line-wise copy
        let upto = -1;
        for (let { from } of state.selection.ranges) {
            let line = state.doc.lineAt(from);
            if (line.number > upto) {
                content.push(line.text);
                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
            }
            upto = line.number;
        }
        linewise = true;
    }
    return { text: textFilter(state, clipboardOutputFilter, content.join(state.lineBreak)), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise)
        return false;
    lastLinewiseCopy = linewise ? text : null;
    if (event.type == "cut" && !view.state.readOnly)
        view.dispatch({
            changes: ranges,
            scrollIntoView: true,
            userEvent: "delete.cut"
        });
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        data.clearData();
        data.setData("text/plain", text);
        return true;
    }
    else {
        captureCopy(view, text);
        return false;
    }
};
const isFocusChange = state.Annotation.define();
function focusChangeTransaction(state, focus) {
    let effects = [];
    for (let getEffect of state.facet(focusChangeEffect)) {
        let effect = getEffect(state, focus);
        if (effect)
            effects.push(effect);
    }
    return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
    setTimeout(() => {
        let focus = view.hasFocus;
        if (focus != view.inputState.notifiedFocused) {
            let tr = focusChangeTransaction(view.state, focus);
            if (tr)
                view.dispatch(tr);
            else
                view.update([]);
        }
    }, 10);
}
observers.focus = view => {
    view.inputState.lastFocusTime = Date.now();
    // When focusing reset the scroll position, move it back to where it was
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
};
observers.blur = view => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = view => {
    if (view.observer.editContext)
        return; // Composition handled by edit context
    if (view.inputState.compositionFirstChange == null)
        view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
        // FIXME possibly set a timeout to clear it again on Android
        view.inputState.composing = 0;
    }
};
observers.compositionend = view => {
    if (view.observer.editContext)
        return; // Composition handled by edit context
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionPendingKey = true;
    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) {
        // Delay flushing for a bit on Android because it'll often fire a
        // bunch of contradictory changes in a row at end of compositon
        view.observer.flushSoon();
    }
    else if (view.inputState.compositionPendingChange) {
        // If we found pending records, schedule a flush.
        Promise.resolve().then(() => view.observer.flush());
    }
    else {
        // Otherwise, make sure that, if no changes come in soon, the
        // composition view is cleared.
        setTimeout(() => {
            if (view.inputState.composing < 0 && view.docView.hasComposition)
                view.update([]);
        }, 50);
    }
};
observers.contextmenu = view => {
    view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
    var _a, _b;
    // In EditContext mode, we must handle insertReplacementText events
    // directly, to make spell checking corrections work
    if (event.inputType == "insertReplacementText" && view.observer.editContext) {
        let text = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData("text/plain"), ranges = event.getTargetRanges();
        if (text && ranges.length) {
            let r = ranges[0];
            let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);
            applyDOMChangeInner(view, { from, to, insert: view.state.toText(text) }, null);
            return true;
        }
    }
    // Because Chrome Android doesn't fire useful key events, use
    // beforeinput to detect backspace (and possibly enter and delete,
    // but those usually don't even seem to fire beforeinput events at
    // the moment) and fake a key event for it.
    //
    // (preventDefault on beforeinput, though supported in the spec,
    // seems to do nothing at all on Chrome).
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {
        view.observer.delayAndroidKey(pending.key, pending.keyCode);
        if (pending.key == "Backspace" || pending.key == "Delete") {
            let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
            setTimeout(() => {
                var _a;
                // Backspacing near uneditable nodes on Chrome Android sometimes
                // closes the virtual keyboard. This tries to crudely detect
                // that and refocus to get it back.
                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {
                    view.contentDOM.blur();
                    view.focus();
                }
            }, 100);
        }
    }
    if (browser.ios && event.inputType == "deleteContentForward") {
        // For some reason, DOM changes (and beforeinput) happen _before_
        // the key event for ctrl-d on iOS when using an external
        // keyboard.
        view.observer.flushSoon();
    }
    // Safari will occasionally forget to fire compositionend at the end of a dead-key composition
    if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
        setTimeout(() => observers.compositionend(view, event), 20);
    }
    return false;
};
const appliedFirefoxHack = new Set;
// In Firefox, when cut/copy handlers are added to the document, that
// somehow avoids a bug where those events aren't fired when the
// selection is empty. See https://github.com/codemirror/dev/issues/1082
// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961
function firefoxCopyCutHack(doc) {
    if (!appliedFirefoxHack.has(doc)) {
        appliedFirefoxHack.add(doc);
        doc.addEventListener("copy", () => { });
        doc.addEventListener("cut", () => { });
    }
}

const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
// Used to track, during updateHeight, if any actual heights changed
let heightChangeFlag = false;
function clearHeightChangeFlag() { heightChangeFlag = false; }
class HeightOracle {
    constructor(lineWrapping) {
        this.lineWrapping = lineWrapping;
        this.doc = state.Text.empty;
        this.heightSamples = {};
        this.lineHeight = 14; // The height of an entire line (line-height)
        this.charWidth = 7;
        this.textHeight = 14; // The height of the actual font (font-size)
        this.lineLength = 30;
    }
    heightForGap(from, to) {
        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
        if (this.lineWrapping)
            lines += Math.max(0, Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength));
        return this.lineHeight * lines;
    }
    heightForLine(length) {
        if (!this.lineWrapping)
            return this.lineHeight;
        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
        return lines * this.lineHeight;
    }
    setDoc(doc) { this.doc = doc; return this; }
    mustRefreshForWrapping(whiteSpace) {
        return (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
        let newHeight = false;
        for (let i = 0; i < lineHeights.length; i++) {
            let h = lineHeights[i];
            if (h < 0) {
                i++;
            }
            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels
                newHeight = true;
                this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
        this.lineWrapping = lineWrapping;
        this.lineHeight = lineHeight;
        this.charWidth = charWidth;
        this.textHeight = textHeight;
        this.lineLength = lineLength;
        if (changed) {
            this.heightSamples = {};
            for (let i = 0; i < knownHeights.length; i++) {
                let h = knownHeights[i];
                if (h < 0)
                    i++;
                else
                    this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return changed;
    }
}
// This object is used by `updateHeight` to make DOM measurements
// arrive at the right nides. The `heights` array is a sequence of
// block heights, starting from position `from`.
class MeasuredHeights {
    constructor(from, heights) {
        this.from = from;
        this.heights = heights;
        this.index = 0;
    }
    get more() { return this.index < this.heights.length; }
}
/**
Record used to represent information about a block-level element
in the editor view.
*/
class BlockInfo {
    /**
    @internal
    */
    constructor(
    /**
    The start of the element in the document.
    */
    from, 
    /**
    The length of the element.
    */
    length, 
    /**
    The top position of the element (relative to the top of the
    document).
    */
    top, 
    /**
    Its height.
    */
    height, 
    /**
    @internal Weird packed field that holds an array of children
    for composite blocks, a decoration for block widgets, and a
    number indicating the amount of widget-create line breaks for
    text blocks.
    */
    _content) {
        this.from = from;
        this.length = length;
        this.top = top;
        this.height = height;
        this._content = _content;
    }
    /**
    The type of element this is. When querying lines, this may be
    an array of all the blocks that make up the line.
    */
    get type() {
        return typeof this._content == "number" ? exports.BlockType.Text :
            Array.isArray(this._content) ? this._content : this._content.type;
    }
    /**
    The end of the element as a document position.
    */
    get to() { return this.from + this.length; }
    /**
    The bottom position of the element.
    */
    get bottom() { return this.top + this.height; }
    /**
    If this is a widget block, this will return the widget
    associated with it.
    */
    get widget() {
        return this._content instanceof PointDecoration ? this._content.widget : null;
    }
    /**
    If this is a textblock, this holds the number of line breaks
    that appear in widgets inside the block.
    */
    get widgetLineBreaks() {
        return typeof this._content == "number" ? this._content : 0;
    }
    /**
    @internal
    */
    join(other) {
        let content = (Array.isArray(this._content) ? this._content : [this])
            .concat(Array.isArray(other._content) ? other._content : [other]);
        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);
    }
}
var QueryType;
(function (QueryType) {
    QueryType[QueryType["ByPos"] = 0] = "ByPos";
    QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
    QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
})(QueryType || (QueryType = {}));
const Epsilon = 1e-3;
class HeightMap {
    constructor(length, // The number of characters covered
    height, // Height of this part of the document
    flags = 2 /* Flag.Outdated */) {
        this.length = length;
        this.height = height;
        this.flags = flags;
    }
    get outdated() { return (this.flags & 2 /* Flag.Outdated */) > 0; }
    set outdated(value) { this.flags = (value ? 2 /* Flag.Outdated */ : 0) | (this.flags & ~2 /* Flag.Outdated */); }
    setHeight(height) {
        if (this.height != height) {
            if (Math.abs(this.height - height) > Epsilon)
                heightChangeFlag = true;
            this.height = height;
        }
    }
    // Base case is to replace a leaf node, which simply builds a tree
    // from the new nodes and returns that (HeightMapBranch and
    // HeightMapGap override this to actually use from/to)
    replace(_from, _to, nodes) {
        return HeightMap.of(nodes);
    }
    // Again, these are base cases, and are overridden for branch and gap nodes.
    decomposeLeft(_to, result) { result.push(this); }
    decomposeRight(_from, result) { result.push(this); }
    applyChanges(decorations, oldDoc, oracle, changes) {
        let me = this, doc = oracle.doc;
        for (let i = changes.length - 1; i >= 0; i--) {
            let { fromA, toA, fromB, toB } = changes[i];
            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
            toB += end.to - toA;
            toA = end.to;
            while (i > 0 && start.from <= changes[i - 1].toA) {
                fromA = changes[i - 1].fromA;
                fromB = changes[i - 1].fromB;
                i--;
                if (fromA < start.from)
                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
            }
            fromB += start.from - fromA;
            fromA = start.from;
            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);
            me = replace(me, me.replace(fromA, toA, nodes));
        }
        return me.updateHeight(oracle, 0);
    }
    static empty() { return new HeightMapText(0, 0); }
    // nodes uses null values to indicate the position of line breaks.
    // There are never line breaks at the start or end of the array, or
    // two line breaks next to each other, and the array isn't allowed
    // to be empty (same restrictions as return value from the builder).
    static of(nodes) {
        if (nodes.length == 1)
            return nodes[0];
        let i = 0, j = nodes.length, before = 0, after = 0;
        for (;;) {
            if (i == j) {
                if (before > after * 2) {
                    let split = nodes[i - 1];
                    if (split.break)
                        nodes.splice(--i, 1, split.left, null, split.right);
                    else
                        nodes.splice(--i, 1, split.left, split.right);
                    j += 1 + split.break;
                    before -= split.size;
                }
                else if (after > before * 2) {
                    let split = nodes[j];
                    if (split.break)
                        nodes.splice(j, 1, split.left, null, split.right);
                    else
                        nodes.splice(j, 1, split.left, split.right);
                    j += 2 + split.break;
                    after -= split.size;
                }
                else {
                    break;
                }
            }
            else if (before < after) {
                let next = nodes[i++];
                if (next)
                    before += next.size;
            }
            else {
                let next = nodes[--j];
                if (next)
                    after += next.size;
            }
        }
        let brk = 0;
        if (nodes[i - 1] == null) {
            brk = 1;
            i--;
        }
        else if (nodes[i] == null) {
            brk = 1;
            j++;
        }
        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
}
function replace(old, val) {
    if (old == val)
        return old;
    if (old.constructor != val.constructor)
        heightChangeFlag = true;
    return val;
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
    constructor(length, height, deco) {
        super(length, height);
        this.deco = deco;
    }
    blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);
    }
    lineAt(_value, _type, oracle, top, offset) {
        return this.blockAt(0, oracle, top, offset);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        if (from <= offset + this.length && to >= offset)
            f(this.blockAt(0, oracle, top, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(measured.heights[measured.index++]);
        this.outdated = false;
        return this;
    }
    toString() { return `block(${this.length})`; }
}
class HeightMapText extends HeightMapBlock {
    constructor(length, height) {
        super(length, height, null);
        this.collapsed = 0; // Amount of collapsed content in the line
        this.widgetHeight = 0; // Maximum inline widget height
        this.breaks = 0; // Number of widget-introduced line breaks on the line
    }
    blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.breaks);
    }
    replace(_from, _to, nodes) {
        let node = nodes[0];
        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* Flag.SingleLine */)) &&
            Math.abs(this.length - node.length) < 10) {
            if (node instanceof HeightMapGap)
                node = new HeightMapText(node.length, this.height);
            else
                node.height = this.height;
            if (!this.outdated)
                node.outdated = false;
            return node;
        }
        else {
            return HeightMap.of(nodes);
        }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(measured.heights[measured.index++]);
        else if (force || this.outdated)
            this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) +
                this.breaks * oracle.lineHeight);
        this.outdated = false;
        return this;
    }
    toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
}
class HeightMapGap extends HeightMap {
    constructor(length) { super(length, 0); }
    heightMetrics(oracle, offset) {
        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
        let lines = lastLine - firstLine + 1;
        let perLine, perChar = 0;
        if (oracle.lineWrapping) {
            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
            perLine = totalPerLine / lines;
            if (this.length > lines + 1)
                perChar = (this.height - totalPerLine) / (this.length - lines - 1);
        }
        else {
            perLine = this.height / lines;
        }
        return { firstLine, lastLine, perLine, perChar };
    }
    blockAt(height, oracle, top, offset) {
        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        if (oracle.lineWrapping) {
            let guess = offset + (height < oracle.lineHeight ? 0
                : Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length));
            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
            let lineTop = Math.max(top, height - lineHeight / 2);
            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
        }
        else {
            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));
            let { from, length } = oracle.doc.line(firstLine + line);
            return new BlockInfo(from, length, top + perLine * line, perLine, 0);
        }
    }
    lineAt(value, type, oracle, top, offset) {
        if (type == QueryType.ByHeight)
            return this.blockAt(value, oracle, top, offset);
        if (type == QueryType.ByPosNoHeight) {
            let { from, to } = oracle.doc.lineAt(value);
            return new BlockInfo(from, to - from, 0, 0, 0);
        }
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
        let linesAbove = line.number - firstLine;
        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        from = Math.max(from, offset);
        to = Math.min(to, offset + this.length);
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        for (let pos = from, lineTop = top; pos <= to;) {
            let line = oracle.doc.lineAt(pos);
            if (pos == from) {
                let linesAbove = line.number - firstLine;
                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
            }
            let lineHeight = perLine + perChar * line.length;
            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
            lineTop += lineHeight;
            pos = line.to + 1;
        }
    }
    replace(from, to, nodes) {
        let after = this.length - to;
        if (after > 0) {
            let last = nodes[nodes.length - 1];
            if (last instanceof HeightMapGap)
                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
            else
                nodes.push(null, new HeightMapGap(after - 1));
        }
        if (from > 0) {
            let first = nodes[0];
            if (first instanceof HeightMapGap)
                nodes[0] = new HeightMapGap(from + first.length);
            else
                nodes.unshift(new HeightMapGap(from - 1), null);
        }
        return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
        result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
        result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let end = offset + this.length;
        if (measured && measured.from <= offset + this.length && measured.more) {
            // Fill in part of this gap with measured lines. We know there
            // can't be widgets or collapsed ranges in those lines, because
            // they would already have been added to the heightmap (gaps
            // only contain plain text).
            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
            if (measured.from > offset)
                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
            while (pos <= end && measured.more) {
                let len = oracle.doc.lineAt(pos).length;
                if (nodes.length)
                    nodes.push(null);
                let height = measured.heights[measured.index++];
                if (singleHeight == -1)
                    singleHeight = height;
                else if (Math.abs(height - singleHeight) >= Epsilon)
                    singleHeight = -2;
                let line = new HeightMapText(len, height);
                line.outdated = false;
                nodes.push(line);
                pos += len + 1;
            }
            if (pos <= end)
                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
            let result = HeightMap.of(nodes);
            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon ||
                Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
                heightChangeFlag = true;
            return replace(this, result);
        }
        else if (force || this.outdated) {
            this.setHeight(oracle.heightForGap(offset, offset + this.length));
            this.outdated = false;
        }
        return this;
    }
    toString() { return `gap(${this.length})`; }
}
class HeightMapBranch extends HeightMap {
    constructor(left, brk, right) {
        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));
        this.left = left;
        this.right = right;
        this.size = left.size + right.size;
    }
    get break() { return this.flags & 1 /* Flag.Break */; }
    blockAt(height, oracle, top, offset) {
        let mid = top + this.left.height;
        return height < mid ? this.left.blockAt(height, oracle, top, offset)
            : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, oracle, top, offset) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
        let base = left ? this.left.lineAt(value, type, oracle, top, offset)
            : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))
            return base;
        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
        if (left)
            return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
        else
            return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        if (this.break) {
            if (from < rightOffset)
                this.left.forEachLine(from, to, oracle, top, offset, f);
            if (to >= rightOffset)
                this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
        }
        else {
            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);
            if (from < mid.from)
                this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);
            if (mid.to >= from && mid.from <= to)
                f(mid);
            if (to > mid.to)
                this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
        }
    }
    replace(from, to, nodes) {
        let rightStart = this.left.length + this.break;
        if (to < rightStart)
            return this.balanced(this.left.replace(from, to, nodes), this.right);
        if (from > this.left.length)
            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
        let result = [];
        if (from > 0)
            this.decomposeLeft(from, result);
        let left = result.length;
        for (let node of nodes)
            result.push(node);
        if (from > 0)
            mergeGaps(result, left - 1);
        if (to < this.length) {
            let right = result.length;
            this.decomposeRight(to, result);
            mergeGaps(result, right);
        }
        return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
        let left = this.left.length;
        if (to <= left)
            return this.left.decomposeLeft(to, result);
        result.push(this.left);
        if (this.break) {
            left++;
            if (to >= left)
                result.push(null);
        }
        if (to > left)
            this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
        let left = this.left.length, right = left + this.break;
        if (from >= right)
            return this.right.decomposeRight(from - right, result);
        if (from < left)
            this.left.decomposeRight(from, result);
        if (this.break && from < right)
            result.push(null);
        result.push(this.right);
    }
    balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size)
            return HeightMap.of(this.break ? [left, null, right] : [left, right]);
        this.left = replace(this.left, left);
        this.right = replace(this.right, right);
        this.setHeight(left.height + right.height);
        this.outdated = left.outdated || right.outdated;
        this.size = left.size + right.size;
        this.length = left.length + this.break + right.length;
        return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
        if (measured && measured.from <= offset + left.length && measured.more)
            rebalance = left = left.updateHeight(oracle, offset, force, measured);
        else
            left.updateHeight(oracle, offset, force);
        if (measured && measured.from <= rightStart + right.length && measured.more)
            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
        else
            right.updateHeight(oracle, rightStart, force);
        if (rebalance)
            return this.balanced(left, right);
        this.height = this.left.height + this.right.height;
        this.outdated = false;
        return this;
    }
    toString() { return this.left + (this.break ? " " : "-") + this.right; }
}
function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null &&
        (before = nodes[around - 1]) instanceof HeightMapGap &&
        (after = nodes[around + 1]) instanceof HeightMapGap)
        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
    constructor(pos, oracle) {
        this.pos = pos;
        this.oracle = oracle;
        this.nodes = [];
        this.lineStart = -1;
        this.lineEnd = -1;
        this.covering = null;
        this.writtenTo = pos;
    }
    get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
        if (this.lineStart > -1) {
            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
            if (last instanceof HeightMapText)
                last.length += end - this.pos;
            else if (end > this.pos || !this.isCovered)
                this.nodes.push(new HeightMapText(end - this.pos, -1));
            this.writtenTo = end;
            if (to > end) {
                this.nodes.push(null);
                this.writtenTo++;
                this.lineStart = -1;
            }
        }
        this.pos = to;
    }
    point(from, to, deco) {
        if (from < to || deco.heightRelevant) {
            let height = deco.widget ? deco.widget.estimatedHeight : 0;
            let breaks = deco.widget ? deco.widget.lineBreaks : 0;
            if (height < 0)
                height = this.oracle.lineHeight;
            let len = to - from;
            if (deco.block) {
                this.addBlock(new HeightMapBlock(len, height, deco));
            }
            else if (len || breaks || height >= relevantWidgetHeight) {
                this.addLineDeco(height, breaks, len);
            }
        }
        else if (to > from) {
            this.span(from, to);
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos)
            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
        if (this.lineStart > -1)
            return;
        let { from, to } = this.oracle.doc.lineAt(this.pos);
        this.lineStart = from;
        this.lineEnd = to;
        if (this.writtenTo < from) {
            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
                this.nodes.push(this.blankContent(this.writtenTo, from - 1));
            this.nodes.push(null);
        }
        if (this.pos > from)
            this.nodes.push(new HeightMapText(this.pos - from, -1));
        this.writtenTo = this.pos;
    }
    blankContent(from, to) {
        let gap = new HeightMapGap(to - from);
        if (this.oracle.doc.lineAt(from).to == to)
            gap.flags |= 4 /* Flag.SingleLine */;
        return gap;
    }
    ensureLine() {
        this.enterLine();
        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (last instanceof HeightMapText)
            return last;
        let line = new HeightMapText(0, -1);
        this.nodes.push(line);
        return line;
    }
    addBlock(block) {
        this.enterLine();
        let deco = block.deco;
        if (deco && deco.startSide > 0 && !this.isCovered)
            this.ensureLine();
        this.nodes.push(block);
        this.writtenTo = this.pos = this.pos + block.length;
        if (deco && deco.endSide > 0)
            this.covering = block;
    }
    addLineDeco(height, breaks, length) {
        let line = this.ensureLine();
        line.length += length;
        line.collapsed += length;
        line.widgetHeight = Math.max(line.widgetHeight, height);
        line.breaks += breaks;
        this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
            this.nodes.push(new HeightMapText(0, -1));
        else if (this.writtenTo < this.pos || last == null)
            this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        let pos = from;
        for (let node of this.nodes) {
            if (node instanceof HeightMapText)
                node.updateHeight(this.oracle, pos);
            pos += node ? node.length : 1;
        }
        return this.nodes;
    }
    // Always called with a region that on both sides either stretches
    // to a line break or the end of the document.
    // The returned array uses null to indicate line breaks, but never
    // starts or ends in a line break, or has multiple line breaks next
    // to each other.
    static build(oracle, decorations, from, to) {
        let builder = new NodeBuilder(from, oracle);
        state.RangeSet.spans(decorations, from, to, builder, 0);
        return builder.finish(from);
    }
}
function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator;
    state.RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
}
class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange() { }
    comparePoint(from, to, a, b) {
        if (from < to || a && a.heightRelevant || b && b.heightRelevant)
            addRange(from, to, this.changes, 5);
    }
}

function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc.body;) {
        if (parent.nodeType == 1) {
            let elt = parent;
            let style = window.getComputedStyle(elt);
            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) &&
                style.overflow != "visible") {
                let parentRect = elt.getBoundingClientRect();
                left = Math.max(left, parentRect.left);
                right = Math.min(right, parentRect.right);
                top = Math.max(top, parentRect.top);
                bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
            }
            parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
        }
        else if (parent.nodeType == 11) { // Shadow root
            parent = parent.host;
        }
        else {
            break;
        }
    }
    return { left: left - rect.left, right: Math.max(left, right) - rect.left,
        top: top - (rect.top + paddingTop), bottom: Math.max(top, bottom) - (rect.top + paddingTop) };
}
function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return { left: 0, right: rect.right - rect.left,
        top: paddingTop, bottom: rect.bottom - (rect.top + paddingTop) };
}
// Line gaps are placeholder widgets used to hide pieces of overlong
// lines within the viewport, as a kludge to keep the editor
// responsive when a ridiculously long line is loaded into it.
class LineGap {
    constructor(from, to, size, displaySize) {
        this.from = from;
        this.to = to;
        this.size = size;
        this.displaySize = displaySize;
    }
    static same(a, b) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            let gA = a[i], gB = b[i];
            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
                return false;
        }
        return true;
    }
    draw(viewState, wrapping) {
        return Decoration.replace({
            widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
        }).range(this.from, this.to);
    }
}
class LineGapWidget extends WidgetType {
    constructor(size, vertical) {
        super();
        this.size = size;
        this.vertical = vertical;
    }
    eq(other) { return other.size == this.size && other.vertical == this.vertical; }
    toDOM() {
        let elt = document.createElement("div");
        if (this.vertical) {
            elt.style.height = this.size + "px";
        }
        else {
            elt.style.width = this.size + "px";
            elt.style.height = "2px";
            elt.style.display = "inline-block";
        }
        return elt;
    }
    get estimatedHeight() { return this.vertical ? this.size : -1; }
}
class ViewState {
    constructor(state$1) {
        this.state = state$1;
        // These are contentDOM-local coordinates
        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
        this.inView = true;
        this.paddingTop = 0; // Padding above the document, scaled
        this.paddingBottom = 0; // Padding below the document, scaled
        this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width
        this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height
        this.editorHeight = 0; // scrollDOM.clientHeight, unscaled
        this.editorWidth = 0; // scrollDOM.clientWidth, unscaled
        this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled
        this.scrolledToBottom = false;
        // The CSS-transformation scale of the editor (transformed size /
        // concrete size)
        this.scaleX = 1;
        this.scaleY = 1;
        // The vertical position (document-relative) to which to anchor the
        // scroll position. -1 means anchor to the end of the document.
        this.scrollAnchorPos = 0;
        // The height at the anchor position. Set by the DOM update phase.
        // -1 means no height available.
        this.scrollAnchorHeight = -1;
        // See VP.MaxDOMHeight
        this.scaler = IdScaler;
        this.scrollTarget = null;
        // Briefly set to true when printing, to disable viewport limiting
        this.printing = false;
        // Flag set when editor content was redrawn, so that the next
        // measure stage knows it must read DOM layout
        this.mustMeasureContent = true;
        this.defaultTextDirection = exports.Direction.LTR;
        this.visibleRanges = [];
        // Cursor 'assoc' is only significant when the cursor is on a line
        // wrap point, where it must stick to the character that it is
        // associated with. Since browsers don't provide a reasonable
        // interface to set or query this, when a selection is set that
        // might cause this to be significant, this flag is set. The next
        // measure phase will check whether the cursor is on a line-wrapping
        // boundary and, if so, reset it to make sure it is positioned in
        // the right place.
        this.mustEnforceCursorAssoc = false;
        let guessWrapping = state$1.facet(contentAttributes).some(v => typeof v != "function" && v.class == "cm-lineWrapping");
        this.heightOracle = new HeightOracle(guessWrapping);
        this.stateDeco = state$1.facet(decorations).filter(d => typeof d != "function");
        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, state.Text.empty, this.heightOracle.setDoc(state$1.doc), [new ChangedRange(0, 0, 0, state$1.doc.length)]);
        for (let i = 0; i < 2; i++) {
            this.viewport = this.getViewport(0, null);
            if (!this.updateForViewport())
                break;
        }
        this.updateViewportLines();
        this.lineGaps = this.ensureLineGaps([]);
        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(this, false)));
        this.computeVisibleRanges();
    }
    updateForViewport() {
        let viewports = [this.viewport], { main } = this.state.selection;
        for (let i = 0; i <= 1; i++) {
            let pos = i ? main.head : main.anchor;
            if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
                let { from, to } = this.lineBlockAt(pos);
                viewports.push(new Viewport(from, to));
            }
        }
        this.viewports = viewports.sort((a, b) => a.from - b.from);
        return this.updateScaler();
    }
    updateScaler() {
        let scaler = this.scaler;
        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */ ? IdScaler :
            new BigScaler(this.heightOracle, this.heightMap, this.viewports);
        return scaler.eq(this.scaler) ? 0 : 2 /* UpdateFlag.Height */;
    }
    updateViewportLines() {
        this.viewportLines = [];
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, block => {
            this.viewportLines.push(scaleBlock(block, this.scaler));
        });
    }
    update(update, scrollTarget = null) {
        this.state = update.state;
        let prevDeco = this.stateDeco;
        this.stateDeco = this.state.facet(decorations).filter(d => typeof d != "function");
        let contentChanges = update.changedRanges;
        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : state.ChangeSet.empty(this.state.doc.length)));
        let prevHeight = this.heightMap.height;
        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
        clearHeightChangeFlag();
        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
        if (this.heightMap.height != prevHeight || heightChangeFlag)
            update.flags |= 2 /* UpdateFlag.Height */;
        if (scrollAnchor) {
            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
            this.scrollAnchorHeight = scrollAnchor.top;
        }
        else {
            this.scrollAnchorPos = -1;
            this.scrollAnchorHeight = this.heightMap.height;
        }
        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) ||
            !this.viewportIsAppropriate(viewport))
            viewport = this.getViewport(0, scrollTarget);
        let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
        this.viewport = viewport;
        update.flags |= this.updateForViewport();
        if (viewportChange || !update.changes.empty || (update.flags & 2 /* UpdateFlag.Height */))
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
        update.flags |= this.computeVisibleRanges();
        if (scrollTarget)
            this.scrollTarget = scrollTarget;
        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&
            update.state.selection.main.empty && update.state.selection.main.assoc &&
            !update.state.facet(nativeSelectionHidden))
            this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
        let dom = view.contentDOM, style = window.getComputedStyle(dom);
        let oracle = this.heightOracle;
        let whiteSpace = style.whiteSpace;
        this.defaultTextDirection = style.direction == "rtl" ? exports.Direction.RTL : exports.Direction.LTR;
        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
        let domRect = dom.getBoundingClientRect();
        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
        this.contentDOMHeight = domRect.height;
        this.mustMeasureContent = false;
        let result = 0, bias = 0;
        if (domRect.width && domRect.height) {
            let { scaleX, scaleY } = getScale(dom, domRect);
            if (scaleX > .005 && Math.abs(this.scaleX - scaleX) > .005 ||
                scaleY > .005 && Math.abs(this.scaleY - scaleY) > .005) {
                this.scaleX = scaleX;
                this.scaleY = scaleY;
                result |= 8 /* UpdateFlag.Geometry */;
                refresh = measureContent = true;
            }
        }
        // Vertical padding
        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
            this.paddingTop = paddingTop;
            this.paddingBottom = paddingBottom;
            result |= 8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;
        }
        if (this.editorWidth != view.scrollDOM.clientWidth) {
            if (oracle.lineWrapping)
                measureContent = true;
            this.editorWidth = view.scrollDOM.clientWidth;
            result |= 8 /* UpdateFlag.Geometry */;
        }
        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
        if (this.scrollTop != scrollTop) {
            this.scrollAnchorHeight = -1;
            this.scrollTop = scrollTop;
        }
        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
        // Pixel viewport
        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
        this.pixelViewport = pixelViewport;
        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (inView != this.inView) {
            this.inView = inView;
            if (inView)
                measureContent = true;
        }
        if (!this.inView && !this.scrollTarget)
            return 0;
        let contentWidth = domRect.width;
        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
            this.contentDOMWidth = domRect.width;
            this.editorHeight = view.scrollDOM.clientHeight;
            result |= 8 /* UpdateFlag.Geometry */;
        }
        if (measureContent) {
            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
            if (oracle.mustRefreshForHeights(lineHeights))
                refresh = true;
            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
                if (refresh) {
                    view.docView.minWidth = 0;
                    result |= 8 /* UpdateFlag.Geometry */;
                }
            }
            if (dTop > 0 && dBottom > 0)
                bias = Math.max(dTop, dBottom);
            else if (dTop < 0 && dBottom < 0)
                bias = Math.min(dTop, dBottom);
            clearHeightChangeFlag();
            for (let vp of this.viewports) {
                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, state.Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
            }
            if (heightChangeFlag)
                result |= 2 /* UpdateFlag.Height */;
        }
        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) ||
            this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from ||
                this.scrollTarget.range.head > this.viewport.to);
        if (viewportChange) {
            if (result & 2 /* UpdateFlag.Height */)
                result |= this.updateScaler();
            this.viewport = this.getViewport(bias, this.scrollTarget);
            result |= this.updateForViewport();
        }
        if ((result & 2 /* UpdateFlag.Height */) || viewportChange)
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
            this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
        result |= this.computeVisibleRanges();
        if (this.mustEnforceCursorAssoc) {
            this.mustEnforceCursorAssoc = false;
            // This is done in the read stage, because moving the selection
            // to a line end is going to trigger a layout anyway, so it
            // can't be a pure write. It should be rare that it does any
            // writing.
            view.docView.enforceCursorAssoc();
        }
        return result;
    }
    get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top); }
    get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom); }
    getViewport(bias, scrollTarget) {
        // This will divide VP.Margin between the top and the
        // bottom, depending on the bias (the change in viewport position
        // since the last update). It'll hold a number between 0 and 1
        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));
        let map = this.heightMap, oracle = this.heightOracle;
        let { visibleTop, visibleBottom } = this;
        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).to);
        // If scrollTarget is given, make sure the viewport includes that position
        if (scrollTarget) {
            let { head } = scrollTarget.range;
            if (head < viewport.from || head > viewport.to) {
                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
                if (scrollTarget.y == "center")
                    topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
                else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
                    topPos = block.top;
                else
                    topPos = block.bottom - viewHeight;
                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).to);
            }
        }
        return viewport;
    }
    mapViewport(viewport, changes) {
        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
    }
    // Checks if a given viewport covers the visible part of the
    // document and not too much beyond that.
    viewportIsAppropriate({ from, to }, bias = 0) {
        if (!this.inView)
            return true;
        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
        let { visibleTop, visibleBottom } = this;
        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) &&
            (to == this.state.doc.length ||
                bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) &&
            (top > visibleTop - 2 * 1000 /* VP.Margin */ && bottom < visibleBottom + 2 * 1000 /* VP.Margin */);
    }
    mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty)
            return gaps;
        let mapped = [];
        for (let gap of gaps)
            if (!changes.touchesRange(gap.from, gap.to))
                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
        return mapped;
    }
    // Computes positions in the viewport where the start or end of a
    // line should be hidden, trying to reuse existing line gaps when
    // appropriate to avoid unneccesary redraws.
    // Uses crude character-counting for the positioning and sizing,
    // since actual DOM coordinates aren't always available and
    // predictable. Relies on generous margins (see LG.Margin) to hide
    // the artifacts this might produce from the user.
    ensureLineGaps(current, mayMeasure) {
        let wrapping = this.heightOracle.lineWrapping;
        let margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */, halfMargin = margin >> 1, doubleMargin = margin << 1;
        // The non-wrapping logic won't work at all in predominantly right-to-left text.
        if (this.defaultTextDirection != exports.Direction.LTR && !wrapping)
            return [];
        let gaps = [];
        let addGap = (from, to, line, structure) => {
            if (to - from < halfMargin)
                return;
            let sel = this.state.selection.main, avoid = [sel.from];
            if (!sel.empty)
                avoid.push(sel.to);
            for (let pos of avoid) {
                if (pos > from && pos < to) {
                    addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);
                    addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);
                    return;
                }
            }
            let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to &&
                Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin &&
                !avoid.some(pos => gap.from < pos && gap.to > pos));
            if (!gap) {
                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping
                if (to < line.to && mayMeasure && wrapping &&
                    mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {
                    let lineStart = mayMeasure.moveToLineBoundary(state.EditorSelection.cursor(to), false, true).head;
                    if (lineStart > from)
                        to = lineStart;
                }
                let size = this.gapSize(line, from, to, structure);
                let displaySize = wrapping || size < 2000000 /* VP.MaxHorizGap */ ? size : 2000000 /* VP.MaxHorizGap */;
                gap = new LineGap(from, to, size, displaySize);
            }
            gaps.push(gap);
        };
        let checkLine = (line) => {
            if (line.length < doubleMargin || line.type != exports.BlockType.Text)
                return;
            let structure = lineStructure(line.from, line.to, this.stateDeco);
            if (structure.total < doubleMargin)
                return;
            let target = this.scrollTarget ? this.scrollTarget.range.head : null;
            let viewFrom, viewTo;
            if (wrapping) {
                let marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight;
                let top, bot;
                if (target != null) {
                    let targetFrac = findFraction(structure, target);
                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
                    top = targetFrac - spaceFrac;
                    bot = targetFrac + spaceFrac;
                }
                else {
                    top = (this.visibleTop - line.top - marginHeight) / line.height;
                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;
                }
                viewFrom = findPosition(structure, top);
                viewTo = findPosition(structure, bot);
            }
            else {
                let totalWidth = structure.total * this.heightOracle.charWidth;
                let marginWidth = margin * this.heightOracle.charWidth;
                let horizOffset = 0;
                if (totalWidth > 2000000 /* VP.MaxHorizGap */)
                    for (let old of current) {
                        if (old.from >= line.from && old.from < line.to && old.size != old.displaySize &&
                            old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
                            horizOffset = old.size - old.displaySize;
                    }
                let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
                let left, right;
                if (target != null) {
                    let targetFrac = findFraction(structure, target);
                    let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
                    left = targetFrac - spaceFrac;
                    right = targetFrac + spaceFrac;
                }
                else {
                    left = (pxLeft - marginWidth) / totalWidth;
                    right = (pxRight + marginWidth) / totalWidth;
                }
                viewFrom = findPosition(structure, left);
                viewTo = findPosition(structure, right);
            }
            if (viewFrom > line.from)
                addGap(line.from, viewFrom, line, structure);
            if (viewTo < line.to)
                addGap(viewTo, line.to, line, structure);
        };
        for (let line of this.viewportLines) {
            if (Array.isArray(line.type))
                line.type.forEach(checkLine);
            else
                checkLine(line);
        }
        return gaps;
    }
    gapSize(line, from, to, structure) {
        let fraction = findFraction(structure, to) - findFraction(structure, from);
        if (this.heightOracle.lineWrapping) {
            return line.height * fraction;
        }
        else {
            return structure.total * this.heightOracle.charWidth * fraction;
        }
    }
    updateLineGaps(gaps) {
        if (!LineGap.same(gaps, this.lineGaps)) {
            this.lineGaps = gaps;
            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this, this.heightOracle.lineWrapping)));
        }
    }
    computeVisibleRanges() {
        let deco = this.stateDeco;
        if (this.lineGaps.length)
            deco = deco.concat(this.lineGapDeco);
        let ranges = [];
        state.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
            span(from, to) { ranges.push({ from, to }); },
            point() { }
        }, 20);
        let changed = ranges.length != this.visibleRanges.length ||
            this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
        this.visibleRanges = ranges;
        return changed ? 4 /* UpdateFlag.Viewport */ : 0;
    }
    lineBlockAt(pos) {
        return (pos >= this.viewport.from && pos <= this.viewport.to &&
            this.viewportLines.find(b => b.from <= pos && b.to >= pos)) ||
            scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
        return (height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom &&
            this.viewportLines.find(l => l.top <= height && l.bottom >= height)) ||
            scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(scrollTop) {
        let block = this.lineBlockAtHeight(scrollTop + 8);
        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
    }
    elementAtHeight(height) {
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
        return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom;
    }
}
class Viewport {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    state.RangeSet.spans(stateDeco, from, to, {
        span() { },
        point(from, to) {
            if (from > pos) {
                ranges.push({ from: pos, to: from });
                total += from - pos;
            }
            pos = to;
        }
    }, 20); // We're only interested in collapsed ranges of a significant size
    if (pos < to) {
        ranges.push({ from: pos, to });
        total += to - pos;
    }
    return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
        return ranges[0].from;
    if (ratio >= 1)
        return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0;; i++) {
        let { from, to } = ranges[i], size = to - from;
        if (dist <= size)
            return from + dist;
        dist -= size;
    }
}
function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
        if (pos <= to) {
            counted += pos - from;
            break;
        }
        counted += to - from;
    }
    return counted / structure.total;
}
function find(array, f) {
    for (let val of array)
        if (f(val))
            return val;
    return undefined;
}
// Don't scale when the document height is within the range of what
// the DOM can handle.
const IdScaler = {
    toDOM(n) { return n; },
    fromDOM(n) { return n; },
    scale: 1,
    eq(other) { return other == this; }
};
// When the height is too big (> VP.MaxDOMHeight), scale down the
// regions outside the viewports so that the total height is
// VP.MaxDOMHeight.
class BigScaler {
    constructor(oracle, heightMap, viewports) {
        let vpHeight = 0, base = 0, domBase = 0;
        this.viewports = viewports.map(({ from, to }) => {
            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
            vpHeight += bottom - top;
            return { from, to, top, bottom, domTop: 0, domBottom: 0 };
        });
        this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);
        for (let obj of this.viewports) {
            obj.domTop = domBase + (obj.top - base) * this.scale;
            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
            base = obj.bottom;
        }
    }
    toDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.top)
                return domBase + (n - base) * this.scale;
            if (n <= vp.bottom)
                return vp.domTop + (n - vp.top);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    fromDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.domTop)
                return base + (n - domBase) / this.scale;
            if (n <= vp.domBottom)
                return vp.top + (n - vp.domTop);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    eq(other) {
        if (!(other instanceof BigScaler))
            return false;
        return this.scale == other.scale && this.viewports.length == other.viewports.length &&
            this.viewports.every((vp, i) => vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);
    }
}
function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
        return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map(b => scaleBlock(b, scaler)) : block._content);
}

const theme = state.Facet.define({ combine: strs => strs.join(" ") });
const darkTheme = state.Facet.define({ combine: values => values.indexOf(true) > -1 });
const baseThemeID = styleMod.StyleModule.newName(), baseLightID = styleMod.StyleModule.newName(), baseDarkID = styleMod.StyleModule.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
    return new styleMod.StyleModule(spec, {
        finish(sel) {
            return /&/.test(sel) ? sel.replace(/&\w*/, m => {
                if (m == "&")
                    return main;
                if (!scopes || !scopes[m])
                    throw new RangeError(`Unsupported selector: ${m}`);
                return scopes[m];
            }) : main + " " + sel;
        }
    });
}
const baseTheme$1 = buildTheme("." + baseThemeID, {
    "&": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
            // Provide a simple default outline to make sure a focused
            // editor is visually distinct. Can't leave the default behavior
            // because that will apply to the content element, which is
            // inside the scrollable container and doesn't include the
            // gutters. We also can't use an 'auto' outline, since those
            // are, for some reason, drawn behind the element content, which
            // will cause things like the active line background to cover
            // the outline (#297).
            outline: "1px dotted #212121"
        },
        display: "flex !important",
        flexDirection: "column"
    },
    ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0,
        overflowAnchor: "none",
    },
    ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal", // https://github.com/codemirror/dev/issues/456
        boxSizing: "border-box",
        minHeight: "100%",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": {
            WebkitUserModify: "read-write-plaintext-only",
        }
    },
    ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap", // For IE
        whiteSpace: "break-spaces",
        wordBreak: "break-word", // For Safari, which doesn't support overflow-wrap: anywhere
        overflowWrap: "anywhere",
        flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
        display: "block",
        padding: "0 2px 0 6px"
    },
    ".cm-layer": {
        position: "absolute",
        left: 0,
        top: 0,
        contain: "size style",
        "& > *": {
            position: "absolute"
        }
    },
    "&light .cm-selectionBackground": {
        background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
        background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#233"
    },
    ".cm-cursorLayer": {
        pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite"
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none",
    },
    ".cm-cursor": {
        display: "none"
    },
    "&dark .cm-cursor": {
        borderLeftColor: "#ddd"
    },
    ".cm-dropCursor": {
        position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
        display: "block"
    },
    ".cm-iso": {
        unicodeBidi: "isolate"
    },
    ".cm-announced": {
        position: "fixed",
        top: "-10000px"
    },
    "@media print": {
        ".cm-announced": { display: "none" }
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
        flexShrink: 0,
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        insetInlineStart: 0,
        zIndex: 200
    },
    "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#6c6c6c",
        borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc"
    },
    ".cm-gutter": {
        display: "flex !important", // Necessary -- prevents margin collapsing
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden"
    },
    ".cm-gutterElement": {
        boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
        backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
        backgroundColor: "#222227"
    },
    ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0,
        zIndex: 300
    },
    "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black"
    },
    "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
        verticalAlign: "text-top",
        height: "1em",
        width: 0,
        display: "inline"
    },
    ".cm-placeholder": {
        color: "#888",
        display: "inline-block",
        verticalAlign: "top",
    },
    ".cm-highlightSpace": {
        backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
        backgroundPosition: "center",
    },
    ".cm-highlightTab": {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: "auto 100%",
        backgroundPosition: "right 90%",
        backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
        backgroundColor: "#ff332255"
    },
    ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "1px"
    },
    "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
        }
    },
    "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
        }
    },
    ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em"
    },
    "&light .cm-textfield": {
        backgroundColor: "white"
    },
    "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit"
    }
}, lightDarkIDs);

const observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
};
// IE11 has very broken mutation observers, so we also listen to
// DOMCharacterDataModified there
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
    constructor(view) {
        this.view = view;
        this.active = false;
        this.editContext = null;
        // The known selection. Kept in our own object, as opposed to just
        // directly accessing the selection because:
        //  - Safari doesn't report the right selection in shadow DOM
        //  - Reading from the selection forces a DOM layout
        //  - This way, we can ignore selectionchange events if we have
        //    already seen the 'new' selection
        this.selectionRange = new DOMSelectionState;
        // Set when a selection change is detected, cleared on flush
        this.selectionChanged = false;
        this.delayedFlush = -1;
        this.resizeTimeout = -1;
        this.queue = [];
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
        this.lastChange = 0;
        this.scrollTargets = [];
        this.intersection = null;
        this.resizeScroll = null;
        this.intersecting = false;
        this.gapIntersection = null;
        this.gaps = [];
        this.printQuery = null;
        // Timeout for scheduling check of the parents that need scroll handlers
        this.parentCheck = -1;
        this.dom = view.contentDOM;
        this.observer = new MutationObserver(mutations => {
            for (let mut of mutations)
                this.queue.push(mut);
            // IE11 will sometimes (on typing over a selection or
            // backspacing out a single character text node) call the
            // observer callback before actually updating the DOM.
            //
            // Unrelatedly, iOS Safari will, when ending a composition,
            // sometimes first clear it, deliver the mutations, and then
            // reinsert the finished text. CodeMirror's handling of the
            // deletion will prevent the reinsertion from happening,
            // breaking composition.
            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) &&
                mutations.some(m => m.type == "childList" && m.removedNodes.length ||
                    m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
                this.flushSoon();
            else
                this.flush();
        });
        if (window.EditContext && view.constructor.EDIT_CONTEXT !== false &&
            // Chrome <126 doesn't support inverted selections in edit context (#1392)
            !(browser.chrome && browser.chrome_version < 126)) {
            this.editContext = new EditContextManager(view);
            if (view.state.facet(editable))
                view.contentDOM.editContext = this.editContext.editContext;
        }
        if (useCharData)
            this.onCharData = (event) => {
                this.queue.push({ target: event.target,
                    type: "characterData",
                    oldValue: event.prevValue });
                this.flushSoon();
            };
        this.onSelectionChange = this.onSelectionChange.bind(this);
        this.onResize = this.onResize.bind(this);
        this.onPrint = this.onPrint.bind(this);
        this.onScroll = this.onScroll.bind(this);
        if (window.matchMedia)
            this.printQuery = window.matchMedia("print");
        if (typeof ResizeObserver == "function") {
            this.resizeScroll = new ResizeObserver(() => {
                var _a;
                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75)
                    this.onResize();
            });
            this.resizeScroll.observe(view.scrollDOM);
        }
        this.addWindowListeners(this.win = view.win);
        this.start();
        if (typeof IntersectionObserver == "function") {
            this.intersection = new IntersectionObserver(entries => {
                if (this.parentCheck < 0)
                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);
                if (entries.length > 0 && (entries[entries.length - 1].intersectionRatio > 0) != this.intersecting) {
                    this.intersecting = !this.intersecting;
                    if (this.intersecting != this.view.inView)
                        this.onScrollChanged(document.createEvent("Event"));
                }
            }, { threshold: [0, .001] });
            this.intersection.observe(this.dom);
            this.gapIntersection = new IntersectionObserver(entries => {
                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
                    this.onScrollChanged(document.createEvent("Event"));
            }, {});
        }
        this.listenForScroll();
        this.readSelectionRange();
    }
    onScrollChanged(e) {
        this.view.inputState.runHandlers("scroll", e);
        if (this.intersecting)
            this.view.measure();
    }
    onScroll(e) {
        if (this.intersecting)
            this.flush(false);
        if (this.editContext)
            this.view.requestMeasure(this.editContext.measureReq);
        this.onScrollChanged(e);
    }
    onResize() {
        if (this.resizeTimeout < 0)
            this.resizeTimeout = setTimeout(() => {
                this.resizeTimeout = -1;
                this.view.requestMeasure();
            }, 50);
    }
    onPrint(event) {
        if ((event.type == "change" || !event.type) && !event.matches)
            return;
        this.view.viewState.printing = true;
        this.view.measure();
        setTimeout(() => {
            this.view.viewState.printing = false;
            this.view.requestMeasure();
        }, 500);
    }
    updateGaps(gaps) {
        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
            this.gapIntersection.disconnect();
            for (let gap of gaps)
                this.gapIntersection.observe(gap);
            this.gaps = gaps;
        }
    }
    onSelectionChange(event) {
        let wasChanged = this.selectionChanged;
        if (!this.readSelectionRange() || this.delayedAndroidKey)
            return;
        let { view } = this, sel = this.selectionRange;
        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
            return;
        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
        if (context && context.ignoreEvent(event)) {
            if (!wasChanged)
                this.selectionChanged = false;
            return;
        }
        // Deletions on IE11 fire their events in the wrong order, giving
        // us a selection change event before the DOM changes are
        // reported.
        // Chrome Android has a similar issue when backspacing out a
        // selection (#645).
        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&
            // (Selection.isCollapsed isn't reliable on IE)
            sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            this.flushSoon();
        else
            this.flush(false);
    }
    readSelectionRange() {
        let { view } = this;
        // The Selection object is broken in shadow roots in Safari. See
        // https://github.com/codemirror/dev/issues/414
        let selection = getSelection(view.root);
        if (!selection)
            return false;
        let range = browser.safari && view.root.nodeType == 11 &&
            view.root.activeElement == this.dom &&
            safariSelectionRangeHack(this.view, selection) || selection;
        if (!range || this.selectionRange.eq(range))
            return false;
        let local = hasSelection(this.dom, range);
        // Detect the situation where the browser has, on focus, moved the
        // selection to the start of the content element. Reset it to the
        // position from the editor state.
        if (local && !this.selectionChanged &&
            view.inputState.lastFocusTime > Date.now() - 200 &&
            view.inputState.lastTouchTime < Date.now() - 300 &&
            atElementStart(this.dom, range)) {
            this.view.inputState.lastFocusTime = 0;
            view.docView.updateSelection();
            return false;
        }
        this.selectionRange.setRange(range);
        if (local)
            this.selectionChanged = true;
        return true;
    }
    setSelectionRange(anchor, head) {
        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
        this.selectionChanged = false;
    }
    clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
        this.parentCheck = -1;
        let i = 0, changed = null;
        for (let dom = this.dom; dom;) {
            if (dom.nodeType == 1) {
                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
                    i++;
                else if (!changed)
                    changed = this.scrollTargets.slice(0, i);
                if (changed)
                    changed.push(dom);
                dom = dom.assignedSlot || dom.parentNode;
            }
            else if (dom.nodeType == 11) { // Shadow root
                dom = dom.host;
            }
            else {
                break;
            }
        }
        if (i < this.scrollTargets.length && !changed)
            changed = this.scrollTargets.slice(0, i);
        if (changed) {
            for (let dom of this.scrollTargets)
                dom.removeEventListener("scroll", this.onScroll);
            for (let dom of this.scrollTargets = changed)
                dom.addEventListener("scroll", this.onScroll);
        }
    }
    ignore(f) {
        if (!this.active)
            return f();
        try {
            this.stop();
            return f();
        }
        finally {
            this.start();
            this.clear();
        }
    }
    start() {
        if (this.active)
            return;
        this.observer.observe(this.dom, observeOptions);
        if (useCharData)
            this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.active = true;
    }
    stop() {
        if (!this.active)
            return;
        this.active = false;
        this.observer.disconnect();
        if (useCharData)
            this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    // Throw away any pending changes
    clear() {
        this.processRecords();
        this.queue.length = 0;
        this.selectionChanged = false;
    }
    // Chrome Android, especially in combination with GBoard, not only
    // doesn't reliably fire regular key events, but also often
    // surrounds the effect of enter or backspace with a bunch of
    // composition events that, when interrupted, cause text duplication
    // or other kinds of corruption. This hack makes the editor back off
    // from handling DOM changes for a moment when such a key is
    // detected (via beforeinput or keydown), and then tries to flush
    // them or, if that has no effect, dispatches the given key.
    delayAndroidKey(key, keyCode) {
        var _a;
        if (!this.delayedAndroidKey) {
            let flush = () => {
                let key = this.delayedAndroidKey;
                if (key) {
                    this.clearDelayedAndroidKey();
                    this.view.inputState.lastKeyCode = key.keyCode;
                    this.view.inputState.lastKeyTime = Date.now();
                    let flushed = this.flush();
                    if (!flushed && key.force)
                        dispatchKey(this.dom, key.key, key.keyCode);
                }
            };
            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
        }
        // Since backspace beforeinput is sometimes signalled spuriously,
        // Enter always takes precedence.
        if (!this.delayedAndroidKey || key == "Enter")
            this.delayedAndroidKey = {
                key, keyCode,
                // Only run the key handler when no changes are detected if
                // this isn't coming right after another change, in which case
                // it is probably part of a weird chain of updates, and should
                // be ignored if it returns the DOM to its previous state.
                force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)
            };
    }
    clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
    }
    flushSoon() {
        if (this.delayedFlush < 0)
            this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1; this.flush(); });
    }
    forceFlush() {
        if (this.delayedFlush >= 0) {
            this.view.win.cancelAnimationFrame(this.delayedFlush);
            this.delayedFlush = -1;
        }
        this.flush();
    }
    pendingRecords() {
        for (let mut of this.observer.takeRecords())
            this.queue.push(mut);
        return this.queue;
    }
    processRecords() {
        let records = this.pendingRecords();
        if (records.length)
            this.queue = [];
        let from = -1, to = -1, typeOver = false;
        for (let record of records) {
            let range = this.readMutation(record);
            if (!range)
                continue;
            if (range.typeOver)
                typeOver = true;
            if (from == -1) {
                ({ from, to } = range);
            }
            else {
                from = Math.min(range.from, from);
                to = Math.max(range.to, to);
            }
        }
        return { from, to, typeOver };
    }
    readChange() {
        let { from, to, typeOver } = this.processRecords();
        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
        if (from < 0 && !newSel)
            return null;
        if (from > -1)
            this.lastChange = Date.now();
        this.view.inputState.lastFocusTime = 0;
        this.selectionChanged = false;
        let change = new DOMChange(this.view, from, to, typeOver);
        this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
        return change;
    }
    // Apply pending changes, if any
    flush(readSelection = true) {
        // Completely hold off flushing when pending keys are set—the code
        // managing those will make sure processRecords is called and the
        // view is resynchronized after
        if (this.delayedFlush >= 0 || this.delayedAndroidKey)
            return false;
        if (readSelection)
            this.readSelectionRange();
        let domChange = this.readChange();
        if (!domChange) {
            this.view.requestMeasure();
            return false;
        }
        let startState = this.view.state;
        let handled = applyDOMChange(this.view, domChange);
        // The view wasn't updated but DOM/selection changes were seen. Reset the view.
        if (this.view.state == startState &&
            (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
            this.view.update([]);
        return handled;
    }
    readMutation(rec) {
        let cView = this.view.docView.nearest(rec.target);
        if (!cView || cView.ignoreMutation(rec))
            return null;
        cView.markDirty(rec.type == "attributes");
        if (rec.type == "attributes")
            cView.flags |= 4 /* ViewFlag.AttrsDirty */;
        if (rec.type == "childList") {
            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };
        }
        else if (rec.type == "characterData") {
            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
        }
        else {
            return null;
        }
    }
    setWindow(win) {
        if (win != this.win) {
            this.removeWindowListeners(this.win);
            this.win = win;
            this.addWindowListeners(this.win);
        }
    }
    addWindowListeners(win) {
        win.addEventListener("resize", this.onResize);
        if (this.printQuery) {
            if (this.printQuery.addEventListener)
                this.printQuery.addEventListener("change", this.onPrint);
            else
                this.printQuery.addListener(this.onPrint);
        }
        else
            win.addEventListener("beforeprint", this.onPrint);
        win.addEventListener("scroll", this.onScroll);
        win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
        win.removeEventListener("scroll", this.onScroll);
        win.removeEventListener("resize", this.onResize);
        if (this.printQuery) {
            if (this.printQuery.removeEventListener)
                this.printQuery.removeEventListener("change", this.onPrint);
            else
                this.printQuery.removeListener(this.onPrint);
        }
        else
            win.removeEventListener("beforeprint", this.onPrint);
        win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    update(update) {
        if (this.editContext) {
            this.editContext.update(update);
            if (update.startState.facet(editable) != update.state.facet(editable))
                update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
        }
    }
    destroy() {
        var _a, _b, _c;
        this.stop();
        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
        for (let dom of this.scrollTargets)
            dom.removeEventListener("scroll", this.onScroll);
        this.removeWindowListeners(this.win);
        clearTimeout(this.parentCheck);
        clearTimeout(this.resizeTimeout);
        this.win.cancelAnimationFrame(this.delayedFlush);
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        if (this.editContext) {
            this.view.contentDOM.editContext = null;
            this.editContext.destroy();
        }
    }
}
function findChild(cView, dom, dir) {
    while (dom) {
        let curView = ContentView.get(dom);
        if (curView && curView.parent == cView)
            return curView;
        let parent = dom.parentNode;
        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
}
function buildSelectionRangeFromRange(view, range) {
    let anchorNode = range.startContainer, anchorOffset = range.startOffset;
    let focusNode = range.endContainer, focusOffset = range.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    // Since such a range doesn't distinguish between anchor and head,
    // use a heuristic that flips it around if its end matches the
    // current anchor.
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
}
// Used to work around a Safari Selection/shadow DOM bug (#414)
function safariSelectionRangeHack(view, selection) {
    if (selection.getComposedRanges) {
        let range = selection.getComposedRanges(view.root)[0];
        if (range)
            return buildSelectionRangeFromRange(view, range);
    }
    let found = null;
    // Because Safari (at least in 2018-2021) doesn't provide regular
    // access to the selection inside a shadowroot, we have to perform a
    // ridiculous hack to get at it—using `execCommand` to trigger a
    // `beforeInput` event so that we can read the target range from the
    // event.
    function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    return found ? buildSelectionRangeFromRange(view, found) : null;
}
class EditContextManager {
    constructor(view) {
        // The document window for which the text in the context is
        // maintained. For large documents, this may be smaller than the
        // editor document. This window always includes the selection head.
        this.from = 0;
        this.to = 0;
        // When applying a transaction, this is used to compare the change
        // made to the context content to the change in the transaction in
        // order to make the minimal changes to the context (since touching
        // that sometimes breaks series of multiple edits made for a single
        // user action on some Android keyboards)
        this.pendingContextChange = null;
        this.handlers = Object.create(null);
        // Kludge to work around the fact that EditContext does not respond
        // well to having its content updated during a composition (see #1472)
        this.composing = null;
        this.resetRange(view.state);
        let context = this.editContext = new window.EditContext({
            text: view.state.doc.sliceString(this.from, this.to),
            selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
            selectionEnd: this.toContextPos(view.state.selection.main.head)
        });
        this.handlers.textupdate = e => {
            let { anchor } = view.state.selection.main;
            let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);
            if (view.inputState.composing >= 0 && !this.composing)
                this.composing = { contextBase: e.updateRangeStart, editorBase: from, drifted: false };
            let change = { from, to, insert: state.Text.of(e.text.split("\n")) };
            // If the window doesn't include the anchor, assume changes
            // adjacent to a side go up to the anchor.
            if (change.from == this.from && anchor < this.from)
                change.from = anchor;
            else if (change.to == this.to && anchor > this.to)
                change.to = anchor;
            // Edit contexts sometimes fire empty changes
            if (change.from == change.to && !change.insert.length)
                return;
            this.pendingContextChange = change;
            if (!view.state.readOnly)
                applyDOMChangeInner(view, change, state.EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd)));
            // If the transaction didn't flush our change, revert it so
            // that the context is in sync with the editor state again.
            if (this.pendingContextChange) {
                this.revertPending(view.state);
                this.setSelection(view.state);
            }
        };
        this.handlers.characterboundsupdate = e => {
            let rects = [], prev = null;
            for (let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++) {
                let rect = view.coordsForChar(i);
                prev = (rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top))
                    || prev || new DOMRect;
                rects.push(prev);
            }
            context.updateCharacterBounds(e.rangeStart, rects);
        };
        this.handlers.textformatupdate = e => {
            let deco = [];
            for (let format of e.getTextFormats()) {
                let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
                if (lineStyle != "None" && thickness != "None") {
                    let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
                    deco.push(Decoration.mark({ attributes: { style } })
                        .range(this.toEditorPos(format.rangeStart), this.toEditorPos(format.rangeEnd)));
                }
            }
            view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
        };
        this.handlers.compositionstart = () => {
            if (view.inputState.composing < 0) {
                view.inputState.composing = 0;
                view.inputState.compositionFirstChange = true;
            }
        };
        this.handlers.compositionend = () => {
            view.inputState.composing = -1;
            view.inputState.compositionFirstChange = null;
            if (this.composing) {
                let { drifted } = this.composing;
                this.composing = null;
                if (drifted)
                    this.reset(view.state);
            }
        };
        for (let event in this.handlers)
            context.addEventListener(event, this.handlers[event]);
        this.measureReq = { read: view => {
                this.editContext.updateControlBounds(view.contentDOM.getBoundingClientRect());
                let sel = getSelection(view.root);
                if (sel && sel.rangeCount)
                    this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
            } };
    }
    applyEdits(update) {
        let off = 0, abort = false, pending = this.pendingContextChange;
        update.changes.iterChanges((fromA, toA, _fromB, _toB, insert) => {
            if (abort)
                return;
            let dLen = insert.length - (toA - fromA);
            if (pending && toA >= pending.to) {
                if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert)) {
                    pending = this.pendingContextChange = null; // Match
                    off += dLen;
                    this.to += dLen;
                    return;
                }
                else { // Mismatch, revert
                    pending = null;
                    this.revertPending(update.state);
                }
            }
            fromA += off;
            toA += off;
            if (toA <= this.from) { // Before the window
                this.from += dLen;
                this.to += dLen;
            }
            else if (fromA < this.to) { // Overlaps with window
                if (fromA < this.from || toA > this.to || (this.to - this.from) + insert.length > 30000 /* CxVp.MaxSize */) {
                    abort = true;
                    return;
                }
                this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert.toString());
                this.to += dLen;
            }
            off += dLen;
        });
        if (pending && !abort)
            this.revertPending(update.state);
        return !abort;
    }
    update(update) {
        let reverted = this.pendingContextChange;
        if (this.composing && (this.composing.drifted || update.transactions.some(tr => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
            this.composing.drifted = true;
            this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
        }
        else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
            this.pendingContextChange = null;
            this.reset(update.state);
        }
        else if (update.docChanged || update.selectionSet || reverted) {
            this.setSelection(update.state);
        }
        if (update.geometryChanged || update.docChanged || update.selectionSet)
            update.view.requestMeasure(this.measureReq);
    }
    resetRange(state) {
        let { head } = state.selection.main;
        this.from = Math.max(0, head - 10000 /* CxVp.Margin */);
        this.to = Math.min(state.doc.length, head + 10000 /* CxVp.Margin */);
    }
    reset(state) {
        this.resetRange(state);
        this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
        this.setSelection(state);
    }
    revertPending(state) {
        let pending = this.pendingContextChange;
        this.pendingContextChange = null;
        this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
    }
    setSelection(state) {
        let { main } = state.selection;
        let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
        let end = this.toContextPos(main.head);
        if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
            this.editContext.updateSelection(start, end);
    }
    rangeIsValid(state) {
        let { head } = state.selection.main;
        return !(this.from > 0 && head - this.from < 500 /* CxVp.MinMargin */ ||
            this.to < state.doc.length && this.to - head < 500 /* CxVp.MinMargin */ ||
            this.to - this.from > 10000 /* CxVp.Margin */ * 3);
    }
    toEditorPos(contextPos) {
        let c = this.composing;
        return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
    }
    toContextPos(editorPos) {
        let c = this.composing;
        return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
    }
    destroy() {
        for (let event in this.handlers)
            this.editContext.removeEventListener(event, this.handlers[event]);
    }
}

// The editor's update state machine looks something like this:
//
//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle
//                                         ↑      ↓
//                                         Updating (measure)
//
// The difference between 'Idle' and 'Idle (unchecked)' lies in
// whether a layout check has been scheduled. A regular update through
// the `update` method updates the DOM in a write-only fashion, and
// relies on a check (scheduled with `requestAnimationFrame`) to make
// sure everything is where it should be and the viewport covers the
// visible code. That check continues to measure and then optionally
// update until it reaches a coherent state.
/**
An editor view represents the editor's user interface. It holds
the editable DOM surface, and possibly other elements such as the
line number gutter. It handles events and dispatches state
transactions for editing actions.
*/
class EditorView {
    /**
    The current editor state.
    */
    get state() { return this.viewState.state; }
    /**
    To be able to display large documents without consuming too much
    memory or overloading the browser, CodeMirror only draws the
    code that is visible (plus a margin around it) to the DOM. This
    property tells you the extent of the current drawn viewport, in
    document positions.
    */
    get viewport() { return this.viewState.viewport; }
    /**
    When there are, for example, large collapsed ranges in the
    viewport, its size can be a lot bigger than the actual visible
    content. Thus, if you are doing something like styling the
    content in the viewport, it is preferable to only do so for
    these ranges, which are the subset of the viewport that is
    actually drawn.
    */
    get visibleRanges() { return this.viewState.visibleRanges; }
    /**
    Returns false when the editor is entirely scrolled out of view
    or otherwise hidden.
    */
    get inView() { return this.viewState.inView; }
    /**
    Indicates whether the user is currently composing text via
    [IME](https://en.wikipedia.org/wiki/Input_method), and at least
    one change has been made in the current composition.
    */
    get composing() { return this.inputState.composing > 0; }
    /**
    Indicates whether the user is currently in composing state. Note
    that on some platforms, like Android, this will be the case a
    lot, since just putting the cursor on a word starts a
    composition there.
    */
    get compositionStarted() { return this.inputState.composing >= 0; }
    /**
    The document or shadow root that the view lives in.
    */
    get root() { return this._root; }
    /**
    @internal
    */
    get win() { return this.dom.ownerDocument.defaultView || window; }
    /**
    Construct a new view. You'll want to either provide a `parent`
    option, or put `view.dom` into your document after creating a
    view, so that the user can see the editor.
    */
    constructor(config = {}) {
        var _a;
        this.plugins = [];
        this.pluginMap = new Map;
        this.editorAttrs = {};
        this.contentAttrs = {};
        this.bidiCache = [];
        this.destroyed = false;
        /**
        @internal
        */
        this.updateState = 2 /* UpdateState.Updating */;
        /**
        @internal
        */
        this.measureScheduled = -1;
        /**
        @internal
        */
        this.measureRequests = [];
        this.contentDOM = document.createElement("div");
        this.scrollDOM = document.createElement("div");
        this.scrollDOM.tabIndex = -1;
        this.scrollDOM.className = "cm-scroller";
        this.scrollDOM.appendChild(this.contentDOM);
        this.announceDOM = document.createElement("div");
        this.announceDOM.className = "cm-announced";
        this.announceDOM.setAttribute("aria-live", "polite");
        this.dom = document.createElement("div");
        this.dom.appendChild(this.announceDOM);
        this.dom.appendChild(this.scrollDOM);
        if (config.parent)
            config.parent.appendChild(this.dom);
        let { dispatch } = config;
        this.dispatchTransactions = config.dispatchTransactions ||
            (dispatch && ((trs) => trs.forEach(tr => dispatch(tr, this)))) ||
            ((trs) => this.update(trs));
        this.dispatch = this.dispatch.bind(this);
        this._root = (config.root || getRoot(config.parent) || document);
        this.viewState = new ViewState(config.state || state.EditorState.create(config));
        if (config.scrollTo && config.scrollTo.is(scrollIntoView))
            this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);
        this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));
        for (let plugin of this.plugins)
            plugin.update(this);
        this.observer = new DOMObserver(this);
        this.inputState = new InputState(this);
        this.inputState.ensureHandlers(this.plugins);
        this.docView = new DocView(this);
        this.mountStyles();
        this.updateAttrs();
        this.updateState = 0 /* UpdateState.Idle */;
        this.requestMeasure();
        if ((_a = document.fonts) === null || _a === void 0 ? void 0 : _a.ready)
            document.fonts.ready.then(() => this.requestMeasure());
    }
    dispatch(...input) {
        let trs = input.length == 1 && input[0] instanceof state.Transaction ? input
            : input.length == 1 && Array.isArray(input[0]) ? input[0]
                : [this.state.update(...input)];
        this.dispatchTransactions(trs, this);
    }
    /**
    Update the view for the given array of transactions. This will
    update the visible document and selection to match the state
    produced by the transactions, and notify view plugins of the
    change. You should usually call
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
    as a primitive.
    */
    update(transactions) {
        if (this.updateState != 0 /* UpdateState.Idle */)
            throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let redrawn = false, attrsChanged = false, update;
        let state$1 = this.state;
        for (let tr of transactions) {
            if (tr.startState != state$1)
                throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            state$1 = tr.state;
        }
        if (this.destroyed) {
            this.viewState.state = state$1;
            return;
        }
        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
        if (transactions.some(tr => tr.annotation(isFocusChange))) {
            this.inputState.notifiedFocused = focus;
            // If a focus-change transaction is being dispatched, set this update flag.
            focusFlag = 1 /* UpdateFlag.Focus */;
        }
        else if (focus != this.inputState.notifiedFocused) {
            this.inputState.notifiedFocused = focus;
            // Schedule a separate focus transaction if necessary, otherwise
            // add a flag to this update
            dispatchFocus = focusChangeTransaction(state$1, focus);
            if (!dispatchFocus)
                focusFlag = 1 /* UpdateFlag.Focus */;
        }
        // If there was a pending DOM change, eagerly read it and try to
        // apply it after the given transactions.
        let pendingKey = this.observer.delayedAndroidKey, domChange = null;
        if (pendingKey) {
            this.observer.clearDelayedAndroidKey();
            domChange = this.observer.readChange();
            // Only try to apply DOM changes if the transactions didn't
            // change the doc or selection.
            if (domChange && !this.state.doc.eq(state$1.doc) || !this.state.selection.eq(state$1.selection))
                domChange = null;
        }
        else {
            this.observer.clear();
        }
        // When the phrases change, redraw the editor
        if (state$1.facet(state.EditorState.phrases) != this.state.facet(state.EditorState.phrases))
            return this.setState(state$1);
        update = ViewUpdate.create(this, state$1, transactions);
        update.flags |= focusFlag;
        let scrollTarget = this.viewState.scrollTarget;
        try {
            this.updateState = 2 /* UpdateState.Updating */;
            for (let tr of transactions) {
                if (scrollTarget)
                    scrollTarget = scrollTarget.map(tr.changes);
                if (tr.scrollIntoView) {
                    let { main } = tr.state.selection;
                    scrollTarget = new ScrollTarget(main.empty ? main : state.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
                }
                for (let e of tr.effects)
                    if (e.is(scrollIntoView))
                        scrollTarget = e.value.clip(this.state);
            }
            this.viewState.update(update, scrollTarget);
            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
            if (!update.empty) {
                this.updatePlugins(update);
                this.inputState.update(update);
            }
            redrawn = this.docView.update(update);
            if (this.state.facet(styleModule) != this.styleModules)
                this.mountStyles();
            attrsChanged = this.updateAttrs();
            this.showAnnouncements(transactions);
            this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent("select.pointer")));
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
        }
        if (update.startState.facet(theme) != update.state.facet(theme))
            this.viewState.mustMeasureContent = true;
        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
            this.requestMeasure();
        if (redrawn)
            this.docViewUpdate();
        if (!update.empty)
            for (let listener of this.state.facet(updateListener)) {
                try {
                    listener(update);
                }
                catch (e) {
                    logException(this.state, e, "update listener");
                }
            }
        if (dispatchFocus || domChange)
            Promise.resolve().then(() => {
                if (dispatchFocus && this.state == dispatchFocus.startState)
                    this.dispatch(dispatchFocus);
                if (domChange) {
                    if (!applyDOMChange(this, domChange) && pendingKey.force)
                        dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
                }
            });
    }
    /**
    Reset the view to the given state. (This will cause the entire
    document to be redrawn and all view plugins to be reinitialized,
    so you should probably only use it when the new state isn't
    derived from the old state. Otherwise, use
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
    */
    setState(newState) {
        if (this.updateState != 0 /* UpdateState.Idle */)
            throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) {
            this.viewState.state = newState;
            return;
        }
        this.updateState = 2 /* UpdateState.Updating */;
        let hadFocus = this.hasFocus;
        try {
            for (let plugin of this.plugins)
                plugin.destroy(this);
            this.viewState = new ViewState(newState);
            this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));
            this.pluginMap.clear();
            for (let plugin of this.plugins)
                plugin.update(this);
            this.docView.destroy();
            this.docView = new DocView(this);
            this.inputState.ensureHandlers(this.plugins);
            this.mountStyles();
            this.updateAttrs();
            this.bidiCache = [];
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
        }
        if (hadFocus)
            this.focus();
        this.requestMeasure();
    }
    updatePlugins(update) {
        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
        if (prevSpecs != specs) {
            let newPlugins = [];
            for (let spec of specs) {
                let found = prevSpecs.indexOf(spec);
                if (found < 0) {
                    newPlugins.push(new PluginInstance(spec));
                }
                else {
                    let plugin = this.plugins[found];
                    plugin.mustUpdate = update;
                    newPlugins.push(plugin);
                }
            }
            for (let plugin of this.plugins)
                if (plugin.mustUpdate != update)
                    plugin.destroy(this);
            this.plugins = newPlugins;
            this.pluginMap.clear();
        }
        else {
            for (let p of this.plugins)
                p.mustUpdate = update;
        }
        for (let i = 0; i < this.plugins.length; i++)
            this.plugins[i].update(this);
        if (prevSpecs != specs)
            this.inputState.ensureHandlers(this.plugins);
    }
    docViewUpdate() {
        for (let plugin of this.plugins) {
            let val = plugin.value;
            if (val && val.docViewUpdate) {
                try {
                    val.docViewUpdate(this);
                }
                catch (e) {
                    logException(this.state, e, "doc view update listener");
                }
            }
        }
    }
    /**
    @internal
    */
    measure(flush = true) {
        if (this.destroyed)
            return;
        if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
        if (this.observer.delayedAndroidKey) {
            this.measureScheduled = -1;
            this.requestMeasure();
            return;
        }
        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame
        if (flush)
            this.observer.forceFlush();
        let updated = null;
        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
            scrollAnchorHeight = -1;
        this.viewState.scrollAnchorHeight = -1;
        try {
            for (let i = 0;; i++) {
                if (scrollAnchorHeight < 0) {
                    if (isScrolledToBottom(sDOM)) {
                        scrollAnchorPos = -1;
                        scrollAnchorHeight = this.viewState.heightMap.height;
                    }
                    else {
                        let block = this.viewState.scrollAnchorAt(scrollTop);
                        scrollAnchorPos = block.from;
                        scrollAnchorHeight = block.top;
                    }
                }
                this.updateState = 1 /* UpdateState.Measuring */;
                let changed = this.viewState.measure(this);
                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
                    break;
                if (i > 5) {
                    console.warn(this.measureRequests.length
                        ? "Measure loop restarted more than 5 times"
                        : "Viewport failed to stabilize");
                    break;
                }
                let measuring = [];
                // Only run measure requests in this cycle when the viewport didn't change
                if (!(changed & 4 /* UpdateFlag.Viewport */))
                    [this.measureRequests, measuring] = [measuring, this.measureRequests];
                let measured = measuring.map(m => {
                    try {
                        return m.read(this);
                    }
                    catch (e) {
                        logException(this.state, e);
                        return BadMeasure;
                    }
                });
                let update = ViewUpdate.create(this, this.state, []), redrawn = false;
                update.flags |= changed;
                if (!updated)
                    updated = update;
                else
                    updated.flags |= changed;
                this.updateState = 2 /* UpdateState.Updating */;
                if (!update.empty) {
                    this.updatePlugins(update);
                    this.inputState.update(update);
                    this.updateAttrs();
                    redrawn = this.docView.update(update);
                    if (redrawn)
                        this.docViewUpdate();
                }
                for (let i = 0; i < measuring.length; i++)
                    if (measured[i] != BadMeasure) {
                        try {
                            let m = measuring[i];
                            if (m.write)
                                m.write(measured[i], this);
                        }
                        catch (e) {
                            logException(this.state, e);
                        }
                    }
                if (redrawn)
                    this.docView.updateSelection(true);
                if (!update.viewportChanged && this.measureRequests.length == 0) {
                    if (this.viewState.editorHeight) {
                        if (this.viewState.scrollTarget) {
                            this.docView.scrollIntoView(this.viewState.scrollTarget);
                            this.viewState.scrollTarget = null;
                            scrollAnchorHeight = -1;
                            continue;
                        }
                        else {
                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height :
                                this.viewState.lineBlockAt(scrollAnchorPos).top;
                            let diff = newAnchorHeight - scrollAnchorHeight;
                            if (diff > 1 || diff < -1) {
                                scrollTop = scrollTop + diff;
                                sDOM.scrollTop = scrollTop / this.scaleY;
                                scrollAnchorHeight = -1;
                                continue;
                            }
                        }
                    }
                    break;
                }
            }
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
            this.measureScheduled = -1;
        }
        if (updated && !updated.empty)
            for (let listener of this.state.facet(updateListener))
                listener(updated);
    }
    /**
    Get the CSS classes for the currently active editor themes.
    */
    get themeClasses() {
        return baseThemeID + " " +
            (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " +
            this.state.facet(theme);
    }
    updateAttrs() {
        let editorAttrs = attrsFromFacet(this, editorAttributes, {
            class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        });
        let contentAttrs = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            translate: "no",
            contenteditable: !this.state.facet(editable) ? "false" : "true",
            class: "cm-content",
            style: `${browser.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
        };
        if (this.state.readOnly)
            contentAttrs["aria-readonly"] = "true";
        attrsFromFacet(this, contentAttributes, contentAttrs);
        let changed = this.observer.ignore(() => {
            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
            return changedContent || changedEditor;
        });
        this.editorAttrs = editorAttrs;
        this.contentAttrs = contentAttrs;
        return changed;
    }
    showAnnouncements(trs) {
        let first = true;
        for (let tr of trs)
            for (let effect of tr.effects)
                if (effect.is(EditorView.announce)) {
                    if (first)
                        this.announceDOM.textContent = "";
                    first = false;
                    let div = this.announceDOM.appendChild(document.createElement("div"));
                    div.textContent = effect.value;
                }
    }
    mountStyles() {
        this.styleModules = this.state.facet(styleModule);
        let nonce = this.state.facet(EditorView.cspNonce);
        styleMod.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : undefined);
    }
    readMeasured() {
        if (this.updateState == 2 /* UpdateState.Updating */)
            throw new Error("Reading the editor layout isn't allowed during an update");
        if (this.updateState == 0 /* UpdateState.Idle */ && this.measureScheduled > -1)
            this.measure(false);
    }
    /**
    Schedule a layout measurement, optionally providing callbacks to
    do custom DOM measuring followed by a DOM write phase. Using
    this is preferable reading DOM layout directly from, for
    example, an event handler, because it'll make sure measuring and
    drawing done by other components is synchronized, avoiding
    unnecessary DOM layout computations.
    */
    requestMeasure(request) {
        if (this.measureScheduled < 0)
            this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
        if (request) {
            if (this.measureRequests.indexOf(request) > -1)
                return;
            if (request.key != null)
                for (let i = 0; i < this.measureRequests.length; i++) {
                    if (this.measureRequests[i].key === request.key) {
                        this.measureRequests[i] = request;
                        return;
                    }
                }
            this.measureRequests.push(request);
        }
    }
    /**
    Get the value of a specific plugin, if present. Note that
    plugins that crash can be dropped from a view, so even when you
    know you registered a given plugin, it is recommended to check
    the return value of this method.
    */
    plugin(plugin) {
        let known = this.pluginMap.get(plugin);
        if (known === undefined || known && known.spec != plugin)
            this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);
        return known && known.update(this).value;
    }
    /**
    The top position of the document, in screen coordinates. This
    may be negative when the editor is scrolled down. Points
    directly to the top of the first line, not above the padding.
    */
    get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    /**
    Reports the padding above and below the document.
    */
    get documentPadding() {
        return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    /**
    If the editor is transformed with CSS, this provides the scale
    along the X axis. Otherwise, it will just be 1. Note that
    transforms other than translation and scaling are not supported.
    */
    get scaleX() { return this.viewState.scaleX; }
    /**
    Provide the CSS transformed scale along the Y axis.
    */
    get scaleY() { return this.viewState.scaleY; }
    /**
    Find the text line or block widget at the given vertical
    position (which is interpreted as relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
    */
    elementAtHeight(height) {
        this.readMeasured();
        return this.viewState.elementAtHeight(height);
    }
    /**
    Find the line block (see
    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
    height, again interpreted relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
    */
    lineBlockAtHeight(height) {
        this.readMeasured();
        return this.viewState.lineBlockAtHeight(height);
    }
    /**
    Get the extent and vertical position of all [line
    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
    are relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
    */
    get viewportLineBlocks() {
        return this.viewState.viewportLines;
    }
    /**
    Find the line block around the given document position. A line
    block is a range delimited on both sides by either a
    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
    start/end of the document. It will usually just hold a line of
    text, but may be broken into multiple textblocks by block
    widgets.
    */
    lineBlockAt(pos) {
        return this.viewState.lineBlockAt(pos);
    }
    /**
    The editor's total content height.
    */
    get contentHeight() {
        return this.viewState.contentHeight;
    }
    /**
    Move a cursor position by [grapheme
    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
    the motion is away from the line start, or towards it. In
    bidirectional text, the line is traversed in visual order, using
    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
    When the start position was the last one on the line, the
    returned position will be across the line break. If there is no
    further line, the original position is returned.
    
    By default, this method moves over a single cluster. The
    optional `by` argument can be used to move across more. It will
    be called with the first cluster as argument, and should return
    a predicate that determines, for each subsequent cluster,
    whether it should also be moved over.
    */
    moveByChar(start, forward, by) {
        return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    /**
    Move a cursor position across the next group of either
    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
    non-whitespace characters.
    */
    moveByGroup(start, forward) {
        return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));
    }
    /**
    Get the cursor position visually at the start or end of a line.
    Note that this may differ from the _logical_ position at its
    start or end (which is simply at `line.from`/`line.to`) if text
    at the start or end goes against the line's base text direction.
    */
    visualLineSide(line, end) {
        let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
        let span = order[end ? order.length - 1 : 0];
        return state.EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
    }
    /**
    Move to the next line boundary in the given direction. If
    `includeWrap` is true, line wrapping is on, and there is a
    further wrap point on the current line, the wrap point will be
    returned. Otherwise this function will return the start or end
    of the line.
    */
    moveToLineBoundary(start, forward, includeWrap = true) {
        return moveToLineBoundary(this, start, forward, includeWrap);
    }
    /**
    Move a cursor position vertically. When `distance` isn't given,
    it defaults to moving to the next line (including wrapped
    lines). Otherwise, `distance` should provide a positive distance
    in pixels.
    
    When `start` has a
    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
    motion will use that as a target horizontal position. Otherwise,
    the cursor's own horizontal position is used. The returned
    cursor will have its goal column set to whichever column was
    used.
    */
    moveVertically(start, forward, distance) {
        return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    /**
    Find the DOM parent node and offset (child offset if `node` is
    an element, character offset when it is a text node) at the
    given document position.
    
    Note that for positions that aren't currently in
    `visibleRanges`, the resulting DOM position isn't necessarily
    meaningful (it may just point before or after a placeholder
    element).
    */
    domAtPos(pos) {
        return this.docView.domAtPos(pos);
    }
    /**
    Find the document position at the given DOM node. Can be useful
    for associating positions with DOM events. Will raise an error
    when `node` isn't part of the editor content.
    */
    posAtDOM(node, offset = 0) {
        return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
        this.readMeasured();
        return posAtCoords(this, coords, precise);
    }
    /**
    Get the screen coordinates at the given document position.
    `side` determines whether the coordinates are based on the
    element before (-1) or after (1) the position (if no element is
    available on the given side, the method will transparently use
    another strategy to get reasonable coordinates).
    */
    coordsAtPos(pos, side = 1) {
        this.readMeasured();
        let rect = this.docView.coordsAt(pos, side);
        if (!rect || rect.left == rect.right)
            return rect;
        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
        return flattenRect(rect, (span.dir == exports.Direction.LTR) == (side > 0));
    }
    /**
    Return the rectangle around a given character. If `pos` does not
    point in front of a character that is in the viewport and
    rendered (i.e. not replaced, not a line break), this will return
    null. For space characters that are a line wrap point, this will
    return the position before the line break.
    */
    coordsForChar(pos) {
        this.readMeasured();
        return this.docView.coordsForChar(pos);
    }
    /**
    The default width of a character in the editor. May not
    accurately reflect the width of all characters (given variable
    width fonts or styling of invididual ranges).
    */
    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }
    /**
    The default height of a line in the editor. May not be accurate
    for all lines.
    */
    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }
    /**
    The text direction
    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
    CSS property) of the editor's content element.
    */
    get textDirection() { return this.viewState.defaultTextDirection; }
    /**
    Find the text direction of the block at the given position, as
    assigned by CSS. If
    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
    isn't enabled, or the given position is outside of the viewport,
    this will always return the same as
    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
    this may trigger a DOM layout.
    */
    textDirectionAt(pos) {
        let perLine = this.state.facet(perLineTextDirection);
        if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
            return this.textDirection;
        this.readMeasured();
        return this.docView.textDirectionAt(pos);
    }
    /**
    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
    (as determined by the
    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
    CSS property of its content element).
    */
    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }
    /**
    Returns the bidirectional text structure of the given line
    (which should be in the current document) as an array of span
    objects. The order of these spans matches the [text
    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
    left-to-right, the leftmost spans come first, otherwise the
    rightmost spans come first.
    */
    bidiSpans(line) {
        if (line.length > MaxBidiLine)
            return trivialOrder(line.length);
        let dir = this.textDirectionAt(line.from), isolates;
        for (let entry of this.bidiCache) {
            if (entry.from == line.from && entry.dir == dir &&
                (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
                return entry.order;
        }
        if (!isolates)
            isolates = getIsolatedRanges(this, line);
        let order = computeOrder(line.text, dir, isolates);
        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
        return order;
    }
    /**
    Check whether the editor has focus.
    */
    get hasFocus() {
        var _a;
        // Safari return false for hasFocus when the context menu is open
        // or closing, which leads us to ignore selection changes from the
        // context menu because it looks like the editor isn't focused.
        // This kludges around that.
        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) &&
            this.root.activeElement == this.contentDOM;
    }
    /**
    Put focus on the editor.
    */
    focus() {
        this.observer.ignore(() => {
            focusPreventScroll(this.contentDOM);
            this.docView.updateSelection();
        });
    }
    /**
    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
    necessary when moving the editor's existing DOM to a new window or shadow root.
    */
    setRoot(root) {
        if (this._root != root) {
            this._root = root;
            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
            this.mountStyles();
        }
    }
    /**
    Clean up this editor view, removing its element from the
    document, unregistering event handlers, and notifying
    plugins. The view instance can no longer be used after
    calling this.
    */
    destroy() {
        if (this.root.activeElement == this.contentDOM)
            this.contentDOM.blur();
        for (let plugin of this.plugins)
            plugin.destroy(this);
        this.plugins = [];
        this.inputState.destroy();
        this.docView.destroy();
        this.dom.remove();
        this.observer.destroy();
        if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
        this.destroyed = true;
    }
    /**
    Returns an effect that can be
    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
    cause it to scroll the given position or range into view.
    */
    static scrollIntoView(pos, options = {}) {
        return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? state.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    /**
    Return an effect that resets the editor to its current (at the
    time this method was called) scroll position. Note that this
    only affects the editor's own scrollable element, not parents.
    See also
    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
    
    The effect should be used with a document identical to the one
    it was created for. Failing to do so is not an error, but may
    not scroll to the expected position. You can
    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
    */
    scrollSnapshot() {
        let { scrollTop, scrollLeft } = this.scrollDOM;
        let ref = this.viewState.scrollAnchorAt(scrollTop);
        return scrollIntoView.of(new ScrollTarget(state.EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
    }
    /**
    Enable or disable tab-focus mode, which disables key bindings
    for Tab and Shift-Tab, letting the browser's default
    focus-changing behavior go through instead. This is useful to
    prevent trapping keyboard users in your editor.
    
    Without argument, this toggles the mode. With a boolean, it
    enables (true) or disables it (false). Given a number, it
    temporarily enables the mode until that number of milliseconds
    have passed or another non-Tab key is pressed.
    */
    setTabFocusMode(to) {
        if (to == null)
            this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
        else if (typeof to == "boolean")
            this.inputState.tabFocusMode = to ? 0 : -1;
        else if (this.inputState.tabFocusMode != 0)
            this.inputState.tabFocusMode = Date.now() + to;
    }
    /**
    Returns an extension that can be used to add DOM event handlers.
    The value should be an object mapping event names to handler
    functions. For any given event, such functions are ordered by
    extension precedence, and the first handler to return true will
    be assumed to have handled that event, and no other handlers or
    built-in behavior will be activated for it. These are registered
    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
    for `scroll` handlers, which will be called any time the
    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
    its parent nodes is scrolled.
    */
    static domEventHandlers(handlers) {
        return ViewPlugin.define(() => ({}), { eventHandlers: handlers });
    }
    /**
    Create an extension that registers DOM event observers. Contrary
    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
    observers can't be prevented from running by a higher-precedence
    handler returning true. They also don't prevent other handlers
    and observers from running when they return true, and should not
    call `preventDefault`.
    */
    static domEventObservers(observers) {
        return ViewPlugin.define(() => ({}), { eventObservers: observers });
    }
    /**
    Create a theme extension. The first argument can be a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)
    style spec providing the styles for the theme. These will be
    prefixed with a generated class for the style.
    
    Because the selectors will be prefixed with a scope class, rule
    that directly match the editor's [wrapper
    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
    added—need to be explicitly differentiated by adding an `&` to
    the selector for that element—for example
    `&.cm-focused`.
    
    When `dark` is set to true, the theme will be marked as dark,
    which will cause the `&dark` rules from [base
    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
    `&light` when a light theme is active).
    */
    static theme(spec, options) {
        let prefix = styleMod.StyleModule.newName();
        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
        if (options && options.dark)
            result.push(darkTheme.of(true));
        return result;
    }
    /**
    Create an extension that adds styles to the base theme. Like
    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
    place of the editor wrapper element when directly targeting
    that. You can also use `&dark` or `&light` instead to only
    target editors with a dark or light theme.
    */
    static baseTheme(spec) {
        return state.Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    /**
    Retrieve an editor view instance from the view's DOM
    representation.
    */
    static findFromDOM(dom) {
        var _a;
        let content = dom.querySelector(".cm-content");
        let cView = content && ContentView.get(content) || ContentView.get(dom);
        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
    }
}
/**
Facet to add a [style
module](https://github.com/marijnh/style-mod#documentation) to
an editor view. The view will ensure that the module is
mounted in its [document
root](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).
*/
EditorView.styleModule = styleModule;
/**
An input handler can override the way changes to the editable
DOM content are handled. Handlers are passed the document
positions between which the change was found, and the new
content. When one returns true, no further input handlers are
called and the default behavior is prevented.

The `insert` argument can be used to get the default transaction
that would be applied for this input. This can be useful when
dispatching the custom behavior as a separate transaction.
*/
EditorView.inputHandler = inputHandler;
/**
Functions provided in this facet will be used to transform text
pasted or dropped into the editor.
*/
EditorView.clipboardInputFilter = clipboardInputFilter;
/**
Transform text copied or dragged from the editor.
*/
EditorView.clipboardOutputFilter = clipboardOutputFilter;
/**
Scroll handlers can override how things are scrolled into view.
If they return `true`, no further handling happens for the
scrolling. If they return false, the default scroll behavior is
applied. Scroll handlers should never initiate editor updates.
*/
EditorView.scrollHandler = scrollHandler;
/**
This facet can be used to provide functions that create effects
to be dispatched when the editor's focus state changes.
*/
EditorView.focusChangeEffect = focusChangeEffect;
/**
By default, the editor assumes all its content has the same
[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`
value to make it read the text direction of every (rendered)
line separately.
*/
EditorView.perLineTextDirection = perLineTextDirection;
/**
Allows you to provide a function that should be called when the
library catches an exception from an extension (mostly from view
plugins, but may be used by other extensions to route exceptions
from user-code-provided callbacks). This is mostly useful for
debugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).
*/
EditorView.exceptionSink = exceptionSink;
/**
A facet that can be used to register a function to be called
every time the view updates.
*/
EditorView.updateListener = updateListener;
/**
Facet that controls whether the editor content DOM is editable.
When its highest-precedence value is `false`, the element will
not have its `contenteditable` attribute set. (Note that this
doesn't affect API calls that change the editor content, even
when those are bound to keys or buttons. See the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)
*/
EditorView.editable = editable;
/**
Allows you to influence the way mouse selection happens. The
functions in this facet will be called for a `mousedown` event
on the editor, and can return an object that overrides the way a
selection is computed from that mouse click or drag.
*/
EditorView.mouseSelectionStyle = mouseSelectionStyle;
/**
Facet used to configure whether a given selection drag event
should move or copy the selection. The given predicate will be
called with the `mousedown` event, and can return `true` when
the drag should move the content.
*/
EditorView.dragMovesSelection = dragMovesSelection$1;
/**
Facet used to configure whether a given selecting click adds a
new range to the existing selection or replaces it entirely. The
default behavior is to check `event.metaKey` on macOS, and
`event.ctrlKey` elsewhere.
*/
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
/**
A facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)
are shown in the view. Decorations can be provided in two
ways—directly, or via a function that takes an editor view.

Only decoration sets provided directly are allowed to influence
the editor's vertical layout structure. The ones provided as
functions are called _after_ the new viewport has been computed,
and thus **must not** introduce block widgets or replacing
decorations that cover line breaks.

If you want decorated ranges to behave like atomic units for
cursor motion and deletion purposes, also provide the range set
containing the decorations to
[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).
*/
EditorView.decorations = decorations;
/**
Facet that works much like
[`decorations`](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), but puts its
inputs at the very bottom of the precedence stack, meaning mark
decorations provided here will only be split by other, partially
overlapping \`outerDecorations\` ranges, and wrap around all
regular decorations. Use this for mark elements that should, as
much as possible, remain in one piece.
*/
EditorView.outerDecorations = outerDecorations;
/**
Used to provide ranges that should be treated as atoms as far as
cursor motion is concerned. This causes methods like
[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and
[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the
commands built on top of them) to skip across such regions when
a selection endpoint would enter them. This does _not_ prevent
direct programmatic [selection
updates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such
regions.
*/
EditorView.atomicRanges = atomicRanges;
/**
When range decorations add a `unicode-bidi: isolate` style, they
should also include a
[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property
in their decoration spec, and be exposed through this facet, so
that the editor can compute the proper text order. (Other values
for `unicode-bidi`, except of course `normal`, are not
supported.)
*/
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
/**
Facet that allows extensions to provide additional scroll
margins (space around the sides of the scrolling element that
should be considered invisible). This can be useful when the
plugin introduces elements that cover part of that element (for
example a horizontally fixed gutter).
*/
EditorView.scrollMargins = scrollMargins;
/**
This facet records whether a dark theme is active. The extension
returned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically
includes an instance of this when the `dark` option is set to
true.
*/
EditorView.darkTheme = darkTheme;
/**
Provides a Content Security Policy nonce to use when creating
the style sheets for the editor. Holds the empty string when no
nonce has been provided.
*/
EditorView.cspNonce = state.Facet.define({ combine: values => values.length ? values[0] : "" });
/**
Facet that provides additional DOM attributes for the editor's
editable DOM element.
*/
EditorView.contentAttributes = contentAttributes;
/**
Facet that provides DOM attributes for the editor's outer
element.
*/
EditorView.editorAttributes = editorAttributes;
/**
An extension that enables line wrapping in the editor (by
setting CSS `white-space` to `pre-wrap` in the content).
*/
EditorView.lineWrapping = EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
/**
State effect used to include screen reader announcements in a
transaction. These will be added to the DOM in a visually hidden
element with `aria-live="polite"` set, and should be used to
describe effects that are visually obvious but may not be
noticed by screen reader users (such as moving to the next
search match).
*/
EditorView.announce = state.StateEffect.define();
// Maximum line length for which we compute accurate bidi info
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
    constructor(from, to, dir, isolates, fresh, order) {
        this.from = from;
        this.to = to;
        this.dir = dir;
        this.isolates = isolates;
        this.fresh = fresh;
        this.order = order;
    }
    static update(cache, changes) {
        if (changes.empty && !cache.some(c => c.fresh))
            return cache;
        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : exports.Direction.LTR;
        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
            let entry = cache[i];
            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
        }
        return result;
    }
}
function attrsFromFacet(view, facet, base) {
    for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
        let source = sources[i], value = typeof source == "function" ? source(view) : source;
        if (value)
            combineAttrs(value, base);
    }
    return base;
}

const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name, platform) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
        result = " ";
    let alt, ctrl, shift, meta;
    for (let i = 0; i < parts.length - 1; ++i) {
        const mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod))
            meta = true;
        else if (/^a(lt)?$/i.test(mod))
            alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
            shift = true;
        else if (/^mod$/i.test(mod)) {
            if (platform == "mac")
                meta = true;
            else
                ctrl = true;
        }
        else
            throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
        result = "Alt-" + result;
    if (ctrl)
        result = "Ctrl-" + result;
    if (meta)
        result = "Meta-" + result;
    if (shift)
        result = "Shift-" + result;
    return result;
}
function modifiers(name, event, shift) {
    if (event.altKey)
        name = "Alt-" + name;
    if (event.ctrlKey)
        name = "Ctrl-" + name;
    if (event.metaKey)
        name = "Meta-" + name;
    if (shift !== false && event.shiftKey)
        name = "Shift-" + name;
    return name;
}
const handleKeyEvents = state.Prec.default(EditorView.domEventHandlers({
    keydown(event, view) {
        return runHandlers(getKeymap(view.state), event, view, "editor");
    }
}));
/**
Facet used for registering keymaps.

You can add multiple keymaps to an editor. Their priorities
determine their precedence (the ones specified early or with high
priority get checked first). When a handler has returned `true`
for a given key, no further handlers are called.
*/
const keymap = state.Facet.define({ enables: handleKeyEvents });
const Keymaps = new WeakMap();
// This is hidden behind an indirection, rather than directly computed
// by the facet, to keep internal types out of the facet's type.
function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map = Keymaps.get(bindings);
    if (!map)
        Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map;
}
/**
Run the key handlers registered for a given scope. The event
object should be a `"keydown"` event. Returns true if any of the
handlers handled it.
*/
function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
}
let storedPrefix = null;
const PrefixTimeout = 4000;
function buildKeymap(bindings, platform = currentPlatform) {
    let bound = Object.create(null);
    let isPrefix = Object.create(null);
    let checkPrefix = (name, is) => {
        let current = isPrefix[name];
        if (current == null)
            isPrefix[name] = is;
        else if (current != is)
            throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add = (scope, key, command, preventDefault, stopPropagation) => {
        var _a, _b;
        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));
        for (let i = 1; i < parts.length; i++) {
            let prefix = parts.slice(0, i).join(" ");
            checkPrefix(prefix, true);
            if (!scopeObj[prefix])
                scopeObj[prefix] = {
                    preventDefault: true,
                    stopPropagation: false,
                    run: [(view) => {
                            let ourObj = storedPrefix = { view, prefix, scope };
                            setTimeout(() => { if (storedPrefix == ourObj)
                                storedPrefix = null; }, PrefixTimeout);
                            return true;
                        }]
                };
        }
        let full = parts.join(" ");
        checkPrefix(full, false);
        let binding = scopeObj[full] || (scopeObj[full] = {
            preventDefault: false,
            stopPropagation: false,
            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
        });
        if (command)
            binding.run.push(command);
        if (preventDefault)
            binding.preventDefault = true;
        if (stopPropagation)
            binding.stopPropagation = true;
    };
    for (let b of bindings) {
        let scopes = b.scope ? b.scope.split(" ") : ["editor"];
        if (b.any)
            for (let scope of scopes) {
                let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
                if (!scopeObj._any)
                    scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
                let { any } = b;
                for (let key in scopeObj)
                    scopeObj[key].run.push(view => any(view, currentKeyEvent));
            }
        let name = b[platform] || b.key;
        if (!name)
            continue;
        for (let scope of scopes) {
            add(scope, name, b.run, b.preventDefault, b.stopPropagation);
            if (b.shift)
                add(scope, "Shift-" + name, b.shift, b.preventDefault, b.stopPropagation);
        }
    }
    return bound;
}
let currentKeyEvent = null;
function runHandlers(map, event, view, scope) {
    currentKeyEvent = event;
    let name = w3cKeyname.keyName(event);
    let charCode = state.codePointAt(name, 0), isChar = state.codePointSize(charCode) == name.length && name != " ";
    let prefix = "", handled = false, prevented = false, stopPropagation = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
        prefix = storedPrefix.prefix + " ";
        if (modifierCodes.indexOf(event.keyCode) < 0) {
            prevented = true;
            storedPrefix = null;
        }
    }
    let ran = new Set;
    let runFor = (binding) => {
        if (binding) {
            for (let cmd of binding.run)
                if (!ran.has(cmd)) {
                    ran.add(cmd);
                    if (cmd(view)) {
                        if (binding.stopPropagation)
                            stopPropagation = true;
                        return true;
                    }
                }
            if (binding.preventDefault) {
                if (binding.stopPropagation)
                    stopPropagation = true;
                prevented = true;
            }
        }
        return false;
    };
    let scopeObj = map[scope], baseName, shiftName;
    if (scopeObj) {
        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {
            handled = true;
        }
        else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) &&
            // Ctrl-Alt may be used for AltGr on Windows
            !(browser.windows && event.ctrlKey && event.altKey) &&
            (baseName = w3cKeyname.base[event.keyCode]) && baseName != name) {
            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
                handled = true;
            }
            else if (event.shiftKey && (shiftName = w3cKeyname.shift[event.keyCode]) != name && shiftName != baseName &&
                runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
                handled = true;
            }
        }
        else if (isChar && event.shiftKey &&
            runFor(scopeObj[prefix + modifiers(name, event, true)])) {
            handled = true;
        }
        if (!handled && runFor(scopeObj._any))
            handled = true;
    }
    if (prevented)
        handled = true;
    if (handled && stopPropagation)
        event.stopPropagation();
    currentKeyEvent = null;
    return handled;
}

/**
Implementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates
a rectangle at a given set of coordinates.
*/
class RectangleMarker {
    /**
    Create a marker with the given class and dimensions. If `width`
    is null, the DOM element will get no width style.
    */
    constructor(className, 
    /**
    The left position of the marker (in pixels, document-relative).
    */
    left, 
    /**
    The top position of the marker.
    */
    top, 
    /**
    The width of the marker, or null if it shouldn't get a width assigned.
    */
    width, 
    /**
    The height of the marker.
    */
    height) {
        this.className = className;
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
    }
    draw() {
        let elt = document.createElement("div");
        elt.className = this.className;
        this.adjust(elt);
        return elt;
    }
    update(elt, prev) {
        if (prev.className != this.className)
            return false;
        this.adjust(elt);
        return true;
    }
    adjust(elt) {
        elt.style.left = this.left + "px";
        elt.style.top = this.top + "px";
        if (this.width != null)
            elt.style.width = this.width + "px";
        elt.style.height = this.height + "px";
    }
    eq(p) {
        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&
            this.className == p.className;
    }
    /**
    Create a set of rectangles for the given selection range,
    assigning them theclass`className`. Will create a single
    rectangle for empty ranges, and a set of selection-style
    rectangles covering the range's content (in a bidi-aware
    way) for non-empty ones.
    */
    static forRange(view, className, range) {
        if (range.empty) {
            let pos = view.coordsAtPos(range.head, range.assoc || 1);
            if (!pos)
                return [];
            let base = getBase(view);
            return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];
        }
        else {
            return rectanglesForRange(view, className, range);
        }
    }
}
function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == exports.Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
    return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, side, inside) {
    let coords = view.coordsAtPos(pos, side * 2);
    if (!coords)
        return inside;
    let editorRect = view.dom.getBoundingClientRect();
    let y = (coords.top + coords.bottom) / 2;
    let left = view.posAtCoords({ x: editorRect.left + 1, y });
    let right = view.posAtCoords({ x: editorRect.right - 1, y });
    if (left == null || right == null)
        return inside;
    return { from: Math.max(inside.from, Math.min(left, right)), to: Math.min(inside.to, Math.max(left, right)) };
}
function rectanglesForRange(view, className, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to)
        return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == exports.Direction.LTR;
    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);
    let lineElt = content.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
    let leftSide = contentRect.left +
        (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
    let visualStart = startBlock.type == exports.BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == exports.BlockType.Text ? endBlock : null;
    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
        visualStart = wrappedLine(view, from, 1, visualStart);
    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
        visualEnd = wrappedLine(view, to, -1, visualEnd);
    if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
        return pieces(drawForLine(range.from, range.to, visualStart));
    }
    else {
        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
        let between = [];
        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) ||
            startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top)
            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));
        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == exports.BlockType.Text)
            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
        return pieces(top).concat(between).concat(pieces(bottom));
    }
    function piece(left, top, right, bottom) {
        return new RectangleMarker(className, left - base.left, top - base.top - 0.01 /* C.Epsilon */, right - left, bottom - top + 0.01 /* C.Epsilon */);
    }
    function pieces({ top, bottom, horizontal }) {
        let pieces = [];
        for (let i = 0; i < horizontal.length; i += 2)
            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
        return pieces;
    }
    // Gets passed from/to in line-local positions
    function drawForLine(from, to, line) {
        let top = 1e9, bottom = -1e9, horizontal = [];
        function addSpan(from, fromOpen, to, toOpen, dir) {
            // Passing 2/-2 is a kludge to force the view to return
            // coordinates on the proper side of block widgets, since
            // normalizing the side there, though appropriate for most
            // coordsAtPos queries, would break selection drawing.
            let fromCoords = view.coordsAtPos(from, (from == line.to ? -2 : 2));
            let toCoords = view.coordsAtPos(to, (to == line.from ? 2 : -2));
            if (!fromCoords || !toCoords)
                return;
            top = Math.min(fromCoords.top, toCoords.top, top);
            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
            if (dir == exports.Direction.LTR)
                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
            else
                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
        }
        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;
        // Split the range by visible range and document line
        for (let r of view.visibleRanges)
            if (r.to > start && r.from < end) {
                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {
                    let docLine = view.state.doc.lineAt(pos);
                    for (let span of view.bidiSpans(docLine)) {
                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
                        if (spanFrom >= endPos)
                            break;
                        if (spanTo > pos)
                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);
                    }
                    pos = docLine.to + 1;
                    if (pos >= endPos)
                        break;
                }
            }
        if (horizontal.length == 0)
            addSpan(start, from == null, end, to == null, view.textDirection);
        return { top, bottom, horizontal };
    }
    function drawForWidget(block, top) {
        let y = contentRect.top + (top ? block.top : block.bottom);
        return { top: y, bottom: y, horizontal: [] };
    }
}
function sameMarker(a, b) {
    return a.constructor == b.constructor && a.eq(b);
}
class LayerView {
    constructor(view, layer) {
        this.view = view;
        this.layer = layer;
        this.drawn = [];
        this.scaleX = 1;
        this.scaleY = 1;
        this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
        this.dom = view.scrollDOM.appendChild(document.createElement("div"));
        this.dom.classList.add("cm-layer");
        if (layer.above)
            this.dom.classList.add("cm-layer-above");
        if (layer.class)
            this.dom.classList.add(layer.class);
        this.scale();
        this.dom.setAttribute("aria-hidden", "true");
        this.setOrder(view.state);
        view.requestMeasure(this.measureReq);
        if (layer.mount)
            layer.mount(this.dom, view);
    }
    update(update) {
        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
            this.setOrder(update.state);
        if (this.layer.update(update, this.dom) || update.geometryChanged) {
            this.scale();
            update.view.requestMeasure(this.measureReq);
        }
    }
    docViewUpdate(view) {
        if (this.layer.updateOnDocViewUpdate !== false)
            view.requestMeasure(this.measureReq);
    }
    setOrder(state) {
        let pos = 0, order = state.facet(layerOrder);
        while (pos < order.length && order[pos] != this.layer)
            pos++;
        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
    }
    measure() {
        return this.layer.markers(this.view);
    }
    scale() {
        let { scaleX, scaleY } = this.view;
        if (scaleX != this.scaleX || scaleY != this.scaleY) {
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
        }
    }
    draw(markers) {
        if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
            let old = this.dom.firstChild, oldI = 0;
            for (let marker of markers) {
                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor &&
                    marker.update(old, this.drawn[oldI])) {
                    old = old.nextSibling;
                    oldI++;
                }
                else {
                    this.dom.insertBefore(marker.draw(), old);
                }
            }
            while (old) {
                let next = old.nextSibling;
                old.remove();
                old = next;
            }
            this.drawn = markers;
        }
    }
    destroy() {
        if (this.layer.destroy)
            this.layer.destroy(this.dom, this.view);
        this.dom.remove();
    }
}
const layerOrder = state.Facet.define();
/**
Define a layer.
*/
function layer(config) {
    return [
        ViewPlugin.define(v => new LayerView(v, config)),
        layerOrder.of(config)
    ];
}

const CanHidePrimary = !browser.ios; // FIXME test IE
const selectionConfig = state.Facet.define({
    combine(configs) {
        return state.combineConfig(configs, {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
        }, {
            cursorBlinkRate: (a, b) => Math.min(a, b),
            drawRangeCursor: (a, b) => a || b
        });
    }
});
/**
Returns an extension that hides the browser's native selection and
cursor, replacing the selection with a background behind the text
(with the `cm-selectionBackground` class), and the
cursors with elements overlaid over the code (using
`cm-cursor-primary` and `cm-cursor-secondary`).

This allows the editor to display secondary selection ranges, and
tends to produce a type of selection more in line with that users
expect in a text editor (the native selection styling will often
leave gaps between lines and won't fill the horizontal space after
a line when the selection continues past it).

It does have a performance cost, in that it requires an extra DOM
layout cycle for many updates (the selection is drawn based on DOM
layout information that's only available after laying out the
content).
*/
function drawSelection(config = {}) {
    return [
        selectionConfig.of(config),
        cursorLayer,
        selectionLayer,
        hideNativeSelection,
        nativeSelectionHidden.of(true)
    ];
}
/**
Retrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration
for this state. (Note that this will return a set of defaults even
if `drawSelection` isn't enabled.)
*/
function getDrawSelectionConfig(state) {
    return state.facet(selectionConfig);
}
function configChanged(update) {
    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
const cursorLayer = layer({
    above: true,
    markers(view) {
        let { state: state$1 } = view, conf = state$1.facet(selectionConfig);
        let cursors = [];
        for (let r of state$1.selection.ranges) {
            let prim = r == state$1.selection.main;
            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
                let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
                let cursor = r.empty ? r : state.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
                for (let piece of RectangleMarker.forRange(view, className, cursor))
                    cursors.push(piece);
            }
        }
        return cursors;
    },
    update(update, dom) {
        if (update.transactions.some(tr => tr.selection))
            dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
        let confChange = configChanged(update);
        if (confChange)
            setBlinkRate(update.state, dom);
        return update.docChanged || update.selectionSet || confChange;
    },
    mount(dom, view) {
        setBlinkRate(view.state, dom);
    },
    class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
const selectionLayer = layer({
    above: false,
    markers(view) {
        return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r))
            .reduce((a, b) => a.concat(b));
    },
    update(update, dom) {
        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
    },
    class: "cm-selectionLayer"
});
const themeSpec = {
    ".cm-line": {
        "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    },
    ".cm-content": {
        "& :focus": {
            caretColor: "initial !important",
            "&::selection, & ::selection": {
                backgroundColor: "Highlight !important"
            }
        }
    }
};
if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = themeSpec[".cm-content"].caretColor = "transparent !important";
const hideNativeSelection = state.Prec.highest(EditorView.theme(themeSpec));

const setDropCursorPos = state.StateEffect.define({
    map(pos, mapping) { return pos == null ? null : mapping.mapPos(pos); }
});
const dropCursorPos = state.StateField.define({
    create() { return null; },
    update(pos, tr) {
        if (pos != null)
            pos = tr.changes.mapPos(pos);
        return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);
    }
});
const drawDropCursor = ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.cursor = null;
        this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
    }
    update(update) {
        var _a;
        let cursorPos = update.state.field(dropCursorPos);
        if (cursorPos == null) {
            if (this.cursor != null) {
                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();
                this.cursor = null;
            }
        }
        else {
            if (!this.cursor) {
                this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
                this.cursor.className = "cm-dropCursor";
            }
            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
                this.view.requestMeasure(this.measureReq);
        }
    }
    readPos() {
        let { view } = this;
        let pos = view.state.field(dropCursorPos);
        let rect = pos != null && view.coordsAtPos(pos);
        if (!rect)
            return null;
        let outer = view.scrollDOM.getBoundingClientRect();
        return {
            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
            height: rect.bottom - rect.top
        };
    }
    drawCursor(pos) {
        if (this.cursor) {
            let { scaleX, scaleY } = this.view;
            if (pos) {
                this.cursor.style.left = pos.left / scaleX + "px";
                this.cursor.style.top = pos.top / scaleY + "px";
                this.cursor.style.height = pos.height / scaleY + "px";
            }
            else {
                this.cursor.style.left = "-100000px";
            }
        }
    }
    destroy() {
        if (this.cursor)
            this.cursor.remove();
    }
    setDropPos(pos) {
        if (this.view.state.field(dropCursorPos) != pos)
            this.view.dispatch({ effects: setDropCursorPos.of(pos) });
    }
}, {
    eventObservers: {
        dragover(event) {
            this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
        },
        dragleave(event) {
            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
                this.setDropPos(null);
        },
        dragend() {
            this.setDropPos(null);
        },
        drop() {
            this.setDropPos(null);
        }
    }
});
/**
Draws a cursor at the current drop position when something is
dragged over the editor.
*/
function dropCursor() {
    return [dropCursorPos, drawDropCursor];
}

function iterMatches(doc, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
        if (!cursor.lineBreak)
            while (m = re.exec(cursor.value))
                f(pos + m.index, m);
    }
}
function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from &&
        visible[0].to == view.viewport.to)
        return visible;
    let result = [];
    for (let { from, to } of visible) {
        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
        if (result.length && result[result.length - 1].to >= from)
            result[result.length - 1].to = to;
        else
            result.push({ from, to });
    }
    return result;
}
/**
Helper class used to make it easier to maintain decorations on
visible code that matches a given regular expression. To be used
in a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object
represent a matching configuration.
*/
class MatchDecorator {
    /**
    Create a decorator.
    */
    constructor(config) {
        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;
        if (!regexp.global)
            throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
        this.regexp = regexp;
        if (decorate) {
            this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
        }
        else if (typeof decoration == "function") {
            this.addMatch = (match, view, from, add) => {
                let deco = decoration(match, view, from);
                if (deco)
                    add(from, from + match[0].length, deco);
            };
        }
        else if (decoration) {
            this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);
        }
        else {
            throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
        }
        this.boundary = boundary;
        this.maxLength = maxLength;
    }
    /**
    Compute the full set of decorations for matches in the given
    view's viewport. You'll want to call this when initializing your
    plugin.
    */
    createDeco(view) {
        let build = new state.RangeSetBuilder(), add = build.add.bind(build);
        for (let { from, to } of matchRanges(view, this.maxLength))
            iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));
        return build.finish();
    }
    /**
    Update a set of decorations for a view update. `deco` _must_ be
    the set of decorations produced by _this_ `MatchDecorator` for
    the view state before the update.
    */
    updateDeco(update, deco) {
        let changeFrom = 1e9, changeTo = -1;
        if (update.docChanged)
            update.changes.iterChanges((_f, _t, from, to) => {
                if (to > update.view.viewport.from && from < update.view.viewport.to) {
                    changeFrom = Math.min(from, changeFrom);
                    changeTo = Math.max(to, changeTo);
                }
            });
        if (update.viewportChanged || changeTo - changeFrom > 1000)
            return this.createDeco(update.view);
        if (changeTo > -1)
            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
        return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
        for (let r of view.visibleRanges) {
            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
            if (to > from) {
                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
                if (this.boundary) {
                    for (; from > fromLine.from; from--)
                        if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                            start = from;
                            break;
                        }
                    for (; to < toLine.to; to++)
                        if (this.boundary.test(toLine.text[to - toLine.from])) {
                            end = to;
                            break;
                        }
                }
                let ranges = [], m;
                let add = (from, to, deco) => ranges.push(deco.range(from, to));
                if (fromLine == toLine) {
                    this.regexp.lastIndex = start - fromLine.from;
                    while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                        this.addMatch(m, view, m.index + fromLine.from, add);
                }
                else {
                    iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));
                }
                deco = deco.update({ filterFrom: start, filterTo: end, filter: (from, to) => from < start || to > end, add: ranges });
            }
        }
        return deco;
    }
}

const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
const Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
};
let _supportsTabSize = null;
function supportsTabSize() {
    var _a;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
        let styles = document.body.style;
        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
}
const specialCharConfig = state.Facet.define({
    combine(configs) {
        let config = state.combineConfig(configs, {
            render: null,
            specialChars: Specials,
            addSpecialChars: null
        });
        if (config.replaceTabs = !supportsTabSize())
            config.specialChars = new RegExp("\t|" + config.specialChars.source, UnicodeRegexpSupport);
        if (config.addSpecialChars)
            config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
        return config;
    }
});
/**
Returns an extension that installs highlighting of special
characters.
*/
function highlightSpecialChars(
/**
Configuration options.
*/
config = {}) {
    return [specialCharConfig.of(config), specialCharPlugin()];
}
let _plugin = null;
function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.decorations = Decoration.none;
            this.decorationCache = Object.create(null);
            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
            this.decorations = this.decorator.createDeco(view);
        }
        makeDecorator(conf) {
            return new MatchDecorator({
                regexp: conf.specialChars,
                decoration: (m, view, pos) => {
                    let { doc } = view.state;
                    let code = state.codePointAt(m[0], 0);
                    if (code == 9) {
                        let line = doc.lineAt(pos);
                        let size = view.state.tabSize, col = state.countColumn(line.text, size, pos - line.from);
                        return Decoration.replace({
                            widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth / this.view.scaleX)
                        });
                    }
                    return this.decorationCache[code] ||
                        (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
                },
                boundary: conf.replaceTabs ? undefined : /[^]/
            });
        }
        update(update) {
            let conf = update.state.facet(specialCharConfig);
            if (update.startState.facet(specialCharConfig) != conf) {
                this.decorator = this.makeDecorator(conf);
                this.decorations = this.decorator.createDeco(update.view);
            }
            else {
                this.decorations = this.decorator.updateDeco(update, this.decorations);
            }
        }
    }, {
        decorations: v => v.decorations
    }));
}
const DefaultPlaceholder = "\u2022";
// Assigns placeholder characters from the Control Pictures block to
// ASCII control characters
function placeholder$1(code) {
    if (code >= 32)
        return DefaultPlaceholder;
    if (code == 10)
        return "\u2424";
    return String.fromCharCode(9216 + code);
}
class SpecialCharWidget extends WidgetType {
    constructor(options, code) {
        super();
        this.options = options;
        this.code = code;
    }
    eq(other) { return other.code == this.code; }
    toDOM(view) {
        let ph = placeholder$1(this.code);
        let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
        let custom = this.options.render && this.options.render(this.code, desc, ph);
        if (custom)
            return custom;
        let span = document.createElement("span");
        span.textContent = ph;
        span.title = desc;
        span.setAttribute("aria-label", desc);
        span.className = "cm-specialChar";
        return span;
    }
    ignoreEvent() { return false; }
}
class TabWidget extends WidgetType {
    constructor(width) {
        super();
        this.width = width;
    }
    eq(other) { return other.width == this.width; }
    toDOM() {
        let span = document.createElement("span");
        span.textContent = "\t";
        span.className = "cm-tab";
        span.style.width = this.width + "px";
        return span;
    }
    ignoreEvent() { return false; }
}

const plugin = ViewPlugin.fromClass(class {
    constructor() {
        this.height = 1000;
        this.attrs = { style: "padding-bottom: 1000px" };
    }
    update(update) {
        let { view } = update;
        let height = view.viewState.editorHeight -
            view.defaultLineHeight - view.documentPadding.top - 0.5;
        if (height >= 0 && height != this.height) {
            this.height = height;
            this.attrs = { style: `padding-bottom: ${height}px` };
        }
    }
});
/**
Returns an extension that makes sure the content has a bottom
margin equivalent to the height of the editor, minus one line
height, so that every line in the document can be scrolled to the
top of the editor.

This is only meaningful when the editor is scrollable, and should
not be enabled in editors that take the size of their content.
*/
function scrollPastEnd() {
    return [plugin, contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null; })];
}

/**
Mark lines that have a cursor on them with the `"cm-activeLine"`
DOM class.
*/
function highlightActiveLine() {
    return activeLineHighlighter;
}
const lineDeco = Decoration.line({ class: "cm-activeLine" });
const activeLineHighlighter = ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.docChanged || update.selectionSet)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let lastLineStart = -1, deco = [];
        for (let r of view.state.selection.ranges) {
            let line = view.lineBlockAt(r.head);
            if (line.from > lastLineStart) {
                deco.push(lineDeco.range(line.from));
                lastLineStart = line.from;
            }
        }
        return Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});

class Placeholder extends WidgetType {
    constructor(content) {
        super();
        this.content = content;
    }
    toDOM(view) {
        let wrap = document.createElement("span");
        wrap.className = "cm-placeholder";
        wrap.style.pointerEvents = "none";
        wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) :
            typeof this.content == "function" ? this.content(view) :
                this.content.cloneNode(true));
        if (typeof this.content == "string")
            wrap.setAttribute("aria-label", "placeholder " + this.content);
        else
            wrap.setAttribute("aria-hidden", "true");
        return wrap;
    }
    coordsAt(dom) {
        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
        if (!rects.length)
            return null;
        let style = window.getComputedStyle(dom.parentNode);
        let rect = flattenRect(rects[0], style.direction != "rtl");
        let lineHeight = parseInt(style.lineHeight);
        if (rect.bottom - rect.top > lineHeight * 1.5)
            return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
        return rect;
    }
    ignoreEvent() { return false; }
}
/**
Extension that enables a placeholder—a piece of example content
to show when the editor is empty.
*/
function placeholder(content) {
    return ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.placeholder = content
                ? Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)])
                : Decoration.none;
        }
        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }
    }, { decorations: v => v.decorations });
}

// Don't compute precise column positions for line offsets above this
// (since it could get expensive). Assume offset==column for them.
const MaxOff = 2000;
function rectangleFor(state$1, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
        for (let i = startLine; i <= endLine; i++) {
            let line = state$1.doc.line(i);
            if (line.length <= endOff)
                ranges.push(state.EditorSelection.range(line.from + startOff, line.to + endOff));
        }
    }
    else {
        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
        for (let i = startLine; i <= endLine; i++) {
            let line = state$1.doc.line(i);
            let start = state.findColumn(line.text, startCol, state$1.tabSize, true);
            if (start < 0) {
                ranges.push(state.EditorSelection.cursor(line.to));
            }
            else {
                let end = state.findColumn(line.text, endCol, state$1.tabSize);
                ranges.push(state.EditorSelection.range(line.from + start, line.from + end));
            }
        }
    }
    return ranges;
}
function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1
        : off == line.length ? absoluteColumn(view, event.clientX)
            : state.countColumn(line.text, view.state.tabSize, offset - line.from);
    return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
    let start = getPos(view, event), startSel = view.state.selection;
    if (!start)
        return null;
    return {
        update(update) {
            if (update.docChanged) {
                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
                let newLine = update.state.doc.lineAt(newStart);
                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
                startSel = startSel.map(update.changes);
            }
        },
        get(event, _extend, multiple) {
            let cur = getPos(view, event);
            if (!cur)
                return startSel;
            let ranges = rectangleFor(view.state, start, cur);
            if (!ranges.length)
                return startSel;
            if (multiple)
                return state.EditorSelection.create(ranges.concat(startSel.ranges));
            else
                return state.EditorSelection.create(ranges);
        }
    };
}
/**
Create an extension that enables rectangular selections. By
default, it will react to left mouse drag with the Alt key held
down. When such a selection occurs, the text within the rectangle
that was dragged over will be selected, as one selection
[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.
*/
function rectangularSelection(options) {
    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);
    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
const keys = {
    Alt: [18, e => !!e.altKey],
    Control: [17, e => !!e.ctrlKey],
    Shift: [16, e => !!e.shiftKey],
    Meta: [91, e => !!e.metaKey]
};
const showCrosshair = { style: "cursor: crosshair" };
/**
Returns an extension that turns the pointer cursor into a
crosshair when a given modifier key, defaulting to Alt, is held
down. Can serve as a visual hint that rectangular selection is
going to happen when paired with
[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).
*/
function crosshairCursor(options = {}) {
    let [code, getter] = keys[options.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.isDown = false;
        }
        set(isDown) {
            if (this.isDown != isDown) {
                this.isDown = isDown;
                this.view.update([]);
            }
        }
    }, {
        eventObservers: {
            keydown(e) {
                this.set(e.keyCode == code || getter(e));
            },
            keyup(e) {
                if (e.keyCode == code || !getter(e))
                    this.set(false);
            },
            mousemove(e) {
                this.set(getter(e));
            }
        }
    });
    return [
        plugin,
        EditorView.contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null; })
    ];
}

const Outside = "-10000px";
class TooltipViewManager {
    constructor(view, facet, createTooltipView, removeTooltipView) {
        this.facet = facet;
        this.createTooltipView = createTooltipView;
        this.removeTooltipView = removeTooltipView;
        this.input = view.state.facet(facet);
        this.tooltips = this.input.filter(t => t);
        let prev = null;
        this.tooltipViews = this.tooltips.map(t => prev = createTooltipView(t, prev));
    }
    update(update, above) {
        var _a;
        let input = update.state.facet(this.facet);
        let tooltips = input.filter(x => x);
        if (input === this.input) {
            for (let t of this.tooltipViews)
                if (t.update)
                    t.update(update);
            return false;
        }
        let tooltipViews = [], newAbove = above ? [] : null;
        for (let i = 0; i < tooltips.length; i++) {
            let tip = tooltips[i], known = -1;
            if (!tip)
                continue;
            for (let i = 0; i < this.tooltips.length; i++) {
                let other = this.tooltips[i];
                if (other && other.create == tip.create)
                    known = i;
            }
            if (known < 0) {
                tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);
                if (newAbove)
                    newAbove[i] = !!tip.above;
            }
            else {
                let tooltipView = tooltipViews[i] = this.tooltipViews[known];
                if (newAbove)
                    newAbove[i] = above[known];
                if (tooltipView.update)
                    tooltipView.update(update);
            }
        }
        for (let t of this.tooltipViews)
            if (tooltipViews.indexOf(t) < 0) {
                this.removeTooltipView(t);
                (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
            }
        if (above) {
            newAbove.forEach((val, i) => above[i] = val);
            above.length = newAbove.length;
        }
        this.input = input;
        this.tooltips = tooltips;
        this.tooltipViews = tooltipViews;
        return true;
    }
}
/**
Creates an extension that configures tooltip behavior.
*/
function tooltips(config = {}) {
    return tooltipConfig.of(config);
}
function windowSpace(view) {
    let { win } = view;
    return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
}
const tooltipConfig = state.Facet.define({
    combine: values => {
        var _a, _b, _c;
        return ({
            position: browser.ios ? "absolute" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
            parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
            tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace,
        });
    }
});
const knownHeight = new WeakMap();
const tooltipPlugin = ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.above = [];
        this.inView = true;
        this.madeAbsolute = false;
        this.lastTransaction = 0;
        this.measureTimeout = -1;
        let config = view.state.facet(tooltipConfig);
        this.position = config.position;
        this.parent = config.parent;
        this.classes = view.themeClasses;
        this.createContainer();
        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
        this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
        this.manager = new TooltipViewManager(view, showTooltip, (t, p) => this.createTooltip(t, p), t => {
            if (this.resizeObserver)
                this.resizeObserver.unobserve(t.dom);
            t.dom.remove();
        });
        this.above = this.manager.tooltips.map(t => !!t.above);
        this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(entries => {
            if (Date.now() > this.lastTransaction - 50 &&
                entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
                this.measureSoon();
        }, { threshold: [1] }) : null;
        this.observeIntersection();
        view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
        this.maybeMeasure();
    }
    createContainer() {
        if (this.parent) {
            this.container = document.createElement("div");
            this.container.style.position = "relative";
            this.container.className = this.view.themeClasses;
            this.parent.appendChild(this.container);
        }
        else {
            this.container = this.view.dom;
        }
    }
    observeIntersection() {
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            for (let tooltip of this.manager.tooltipViews)
                this.intersectionObserver.observe(tooltip.dom);
        }
    }
    measureSoon() {
        if (this.measureTimeout < 0)
            this.measureTimeout = setTimeout(() => {
                this.measureTimeout = -1;
                this.maybeMeasure();
            }, 50);
    }
    update(update) {
        if (update.transactions.length)
            this.lastTransaction = Date.now();
        let updated = this.manager.update(update, this.above);
        if (updated)
            this.observeIntersection();
        let shouldMeasure = updated || update.geometryChanged;
        let newConfig = update.state.facet(tooltipConfig);
        if (newConfig.position != this.position && !this.madeAbsolute) {
            this.position = newConfig.position;
            for (let t of this.manager.tooltipViews)
                t.dom.style.position = this.position;
            shouldMeasure = true;
        }
        if (newConfig.parent != this.parent) {
            if (this.parent)
                this.container.remove();
            this.parent = newConfig.parent;
            this.createContainer();
            for (let t of this.manager.tooltipViews)
                this.container.appendChild(t.dom);
            shouldMeasure = true;
        }
        else if (this.parent && this.view.themeClasses != this.classes) {
            this.classes = this.container.className = this.view.themeClasses;
        }
        if (shouldMeasure)
            this.maybeMeasure();
    }
    createTooltip(tooltip, prev) {
        let tooltipView = tooltip.create(this.view);
        let before = prev ? prev.dom : null;
        tooltipView.dom.classList.add("cm-tooltip");
        if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
            let arrow = document.createElement("div");
            arrow.className = "cm-tooltip-arrow";
            tooltipView.dom.appendChild(arrow);
        }
        tooltipView.dom.style.position = this.position;
        tooltipView.dom.style.top = Outside;
        tooltipView.dom.style.left = "0px";
        this.container.insertBefore(tooltipView.dom, before);
        if (tooltipView.mount)
            tooltipView.mount(this.view);
        if (this.resizeObserver)
            this.resizeObserver.observe(tooltipView.dom);
        return tooltipView;
    }
    destroy() {
        var _a, _b, _c;
        this.view.win.removeEventListener("resize", this.measureSoon);
        for (let tooltipView of this.manager.tooltipViews) {
            tooltipView.dom.remove();
            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);
        }
        if (this.parent)
            this.container.remove();
        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
        clearTimeout(this.measureTimeout);
    }
    readMeasure() {
        let scaleX = 1, scaleY = 1, makeAbsolute = false;
        if (this.position == "fixed" && this.manager.tooltipViews.length) {
            let { dom } = this.manager.tooltipViews[0];
            if (browser.gecko) {
                // Firefox sets the element's `offsetParent` to the
                // transformed element when a transform interferes with fixed
                // positioning.
                makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
            }
            else if (dom.style.top == Outside && dom.style.left == "0px") {
                // On other browsers, we have to awkwardly try and use other
                // information to detect a transform.
                let rect = dom.getBoundingClientRect();
                makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;
            }
        }
        if (makeAbsolute || this.position == "absolute") {
            if (this.parent) {
                let rect = this.parent.getBoundingClientRect();
                if (rect.width && rect.height) {
                    scaleX = rect.width / this.parent.offsetWidth;
                    scaleY = rect.height / this.parent.offsetHeight;
                }
            }
            else {
                ({ scaleX, scaleY } = this.view.viewState);
            }
        }
        let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
        return {
            visible: {
                left: visible.left + margins.left, top: visible.top + margins.top,
                right: visible.right - margins.right, bottom: visible.bottom - margins.bottom
            },
            parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
            pos: this.manager.tooltips.map((t, i) => {
                let tv = this.manager.tooltipViews[i];
                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
            }),
            size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
            scaleX, scaleY, makeAbsolute
        };
    }
    writeMeasure(measured) {
        var _a;
        if (measured.makeAbsolute) {
            this.madeAbsolute = true;
            this.position = "absolute";
            for (let t of this.manager.tooltipViews)
                t.dom.style.position = "absolute";
        }
        let { visible, space, scaleX, scaleY } = measured;
        let others = [];
        for (let i = 0; i < this.manager.tooltips.length; i++) {
            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
            let pos = measured.pos[i], size = measured.size[i];
            // Hide tooltips that are outside of the editor.
            if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) ||
                pos.top >= Math.min(visible.bottom, space.bottom) ||
                pos.right < Math.max(visible.left, space.left) - .1 ||
                pos.left > Math.min(visible.right, space.right) + .1)) {
                dom.style.top = Outside;
                continue;
            }
            let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
            let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;
            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;
            let offset = tView.offset || noOffset, ltr = this.view.textDirection == exports.Direction.LTR;
            let left = size.width > space.right - space.left
                ? (ltr ? space.left : space.right - size.width)
                : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width))
                    : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x), space.right - width);
            let above = this.above[i];
            if (!tooltip.strictSide && (above
                ? pos.top - height - arrowHeight - offset.y < space.top
                : pos.bottom + height + arrowHeight + offset.y > space.bottom) &&
                above == (space.bottom - pos.bottom > pos.top - space.top))
                above = this.above[i] = !above;
            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
            if (spaceVert < height && tView.resize !== false) {
                if (spaceVert < this.view.defaultLineHeight) {
                    dom.style.top = Outside;
                    continue;
                }
                knownHeight.set(tView, height);
                dom.style.height = (height = spaceVert) / scaleY + "px";
            }
            else if (dom.style.height) {
                dom.style.height = "";
            }
            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
            let right = left + width;
            if (tView.overlap !== true)
                for (let r of others)
                    if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)
                        top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
            if (this.position == "absolute") {
                dom.style.top = (top - measured.parent.top) / scaleY + "px";
                dom.style.left = (left - measured.parent.left) / scaleX + "px";
            }
            else {
                dom.style.top = top / scaleY + "px";
                dom.style.left = left / scaleX + "px";
            }
            if (arrow) {
                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */);
                arrow.style.left = arrowLeft / scaleX + "px";
            }
            if (tView.overlap !== true)
                others.push({ left, top, right, bottom: top + height });
            dom.classList.toggle("cm-tooltip-above", above);
            dom.classList.toggle("cm-tooltip-below", !above);
            if (tView.positioned)
                tView.positioned(measured.space);
        }
    }
    maybeMeasure() {
        if (this.manager.tooltips.length) {
            if (this.view.inView)
                this.view.requestMeasure(this.measureReq);
            if (this.inView != this.view.inView) {
                this.inView = this.view.inView;
                if (!this.inView)
                    for (let tv of this.manager.tooltipViews)
                        tv.dom.style.top = Outside;
            }
        }
    }
}, {
    eventObservers: {
        scroll() { this.maybeMeasure(); }
    }
});
const baseTheme = EditorView.baseTheme({
    ".cm-tooltip": {
        zIndex: 500,
        boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
        border: "1px solid #bbb",
        backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
        borderTop: "1px solid #bbb",
    },
    "&dark .cm-tooltip": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tooltip-arrow": {
        height: `${7 /* Arrow.Size */}px`,
        width: `${7 /* Arrow.Size */ * 2}px`,
        position: "absolute",
        zIndex: -1,
        overflow: "hidden",
        "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: `${7 /* Arrow.Size */}px solid transparent`,
            borderRight: `${7 /* Arrow.Size */}px solid transparent`,
        },
        ".cm-tooltip-above &": {
            bottom: `-${7 /* Arrow.Size */}px`,
            "&:before": {
                borderTop: `${7 /* Arrow.Size */}px solid #bbb`,
            },
            "&:after": {
                borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                bottom: "1px"
            }
        },
        ".cm-tooltip-below &": {
            top: `-${7 /* Arrow.Size */}px`,
            "&:before": {
                borderBottom: `${7 /* Arrow.Size */}px solid #bbb`,
            },
            "&:after": {
                borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                top: "1px"
            }
        },
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
        "&:before": {
            borderTopColor: "#333338",
            borderBottomColor: "#333338"
        },
        "&:after": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
        }
    }
});
const noOffset = { x: 0, y: 0 };
/**
Facet to which an extension can add a value to show a tooltip.
*/
const showTooltip = state.Facet.define({
    enables: [tooltipPlugin, baseTheme]
});
const showHoverTooltip = state.Facet.define({
    combine: inputs => inputs.reduce((a, i) => a.concat(i), [])
});
class HoverTooltipHost {
    // Needs to be static so that host tooltip instances always match
    static create(view) {
        return new HoverTooltipHost(view);
    }
    constructor(view) {
        this.view = view;
        this.mounted = false;
        this.dom = document.createElement("div");
        this.dom.classList.add("cm-tooltip-hover");
        this.manager = new TooltipViewManager(view, showHoverTooltip, (t, p) => this.createHostedView(t, p), t => t.dom.remove());
    }
    createHostedView(tooltip, prev) {
        let hostedView = tooltip.create(this.view);
        hostedView.dom.classList.add("cm-tooltip-section");
        this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
        if (this.mounted && hostedView.mount)
            hostedView.mount(this.view);
        return hostedView;
    }
    mount(view) {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.mount)
                hostedView.mount(view);
        }
        this.mounted = true;
    }
    positioned(space) {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.positioned)
                hostedView.positioned(space);
        }
    }
    update(update) {
        this.manager.update(update);
    }
    destroy() {
        var _a;
        for (let t of this.manager.tooltipViews)
            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
    }
    passProp(name) {
        let value = undefined;
        for (let view of this.manager.tooltipViews) {
            let given = view[name];
            if (given !== undefined) {
                if (value === undefined)
                    value = given;
                else if (value !== given)
                    return undefined;
            }
        }
        return value;
    }
    get offset() { return this.passProp("offset"); }
    get getCoords() { return this.passProp("getCoords"); }
    get overlap() { return this.passProp("overlap"); }
    get resize() { return this.passProp("resize"); }
}
const showHoverTooltipHost = showTooltip.compute([showHoverTooltip], state => {
    let tooltips = state.facet(showHoverTooltip);
    if (tooltips.length === 0)
        return null;
    return {
        pos: Math.min(...tooltips.map(t => t.pos)),
        end: Math.max(...tooltips.map(t => { var _a; return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos; })),
        create: HoverTooltipHost.create,
        above: tooltips[0].above,
        arrow: tooltips.some(t => t.arrow),
    };
});
class HoverPlugin {
    constructor(view, source, field, setHover, hoverTime) {
        this.view = view;
        this.source = source;
        this.field = field;
        this.setHover = setHover;
        this.hoverTime = hoverTime;
        this.hoverTimeout = -1;
        this.restartTimeout = -1;
        this.pending = null;
        this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
        if (this.pending) {
            this.pending = null;
            clearTimeout(this.restartTimeout);
            this.restartTimeout = setTimeout(() => this.startHover(), 20);
        }
    }
    get active() {
        return this.view.state.field(this.field);
    }
    checkHover() {
        this.hoverTimeout = -1;
        if (this.active.length)
            return;
        let hovered = Date.now() - this.lastMove.time;
        if (hovered < this.hoverTime)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
        else
            this.startHover();
    }
    startHover() {
        clearTimeout(this.restartTimeout);
        let { view, lastMove } = this;
        let desc = view.docView.nearest(lastMove.target);
        if (!desc)
            return;
        let pos, side = 1;
        if (desc instanceof WidgetView) {
            pos = desc.posAtStart;
        }
        else {
            pos = view.posAtCoords(lastMove);
            if (pos == null)
                return;
            let posCoords = view.coordsAtPos(pos);
            if (!posCoords ||
                lastMove.y < posCoords.top || lastMove.y > posCoords.bottom ||
                lastMove.x < posCoords.left - view.defaultCharacterWidth ||
                lastMove.x > posCoords.right + view.defaultCharacterWidth)
                return;
            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);
            let rtl = bidi && bidi.dir == exports.Direction.RTL ? -1 : 1;
            side = (lastMove.x < posCoords.left ? -rtl : rtl);
        }
        let open = this.source(view, pos, side);
        if (open === null || open === void 0 ? void 0 : open.then) {
            let pending = this.pending = { pos };
            open.then(result => {
                if (this.pending == pending) {
                    this.pending = null;
                    if (result && !(Array.isArray(result) && !result.length))
                        view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
                }
            }, e => logException(view.state, e, "hover tooltip"));
        }
        else if (open && !(Array.isArray(open) && !open.length)) {
            view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
        }
    }
    get tooltip() {
        let plugin = this.view.plugin(tooltipPlugin);
        let index = plugin ? plugin.manager.tooltips.findIndex(t => t.create == HoverTooltipHost.create) : -1;
        return index > -1 ? plugin.manager.tooltipViews[index] : null;
    }
    mousemove(event) {
        var _a, _b;
        this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
        if (this.hoverTimeout < 0)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
        let { active, tooltip } = this;
        if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
            let { pos } = active[0] || this.pending, end = (_b = (_a = active[0]) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : pos;
            if ((pos == end ? this.view.posAtCoords(this.lastMove) != pos
                : !isOverRange(this.view, pos, end, event.clientX, event.clientY))) {
                this.view.dispatch({ effects: this.setHover.of([]) });
                this.pending = null;
            }
        }
    }
    mouseleave(event) {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = -1;
        let { active } = this;
        if (active.length) {
            let { tooltip } = this;
            let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
            if (!inTooltip)
                this.view.dispatch({ effects: this.setHover.of([]) });
            else
                this.watchTooltipLeave(tooltip.dom);
        }
    }
    watchTooltipLeave(tooltip) {
        let watch = (event) => {
            tooltip.removeEventListener("mouseleave", watch);
            if (this.active.length && !this.view.dom.contains(event.relatedTarget))
                this.view.dispatch({ effects: this.setHover.of([]) });
        };
        tooltip.addEventListener("mouseleave", watch);
    }
    destroy() {
        clearTimeout(this.hoverTimeout);
        this.view.dom.removeEventListener("mouseleave", this.mouseleave);
        this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
}
const tooltipMargin = 4;
function isInTooltip(tooltip, event) {
    let { left, right, top, bottom } = tooltip.getBoundingClientRect(), arrow;
    if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
        let arrowRect = arrow.getBoundingClientRect();
        top = Math.min(arrowRect.top, top);
        bottom = Math.max(arrowRect.bottom, bottom);
    }
    return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin &&
        event.clientY >= top - tooltipMargin && event.clientY <= bottom + tooltipMargin;
}
function isOverRange(view, from, to, x, y, margin) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y)
        return false;
    let pos = view.posAtCoords({ x, y }, false);
    return pos >= from && pos <= to;
}
/**
Set up a hover tooltip, which shows up when the pointer hovers
over ranges of text. The callback is called when the mouse hovers
over the document text. It should, if there is a tooltip
associated with position `pos`, return the tooltip description
(either directly or in a promise). The `side` argument indicates
on which side of the position the pointer is—it will be -1 if the
pointer is before the position, 1 if after the position.

Note that all hover tooltips are hosted within a single tooltip
container element. This allows multiple tooltips over the same
range to be "merged" together without overlapping.

The return value is a valid [editor extension](https://codemirror.net/6/docs/ref/#state.Extension)
but also provides an `active` property holding a state field that
can be used to read the currently active tooltips produced by this
extension.
*/
function hoverTooltip(source, options = {}) {
    let setHover = state.StateEffect.define();
    let hoverState = state.StateField.define({
        create() { return []; },
        update(value, tr) {
            if (value.length) {
                if (options.hideOnChange && (tr.docChanged || tr.selection))
                    value = [];
                else if (options.hideOn)
                    value = value.filter(v => !options.hideOn(tr, v));
                if (tr.docChanged) {
                    let mapped = [];
                    for (let tooltip of value) {
                        let newPos = tr.changes.mapPos(tooltip.pos, -1, state.MapMode.TrackDel);
                        if (newPos != null) {
                            let copy = Object.assign(Object.create(null), tooltip);
                            copy.pos = newPos;
                            if (copy.end != null)
                                copy.end = tr.changes.mapPos(copy.end);
                            mapped.push(copy);
                        }
                    }
                    value = mapped;
                }
            }
            for (let effect of tr.effects) {
                if (effect.is(setHover))
                    value = effect.value;
                if (effect.is(closeHoverTooltipEffect))
                    value = [];
            }
            return value;
        },
        provide: f => showHoverTooltip.from(f)
    });
    return {
        active: hoverState,
        extension: [
            hoverState,
            ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */)),
            showHoverTooltipHost
        ]
    };
}
/**
Get the active tooltip view for a given tooltip, if available.
*/
function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin)
        return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
}
/**
Returns true if any hover tooltips are currently active.
*/
function hasHoverTooltips(state) {
    return state.facet(showHoverTooltip).some(x => x);
}
const closeHoverTooltipEffect = state.StateEffect.define();
/**
Transaction effect that closes all hover tooltips.
*/
const closeHoverTooltips = closeHoverTooltipEffect.of(null);
/**
Tell the tooltip extension to recompute the position of the active
tooltips. This can be useful when something happens (such as a
re-positioning or CSS change affecting the editor) that could
invalidate the existing tooltip positions.
*/
function repositionTooltips(view) {
    let plugin = view.plugin(tooltipPlugin);
    if (plugin)
        plugin.maybeMeasure();
}

const panelConfig = state.Facet.define({
    combine(configs) {
        let topContainer, bottomContainer;
        for (let c of configs) {
            topContainer = topContainer || c.topContainer;
            bottomContainer = bottomContainer || c.bottomContainer;
        }
        return { topContainer, bottomContainer };
    }
});
/**
Configures the panel-managing extension.
*/
function panels(config) {
    return config ? [panelConfig.of(config)] : [];
}
/**
Get the active panel created by the given constructor, if any.
This can be useful when you need access to your panels' DOM
structure.
*/
function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
}
const panelPlugin = ViewPlugin.fromClass(class {
    constructor(view) {
        this.input = view.state.facet(showPanel);
        this.specs = this.input.filter(s => s);
        this.panels = this.specs.map(spec => spec(view));
        let conf = view.state.facet(panelConfig);
        this.top = new PanelGroup(view, true, conf.topContainer);
        this.bottom = new PanelGroup(view, false, conf.bottomContainer);
        this.top.sync(this.panels.filter(p => p.top));
        this.bottom.sync(this.panels.filter(p => !p.top));
        for (let p of this.panels) {
            p.dom.classList.add("cm-panel");
            if (p.mount)
                p.mount();
        }
    }
    update(update) {
        let conf = update.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
            this.top.sync([]);
            this.top = new PanelGroup(update.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
            this.bottom.sync([]);
            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        let input = update.state.facet(showPanel);
        if (input != this.input) {
            let specs = input.filter(x => x);
            let panels = [], top = [], bottom = [], mount = [];
            for (let spec of specs) {
                let known = this.specs.indexOf(spec), panel;
                if (known < 0) {
                    panel = spec(update.view);
                    mount.push(panel);
                }
                else {
                    panel = this.panels[known];
                    if (panel.update)
                        panel.update(update);
                }
                panels.push(panel);
                (panel.top ? top : bottom).push(panel);
            }
            this.specs = specs;
            this.panels = panels;
            this.top.sync(top);
            this.bottom.sync(bottom);
            for (let p of mount) {
                p.dom.classList.add("cm-panel");
                if (p.mount)
                    p.mount();
            }
        }
        else {
            for (let p of this.panels)
                if (p.update)
                    p.update(update);
        }
    }
    destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
});
class PanelGroup {
    constructor(view, top, container) {
        this.view = view;
        this.top = top;
        this.container = container;
        this.dom = undefined;
        this.classes = "";
        this.panels = [];
        this.syncClasses();
    }
    sync(panels) {
        for (let p of this.panels)
            if (p.destroy && panels.indexOf(p) < 0)
                p.destroy();
        this.panels = panels;
        this.syncDOM();
    }
    syncDOM() {
        if (this.panels.length == 0) {
            if (this.dom) {
                this.dom.remove();
                this.dom = undefined;
            }
            return;
        }
        if (!this.dom) {
            this.dom = document.createElement("div");
            this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
            this.dom.style[this.top ? "top" : "bottom"] = "0";
            let parent = this.container || this.view.dom;
            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
        }
        let curDOM = this.dom.firstChild;
        for (let panel of this.panels) {
            if (panel.dom.parentNode == this.dom) {
                while (curDOM != panel.dom)
                    curDOM = rm(curDOM);
                curDOM = curDOM.nextSibling;
            }
            else {
                this.dom.insertBefore(panel.dom, curDOM);
            }
        }
        while (curDOM)
            curDOM = rm(curDOM);
    }
    scrollMargin() {
        return !this.dom || this.container ? 0
            : Math.max(0, this.top ?
                this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) :
                Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses)
            return;
        for (let cls of this.classes.split(" "))
            if (cls)
                this.container.classList.remove(cls);
        for (let cls of (this.classes = this.view.themeClasses).split(" "))
            if (cls)
                this.container.classList.add(cls);
    }
}
function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
}
/**
Opening a panel is done by providing a constructor function for
the panel through this facet. (The panel is closed again when its
constructor is no longer provided.) Values of `null` are ignored.
*/
const showPanel = state.Facet.define({
    enables: panelPlugin
});

/**
A gutter marker represents a bit of information attached to a line
in a specific gutter. Your own custom markers have to extend this
class.
*/
class GutterMarker extends state.RangeValue {
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    Compare this marker to another marker of the same type.
    */
    eq(other) { return false; }
    /**
    Called if the marker has a `toDOM` method and its representation
    was removed from a gutter.
    */
    destroy(dom) { }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = undefined;
GutterMarker.prototype.mapMode = state.MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
/**
Facet used to add a class to all gutter elements for a given line.
Markers given to this facet should _only_ define an
[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a
[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear
in all gutters for the line).
*/
const gutterLineClass = state.Facet.define();
/**
Facet used to add a class to all gutter elements next to a widget.
Should not provide widgets with a `toDOM` method.
*/
const gutterWidgetClass = state.Facet.define();
const defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => state.RangeSet.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
};
const activeGutters = state.Facet.define();
/**
Define an editor gutter. The order in which the gutters appear is
determined by their extension priority.
*/
function gutter(config) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
}
const unfixGutters = state.Facet.define({
    combine: values => values.some(x => x)
});
/**
The gutter-drawing plugin is automatically enabled when you add a
gutter, but you can use this function to explicitly configure it.

Unless `fixed` is explicitly set to `false`, the gutters are
fixed, meaning they don't scroll along with the content
horizontally (except on Internet Explorer, which doesn't support
CSS [`position:
sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).
*/
function gutters(config) {
    let result = [
        gutterView,
    ];
    if (config && config.fixed === false)
        result.push(unfixGutters.of(true));
    return result;
}
const gutterView = ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.prevViewport = view.viewport;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters";
        this.dom.setAttribute("aria-hidden", "true");
        this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + "px";
        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));
        for (let gutter of this.gutters)
            this.dom.appendChild(gutter.dom);
        this.fixed = !view.state.facet(unfixGutters);
        if (this.fixed) {
            // FIXME IE11 fallback, which doesn't support position: sticky,
            // by using position: relative + event handlers that realign the
            // gutter (or just force fixed=false on IE11?)
            this.dom.style.position = "sticky";
        }
        this.syncGutters(false);
        view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
        if (this.updateGutters(update)) {
            // Detach during sync when the viewport changed significantly
            // (such as during scrolling), since for large updates that is
            // faster.
            let vpA = this.prevViewport, vpB = update.view.viewport;
            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
        }
        if (update.geometryChanged) {
            this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + "px";
        }
        if (this.view.state.facet(unfixGutters) != !this.fixed) {
            this.fixed = !this.fixed;
            this.dom.style.position = this.fixed ? "sticky" : "";
        }
        this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
        let after = this.dom.nextSibling;
        if (detach)
            this.dom.remove();
        let lineClasses = state.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
        let classSet = [];
        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));
        for (let line of this.view.viewportLineBlocks) {
            if (classSet.length)
                classSet = [];
            if (Array.isArray(line.type)) {
                let first = true;
                for (let b of line.type) {
                    if (b.type == exports.BlockType.Text && first) {
                        advanceCursor(lineClasses, classSet, b.from);
                        for (let cx of contexts)
                            cx.line(this.view, b, classSet);
                        first = false;
                    }
                    else if (b.widget) {
                        for (let cx of contexts)
                            cx.widget(this.view, b);
                    }
                }
            }
            else if (line.type == exports.BlockType.Text) {
                advanceCursor(lineClasses, classSet, line.from);
                for (let cx of contexts)
                    cx.line(this.view, line, classSet);
            }
            else if (line.widget) {
                for (let cx of contexts)
                    cx.widget(this.view, line);
            }
        }
        for (let cx of contexts)
            cx.finish();
        if (detach)
            this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
        let change = update.docChanged || update.heightChanged || update.viewportChanged ||
            !state.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
        if (prev == cur) {
            for (let gutter of this.gutters)
                if (gutter.update(update))
                    change = true;
        }
        else {
            change = true;
            let gutters = [];
            for (let conf of cur) {
                let known = prev.indexOf(conf);
                if (known < 0) {
                    gutters.push(new SingleGutterView(this.view, conf));
                }
                else {
                    this.gutters[known].update(update);
                    gutters.push(this.gutters[known]);
                }
            }
            for (let g of this.gutters) {
                g.dom.remove();
                if (gutters.indexOf(g) < 0)
                    g.destroy();
            }
            for (let g of gutters)
                this.dom.appendChild(g.dom);
            this.gutters = gutters;
        }
        return change;
    }
    destroy() {
        for (let view of this.gutters)
            view.destroy();
        this.dom.remove();
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        if (!value || value.gutters.length == 0 || !value.fixed)
            return null;
        return view.textDirection == exports.Direction.LTR
            ? { left: value.dom.offsetWidth * view.scaleX }
            : { right: value.dom.offsetWidth * view.scaleX };
    })
});
function asArray(val) { return (Array.isArray(val) ? val : [val]); }
function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
        if (cursor.from == pos)
            collect.push(cursor.value);
        cursor.next();
    }
}
class UpdateContext {
    constructor(gutter, viewport, height) {
        this.gutter = gutter;
        this.height = height;
        this.i = 0;
        this.cursor = state.RangeSet.iter(gutter.markers, viewport.from);
    }
    addElement(view, block, markers) {
        let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
        if (this.i == gutter.elements.length) {
            let newElt = new GutterElement(view, height, above, markers);
            gutter.elements.push(newElt);
            gutter.dom.appendChild(newElt.dom);
        }
        else {
            gutter.elements[this.i].update(view, height, above, markers);
        }
        this.height = block.bottom;
        this.i++;
    }
    line(view, line, extraMarkers) {
        let localMarkers = [];
        advanceCursor(this.cursor, localMarkers, line.from);
        if (extraMarkers.length)
            localMarkers = localMarkers.concat(extraMarkers);
        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
        if (forLine)
            localMarkers.unshift(forLine);
        let gutter = this.gutter;
        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)
            return;
        this.addElement(view, line, localMarkers);
    }
    widget(view, block) {
        let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
        for (let cls of view.state.facet(gutterWidgetClass)) {
            let marker = cls(view, block.widget, block);
            if (marker)
                (markers || (markers = [])).push(marker);
        }
        if (markers)
            this.addElement(view, block, markers);
    }
    finish() {
        let gutter = this.gutter;
        while (gutter.elements.length > this.i) {
            let last = gutter.elements.pop();
            gutter.dom.removeChild(last.dom);
            last.destroy();
        }
    }
}
class SingleGutterView {
    constructor(view, config) {
        this.view = view;
        this.config = config;
        this.elements = [];
        this.spacer = null;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for (let prop in config.domEventHandlers) {
            this.dom.addEventListener(prop, (event) => {
                let target = event.target, y;
                if (target != this.dom && this.dom.contains(target)) {
                    while (target.parentNode != this.dom)
                        target = target.parentNode;
                    let rect = target.getBoundingClientRect();
                    y = (rect.top + rect.bottom) / 2;
                }
                else {
                    y = event.clientY;
                }
                let line = view.lineBlockAtHeight(y - view.documentTop);
                if (config.domEventHandlers[prop](view, line, event))
                    event.preventDefault();
            });
        }
        this.markers = asArray(config.markers(view));
        if (config.initialSpacer) {
            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
            this.dom.appendChild(this.spacer.dom);
            this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
        }
    }
    update(update) {
        let prevMarkers = this.markers;
        this.markers = asArray(this.config.markers(update.view));
        if (this.spacer && this.config.updateSpacer) {
            let updated = this.config.updateSpacer(this.spacer.markers[0], update);
            if (updated != this.spacer.markers[0])
                this.spacer.update(update.view, 0, 0, [updated]);
        }
        let vp = update.view.viewport;
        return !state.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) ||
            (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
        for (let elt of this.elements)
            elt.destroy();
    }
}
class GutterElement {
    constructor(view, height, above, markers) {
        this.height = -1;
        this.above = 0;
        this.markers = [];
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutterElement";
        this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
        if (this.height != height) {
            this.height = height;
            this.dom.style.height = height + "px";
        }
        if (this.above != above)
            this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
        if (!sameMarkers(this.markers, markers))
            this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
        let cls = "cm-gutterElement", domPos = this.dom.firstChild;
        for (let iNew = 0, iOld = 0;;) {
            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
            if (marker) {
                let c = marker.elementClass;
                if (c)
                    cls += " " + c;
                for (let i = iOld; i < this.markers.length; i++)
                    if (this.markers[i].compare(marker)) {
                        skipTo = i;
                        matched = true;
                        break;
                    }
            }
            else {
                skipTo = this.markers.length;
            }
            while (iOld < skipTo) {
                let next = this.markers[iOld++];
                if (next.toDOM) {
                    next.destroy(domPos);
                    let after = domPos.nextSibling;
                    domPos.remove();
                    domPos = after;
                }
            }
            if (!marker)
                break;
            if (marker.toDOM) {
                if (matched)
                    domPos = domPos.nextSibling;
                else
                    this.dom.insertBefore(marker.toDOM(view), domPos);
            }
            if (matched)
                iOld++;
        }
        this.dom.className = cls;
        this.markers = markers;
    }
    destroy() {
        this.setMarkers(null, []); // First argument not used unless creating markers
    }
}
function sameMarkers(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!a[i].compare(b[i]))
            return false;
    return true;
}
/**
Facet used to provide markers to the line number gutter.
*/
const lineNumberMarkers = state.Facet.define();
/**
Facet used to create markers in the line number gutter next to widgets.
*/
const lineNumberWidgetMarker = state.Facet.define();
const lineNumberConfig = state.Facet.define({
    combine(values) {
        return state.combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
            domEventHandlers(a, b) {
                let result = Object.assign({}, a);
                for (let event in b) {
                    let exists = result[event], add = b[event];
                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;
                }
                return result;
            }
        });
    }
});
class NumberMarker extends GutterMarker {
    constructor(number) {
        super();
        this.number = number;
    }
    eq(other) { return this.number == other.number; }
    toDOM() { return document.createTextNode(this.number); }
}
function formatNumber(view, number) {
    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
}
const lineNumberGutter = activeGutters.compute([lineNumberConfig], state => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) { return view.state.facet(lineNumberMarkers); },
    lineMarker(view, line, others) {
        if (others.some(m => m.toDOM))
            return null;
        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    widgetMarker: (view, widget, block) => {
        for (let m of view.state.facet(lineNumberWidgetMarker)) {
            let result = m(view, widget, block);
            if (result)
                return result;
        }
        return null;
    },
    lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
        return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
/**
Create a line number gutter extension.
*/
function lineNumbers(config = {}) {
    return [
        lineNumberConfig.of(config),
        gutters(),
        lineNumberGutter
    ];
}
function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
        last = last * 10 + 9;
    return last;
}
const activeLineGutterMarker = new class extends GutterMarker {
    constructor() {
        super(...arguments);
        this.elementClass = "cm-activeLineGutter";
    }
};
const activeLineGutterHighlighter = gutterLineClass.compute(["selection"], state$1 => {
    let marks = [], last = -1;
    for (let range of state$1.selection.ranges) {
        let linePos = state$1.doc.lineAt(range.head).from;
        if (linePos > last) {
            last = linePos;
            marks.push(activeLineGutterMarker.range(linePos));
        }
    }
    return state.RangeSet.of(marks);
});
/**
Returns an extension that adds a `cm-activeLineGutter` class to
all gutter elements on the [active
line](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).
*/
function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
}

function matcher(decorator) {
    return ViewPlugin.define(view => ({
        decorations: decorator.createDeco(view),
        update(u) {
            this.decorations = decorator.updateDeco(u, this.decorations);
        },
    }), {
        decorations: v => v.decorations
    });
}
const tabDeco = Decoration.mark({ class: "cm-highlightTab" });
const spaceDeco = Decoration.mark({ class: "cm-highlightSpace" });
const whitespaceHighlighter = matcher(new MatchDecorator({
    regexp: /\t| /g,
    decoration: match => match[0] == "\t" ? tabDeco : spaceDeco,
    boundary: /\S/,
}));
/**
Returns an extension that highlights whitespace, adding a
`cm-highlightSpace` class to stretches of spaces, and a
`cm-highlightTab` class to individual tab characters. By default,
the former are shown as faint dots, and the latter as arrows.
*/
function highlightWhitespace() {
    return whitespaceHighlighter;
}
const trailingHighlighter = matcher(new MatchDecorator({
    regexp: /\s+$/g,
    decoration: Decoration.mark({ class: "cm-trailingSpace" }),
    boundary: /\S/,
}));
/**
Returns an extension that adds a `cm-trailingSpace` class to all
trailing whitespace.
*/
function highlightTrailingWhitespace() {
    return trailingHighlighter;
}

/**
@internal
*/
const __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder,
    moveVisually, clearHeightChangeFlag, getHeightChangeFlag: () => heightChangeFlag };

exports.BidiSpan = BidiSpan;
exports.BlockInfo = BlockInfo;
exports.Decoration = Decoration;
exports.EditorView = EditorView;
exports.GutterMarker = GutterMarker;
exports.MatchDecorator = MatchDecorator;
exports.RectangleMarker = RectangleMarker;
exports.ViewPlugin = ViewPlugin;
exports.ViewUpdate = ViewUpdate;
exports.WidgetType = WidgetType;
exports.__test = __test;
exports.closeHoverTooltips = closeHoverTooltips;
exports.crosshairCursor = crosshairCursor;
exports.drawSelection = drawSelection;
exports.dropCursor = dropCursor;
exports.getDrawSelectionConfig = getDrawSelectionConfig;
exports.getPanel = getPanel;
exports.getTooltip = getTooltip;
exports.gutter = gutter;
exports.gutterLineClass = gutterLineClass;
exports.gutterWidgetClass = gutterWidgetClass;
exports.gutters = gutters;
exports.hasHoverTooltips = hasHoverTooltips;
exports.highlightActiveLine = highlightActiveLine;
exports.highlightActiveLineGutter = highlightActiveLineGutter;
exports.highlightSpecialChars = highlightSpecialChars;
exports.highlightTrailingWhitespace = highlightTrailingWhitespace;
exports.highlightWhitespace = highlightWhitespace;
exports.hoverTooltip = hoverTooltip;
exports.keymap = keymap;
exports.layer = layer;
exports.lineNumberMarkers = lineNumberMarkers;
exports.lineNumberWidgetMarker = lineNumberWidgetMarker;
exports.lineNumbers = lineNumbers;
exports.logException = logException;
exports.panels = panels;
exports.placeholder = placeholder;
exports.rectangularSelection = rectangularSelection;
exports.repositionTooltips = repositionTooltips;
exports.runScopeHandlers = runScopeHandlers;
exports.scrollPastEnd = scrollPastEnd;
exports.showPanel = showPanel;
exports.showTooltip = showTooltip;
exports.tooltips = tooltips;


/***/ }),

/***/ "./node_modules/@lezer/common/dist/index.cjs":
/*!***************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.cjs ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
The default maximum length of a `TreeBuffer` node.
*/
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
/**
Each [node type](#common.NodeType) or [individual tree](#common.Tree)
can have metadata associated with it in props. Instances of this
class represent prop names.
*/
class NodeProp {
    /**
    Create a new node prop type.
    */
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /**
    This is meant to be used with
    [`NodeSet.extend`](#common.NodeSet.extend) or
    [`LRParser.configure`](#lr.ParserConfig.props) to compute
    prop values for each node type in the set. Takes a [match
    object](#common.NodeType^match) or function that returns undefined
    if the node type doesn't get this prop, and the prop's value if
    it does.
    */
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/**
Prop that is used to describe matching delimiters. For opening
delimiters, this holds an array of node names (written as a
space-separated string when declaring this prop in a grammar)
for the node types of closing delimiters that match it.
*/
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/**
The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
attached to closing delimiters, holding an array of node names
of types of matching opening delimiters.
*/
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/**
Used to assign node types to groups (for example, all node
types that represent an expression could be tagged with an
`"Expression"` group).
*/
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
/**
Attached to nodes to indicate these should be
[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)
in a bidirectional text isolate, so that direction-neutral
characters on their sides don't incorrectly get associated with
surrounding text. You'll generally want to set this for nodes
that contain arbitrary text, like strings and comments, and for
nodes that appear _inside_ arbitrary text, like HTML tags. When
not given a value, in a grammar declaration, defaults to
`"auto"`.
*/
NodeProp.isolate = new NodeProp({ deserialize: value => {
        if (value && value != "rtl" && value != "ltr" && value != "auto")
            throw new RangeError("Invalid value for isolate: " + value);
        return value || "auto";
    } });
/**
The hash of the [context](#lr.ContextTracker.constructor)
that the node was parsed in, if any. Used to limit reuse of
contextual nodes.
*/
NodeProp.contextHash = new NodeProp({ perNode: true });
/**
The distance beyond the end of the node that the tokenizer
looked ahead for any of the tokens inside the node. (The LR
parser only stores this when it is larger than 25, for
efficiency reasons.)
*/
NodeProp.lookAhead = new NodeProp({ perNode: true });
/**
This per-node prop is used to replace a given node, or part of a
node, with another tree. This is useful to include trees from
different languages in mixed-language parsers.
*/
NodeProp.mounted = new NodeProp({ perNode: true });
/**
A mounted tree, which can be [stored](#common.NodeProp^mounted) on
a tree node to indicate that parts of its content are
represented by another tree.
*/
class MountedTree {
    constructor(
    /**
    The inner tree.
    */
    tree, 
    /**
    If this is null, this tree replaces the entire node (it will
    be included in the regular iteration instead of its host
    node). If not, only the given ranges are considered to be
    covered by this tree. This is used for trees that are mixed in
    a way that isn't strictly hierarchical. Such mounted trees are
    only entered by [`resolveInner`](#common.Tree.resolveInner)
    and [`enter`](#common.SyntaxNode.enter).
    */
    overlay, 
    /**
    The parser used to create this subtree.
    */
    parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
    /**
    @internal
    */
    static get(tree) {
        return tree && tree.props && tree.props[NodeProp.mounted.id];
    }
}
const noProps = Object.create(null);
/**
Each node in a syntax tree has a node type associated with it.
*/
class NodeType {
    /**
    @internal
    */
    constructor(
    /**
    The name of the node type. Not necessarily unique, but if the
    grammar was written properly, different node types with the
    same name within a node set should play the same semantic
    role.
    */
    name, 
    /**
    @internal
    */
    props, 
    /**
    The id of this node in its set. Corresponds to the term ids
    used in the parser.
    */
    id, 
    /**
    @internal
    */
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    /**
    Define a node type.
    */
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |
            (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    /**
    Retrieves a node prop for this type. Will return `undefined` if
    the prop isn't present on this node.
    */
    prop(prop) { return this.props[prop.id]; }
    /**
    True when this is the top node of a grammar.
    */
    get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }
    /**
    True when this node is produced by a skip rule.
    */
    get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }
    /**
    Indicates whether this is an error node.
    */
    get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }
    /**
    When true, this node type doesn't correspond to a user-declared
    named node, for example because it is used to cache repetition.
    */
    get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }
    /**
    Returns true when this node's name or one of its
    [groups](#common.NodeProp^group) matches the given string.
    */
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /**
    Create a function from node types to arbitrary values by
    specifying an object whose property names are node or
    [group](#common.NodeProp^group) names. Often useful with
    [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    names, separated by spaces, in a single property name to map
    multiple node names to a single value.
    */
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/**
An empty dummy node type to use when no actual type is available.
*/
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);
/**
A node set holds a collection of node types. It is used to
compactly represent trees by storing their type ids, rather than a
full pointer to the type object, in a numeric array. Each parser
[has](#lr.LRParser.nodeSet) a node set, and [tree
buffers](#common.TreeBuffer) can only store collections of nodes
from the same set. A set can have a maximum of 2**16 (65536) node
types in it, so that the ids fit into 16-bit typed array slots.
*/
class NodeSet {
    /**
    Create a set with the given types. The `id` property of each
    type should correspond to its position within the array.
    */
    constructor(
    /**
    The node types in this set, by id.
    */
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /**
    Create a copy of this set with some node properties added. The
    arguments to this method can be created with
    [`NodeProp.add`](#common.NodeProp.add).
    */
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
/**
Options that control iteration. Can be combined with the `|`
operator to enable multiple ones.
*/
exports.IterMode = void 0;
(function (IterMode) {
    /**
    When enabled, iteration will only visit [`Tree`](#common.Tree)
    objects, not nodes packed into
    [`TreeBuffer`](#common.TreeBuffer)s.
    */
    IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    /**
    Enable this to make iteration include anonymous nodes (such as
    the nodes that wrap repeated grammar constructs into a balanced
    tree).
    */
    IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    /**
    By default, regular [mounted](#common.NodeProp^mounted) nodes
    replace their base node in iteration. Enable this to ignore them
    instead.
    */
    IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
    /**
    This option only applies in
    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the
    library to not enter mounted overlays if one covers the given
    position.
    */
    IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(exports.IterMode || (exports.IterMode = {}));
/**
A piece of syntax tree. There are two ways to approach these
trees: the way they are actually stored in memory, and the
convenient way.

Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
objects. By packing detail information into `TreeBuffer` leaf
nodes, the representation is made a lot more memory-efficient.

However, when you want to actually work with tree nodes, this
representation is very awkward, so most client code will want to
use the [`TreeCursor`](#common.TreeCursor) or
[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
a view on some part of this data structure, and can be used to
move around to adjacent nodes.
*/
class Tree {
    /**
    Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    */
    constructor(
    /**
    The type of the top node.
    */
    type, 
    /**
    This node's child nodes.
    */
    children, 
    /**
    The positions (offsets relative to the start of this tree) of
    the children.
    */
    positions, 
    /**
    The total length of this tree
    */
    length, 
    /**
    Per-node [node props](#common.NodeProp) to associate with this node.
    */
    props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        /**
        @internal
        */
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    /**
    @internal
    */
    toString() {
        let mounted = MountedTree.get(this);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /**
    Get a [tree cursor](#common.TreeCursor) positioned at the top of
    the tree. Mode can be used to [control](#common.IterMode) which
    nodes the cursor visits.
    */
    cursor(mode = 0) {
        return new TreeCursor(this.topNode, mode);
    }
    /**
    Get a [tree cursor](#common.TreeCursor) pointing into this tree
    at the given position and side (see
    [`moveTo`](#common.TreeCursor.moveTo).
    */
    cursorAt(pos, side = 0, mode = 0) {
        let scope = CachedNode.get(this) || this.topNode;
        let cursor = new TreeCursor(scope);
        cursor.moveTo(pos, side);
        CachedNode.set(this, cursor._tree);
        return cursor;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) object for the top of the
    tree.
    */
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /**
    Get the [syntax node](#common.SyntaxNode) at the given position.
    If `side` is -1, this will move into nodes that end at the
    position. If 1, it'll move into nodes that start at the
    position. With 0, it'll only enter nodes that cover the position
    from both sides.
    
    Note that this will not enter
    [overlays](#common.MountedTree.overlay), and you often want
    [`resolveInner`](#common.Tree.resolveInner) instead.
    */
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    /**
    Like [`resolve`](#common.Tree.resolve), but will enter
    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    pointing into the innermost overlaid tree at the given position
    (with parent links going through all parent structure, including
    the host trees).
    */
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    /**
    In some situations, it can be useful to iterate through all
    nodes around a position, including those in overlays that don't
    directly cover the position. This method gives you an iterator
    that will produce all nodes, from small to big, around the given
    position.
    */
    resolveStack(pos, side = 0) {
        return stackIterator(this, pos, side);
    }
    /**
    Iterate over the tree and its children, calling `enter` for any
    node that touches the `from`/`to` region (if given) before
    running over such a node's children, and `leave` (if given) when
    leaving the node. When `enter` returns `false`, that node will
    not have its children iterated over (or `leave` called).
    */
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        let mode = spec.mode || 0, anon = (mode & exports.IterMode.IncludeAnonymous) > 0;
        for (let c = this.cursor(mode | exports.IterMode.IncludeAnonymous);;) {
            let entered = false;
            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
                if (c.firstChild())
                    continue;
                entered = true;
            }
            for (;;) {
                if (entered && leave && (anon || !c.type.isAnonymous))
                    leave(c);
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                entered = true;
            }
        }
    }
    /**
    Get the value of the given [node prop](#common.NodeProp) for this
    node. Works with both per-node and per-type props.
    */
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    /**
    Returns the node's [per-node props](#common.NodeProp.perNode) in a
    format that can be passed to the [`Tree`](#common.Tree)
    constructor.
    */
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    /**
    Balance the direct children of this tree, producing a copy of
    which may have children grouped into subtrees with type
    [`NodeType.none`](#common.NodeType^none).
    */
    balance(config = {}) {
        return this.children.length <= 8 /* Balance.BranchFactor */ ? this :
            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    /**
    Build a tree from a postfix-ordered buffer of node information,
    or a cursor over such a buffer.
    */
    static build(data) { return buildTree(data); }
}
/**
The empty tree
*/
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
/**
Tree buffers contain (type, start, end, endIndex) quads for each
node. In such a buffer, nodes are stored in prefix order (parents
before children, with the endIndex of the parent indicating which
children belong to it).
*/
class TreeBuffer {
    /**
    Create a tree buffer.
    */
    constructor(
    /**
    The buffer's content.
    */
    buffer, 
    /**
    The total length of the group of nodes in the buffer.
    */
    length, 
    /**
    The node set used in this buffer.
    */
    set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    /**
    @internal
    */
    get type() { return NodeType.none; }
    /**
    @internal
    */
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /**
    @internal
    */
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /**
    @internal
    */
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    /**
    @internal
    */
    slice(startI, endI, from) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI), len = 0;
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            let to = copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
            len = Math.max(len, to);
        }
        return new TreeBuffer(copy, len, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2 /* Side.Before */: return from < pos;
        case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;
        case 0 /* Side.Around */: return from < pos && to > pos;
        case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;
        case 2 /* Side.After */: return to > pos;
        case 4 /* Side.DontCare */: return true;
    }
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    let mode = overlays ? 0 : exports.IterMode.IgnoreOverlays;
    // Must go up out of overlays when those do not overlap with pos
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, mode);
        if (!inner)
            return node;
        node = inner;
    }
}
class BaseNode {
    cursor(mode = 0) { return new TreeCursor(this, mode); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    matchContext(context) {
        return matchNodeContext(this.parent, context);
    }
    enterUnfinishedNodesBefore(pos) {
        let scan = this.childBefore(pos), node = this;
        while (scan) {
            let last = scan.lastChild;
            if (!last || last.to != scan.to)
                break;
            if (last.type.isError && last.from == last.to) {
                node = scan;
                scan = last.prevSibling;
            }
            else {
                scan = last;
            }
        }
        return node;
    }
    get node() { return this; }
    get next() { return this.parent; }
}
class TreeNode extends BaseNode {
    constructor(_tree, from, 
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
        super();
        this._tree = _tree;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this._tree.type; }
    get name() { return this._tree.type.name; }
    get to() { return this.from + this._tree.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & exports.IterMode.ExcludeBuffers)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & exports.IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & exports.IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & exports.IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & exports.IterMode.IncludeAnonymous) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent._tree.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }
    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }
    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }
    enter(pos, side, mode = 0) {
        let mounted;
        if (!(mode & exports.IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;
    }
    get tree() { return this._tree; }
    toTree() { return this._tree; }
    /**
    @internal
    */
    toString() { return this._tree.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor(), result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        for (let found = false; !found;) {
            found = cur.type.is(before);
            if (!cur.nextSibling())
                return result;
        }
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
function matchNodeContext(node, context, i = context.length - 1) {
    for (let p = node; i >= 0; p = p.parent) {
        if (!p)
            return false;
        if (!p.type.isAnonymous) {
            if (context[i] && context[i] != p.name)
                return false;
            i--;
        }
    }
    return true;
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode extends BaseNode {
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    constructor(context, _parent, index) {
        super();
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }
    get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }
    childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }
    childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }
    enter(pos, side, mode = 0) {
        if (mode & exports.IterMode.ExcludeBuffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));
    }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1];
            children.push(buffer.slice(startI, endI, from));
            positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
    }
    /**
    @internal
    */
    toString() { return this.context.buffer.childString(this.index); }
}
function iterStack(heads) {
    if (!heads.length)
        return null;
    let pick = 0, picked = heads[0];
    for (let i = 1; i < heads.length; i++) {
        let node = heads[i];
        if (node.from > picked.from || node.to < picked.to) {
            picked = node;
            pick = i;
        }
    }
    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
    let newHeads = heads.slice();
    if (next)
        newHeads[pick] = next;
    else
        newHeads.splice(pick, 1);
    return new StackIterator(newHeads, picked);
}
class StackIterator {
    constructor(heads, node) {
        this.heads = heads;
        this.node = node;
    }
    get next() { return iterStack(this.heads); }
}
function stackIterator(tree, pos, side) {
    let inner = tree.resolveInner(pos, side), layers = null;
    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
        if (scan.index < 0) { // This is an overlay root
            let parent = scan.parent;
            (layers || (layers = [inner])).push(parent.resolve(pos, side));
            scan = parent;
        }
        else {
            let mount = MountedTree.get(scan.tree);
            // Relevant overlay branching off
            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
                (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
            }
        }
    }
    return layers ? iterStack(layers) : inner;
}
/**
A tree cursor object focuses on a given node in a syntax tree, and
allows you to move to adjacent nodes.
*/
class TreeCursor {
    /**
    Shorthand for `.type.name`.
    */
    get name() { return this.type.name; }
    /**
    @internal
    */
    constructor(node, 
    /**
    @internal
    */
    mode = 0) {
        this.mode = mode;
        /**
        @internal
        */
        this.buffer = null;
        this.stack = [];
        /**
        @internal
        */
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    /**
    @internal
    */
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /**
    @internal
    */
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /**
    @internal
    */
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /**
    Move the cursor to this node's first child. When this returns
    false, the node has no child, and the cursor has not been moved.
    */
    firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }
    /**
    Move the cursor to this node's last child.
    */
    lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }
    /**
    Move the cursor to the first child that ends after `pos`.
    */
    childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }
    /**
    Move to the last child that starts before `pos`.
    */
    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }
    /**
    Move the cursor to the child around `pos`. If side is -1 the
    child may end at that position, when 1 it may start there. This
    will also enter [overlaid](#common.MountedTree.overlay)
    [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    set to false.
    */
    enter(pos, side, mode = this.mode) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, mode));
        return mode & exports.IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    /**
    Move to the node's parent node, if this isn't the top node.
    */
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & exports.IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & exports.IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /**
    @internal
    */
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;
    }
    /**
    Move to this node's next sibling, if any.
    */
    nextSibling() { return this.sibling(1); }
    /**
    Move to this node's previous sibling, if any.
    */
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
                    let child = parent._tree.children[i];
                    if ((this.mode & exports.IterMode.IncludeAnonymous) ||
                        child instanceof TreeBuffer ||
                        !child.type.isAnonymous ||
                        hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /**
    Move to the next node in a
    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
    traversal, going from a node to its first child or, if the
    current node is empty or `enter` is false, its next sibling or
    the next sibling of the first parent node that has one.
    */
    next(enter = true) { return this.move(1, enter); }
    /**
    Move to the next node in a last-to-first pre-order traversal. A
    node is followed by its last child or, if it has none, its
    previous sibling or the previous sibling of the first parent
    node that has one.
    */
    prev(enter = true) { return this.move(-1, enter); }
    /**
    Move the cursor to the innermost node that covers `pos`. If
    `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    it will enter nodes that start at `pos`.
    */
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) at the cursor's current
    position.
    */
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /**
    Get the [tree](#common.Tree) that represents the current node, if
    any. Will return null when the node is in a [tree
    buffer](#common.TreeBuffer).
    */
    get tree() {
        return this.buffer ? null : this._tree._tree;
    }
    /**
    Iterate over the current node and all its descendants, calling
    `enter` when entering a node and `leave`, if given, when leaving
    one. When `enter` returns `false`, any children of that node are
    skipped, and `leave` isn't called for it.
    */
    iterate(enter, leave) {
        for (let depth = 0;;) {
            let mustLeave = false;
            if (this.type.isAnonymous || enter(this) !== false) {
                if (this.firstChild()) {
                    depth++;
                    continue;
                }
                if (!this.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(this);
                mustLeave = this.type.isAnonymous;
                if (!depth)
                    return;
                if (this.nextSibling())
                    break;
                this.parent();
                depth--;
                mustLeave = true;
            }
        }
    }
    /**
    Test whether the current node matches a given context—a sequence
    of direct parent node names. Empty strings in the context array
    are treated as wildcards.
    */
    matchContext(context) {
        if (!this.buffer)
            return matchNodeContext(this.node.parent, context);
        let { buffer } = this.buffer, { types } = buffer.set;
        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
            if (d < 0)
                return matchNodeContext(this._tree, context, i);
            let type = types[buffer.buffer[this.stack[d]]];
            if (!type.isAnonymous) {
                if (context[i] && context[i] != type.name)
                    return false;
                i--;
            }
        }
        return true;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
        while (size < 0) {
            cursor.next();
            if (size == -1 /* SpecialRecord.Reuse */) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change
                contextHash = id;
                return;
            }
            else if (size == -4 /* SpecialRecord.LookAhead */) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else if (depth > 2500 /* CutOff.Depth */) {
                    takeFlatNode(start, endPos, localChildren, localPositions);
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type, contextAtStart);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function takeFlatNode(parentStart, minPos, children, positions) {
        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions
        let nodeCount = 0, stopAt = -1;
        while (cursor.pos > minPos) {
            let { id, start, end, size } = cursor;
            if (size > 4) { // Not a leaf
                cursor.next();
            }
            else if (stopAt > -1 && start < stopAt) {
                break;
            }
            else {
                if (stopAt < 0)
                    stopAt = end - maxBufferLength;
                nodes.push(id, start, end);
                nodeCount++;
                cursor.next();
            }
        }
        if (nodeCount) {
            let buffer = new Uint16Array(nodeCount * 4);
            let start = nodes[nodes.length - 2];
            for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
                buffer[j++] = nodes[i];
                buffer[j++] = nodes[i + 1] - start;
                buffer[j++] = nodes[i + 2] - start;
                buffer[j++] = j;
            }
            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));
            positions.push(start - parentStart);
        }
    }
    function makeBalanced(type, contextHash) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead, contextHash);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead, contextHash) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to, contextHash));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead, contextHash, props) {
        if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat && nodeSize >= 0) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3 /* SpecialRecord.ContextChange */)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3 /* SpecialRecord.ContextChange */) {
            contextHash = id;
        }
        else if (size == -4 /* SpecialRecord.LookAhead */) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(
// The type the balanced tree's inner nodes.
balanceType, 
// The direct children and their positions
children, positions, 
// The index range in children/positions to use
from, to, 
// The start position of the nodes, relative to their parent.
start, 
// Length of the outer node
length, 
// Function to build the top node of the balanced tree
mkTop, 
// Function to build internal nodes for the balanced tree
mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom]; // Only trees can have a size > 1
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}
/**
Provides a way to associate values with pieces of trees. As long
as that part of the tree is reused, the associated values can be
retrieved from an updated tree.
*/
class NodeWeakMap {
    constructor() {
        this.map = new WeakMap();
    }
    setBuffer(buffer, index, value) {
        let inner = this.map.get(buffer);
        if (!inner)
            this.map.set(buffer, inner = new Map);
        inner.set(index, value);
    }
    getBuffer(buffer, index) {
        let inner = this.map.get(buffer);
        return inner && inner.get(index);
    }
    /**
    Set the value for this syntax node.
    */
    set(node, value) {
        if (node instanceof BufferNode)
            this.setBuffer(node.context.buffer, node.index, value);
        else if (node instanceof TreeNode)
            this.map.set(node.tree, value);
    }
    /**
    Retrieve value for this syntax node, if it exists in the map.
    */
    get(node) {
        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)
            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;
    }
    /**
    Set the value for the node that a cursor currently points to.
    */
    cursorSet(cursor, value) {
        if (cursor.buffer)
            this.setBuffer(cursor.buffer.buffer, cursor.index, value);
        else
            this.map.set(cursor.tree, value);
    }
    /**
    Retrieve the value for the node that a cursor currently points
    to.
    */
    cursorGet(cursor) {
        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
    }
}

/**
Tree fragments are used during [incremental
parsing](#common.Parser.startParse) to track parts of old trees
that can be reused in a new parse. An array of fragments is used
to track regions of an old tree whose nodes might be reused in new
parses. Use the static
[`applyChanges`](#common.TreeFragment^applyChanges) method to
update fragments for document changes.
*/
class TreeFragment {
    /**
    Construct a tree fragment. You'll usually want to use
    [`addTree`](#common.TreeFragment^addTree) and
    [`applyChanges`](#common.TreeFragment^applyChanges) instead of
    calling this directly.
    */
    constructor(
    /**
    The start of the unchanged range pointed to by this fragment.
    This refers to an offset in the _updated_ document (as opposed
    to the original tree).
    */
    from, 
    /**
    The end of the unchanged range.
    */
    to, 
    /**
    The tree that this fragment is based on.
    */
    tree, 
    /**
    The offset between the fragment's tree and the document that
    this fragment can be used against. Add this when going from
    document to tree positions, subtract it to go from tree to
    document positions.
    */
    offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);
    }
    /**
    Whether the start of the fragment represents the start of a
    parse, or the end of a change. (In the second case, it may not
    be safe to reuse some nodes at the start, depending on the
    parsing algorithm.)
    */
    get openStart() { return (this.open & 1 /* Open.Start */) > 0; }
    /**
    Whether the end of the fragment represents the end of a
    full-document parse, or the start of a change.
    */
    get openEnd() { return (this.open & 2 /* Open.End */) > 0; }
    /**
    Create a set of fragments from a freshly parsed tree, or update
    an existing set of fragments by replacing the ones that overlap
    with a tree with content from the new tree. When `partial` is
    true, the parse is treated as incomplete, and the resulting
    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    true.
    */
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    /**
    Apply a set of edits to an array of fragments, removing or
    splitting fragments as necessary to remove edited ranges, and
    adjusting offsets for fragments that moved.
    */
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
/**
A superclass that parsers should extend.
*/
class Parser {
    /**
    Start a parse, returning a [partial parse](#common.PartialParse)
    object. [`fragments`](#common.TreeFragment) can be passed in to
    make the parse incremental.
    
    By default, the entire input is parsed. You can pass `ranges`,
    which should be a sorted array of non-empty, non-overlapping
    ranges, to parse only those ranges. The tree returned in that
    case will start at `ranges[0].from`.
    */
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    /**
    Run a full parse, returning the resulting tree.
    */
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}

/**
Create a parse wrapper that, after the inner parse completes,
scans its tree for mixed language regions with the `nest`
function, runs the resulting [inner parses](#common.NestedParse),
and then [mounts](#common.NodeProp^mounted) their results onto the
tree.
*/
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, from) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.from = from;
    }
}
function checkRanges(ranges) {
    if (!ranges.length || ranges.some(r => r.from >= r.to))
        throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            // This is a somewhat dodgy but super helpful hack where we
            // patch up nodes created by the inner parse (and thus
            // presumably not aliased anywhere else) to hold the information
            // about the inner parse.
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), exports.IterMode.IncludeAnonymous | exports.IterMode.IgnoreMounts);
        scan: for (let nest, isCovered;;) {
            let enter = true, range;
            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {
                enter = false;
            }
            else if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2 /* Cover.Full */;
            }
            else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) &&
                (cursor.from < cursor.to || !nest.overlay)) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay ||
                        (cursor.from < cursor.to ? [new Range(cursor.from, cursor.to)] : []));
                    if (ranges.length)
                        checkRanges(ranges);
                    if (ranges.length || !nest.overlay)
                        this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges)
                            : nest.parser.startParse(""), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new Range(cursor.from, cursor.to);
                if (range.from < range.to) {
                    let last = overlay.ranges.length - 1;
                    if (last >= 0 && overlay.ranges[last].to == range.from)
                        overlay.ranges[last] = { from: overlay.ranges[last].from, to: range.to };
                    else
                        overlay.ranges.push(range);
                }
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length) {
                            checkRanges(ranges);
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));
                        }
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;
    }
    return 0 /* Cover.None */;
}
// Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1];
        nodes.push(buf.slice(startI, endI, from));
        positions.push(from - off);
    }
}
// This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.
function materialize(cursor) {
    let { node } = cursor, stack = [];
    let buffer = node.context.buffer;
    // Scan up to the nearest tree
    do {
        stack.push(cursor.index);
        cursor.parent();
    } while (!cursor.tree);
    // Find the index of the buffer in that tree
    let base = cursor.tree, i = base.children.indexOf(buffer);
    let buf = base.children[i], b = buf.buffer, newStack = [i];
    // Split a level in the buffer, putting the nodes before and after
    // the child that contains `node` into new buffers.
    function split(startI, endI, type, innerOffset, length, stackPos) {
        let targetI = stack[stackPos];
        let children = [], positions = [];
        sliceBuf(buf, startI, targetI, children, positions, innerOffset);
        let from = b[targetI + 1], to = b[targetI + 2];
        newStack.push(children.length);
        let child = stackPos
            ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1)
            : node.toTree();
        children.push(child);
        positions.push(from - innerOffset);
        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);
        return new Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);
    // Move the cursor back to the target node
    for (let index of newStack) {
        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];
        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));
    }
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.cursor(exports.IterMode.IncludeAnonymous | exports.IterMode.IgnoreMounts);
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, exports.IterMode.IgnoreOverlays | exports.IterMode.ExcludeBuffers)) ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
// Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
        }
    }
    return result;
}

exports.DefaultBufferLength = DefaultBufferLength;
exports.MountedTree = MountedTree;
exports.NodeProp = NodeProp;
exports.NodeSet = NodeSet;
exports.NodeType = NodeType;
exports.NodeWeakMap = NodeWeakMap;
exports.Parser = Parser;
exports.Tree = Tree;
exports.TreeBuffer = TreeBuffer;
exports.TreeCursor = TreeCursor;
exports.TreeFragment = TreeFragment;
exports.parseMixed = parseMixed;


/***/ }),

/***/ "./node_modules/@lezer/css/dist/index.cjs":
/*!************************************************!*\
  !*** ./node_modules/@lezer/css/dist/index.cjs ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var lr = __webpack_require__(/*! @lezer/lr */ "./node_modules/@lezer/lr/dist/index.cjs");
var highlight = __webpack_require__(/*! @lezer/highlight */ "./node_modules/@lezer/highlight/dist/index.cjs");

// This file was generated by lezer-generator. You probably shouldn't edit it.
const descendantOp = 99,
  Unit = 1,
  callee = 100,
  identifier = 101,
  VariableName = 2;

/* Hand-written tokenizers for CSS tokens that can't be
   expressed by Lezer's built-in tokenizer. */

const space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197,
               8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];
const colon = 58, parenL = 40, underscore = 95, bracketL = 91, dash = 45, period = 46,
      hash = 35, percent = 37, ampersand = 38, backslash = 92, newline = 10;

function isAlpha(ch) { return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161 }

function isDigit(ch) { return ch >= 48 && ch <= 57 }

const identifiers = new lr.ExternalTokenizer((input, stack) => {
  for (let inside = false, dashes = 0, i = 0;; i++) {
    let {next} = input;
    if (isAlpha(next) || next == dash || next == underscore || (inside && isDigit(next))) {
      if (!inside && (next != dash || i > 0)) inside = true;
      if (dashes === i && next == dash) dashes++;
      input.advance();
    } else if (next == backslash && input.peek(1) != newline) {
      input.advance();
      if (input.next > -1) input.advance();
      inside = true;
    } else {
      if (inside)
        input.acceptToken(next == parenL ? callee : dashes == 2 && stack.canShift(VariableName) ? VariableName : identifier);
      break
    }
  }
});

const descendant = new lr.ExternalTokenizer(input => {
  if (space.includes(input.peek(-1))) {
    let {next} = input;
    if (isAlpha(next) || next == underscore || next == hash || next == period ||
        next == bracketL || next == colon && isAlpha(input.peek(1)) ||
        next == dash || next == ampersand)
      input.acceptToken(descendantOp);
  }
});

const unitToken = new lr.ExternalTokenizer(input => {
  if (!space.includes(input.peek(-1))) {
    let {next} = input;
    if (next == percent) { input.advance(); input.acceptToken(Unit); }
    if (isAlpha(next)) {
      do { input.advance(); } while (isAlpha(input.next) || isDigit(input.next))
      input.acceptToken(Unit);
    }
  }
});

const cssHighlighting = highlight.styleTags({
  "AtKeyword import charset namespace keyframes media supports": highlight.tags.definitionKeyword,
  "from to selector": highlight.tags.keyword,
  NamespaceName: highlight.tags.namespace,
  KeyframeName: highlight.tags.labelName,
  KeyframeRangeName: highlight.tags.operatorKeyword,
  TagName: highlight.tags.tagName,
  ClassName: highlight.tags.className,
  PseudoClassName: highlight.tags.constant(highlight.tags.className),
  IdName: highlight.tags.labelName,
  "FeatureName PropertyName": highlight.tags.propertyName,
  AttributeName: highlight.tags.attributeName,
  NumberLiteral: highlight.tags.number,
  KeywordQuery: highlight.tags.keyword,
  UnaryQueryOp: highlight.tags.operatorKeyword,
  "CallTag ValueName": highlight.tags.atom,
  VariableName: highlight.tags.variableName,
  Callee: highlight.tags.operatorKeyword,
  Unit: highlight.tags.unit,
  "UniversalSelector NestingSelector": highlight.tags.definitionOperator,
  MatchOp: highlight.tags.compareOperator,
  "ChildOp SiblingOp, LogicOp": highlight.tags.logicOperator,
  BinOp: highlight.tags.arithmeticOperator,
  Important: highlight.tags.modifier,
  Comment: highlight.tags.blockComment,
  ColorLiteral: highlight.tags.color,
  "ParenthesizedContent StringLiteral": highlight.tags.string,
  ":": highlight.tags.punctuation,
  "PseudoOp #": highlight.tags.derefOperator,
  "; ,": highlight.tags.separator,
  "( )": highlight.tags.paren,
  "[ ]": highlight.tags.squareBracket,
  "{ }": highlight.tags.brace
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_callee = {__proto__:null,lang:32, "nth-child":32, "nth-last-child":32, "nth-of-type":32, "nth-last-of-type":32, dir:32, "host-context":32, url:60, "url-prefix":60, domain:60, regexp:60, selector:138};
const spec_AtKeyword = {__proto__:null,"@import":118, "@media":142, "@charset":146, "@namespace":150, "@keyframes":156, "@supports":168};
const spec_identifier = {__proto__:null,not:132, only:132};
const parser = lr.LRParser.deserialize({
  version: 14,
  states: ":jQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO-kQdO,59}O-{Q[O'#E^O.YQWO,5;_O.YQWO,5;_POOO'#EV'#EVP.eO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO/[QXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/iQ`O1G/^O0SQXO1G/aO0jQXO1G/cO1QQXO1G/dO1hQWO,59|O1mQ[O'#DSO1tQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1{QpO,59]OOQS,59_,59_O${QdO,59aO2TQWO1G/mOOQS,59c,59cO2YQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2eQ[O,59jOOQS,59j,59jO2mQWO'#DjO2xQWO,5:VO2}QWO,5:]O&`Q[O,5:XO&`Q[O'#E_O3VQWO,5;`O3bQWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3sQWO1G0OO3xQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO4TQtO1G/iOOQO1G/i1G/iOOQO,5:x,5:xO4kQ[O,5:xOOQO-E8[-E8[O4xQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO5TQXO'#ErO5[QWO,59nO5aQtO'#EXO6XQdO'#EoO6cQWO,59ZO6hQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XOOQS1G/P1G/PO6pQWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6uQWO,5:yOOQO-E8]-E8]O7TQXO1G/xOOQS7+%j7+%jO7[QYO'#CsOOQO'#EQ'#EQO7gQ`O'#EPOOQO'#EP'#EPO7rQWO'#E`O7zQdO,5:jOOQS,5:j,5:jO8VQtO'#E]O${QdO'#E]O9WQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9kQpO<<HdO9sQWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9{QWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO:TQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3{QdO'#EaO7rQWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO:[QtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO;]QdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
  stateData: ";o~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!X#rO!Y!Va#U!Va!S!Va~P${O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#xO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.pOp#zO|#{O~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/qOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/qOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/qO!S#|O~Oa#fP~P(aOa#cP~P${Oa$TOj#XO~O!Y$VO~Oa$WOh$XOo$XO~Op$ZO#X#]O~O]!`Xa!^X!b!^X~O]$[O~Oa$]O!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$bO~O!S$iO#X$dO#e$cO~Oj#XOt$kO!X$mO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$qO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$sOa#cX~P${Oa$uO~Oj#XOp$vO~Oa$wO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$yO~P.pOP#WOtgX!TgX~O#e$cOt!sX!T!sX~Ot${O!TwO~O!S%PO#X$dO#e$cO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$kO!X%SO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%TO~OtoOa#fa~Ot$sOa#ca~Oa%WO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
  goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#tkYOPdhotuvw!n#R#h#tkSOPdhotuvw!n#R#h#tQmTR!tnQ{VR!xqQ!x}Q#Z!XR#y!zq![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%Up![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%UU$f#m$h${R$z$eq!XZ]!T!m#S#U#X#q#{$Q$[$k$l$s$x%Up![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%UQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#y!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ$}$gR%Z$|SgPwQ!phQ#s!nR$n#tZfPhw!n#ta!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$g#m$hR%X${V$e#m$h${Q!rjR#w!rQdOShPwU!ldh#tR#t!nQ$Q#SU$r$Q$x%UQ$x$[R%U$sQ#_!ZR$Y#_Q$t$QR%V$tQpUS!vp$pR$p#}Q$l#qR%R$lQ!ogS#u!o#vR#v!pQ#f!_R$`#fQ$h#mR%O$hQ$|$gR%Y$|_cOPdhw!n#t^UOPdhw!n#tQ!uoQ!}tQ#OuQ#PvQ#}#RR$a#hR$R#SQ!VZQ!d]Q#V!TQ#q!m[$P#S$Q$[$s$x%UQ$S#UQ$U#XS$j#q$lQ$o#{R%Q$kR$O#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$^#dR$_#e",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2,3,24,""],
    ["openedBy", 17,"(",32,"[",50,"{"],
    ["closedBy", 18,")",33,"]",51,"}"]
  ],
  propSources: [cssHighlighting],
  skippedNodes: [0,3,87],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [descendant, unitToken, identifiers, 1, 2, 3, 4, new lr.LocalTokenGroup("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
  topRules: {"StyleSheet":[0,4],"Styles":[1,86]},
  specialized: [{term: 100, get: (value) => spec_callee[value] || -1},{term: 58, get: (value) => spec_AtKeyword[value] || -1},{term: 101, get: (value) => spec_identifier[value] || -1}],
  tokenPrec: 1219
});

exports.parser = parser;


/***/ }),

/***/ "./node_modules/@lezer/highlight/dist/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var common = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.cjs");

let nextTagID = 0;
/**
Highlighting tags are markers that denote a highlighting category.
They are [associated](#highlight.styleTags) with parts of a syntax
tree by a language mode, and then mapped to an actual CSS style by
a [highlighter](#highlight.Highlighter).

Because syntax tree node types and highlight styles have to be
able to talk the same language, CodeMirror uses a mostly _closed_
[vocabulary](#highlight.tags) of syntax tags (as opposed to
traditional open string-based systems, which make it hard for
highlighting themes to cover all the tokens produced by the
various languages).

It _is_ possible to [define](#highlight.Tag^define) your own
highlighting tags for system-internal use (where you control both
the language package and the highlighter), but such tags will not
be picked up by regular highlighters (though you can derive them
from standard tags to allow highlighters to fall back to those).
*/
class Tag {
    /**
    @internal
    */
    constructor(
    /**
    The optional name of the base tag @internal
    */
    name, 
    /**
    The set of this tag and all its parent tags, starting with
    this one itself and sorted in order of decreasing specificity.
    */
    set, 
    /**
    The base unmodified tag that this one is based on, if it's
    modified @internal
    */
    base, 
    /**
    The modifiers applied to this.base @internal
    */
    modified) {
        this.name = name;
        this.set = set;
        this.base = base;
        this.modified = modified;
        /**
        @internal
        */
        this.id = nextTagID++;
    }
    toString() {
        let { name } = this;
        for (let mod of this.modified)
            if (mod.name)
                name = `${mod.name}(${name})`;
        return name;
    }
    static define(nameOrParent, parent) {
        let name = typeof nameOrParent == "string" ? nameOrParent : "?";
        if (nameOrParent instanceof Tag)
            parent = nameOrParent;
        if (parent === null || parent === void 0 ? void 0 : parent.base)
            throw new Error("Can not derive from a modified tag");
        let tag = new Tag(name, [], null, []);
        tag.set.push(tag);
        if (parent)
            for (let t of parent.set)
                tag.set.push(t);
        return tag;
    }
    /**
    Define a tag _modifier_, which is a function that, given a tag,
    will return a tag that is a subtag of the original. Applying the
    same modifier to a twice tag will return the same value (`m1(t1)
    == m1(t1)`) and applying multiple modifiers will, regardless or
    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
    
    When multiple modifiers are applied to a given base tag, each
    smaller set of modifiers is registered as a parent, so that for
    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
    `m1(m3(t1)`, and so on.
    */
    static defineModifier(name) {
        let mod = new Modifier(name);
        return (tag) => {
            if (tag.modified.indexOf(mod) > -1)
                return tag;
            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
        };
    }
}
let nextModifierID = 0;
class Modifier {
    constructor(name) {
        this.name = name;
        this.instances = [];
        this.id = nextModifierID++;
    }
    static get(base, mods) {
        if (!mods.length)
            return base;
        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));
        if (exists)
            return exists;
        let set = [], tag = new Tag(base.name, set, base, mods);
        for (let m of mods)
            m.instances.push(tag);
        let configs = powerSet(mods);
        for (let parent of base.set)
            if (!parent.modified.length)
                for (let config of configs)
                    set.push(Modifier.get(parent, config));
        return tag;
    }
}
function sameArray(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
    let sets = [[]];
    for (let i = 0; i < array.length; i++) {
        for (let j = 0, e = sets.length; j < e; j++) {
            sets.push(sets[j].concat(array[i]));
        }
    }
    return sets.sort((a, b) => b.length - a.length);
}
/**
This function is used to add a set of tags to a language syntax
via [`NodeSet.extend`](#common.NodeSet.extend) or
[`LRParser.configure`](#lr.LRParser.configure).

The argument object maps node selectors to [highlighting
tags](#highlight.Tag) or arrays of tags.

Node selectors may hold one or more (space-separated) node paths.
Such a path can be a [node name](#common.NodeType.name), or
multiple node names (or `*` wildcards) separated by slash
characters, as in `"Block/Declaration/VariableName"`. Such a path
matches the final node but only if its direct parent nodes are the
other nodes mentioned. A `*` in such a path matches any parent,
but only a single level—wildcards that match multiple parents
aren't supported, both for efficiency reasons and because Lezer
trees make it rather hard to reason about what they would match.)

A path can be ended with `/...` to indicate that the tag assigned
to the node should also apply to all child nodes, even if they
match their own style (by default, only the innermost style is
used).

When a path ends in `!`, as in `Attribute!`, no further matching
happens for the node's child nodes, and the entire node gets the
given style.

In this notation, node names that contain `/`, `!`, `*`, or `...`
must be quoted as JSON strings.

For example:

```javascript
parser.withProps(
  styleTags({
    // Style Number and BigNumber nodes
    "Number BigNumber": tags.number,
    // Style Escape nodes whose parent is String
    "String/Escape": tags.escape,
    // Style anything inside Attributes nodes
    "Attributes!": tags.meta,
    // Add a style to all content inside Italic nodes
    "Italic/...": tags.emphasis,
    // Style InvalidString nodes as both `string` and `invalid`
    "InvalidString": [tags.string, tags.invalid],
    // Style the node named "/" as punctuation
    '"/"': tags.punctuation
  })
)
```
*/
function styleTags(spec) {
    let byName = Object.create(null);
    for (let prop in spec) {
        let tags = spec[prop];
        if (!Array.isArray(tags))
            tags = [tags];
        for (let part of prop.split(" "))
            if (part) {
                let pieces = [], mode = 2 /* Mode.Normal */, rest = part;
                for (let pos = 0;;) {
                    if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                        mode = 1 /* Mode.Inherit */;
                        break;
                    }
                    let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                    if (!m)
                        throw new RangeError("Invalid path: " + part);
                    pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                    pos += m[0].length;
                    if (pos == part.length)
                        break;
                    let next = part[pos++];
                    if (pos == part.length && next == "!") {
                        mode = 0 /* Mode.Opaque */;
                        break;
                    }
                    if (next != "/")
                        throw new RangeError("Invalid path: " + part);
                    rest = part.slice(pos);
                }
                let last = pieces.length - 1, inner = pieces[last];
                if (!inner)
                    throw new RangeError("Invalid path: " + part);
                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);
                byName[inner] = rule.sort(byName[inner]);
            }
    }
    return ruleNodeProp.add(byName);
}
const ruleNodeProp = new common.NodeProp();
class Rule {
    constructor(tags, mode, context, next) {
        this.tags = tags;
        this.mode = mode;
        this.context = context;
        this.next = next;
    }
    get opaque() { return this.mode == 0 /* Mode.Opaque */; }
    get inherit() { return this.mode == 1 /* Mode.Inherit */; }
    sort(other) {
        if (!other || other.depth < this.depth) {
            this.next = other;
            return this;
        }
        other.next = this.sort(other.next);
        return other;
    }
    get depth() { return this.context ? this.context.length : 0; }
}
Rule.empty = new Rule([], 2 /* Mode.Normal */, null);
/**
Define a [highlighter](#highlight.Highlighter) from an array of
tag/class pairs. Classes associated with more specific tags will
take precedence.
*/
function tagHighlighter(tags, options) {
    let map = Object.create(null);
    for (let style of tags) {
        if (!Array.isArray(style.tag))
            map[style.tag.id] = style.class;
        else
            for (let tag of style.tag)
                map[tag.id] = style.class;
    }
    let { scope, all = null } = options || {};
    return {
        style: (tags) => {
            let cls = all;
            for (let tag of tags) {
                for (let sub of tag.set) {
                    let tagClass = map[sub.id];
                    if (tagClass) {
                        cls = cls ? cls + " " + tagClass : tagClass;
                        break;
                    }
                }
            }
            return cls;
        },
        scope
    };
}
function highlightTags(highlighters, tags) {
    let result = null;
    for (let highlighter of highlighters) {
        let value = highlighter.style(tags);
        if (value)
            result = result ? result + " " + value : value;
    }
    return result;
}
/**
Highlight the given [tree](#common.Tree) with the given
[highlighter](#highlight.Highlighter). Often, the higher-level
[`highlightCode`](#highlight.highlightCode) function is easier to
use.
*/
function highlightTree(tree, highlighter, 
/**
Assign styling to a region of the text. Will be called, in order
of position, for any ranges where more than zero classes apply.
`classes` is a space separated string of CSS classes.
*/
putStyle, 
/**
The start of the range to highlight.
*/
from = 0, 
/**
The end of the range.
*/
to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
}
/**
Highlight the given tree with the given highlighter, calling
`putText` for every piece of text, either with a set of classes or
with the empty string when unstyled, and `putBreak` for every line
break.
*/
function highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {
    let pos = from;
    function writeTo(p, classes) {
        if (p <= pos)
            return;
        for (let text = code.slice(pos, p), i = 0;;) {
            let nextBreak = text.indexOf("\n", i);
            let upto = nextBreak < 0 ? text.length : nextBreak;
            if (upto > i)
                putText(text.slice(i, upto), classes);
            if (nextBreak < 0)
                break;
            putBreak();
            i = nextBreak + 1;
        }
        pos = p;
    }
    highlightTree(tree, highlighter, (from, to, classes) => {
        writeTo(from, "");
        writeTo(to, classes);
    }, from, to);
    writeTo(to, "");
}
class HighlightBuilder {
    constructor(at, highlighters, span) {
        this.at = at;
        this.highlighters = highlighters;
        this.span = span;
        this.class = "";
    }
    startSpan(at, cls) {
        if (cls != this.class) {
            this.flush(at);
            if (at > this.at)
                this.at = at;
            this.class = cls;
        }
    }
    flush(to) {
        if (to > this.at && this.class)
            this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, highlighters) {
        let { type, from: start, to: end } = cursor;
        if (start >= to || end <= from)
            return;
        if (type.isTop)
            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));
        let cls = inheritedClass;
        let rule = getStyleTags(cursor) || Rule.empty;
        let tagCls = highlightTags(highlighters, rule.tags);
        if (tagCls) {
            if (cls)
                cls += " ";
            cls += tagCls;
            if (rule.mode == 1 /* Mode.Inherit */)
                inheritedClass += (inheritedClass ? " " : "") + tagCls;
        }
        this.startSpan(Math.max(from, start), cls);
        if (rule.opaque)
            return;
        let mounted = cursor.tree && cursor.tree.prop(common.NodeProp.mounted);
        if (mounted && mounted.overlay) {
            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));
            let hasChild = cursor.firstChild();
            for (let i = 0, pos = start;; i++) {
                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
                let nextPos = next ? next.from + start : end;
                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
                if (rangeFrom < rangeTo && hasChild) {
                    while (cursor.from < rangeTo) {
                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
                        this.startSpan(Math.min(rangeTo, cursor.to), cls);
                        if (cursor.to >= nextPos || !cursor.nextSibling())
                            break;
                    }
                }
                if (!next || nextPos > to)
                    break;
                pos = next.to + start;
                if (pos > from) {
                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
                    this.startSpan(Math.min(to, pos), cls);
                }
            }
            if (hasChild)
                cursor.parent();
        }
        else if (cursor.firstChild()) {
            if (mounted)
                inheritedClass = "";
            do {
                if (cursor.to <= from)
                    continue;
                if (cursor.from >= to)
                    break;
                this.highlightRange(cursor, from, to, inheritedClass, highlighters);
                this.startSpan(Math.min(to, cursor.to), cls);
            } while (cursor.nextSibling());
            cursor.parent();
        }
    }
}
/**
Match a syntax node's [highlight rules](#highlight.styleTags). If
there's a match, return its set of tags, and whether it is
opaque (uses a `!`) or applies to all child nodes (`/...`).
*/
function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
        rule = rule.next;
    return rule || null;
}
const t = Tag.define;
const comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
/**
The default set of highlighting [tags](#highlight.Tag).

This collection is heavily biased towards programming languages,
and necessarily incomplete. A full ontology of syntactic
constructs would fill a stack of books, and be impractical to
write themes for. So try to make do with this set. If all else
fails, [open an
issue](https://github.com/codemirror/codemirror.next) to propose a
new tag, or [define](#highlight.Tag^define) a local custom tag for
your use case.

Note that it is not obligatory to always attach the most specific
tag possible to an element—if your grammar can't easily
distinguish a certain type of element (such as a local variable),
it is okay to style it as its more general variant (a variable).

For tags that extend some parent tag, the documentation links to
the parent.
*/
const tags = {
    /**
    A comment.
    */
    comment,
    /**
    A line [comment](#highlight.tags.comment).
    */
    lineComment: t(comment),
    /**
    A block [comment](#highlight.tags.comment).
    */
    blockComment: t(comment),
    /**
    A documentation [comment](#highlight.tags.comment).
    */
    docComment: t(comment),
    /**
    Any kind of identifier.
    */
    name,
    /**
    The [name](#highlight.tags.name) of a variable.
    */
    variableName: t(name),
    /**
    A type [name](#highlight.tags.name).
    */
    typeName: typeName,
    /**
    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
    */
    tagName: t(typeName),
    /**
    A property or field [name](#highlight.tags.name).
    */
    propertyName: propertyName,
    /**
    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
    */
    attributeName: t(propertyName),
    /**
    The [name](#highlight.tags.name) of a class.
    */
    className: t(name),
    /**
    A label [name](#highlight.tags.name).
    */
    labelName: t(name),
    /**
    A namespace [name](#highlight.tags.name).
    */
    namespace: t(name),
    /**
    The [name](#highlight.tags.name) of a macro.
    */
    macroName: t(name),
    /**
    A literal value.
    */
    literal,
    /**
    A string [literal](#highlight.tags.literal).
    */
    string,
    /**
    A documentation [string](#highlight.tags.string).
    */
    docString: t(string),
    /**
    A character literal (subtag of [string](#highlight.tags.string)).
    */
    character: t(string),
    /**
    An attribute value (subtag of [string](#highlight.tags.string)).
    */
    attributeValue: t(string),
    /**
    A number [literal](#highlight.tags.literal).
    */
    number,
    /**
    An integer [number](#highlight.tags.number) literal.
    */
    integer: t(number),
    /**
    A floating-point [number](#highlight.tags.number) literal.
    */
    float: t(number),
    /**
    A boolean [literal](#highlight.tags.literal).
    */
    bool: t(literal),
    /**
    Regular expression [literal](#highlight.tags.literal).
    */
    regexp: t(literal),
    /**
    An escape [literal](#highlight.tags.literal), for example a
    backslash escape in a string.
    */
    escape: t(literal),
    /**
    A color [literal](#highlight.tags.literal).
    */
    color: t(literal),
    /**
    A URL [literal](#highlight.tags.literal).
    */
    url: t(literal),
    /**
    A language keyword.
    */
    keyword,
    /**
    The [keyword](#highlight.tags.keyword) for the self or this
    object.
    */
    self: t(keyword),
    /**
    The [keyword](#highlight.tags.keyword) for null.
    */
    null: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) denoting some atomic value.
    */
    atom: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that represents a unit.
    */
    unit: t(keyword),
    /**
    A modifier [keyword](#highlight.tags.keyword).
    */
    modifier: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that acts as an operator.
    */
    operatorKeyword: t(keyword),
    /**
    A control-flow related [keyword](#highlight.tags.keyword).
    */
    controlKeyword: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that defines something.
    */
    definitionKeyword: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) related to defining or
    interfacing with modules.
    */
    moduleKeyword: t(keyword),
    /**
    An operator.
    */
    operator,
    /**
    An [operator](#highlight.tags.operator) that dereferences something.
    */
    derefOperator: t(operator),
    /**
    Arithmetic-related [operator](#highlight.tags.operator).
    */
    arithmeticOperator: t(operator),
    /**
    Logical [operator](#highlight.tags.operator).
    */
    logicOperator: t(operator),
    /**
    Bit [operator](#highlight.tags.operator).
    */
    bitwiseOperator: t(operator),
    /**
    Comparison [operator](#highlight.tags.operator).
    */
    compareOperator: t(operator),
    /**
    [Operator](#highlight.tags.operator) that updates its operand.
    */
    updateOperator: t(operator),
    /**
    [Operator](#highlight.tags.operator) that defines something.
    */
    definitionOperator: t(operator),
    /**
    Type-related [operator](#highlight.tags.operator).
    */
    typeOperator: t(operator),
    /**
    Control-flow [operator](#highlight.tags.operator).
    */
    controlOperator: t(operator),
    /**
    Program or markup punctuation.
    */
    punctuation,
    /**
    [Punctuation](#highlight.tags.punctuation) that separates
    things.
    */
    separator: t(punctuation),
    /**
    Bracket-style [punctuation](#highlight.tags.punctuation).
    */
    bracket,
    /**
    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
    tokens).
    */
    angleBracket: t(bracket),
    /**
    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
    tokens).
    */
    squareBracket: t(bracket),
    /**
    Parentheses (usually `(` and `)` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    paren: t(bracket),
    /**
    Braces (usually `{` and `}` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    brace: t(bracket),
    /**
    Content, for example plain text in XML or markup documents.
    */
    content,
    /**
    [Content](#highlight.tags.content) that represents a heading.
    */
    heading,
    /**
    A level 1 [heading](#highlight.tags.heading).
    */
    heading1: t(heading),
    /**
    A level 2 [heading](#highlight.tags.heading).
    */
    heading2: t(heading),
    /**
    A level 3 [heading](#highlight.tags.heading).
    */
    heading3: t(heading),
    /**
    A level 4 [heading](#highlight.tags.heading).
    */
    heading4: t(heading),
    /**
    A level 5 [heading](#highlight.tags.heading).
    */
    heading5: t(heading),
    /**
    A level 6 [heading](#highlight.tags.heading).
    */
    heading6: t(heading),
    /**
    A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
    */
    contentSeparator: t(content),
    /**
    [Content](#highlight.tags.content) that represents a list.
    */
    list: t(content),
    /**
    [Content](#highlight.tags.content) that represents a quote.
    */
    quote: t(content),
    /**
    [Content](#highlight.tags.content) that is emphasized.
    */
    emphasis: t(content),
    /**
    [Content](#highlight.tags.content) that is styled strong.
    */
    strong: t(content),
    /**
    [Content](#highlight.tags.content) that is part of a link.
    */
    link: t(content),
    /**
    [Content](#highlight.tags.content) that is styled as code or
    monospace.
    */
    monospace: t(content),
    /**
    [Content](#highlight.tags.content) that has a strike-through
    style.
    */
    strikethrough: t(content),
    /**
    Inserted text in a change-tracking format.
    */
    inserted: t(),
    /**
    Deleted text.
    */
    deleted: t(),
    /**
    Changed text.
    */
    changed: t(),
    /**
    An invalid or unsyntactic element.
    */
    invalid: t(),
    /**
    Metadata or meta-instruction.
    */
    meta,
    /**
    [Metadata](#highlight.tags.meta) that applies to the entire
    document.
    */
    documentMeta: t(meta),
    /**
    [Metadata](#highlight.tags.meta) that annotates or adds
    attributes to a given syntactic element.
    */
    annotation: t(meta),
    /**
    Processing instruction or preprocessor directive. Subtag of
    [meta](#highlight.tags.meta).
    */
    processingInstruction: t(meta),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that a
    given element is being defined. Expected to be used with the
    various [name](#highlight.tags.name) tags.
    */
    definition: Tag.defineModifier("definition"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that
    something is constant. Mostly expected to be used with
    [variable names](#highlight.tags.variableName).
    */
    constant: Tag.defineModifier("constant"),
    /**
    [Modifier](#highlight.Tag^defineModifier) used to indicate that
    a [variable](#highlight.tags.variableName) or [property
    name](#highlight.tags.propertyName) is being called or defined
    as a function.
    */
    function: Tag.defineModifier("function"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that can be applied to
    [names](#highlight.tags.name) to indicate that they belong to
    the language's standard environment.
    */
    standard: Tag.defineModifier("standard"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates a given
    [names](#highlight.tags.name) is local to some scope.
    */
    local: Tag.defineModifier("local"),
    /**
    A generic variant [modifier](#highlight.Tag^defineModifier) that
    can be used to tag language-specific alternative variants of
    some common tag. It is recommended for themes to define special
    forms of at least the [string](#highlight.tags.string) and
    [variable name](#highlight.tags.variableName) tags, since those
    come up a lot.
    */
    special: Tag.defineModifier("special")
};
for (let name in tags) {
    let val = tags[name];
    if (val instanceof Tag)
        val.name = name;
}
/**
This is a highlighter that adds stable, predictable classes to
tokens, for styling with external CSS.

The following tags are mapped to their name prefixed with `"tok-"`
(for example `"tok-comment"`):

* [`link`](#highlight.tags.link)
* [`heading`](#highlight.tags.heading)
* [`emphasis`](#highlight.tags.emphasis)
* [`strong`](#highlight.tags.strong)
* [`keyword`](#highlight.tags.keyword)
* [`atom`](#highlight.tags.atom)
* [`bool`](#highlight.tags.bool)
* [`url`](#highlight.tags.url)
* [`labelName`](#highlight.tags.labelName)
* [`inserted`](#highlight.tags.inserted)
* [`deleted`](#highlight.tags.deleted)
* [`literal`](#highlight.tags.literal)
* [`string`](#highlight.tags.string)
* [`number`](#highlight.tags.number)
* [`variableName`](#highlight.tags.variableName)
* [`typeName`](#highlight.tags.typeName)
* [`namespace`](#highlight.tags.namespace)
* [`className`](#highlight.tags.className)
* [`macroName`](#highlight.tags.macroName)
* [`propertyName`](#highlight.tags.propertyName)
* [`operator`](#highlight.tags.operator)
* [`comment`](#highlight.tags.comment)
* [`meta`](#highlight.tags.meta)
* [`punctuation`](#highlight.tags.punctuation)
* [`invalid`](#highlight.tags.invalid)

In addition, these mappings are provided:

* [`regexp`](#highlight.tags.regexp),
  [`escape`](#highlight.tags.escape), and
  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)
  are mapped to `"tok-string2"`
* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName2"`
* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName tok-local"`
* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName tok-definition"`
* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)
  to `"tok-propertyName tok-definition"`
*/
const classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
]);

exports.Tag = Tag;
exports.classHighlighter = classHighlighter;
exports.getStyleTags = getStyleTags;
exports.highlightCode = highlightCode;
exports.highlightTree = highlightTree;
exports.styleTags = styleTags;
exports.tagHighlighter = tagHighlighter;
exports.tags = tags;


/***/ }),

/***/ "./node_modules/@lezer/html/dist/index.cjs":
/*!*************************************************!*\
  !*** ./node_modules/@lezer/html/dist/index.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var lr = __webpack_require__(/*! @lezer/lr */ "./node_modules/@lezer/lr/dist/index.cjs");
var highlight = __webpack_require__(/*! @lezer/highlight */ "./node_modules/@lezer/highlight/dist/index.cjs");
var common = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.cjs");

// This file was generated by lezer-generator. You probably shouldn't edit it.
const scriptText = 54,
  StartCloseScriptTag = 1,
  styleText = 55,
  StartCloseStyleTag = 2,
  textareaText = 56,
  StartCloseTextareaTag = 3,
  EndTag = 4,
  SelfClosingEndTag = 5,
  StartTag = 6,
  StartScriptTag = 7,
  StartStyleTag = 8,
  StartTextareaTag = 9,
  StartSelfClosingTag = 10,
  StartCloseTag = 11,
  NoMatchStartCloseTag = 12,
  MismatchedStartCloseTag = 13,
  missingCloseTag = 57,
  IncompleteCloseTag = 14,
  commentContent$1 = 58,
  Element = 20,
  TagName = 22,
  Attribute = 23,
  AttributeName = 24,
  AttributeValue = 26,
  UnquotedAttributeValue = 27,
  ScriptText = 28,
  StyleText = 31,
  TextareaText = 34,
  OpenTag = 36,
  CloseTag = 37,
  Dialect_noMatch = 0,
  Dialect_selfClosing = 1;

/* Hand-written tokenizers for HTML. */

const selfClosers = {
  area: true, base: true, br: true, col: true, command: true,
  embed: true, frame: true, hr: true, img: true, input: true,
  keygen: true, link: true, meta: true, param: true, source: true,
  track: true, wbr: true, menuitem: true
};

const implicitlyClosed = {
  dd: true, li: true, optgroup: true, option: true, p: true,
  rp: true, rt: true, tbody: true, td: true, tfoot: true,
  th: true, tr: true
};

const closeOnOpen = {
  dd: {dd: true, dt: true},
  dt: {dd: true, dt: true},
  li: {li: true},
  option: {option: true, optgroup: true},
  optgroup: {optgroup: true},
  p: {
    address: true, article: true, aside: true, blockquote: true, dir: true,
    div: true, dl: true, fieldset: true, footer: true, form: true,
    h1: true, h2: true, h3: true, h4: true, h5: true, h6: true,
    header: true, hgroup: true, hr: true, menu: true, nav: true, ol: true,
    p: true, pre: true, section: true, table: true, ul: true
  },
  rp: {rp: true, rt: true},
  rt: {rp: true, rt: true},
  tbody: {tbody: true, tfoot: true},
  td: {td: true, th: true},
  tfoot: {tbody: true},
  th: {td: true, th: true},
  thead: {tbody: true, tfoot: true},
  tr: {tr: true}
};

function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161
}

function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32
}

let cachedName = null, cachedInput = null, cachedPos = 0;
function tagNameAfter(input, offset) {
  let pos = input.pos + offset;
  if (cachedPos == pos && cachedInput == input) return cachedName
  let next = input.peek(offset);
  while (isSpace(next)) next = input.peek(++offset);
  let name = "";
  for (;;) {
    if (!nameChar(next)) break
    name += String.fromCharCode(next);
    next = input.peek(++offset);
  }
  // Undefined to signal there's a <? or <!, null for just missing
  cachedInput = input; cachedPos = pos;
  return cachedName = name ? name.toLowerCase() : next == question || next == bang ? undefined : null
}

const lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33, dash = 45;

function ElementContext(name, parent) {
  this.name = name;
  this.parent = parent;
}

const startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];

const elementContext = new lr.ContextTracker({
  start: null,
  shift(context, term, stack, input) {
    return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  reduce(context, term) {
    return term == Element && context ? context.parent : context
  },
  reuse(context, node, stack, input) {
    let type = node.type.id;
    return type == StartTag || type == OpenTag
      ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  strict: false
});

const tagStart = new lr.ExternalTokenizer((input, stack) => {
  if (input.next != lessThan) {
    // End of file, close any open tags
    if (input.next < 0 && stack.context) input.acceptToken(missingCloseTag);
    return
  }
  input.advance();
  let close = input.next == slash;
  if (close) input.advance();
  let name = tagNameAfter(input, 0);
  if (name === undefined) return
  if (!name) return input.acceptToken(close ? IncompleteCloseTag : StartTag)

  let parent = stack.context ? stack.context.name : null;
  if (close) {
    if (name == parent) return input.acceptToken(StartCloseTag)
    if (parent && implicitlyClosed[parent]) return input.acceptToken(missingCloseTag, -2)
    if (stack.dialectEnabled(Dialect_noMatch)) return input.acceptToken(NoMatchStartCloseTag)
    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return
    input.acceptToken(MismatchedStartCloseTag);
  } else {
    if (name == "script") return input.acceptToken(StartScriptTag)
    if (name == "style") return input.acceptToken(StartStyleTag)
    if (name == "textarea") return input.acceptToken(StartTextareaTag)
    if (selfClosers.hasOwnProperty(name)) return input.acceptToken(StartSelfClosingTag)
    if (parent && closeOnOpen[parent] && closeOnOpen[parent][name]) input.acceptToken(missingCloseTag, -1);
    else input.acceptToken(StartTag);
  }
}, {contextual: true});

const commentContent = new lr.ExternalTokenizer(input => {
  for (let dashes = 0, i = 0;; i++) {
    if (input.next < 0) {
      if (i) input.acceptToken(commentContent$1);
      break
    }
    if (input.next == dash) {
      dashes++;
    } else if (input.next == greaterThan && dashes >= 2) {
      if (i >= 3) input.acceptToken(commentContent$1, -2);
      break
    } else {
      dashes = 0;
    }
    input.advance();
  }
});

function inForeignElement(context) {
  for (; context; context = context.parent)
    if (context.name == "svg" || context.name == "math") return true
  return false
}

const endTag = new lr.ExternalTokenizer((input, stack) => {
  if (input.next == slash && input.peek(1) == greaterThan) {
    let selfClosing = stack.dialectEnabled(Dialect_selfClosing) || inForeignElement(stack.context);
    input.acceptToken(selfClosing ? SelfClosingEndTag : EndTag, 2);
  } else if (input.next == greaterThan) {
    input.acceptToken(EndTag, 1);
  }
});

function contentTokenizer(tag, textToken, endToken) {
  let lastState = 2 + tag.length;
  return new lr.ExternalTokenizer(input => {
    // state means:
    // - 0 nothing matched
    // - 1 '<' matched
    // - 2 '</' + possibly whitespace matched
    // - 3-(1+tag.length) part of the tag matched
    // - lastState whole tag + possibly whitespace matched
    for (let state = 0, matchedLen = 0, i = 0;; i++) {
      if (input.next < 0) {
        if (i) input.acceptToken(textToken);
        break
      }
      if (state == 0 && input.next == lessThan ||
          state == 1 && input.next == slash ||
          state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {
        state++;
        matchedLen++;
      } else if ((state == 2 || state == lastState) && isSpace(input.next)) {
        matchedLen++;
      } else if (state == lastState && input.next == greaterThan) {
        if (i > matchedLen)
          input.acceptToken(textToken, -matchedLen);
        else
          input.acceptToken(endToken, -(matchedLen - 2));
        break
      } else if ((input.next == 10 /* '\n' */ || input.next == 13 /* '\r' */) && i) {
        input.acceptToken(textToken, 1);
        break
      } else {
        state = matchedLen = 0;
      }
      input.advance();
    }
  })
}

const scriptTokens = contentTokenizer("script", scriptText, StartCloseScriptTag);

const styleTokens = contentTokenizer("style", styleText, StartCloseStyleTag);

const textareaTokens = contentTokenizer("textarea", textareaText, StartCloseTextareaTag);

const htmlHighlighting = highlight.styleTags({
  "Text RawText": highlight.tags.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": highlight.tags.angleBracket,
  TagName: highlight.tags.tagName,
  "MismatchedCloseTag/TagName": [highlight.tags.tagName,  highlight.tags.invalid],
  AttributeName: highlight.tags.attributeName,
  "AttributeValue UnquotedAttributeValue": highlight.tags.attributeValue,
  Is: highlight.tags.definitionOperator,
  "EntityReference CharacterReference": highlight.tags.character,
  Comment: highlight.tags.blockComment,
  ProcessingInst: highlight.tags.processingInstruction,
  DoctypeDecl: highlight.tags.documentMeta
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = lr.LRParser.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: elementContext,
  nodeProps: [
    ["closedBy", -10,1,2,3,7,8,9,10,11,12,13,"EndTag",6,"EndTag SelfClosingEndTag",-4,21,30,33,36,"CloseTag"],
    ["openedBy", 4,"StartTag StartCloseTag",5,"StartTag",-4,29,32,35,37,"OpenTag"],
    ["group", -9,14,17,18,19,20,39,40,41,42,"Entity",16,"Entity TextContent",-3,28,31,34,"TextContent Entity"],
    ["isolate", -11,21,29,30,32,33,35,36,37,38,41,42,"ltr",-3,26,27,39,""]
  ],
  propSources: [htmlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [scriptTokens, styleTokens, textareaTokens, endTag, tagStart, commentContent, 0, 1, 2, 3, 4, 5],
  topRules: {"Document":[0,15]},
  dialects: {noMatch: 0, selfClosing: 509},
  tokenPrec: 511
});

function getAttrs(openTag, input) {
  let attrs = Object.create(null);
  for (let att of openTag.getChildren(Attribute)) {
    let name = att.getChild(AttributeName), value = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue);
    if (name) attrs[input.read(name.from, name.to)] =
      !value ? "" : value.type.id == AttributeValue ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);
  }
  return attrs
}

function findTagName(openTag, input) {
  let tagNameNode = openTag.getChild(TagName);
  return tagNameNode ? input.read(tagNameNode.from, tagNameNode.to) : " "
}

function maybeNest(node, input, tags) {
  let attrs;
  for (let tag of tags) {
    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node.node.parent.firstChild, input))))
      return {parser: tag.parser}
  }
  return null
}

// tags?: {
//   tag: string,
//   attrs?: ({[attr: string]: string}) => boolean,
//   parser: Parser
// }[]
// attributes?: {
//   name: string,
//   tagName?: string,
//   parser: Parser
// }[]
 
function configureNesting(tags = [], attributes = []) {
  let script = [], style = [], textarea = [], other = [];
  for (let tag of tags) {
    let array = tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : other;
    array.push(tag);
  }
  let attrs = attributes.length ? Object.create(null) : null;
  for (let attr of attributes) (attrs[attr.name] || (attrs[attr.name] = [])).push(attr);

  return common.parseMixed((node, input) => {
    let id = node.type.id;
    if (id == ScriptText) return maybeNest(node, input, script)
    if (id == StyleText) return maybeNest(node, input, style)
    if (id == TextareaText) return maybeNest(node, input, textarea)

    if (id == Element && other.length) {
      let n = node.node, open = n.firstChild, tagName = open && findTagName(open, input), attrs;
      if (tagName) for (let tag of other) {
        if (tag.tag == tagName && (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(open, input))))) {
          let close = n.lastChild;
          let to = close.type.id == CloseTag ? close.from : n.to;
          if (to > open.to)
            return {parser: tag.parser, overlay: [{from: open.to, to}]}
        }
      }
    }

    if (attrs && id == Attribute) {
      let n = node.node, nameNode;
      if (nameNode = n.firstChild) {
        let matches = attrs[input.read(nameNode.from, nameNode.to)];
        if (matches) for (let attr of matches) {
          if (attr.tagName && attr.tagName != findTagName(n.parent, input)) continue
          let value = n.lastChild;
          if (value.type.id == AttributeValue) {
            let from = value.from + 1;
            let last = value.lastChild, to = value.to - (last && last.isError ? 0 : 1);
            if (to > from) return {parser: attr.parser, overlay: [{from, to}]}
          } else if (value.type.id == UnquotedAttributeValue) {
            return {parser: attr.parser, overlay: [{from: value.from, to: value.to}]}
          }
        }
      }
    }
    return null
  })
}

exports.configureNesting = configureNesting;
exports.parser = parser;


/***/ }),

/***/ "./node_modules/@lezer/javascript/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@lezer/javascript/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var lr = __webpack_require__(/*! @lezer/lr */ "./node_modules/@lezer/lr/dist/index.cjs");
var highlight = __webpack_require__(/*! @lezer/highlight */ "./node_modules/@lezer/highlight/dist/index.cjs");

// This file was generated by lezer-generator. You probably shouldn't edit it.
const noSemi = 314,
  noSemiType = 315,
  incdec = 1,
  incdecPrefix = 2,
  questionDot = 3,
  JSXStartTag = 4,
  insertSemi = 316,
  spaces = 318,
  newline = 319,
  LineComment = 5,
  BlockComment = 6,
  Dialect_jsx = 0;

/* Hand-written tokenizers for JavaScript tokens that can't be
   expressed by lezer's built-in tokenizer. */

const space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200,
               8201, 8202, 8232, 8233, 8239, 8287, 12288];

const braceR = 125, semicolon = 59, slash = 47, star = 42, plus = 43, minus = 45, lt = 60, comma = 44,
      question = 63, dot = 46, bracketL = 91;

const trackNewline = new lr.ContextTracker({
  start: false,
  shift(context, term) {
    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline
  },
  strict: false
});

const insertSemicolon = new lr.ExternalTokenizer((input, stack) => {
  let {next} = input;
  if (next == braceR || next == -1 || stack.context)
    input.acceptToken(insertSemi);
}, {contextual: true, fallback: true});

const noSemicolon = new lr.ExternalTokenizer((input, stack) => {
  let {next} = input, after;
  if (space.indexOf(next) > -1) return
  if (next == slash && ((after = input.peek(1)) == slash || after == star)) return
  if (next != braceR && next != semicolon && next != -1 && !stack.context)
    input.acceptToken(noSemi);
}, {contextual: true});

const noSemicolonType = new lr.ExternalTokenizer((input, stack) => {
  if (input.next == bracketL && !stack.context) input.acceptToken(noSemiType);
}, {contextual: true});

const operatorToken = new lr.ExternalTokenizer((input, stack) => {
  let {next} = input;
  if (next == plus || next == minus) {
    input.advance();
    if (next == input.next) {
      input.advance();
      let mayPostfix = !stack.context && stack.canShift(incdec);
      input.acceptToken(mayPostfix ? incdec : incdecPrefix);
    }
  } else if (next == question && input.peek(1) == dot) {
    input.advance(); input.advance();
    if (input.next < 48 || input.next > 57) // No digit after
      input.acceptToken(questionDot);
  }
}, {contextual: true});

function identifierChar(ch, start) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 ||
    !start && ch >= 48 && ch <= 57
}

const jsx = new lr.ExternalTokenizer((input, stack) => {
  if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return
  input.advance();
  if (input.next == slash) return
  // Scan for an identifier followed by a comma or 'extends', don't
  // treat this as a start tag if present.
  let back = 0;
  while (space.indexOf(input.next) > -1) { input.advance(); back++; }
  if (identifierChar(input.next, true)) {
    input.advance();
    back++;
    while (identifierChar(input.next, false)) { input.advance(); back++; }
    while (space.indexOf(input.next) > -1) { input.advance(); back++; }
    if (input.next == comma) return
    for (let i = 0;; i++) {
      if (i == 7) {
        if (!identifierChar(input.next, true)) return
        break
      }
      if (input.next != "extends".charCodeAt(i)) break
      input.advance();
      back++;
    }
  }
  input.acceptToken(JSXStartTag, -back);
});

const jsHighlight = highlight.styleTags({
  "get set async static": highlight.tags.modifier,
  "for while do if else switch try catch finally return throw break continue default case": highlight.tags.controlKeyword,
  "in of await yield void typeof delete instanceof": highlight.tags.operatorKeyword,
  "let var const using function class extends": highlight.tags.definitionKeyword,
  "import export from": highlight.tags.moduleKeyword,
  "with debugger as new": highlight.tags.keyword,
  TemplateString: highlight.tags.special(highlight.tags.string),
  super: highlight.tags.atom,
  BooleanLiteral: highlight.tags.bool,
  this: highlight.tags.self,
  null: highlight.tags.null,
  Star: highlight.tags.modifier,
  VariableName: highlight.tags.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": highlight.tags.function(highlight.tags.variableName),
  VariableDefinition: highlight.tags.definition(highlight.tags.variableName),
  Label: highlight.tags.labelName,
  PropertyName: highlight.tags.propertyName,
  PrivatePropertyName: highlight.tags.special(highlight.tags.propertyName),
  "CallExpression/MemberExpression/PropertyName": highlight.tags.function(highlight.tags.propertyName),
  "FunctionDeclaration/VariableDefinition": highlight.tags.function(highlight.tags.definition(highlight.tags.variableName)),
  "ClassDeclaration/VariableDefinition": highlight.tags.definition(highlight.tags.className),
  "NewExpression/VariableName": highlight.tags.className,
  PropertyDefinition: highlight.tags.definition(highlight.tags.propertyName),
  PrivatePropertyDefinition: highlight.tags.definition(highlight.tags.special(highlight.tags.propertyName)),
  UpdateOp: highlight.tags.updateOperator,
  "LineComment Hashbang": highlight.tags.lineComment,
  BlockComment: highlight.tags.blockComment,
  Number: highlight.tags.number,
  String: highlight.tags.string,
  Escape: highlight.tags.escape,
  ArithOp: highlight.tags.arithmeticOperator,
  LogicOp: highlight.tags.logicOperator,
  BitOp: highlight.tags.bitwiseOperator,
  CompareOp: highlight.tags.compareOperator,
  RegExp: highlight.tags.regexp,
  Equals: highlight.tags.definitionOperator,
  Arrow: highlight.tags.function(highlight.tags.punctuation),
  ": Spread": highlight.tags.punctuation,
  "( )": highlight.tags.paren,
  "[ ]": highlight.tags.squareBracket,
  "{ }": highlight.tags.brace,
  "InterpolationStart InterpolationEnd": highlight.tags.special(highlight.tags.brace),
  ".": highlight.tags.derefOperator,
  ", ;": highlight.tags.separator,
  "@": highlight.tags.meta,

  TypeName: highlight.tags.typeName,
  TypeDefinition: highlight.tags.definition(highlight.tags.typeName),
  "type enum interface implements namespace module declare": highlight.tags.definitionKeyword,
  "abstract global Privacy readonly override": highlight.tags.modifier,
  "is keyof unique infer asserts": highlight.tags.operatorKeyword,

  JSXAttributeValue: highlight.tags.attributeValue,
  JSXText: highlight.tags.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": highlight.tags.angleBracket,
  "JSXIdentifier JSXNameSpacedName": highlight.tags.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": highlight.tags.attributeName,
  "JSXBuiltin/JSXIdentifier": highlight.tags.standard(highlight.tags.tagName)
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,export:20, as:25, from:33, default:36, async:41, function:42, const:52, extends:56, this:60, true:68, false:68, null:80, void:84, typeof:88, super:104, new:138, delete:150, yield:159, await:163, class:168, public:231, private:231, protected:231, readonly:233, instanceof:252, satisfies:255, in:256, import:290, keyof:347, unique:351, infer:357, asserts:393, is:395, abstract:415, implements:417, type:419, let:422, var:424, using:427, interface:433, enum:437, namespace:443, module:445, declare:449, global:453, for:472, of:481, while:484, with:488, do:492, if:496, else:498, switch:502, case:508, try:514, catch:518, finally:522, return:526, throw:530, break:534, continue:538, debugger:542};
const spec_word = {__proto__:null,async:125, get:127, set:129, declare:191, public:193, private:193, protected:193, static:195, abstract:197, override:199, readonly:205, accessor:207, new:399};
const spec_LessThan = {__proto__:null,"<":189};
const parser = lr.LRParser.deserialize({
  version: 14,
  states: "$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#D_O.QQlO'#DeO.bQlO'#DpO%[QlO'#DxO0fQlO'#EQOOQ!0Lf'#EY'#EYO1PQ`O'#EVOOQO'#En'#EnOOQO'#Ij'#IjO1XQ`O'#GrO1dQ`O'#EmO1iQ`O'#EmO3hQ!0MxO'#JpO6[Q!0MxO'#JqO6uQ`O'#F[O6zQ,UO'#FsOOQ!0Lf'#Fe'#FeO7VO7dO'#FeO7eQMhO'#F{O9UQ`O'#FzOOQ!0Lf'#Jq'#JqOOQ!0Lb'#Jp'#JpO9ZQ`O'#GvOOQ['#K]'#K]O9fQ`O'#IWO9kQ!0LrO'#IXOOQ['#J^'#J^OOQ['#I]'#I]Q`QlOOQ`QlOOO9sQ!L^O'#DtO9zQlO'#D|O:RQlO'#EOO9aQ`O'#GrO:YQMhO'#CoO:hQ`O'#ElO:sQ`O'#EwO:xQMhO'#FdO;gQ`O'#GrOOQO'#K^'#K^O;lQ`O'#K^O;zQ`O'#GzO;zQ`O'#G{O;zQ`O'#G}O9aQ`O'#HQO<qQ`O'#HTO>YQ`O'#CeO>jQ`O'#HaO>rQ`O'#HgO>rQ`O'#HiO`QlO'#HkO>rQ`O'#HmO>rQ`O'#HpO>wQ`O'#HvO>|Q!0LsO'#H|O%[QlO'#IOO?XQ!0LsO'#IQO?dQ!0LsO'#ISO9kQ!0LrO'#IUO?oQ!0MxO'#CiO@qQpO'#DjQOQ`OOO%[QlO'#EOOAXQ`O'#ERO:YQMhO'#ElOAdQ`O'#ElOAoQ!bO'#FdOOQ['#Cg'#CgOOQ!0Lb'#Do'#DoOOQ!0Lb'#Jt'#JtO%[QlO'#JtOOQO'#Jw'#JwOOQO'#If'#IfOBoQpO'#EeOOQ!0Lb'#Ed'#EdOOQ!0Lb'#J{'#J{OCkQ!0MSO'#EeOCuQpO'#EUOOQO'#Jv'#JvODZQpO'#JwOEhQpO'#EUOCuQpO'#EePEuO&2DjO'#CbPOOO)CD{)CD{OOOO'#I^'#I^OFQO#tO,59UOOQ!0Lh,59U,59UOOOO'#I_'#I_OF`O&jO,59UOFnQ!L^O'#DaOOOO'#Ia'#IaOFuO#@ItO,59yOOQ!0Lf,59y,59yOGTQlO'#IbOGhQ`O'#JrOIgQ!fO'#JrO+}QlO'#JrOInQ`O,5:POJUQ`O'#EnOJcQ`O'#KROJnQ`O'#KQOJnQ`O'#KQOJvQ`O,5;[OJ{Q`O'#KPOOQ!0Ln,5:[,5:[OKSQlO,5:[OMQQ!0MxO,5:dOMqQ`O,5:lON[Q!0LrO'#KOONcQ`O'#J}O9ZQ`O'#J}ONwQ`O'#J}O! PQ`O,5;ZO! UQ`O'#J}O!#ZQ!fO'#JqOOQ!0Lh'#Ci'#CiO%[QlO'#EQO!#yQ!fO,5:qOOQS'#Jx'#JxOOQO-E<h-E<hO9aQ`O,5=^O!$aQ`O,5=^O!$fQlO,5;XO!&iQMhO'#EiO!(SQ`O,5;XO!(XQlO'#DwO!(cQpO,5;bO!(kQpO,5;bO%[QlO,5;bOOQ['#FS'#FSOOQ['#FU'#FUO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cOOQ['#FY'#FYO!(yQlO,5;sOOQ!0Lf,5;x,5;xOOQ!0Lf,5;y,5;yOOQ!0Lf,5;{,5;{O%[QlO'#InO!*|Q!0LrO,5<hO%[QlO,5;cO!&iQMhO,5;cO!+kQMhO,5;cO!-]QMhO'#E[O%[QlO,5;vOOQ!0Lf,5;z,5;zO!-dQ,UO'#FiO!.aQ,UO'#KVO!-{Q,UO'#KVO!.hQ,UO'#KVOOQO'#KV'#KVO!.|Q,UO,5<ROOOW,5<_,5<_O!/_QlO'#FuOOOW'#Im'#ImO7VO7dO,5<PO!/fQ,UO'#FwOOQ!0Lf,5<P,5<PO!0VQ$IUO'#CwOOQ!0Lh'#C{'#C{O!0jO#@ItO'#DPO!1WQMjO,5<dO!1_Q`O,5<gO!2zQ(CWO'#GWO!3XQ`O'#GXO!3^Q`O'#GXO!4|Q(CWO'#G]O!6RQpO'#GaOOQO'#Gm'#GmO!+rQMhO'#GlOOQO'#Go'#GoO!+rQMhO'#GnO!6tQ$IUO'#JjOOQ!0Lh'#Jj'#JjO!7OQ`O'#JiO!7^Q`O'#JhO!7fQ`O'#CuOOQ!0Lh'#Cy'#CyO!7qQ`O'#C{OOQ!0Lh'#DT'#DTOOQ!0Lh'#DV'#DVO1SQ`O'#DXO!+rQMhO'#GOO!+rQMhO'#GQO!7vQ`O'#GSO!7{Q`O'#GTO!3^Q`O'#GZO!+rQMhO'#G`O;zQ`O'#JiO!8QQ`O'#EoO!8oQ`O,5<fOOQ!0Lb'#Cr'#CrO!8wQ`O'#EpO!9qQpO'#EqOOQ!0Lb'#KP'#KPO!9xQ!0LrO'#K_O9kQ!0LrO,5=bO`QlO,5>rOOQ['#Jf'#JfOOQ[,5>s,5>sOOQ[-E<Z-E<ZO!;wQ!0MxO,5:`O!9lQpO,5:^O!>bQ!0MxO,5:hO%[QlO,5:hO!@xQ!0MxO,5:jOOQO,5@x,5@xO!AiQMhO,5=^O!AwQ!0LrO'#JgO9UQ`O'#JgO!BYQ!0LrO,59ZO!BeQpO,59ZO!BmQMhO,59ZO:YQMhO,59ZO!BxQ`O,5;XO!CQQ`O'#H`O!CfQ`O'#KbO%[QlO,5;|O!9lQpO,5<OO!CnQ`O,5=yO!CsQ`O,5=yO!CxQ`O,5=yO9kQ!0LrO,5=yO;zQ`O,5=iOOQO'#Cw'#CwO!DWQpO,5=fO!D`QMhO,5=gO!DkQ`O,5=iO!DpQ!bO,5=lO!DxQ`O'#K^O>wQ`O'#HVO9aQ`O'#HXO!D}Q`O'#HXO:YQMhO'#HZO!ESQ`O'#HZOOQ[,5=o,5=oO!EXQ`O'#H[O!EjQ`O'#CoO!EoQ`O,59PO!EyQ`O,59PO!HOQlO,59POOQ[,59P,59PO!H`Q!0LrO,59PO%[QlO,59PO!JkQlO'#HcOOQ['#Hd'#HdOOQ['#He'#HeO`QlO,5={O!KRQ`O,5={O`QlO,5>RO`QlO,5>TO!KWQ`O,5>VO`QlO,5>XO!K]Q`O,5>[O!KbQlO,5>bOOQ[,5>h,5>hO%[QlO,5>hO9kQ!0LrO,5>jOOQ[,5>l,5>lO# lQ`O,5>lOOQ[,5>n,5>nO# lQ`O,5>nOOQ[,5>p,5>pO#!YQpO'#D]O%[QlO'#JtO#!{QpO'#JtO##VQpO'#DkO##hQpO'#DkO#%yQlO'#DkO#&QQ`O'#JsO#&YQ`O,5:UO#&_Q`O'#ErO#&mQ`O'#KSO#&uQ`O,5;]O#&zQpO'#DkO#'XQpO'#ETOOQ!0Lf,5:m,5:mO%[QlO,5:mO#'`Q`O,5:mO>wQ`O,5;WO!BeQpO,5;WO!BmQMhO,5;WO:YQMhO,5;WO#'hQ`O,5@`O#'mQ07dO,5:qOOQO-E<d-E<dO#(sQ!0MSO,5;POCuQpO,5:pO#(}QpO,5:pOCuQpO,5;PO!BYQ!0LrO,5:pOOQ!0Lb'#Eh'#EhOOQO,5;P,5;PO%[QlO,5;PO#)[Q!0LrO,5;PO#)gQ!0LrO,5;PO!BeQpO,5:pOOQO,5;V,5;VO#)uQ!0LrO,5;PPOOO'#I['#I[P#*ZO&2DjO,58|POOO,58|,58|OOOO-E<[-E<[OOQ!0Lh1G.p1G.pOOOO-E<]-E<]OOOO,59{,59{O#*fQ!bO,59{OOOO-E<_-E<_OOQ!0Lf1G/e1G/eO#*kQ!fO,5>|O+}QlO,5>|OOQO,5?S,5?SO#*uQlO'#IbOOQO-E<`-E<`O#+SQ`O,5@^O#+[Q!fO,5@^O#+cQ`O,5@lOOQ!0Lf1G/k1G/kO%[QlO,5@mO#+kQ`O'#IhOOQO-E<f-E<fO#+cQ`O,5@lOOQ!0Lb1G0v1G0vOOQ!0Ln1G/v1G/vOOQ!0Ln1G0W1G0WO%[QlO,5@jO#,PQ!0LrO,5@jO#,bQ!0LrO,5@jO#,iQ`O,5@iO9ZQ`O,5@iO#,qQ`O,5@iO#-PQ`O'#IkO#,iQ`O,5@iOOQ!0Lb1G0u1G0uO!(cQpO,5:sO!(nQpO,5:sOOQS,5:u,5:uO#-qQdO,5:uO#-yQMhO1G2xO9aQ`O1G2xOOQ!0Lf1G0s1G0sO#.XQ!0MxO1G0sO#/^Q!0MvO,5;TOOQ!0Lh'#GV'#GVO#/zQ!0MzO'#JjO!$fQlO1G0sO#2VQ!fO'#JuO%[QlO'#JuO#2aQ`O,5:cOOQ!0Lh'#D]'#D]OOQ!0Lf1G0|1G0|O%[QlO1G0|OOQ!0Lf1G1e1G1eO#2fQ`O1G0|O#4zQ!0MxO1G0}O#5RQ!0MxO1G0}O#7iQ!0MxO1G0}O#7pQ!0MxO1G0}O#:WQ!0MxO1G0}O#<nQ!0MxO1G0}O#<uQ!0MxO1G0}O#<|Q!0MxO1G0}O#?dQ!0MxO1G0}O#?kQ!0MxO1G0}O#AxQ?MtO'#CiO#CsQ?MtO1G1_O#CzQ?MtO'#JqO#D_Q!0MxO,5?YOOQ!0Lb-E<l-E<lO#FlQ!0MxO1G0}O#GiQ!0MzO1G0}OOQ!0Lf1G0}1G0}O#HlQMjO'#JzO#HvQ`O,5:vO#H{Q!0MxO1G1bO#IoQ,UO,5<VO#IwQ,UO,5<WO#JPQ,UO'#FnO#JhQ`O'#FmOOQO'#KW'#KWOOQO'#Il'#IlO#JmQ,UO1G1mOOQ!0Lf1G1m1G1mOOOW1G1x1G1xO#KOQ?MtO'#JpO#KYQ`O,5<aO!(yQlO,5<aOOOW-E<k-E<kOOQ!0Lf1G1k1G1kO#K_QpO'#KVOOQ!0Lf,5<c,5<cO#KgQpO,5<cO#KlQMhO'#DROOOO'#I`'#I`O#KsO#@ItO,59kOOQ!0Lh,59k,59kO%[QlO1G2OO!7{Q`O'#IpO#LOQ`O,5<yOOQ!0Lh,5<v,5<vO!+rQMhO'#IsO#LlQMjO,5=WO!+rQMhO'#IuO#M_QMjO,5=YO!&iQMhO,5=[OOQO1G2R1G2RO#MiQ!dO'#CrO#M|Q(CWO'#EpO$ RQpO'#GaO$ iQ!dO,5<rO$ pQ`O'#KYO9ZQ`O'#KYO$!OQ`O,5<tO!+rQMhO,5<sO$!TQ`O'#GYO$!fQ`O,5<sO$!kQ!dO'#GVO$!xQ!dO'#KZO$#SQ`O'#KZO!&iQMhO'#KZO$#XQ`O,5<wO$#^QlO'#JtO$#hQpO'#GbO##hQpO'#GbO$#yQ`O'#GfO!3^Q`O'#GjO$$OQ!0LrO'#IrO$$ZQpO,5<{OOQ!0Lp,5<{,5<{O$$bQpO'#GbO$$oQpO'#GcO$%QQpO'#GcO$%VQMjO,5=WO$%gQMjO,5=YOOQ!0Lh,5=],5=]O!+rQMhO,5@TO!+rQMhO,5@TO$%wQ`O'#IwO$&VQ`O,5@SO$&_Q`O,59aOOQ!0Lh,59g,59gO$'UQ$IYO,59sOOQ!0Lh'#Jn'#JnO$'wQMjO,5<jO$(jQMjO,5<lO@iQ`O,5<nOOQ!0Lh,5<o,5<oO$(tQ`O,5<uO$(yQMjO,5<zO$)ZQ`O,5@TO$)iQ`O'#J}O!$fQlO1G2QO$)nQ`O1G2QO9ZQ`O'#KQO9ZQ`O'#ErO%[QlO'#ErO9ZQ`O'#IyO$)sQ!0LrO,5@yOOQ[1G2|1G2|OOQ[1G4^1G4^OOQ!0Lf1G/z1G/zOOQ!0Lf1G/x1G/xO$+uQ!0MxO1G0SOOQ[1G2x1G2xO!&iQMhO1G2xO%[QlO1G2xO#-|Q`O1G2xO$-yQMhO'#EiOOQ!0Lb,5@R,5@RO$.WQ!0LrO,5@ROOQ[1G.u1G.uO!BYQ!0LrO1G.uO!BeQpO1G.uO!BmQMhO1G.uO$.iQ`O1G0sO$.nQ`O'#CiO$.yQ`O'#KcO$/RQ`O,5=zO$/WQ`O'#KcO$/]Q`O'#KcO$/kQ`O'#JPO$/yQ`O,5@|O$0RQ!fO1G1hOOQ!0Lf1G1j1G1jO9aQ`O1G3eO@iQ`O1G3eO$0YQ`O1G3eO$0_Q`O1G3eOOQ[1G3e1G3eO!DkQ`O1G3TO!&iQMhO1G3QO$0dQ`O1G3QOOQ[1G3R1G3RO!&iQMhO1G3RO$0iQ`O1G3RO$0qQpO'#HPOOQ[1G3T1G3TO!5|QpO'#I{O!DpQ!bO1G3WOOQ[1G3W1G3WOOQ[,5=q,5=qO$0yQMhO,5=sO9aQ`O,5=sO$#yQ`O,5=uO9UQ`O,5=uO!BeQpO,5=uO!BmQMhO,5=uO:YQMhO,5=uO$1XQ`O'#KaO$1dQ`O,5=vOOQ[1G.k1G.kO$1iQ!0LrO1G.kO@iQ`O1G.kO$1tQ`O1G.kO9kQ!0LrO1G.kO$3|Q!fO,5AOO$4ZQ`O,5AOO9ZQ`O,5AOO$4fQlO,5=}O$4mQ`O,5=}OOQ[1G3g1G3gO`QlO1G3gOOQ[1G3m1G3mOOQ[1G3o1G3oO>rQ`O1G3qO$4rQlO1G3sO$8vQlO'#HrOOQ[1G3v1G3vO$9TQ`O'#HxO>wQ`O'#HzOOQ[1G3|1G3|O$9]QlO1G3|O9kQ!0LrO1G4SOOQ[1G4U1G4UOOQ!0Lb'#G^'#G^O9kQ!0LrO1G4WO9kQ!0LrO1G4YO$=dQ`O,5@`O!(yQlO,5;^O9ZQ`O,5;^O>wQ`O,5:VO!(yQlO,5:VO!BeQpO,5:VO$=iQ?MtO,5:VOOQO,5;^,5;^O$=sQpO'#IcO$>ZQ`O,5@_OOQ!0Lf1G/p1G/pO$>cQpO'#IiO$>mQ`O,5@nOOQ!0Lb1G0w1G0wO##hQpO,5:VOOQO'#Ie'#IeO$>uQpO,5:oOOQ!0Ln,5:o,5:oO#'cQ`O1G0XOOQ!0Lf1G0X1G0XO%[QlO1G0XOOQ!0Lf1G0r1G0rO>wQ`O1G0rO!BeQpO1G0rO!BmQMhO1G0rOOQ!0Lb1G5z1G5zO!BYQ!0LrO1G0[OOQO1G0k1G0kO%[QlO1G0kO$>|Q!0LrO1G0kO$?XQ!0LrO1G0kO!BeQpO1G0[OCuQpO1G0[O$?gQ!0LrO1G0kOOQO1G0[1G0[O$?{Q!0MxO1G0kPOOO-E<Y-E<YPOOO1G.h1G.hOOOO1G/g1G/gO$@VQ!bO,5<hO$@_Q!fO1G4hOOQO1G4n1G4nO%[QlO,5>|O$@iQ`O1G5xO$@qQ`O1G6WO$@yQ!fO1G6XO9ZQ`O,5?SO$ATQ!0MxO1G6UO%[QlO1G6UO$AeQ!0LrO1G6UO$AvQ`O1G6TO$AvQ`O1G6TO9ZQ`O1G6TO$BOQ`O,5?VO9ZQ`O,5?VOOQO,5?V,5?VO$BdQ`O,5?VO$)iQ`O,5?VOOQO-E<i-E<iOOQS1G0_1G0_OOQS1G0a1G0aO#-tQ`O1G0aOOQ[7+(d7+(dO!&iQMhO7+(dO%[QlO7+(dO$BrQ`O7+(dO$B}QMhO7+(dO$C]Q!0MzO,5=WO$EhQ!0MzO,5=YO$GsQ!0MzO,5=WO$JUQ!0MzO,5=YO$LgQ!0MzO,59sO$NlQ!0MzO,5<jO%!wQ!0MzO,5<lO%%SQ!0MzO,5<zOOQ!0Lf7+&_7+&_O%'eQ!0MxO7+&_O%(XQlO'#IdO%(fQ`O,5@aO%(nQ!fO,5@aOOQ!0Lf1G/}1G/}O%(xQ`O7+&hOOQ!0Lf7+&h7+&hO%(}Q?MtO,5:dO%[QlO7+&yO%)XQ?MtO,5:`O%)fQ?MtO,5:hO%)pQ?MtO,5:jO%)zQMhO'#IgO%*UQ`O,5@fOOQ!0Lh1G0b1G0bOOQO1G1q1G1qOOQO1G1r1G1rO%*^Q!jO,5<YO!(yQlO,5<XOOQO-E<j-E<jOOQ!0Lf7+'X7+'XOOOW7+'d7+'dOOOW1G1{1G1{O%*iQ`O1G1{OOQ!0Lf1G1}1G1}OOOO,59m,59mO%*nQ!dO,59mOOOO-E<^-E<^OOQ!0Lh1G/V1G/VO%*uQ!0MxO7+'jOOQ!0Lh,5?[,5?[O%+iQMhO1G2eP%+pQ`O'#IpPOQ!0Lh-E<n-E<nO%,^QMjO,5?_OOQ!0Lh-E<q-E<qO%-PQMjO,5?aOOQ!0Lh-E<s-E<sO%-ZQ!dO1G2vO%-bQ!dO'#CrO%-xQMhO'#KQO$#^QlO'#JtOOQ!0Lh1G2^1G2^O%.PQ`O'#IoO%.eQ`O,5@tO%.eQ`O,5@tO%.mQ`O,5@tO%.xQ`O,5@tOOQO1G2`1G2`O%/WQMjO1G2_O!+rQMhO1G2_O%/hQ(CWO'#IqO%/uQ`O,5@uO!&iQMhO,5@uO%/}Q!dO,5@uOOQ!0Lh1G2c1G2cO%2_Q!fO'#CiO%2iQ`O,5=OOOQ!0Lb,5<|,5<|O%2qQpO,5<|OOQ!0Lb,5<},5<}OCfQ`O,5<|O%2|QpO,5<|OOQ!0Lb,5=Q,5=QO$)iQ`O,5=UOOQO,5?^,5?^OOQO-E<p-E<pOOQ!0Lp1G2g1G2gO##hQpO,5<|O$#^QlO,5=OO%3[Q`O,5<}O%3gQpO,5<}O!+rQMhO'#IsO%4aQMjO1G2rO!+rQMhO'#IuO%5SQMjO1G2tO%5^QMjO1G5oO%5hQMjO1G5oOOQO,5?c,5?cOOQO-E<u-E<uOOQO1G.{1G.{O!9lQpO,59uO%[QlO,59uOOQ!0Lh,5<i,5<iO%5uQ`O1G2YO!+rQMhO1G2aO!+rQMhO1G5oO!+rQMhO1G5oO%5zQ!0MxO7+'lOOQ!0Lf7+'l7+'lO!$fQlO7+'lO%6nQ`O,5;^OOQ!0Lb,5?e,5?eOOQ!0Lb-E<w-E<wO%6sQ!dO'#K[O#'cQ`O7+(dO4UQ!fO7+(dO$BuQ`O7+(dO%6}Q!0MvO'#CiO%7nQ!0LrO,5=RO%8PQ!0MvO,5=RO%8dQ`O,5=ROOQ!0Lb1G5m1G5mOOQ[7+$a7+$aO!BYQ!0LrO7+$aO!BeQpO7+$aO!$fQlO7+&_O%8lQ`O'#JOO%9TQ`O,5@}OOQO1G3f1G3fO9aQ`O,5@}O%9TQ`O,5@}O%9]Q`O,5@}OOQO,5?k,5?kOOQO-E<}-E<}OOQ!0Lf7+'S7+'SO%9bQ`O7+)PO9kQ!0LrO7+)PO9aQ`O7+)PO@iQ`O7+)POOQ[7+(o7+(oO%9gQ!0MvO7+(lO!&iQMhO7+(lO!DfQ`O7+(mOOQ[7+(m7+(mO!&iQMhO7+(mO%9qQ`O'#K`O%9|Q`O,5=kOOQO,5?g,5?gOOQO-E<y-E<yOOQ[7+(r7+(rO%;`QpO'#HYOOQ[1G3_1G3_O!&iQMhO1G3_O%[QlO1G3_O%;gQ`O1G3_O%;rQMhO1G3_O9kQ!0LrO1G3aO$#yQ`O1G3aO9UQ`O1G3aO!BeQpO1G3aO!BmQMhO1G3aO%<QQ`O'#I}O%<fQ`O,5@{O%<nQpO,5@{OOQ!0Lb1G3b1G3bOOQ[7+$V7+$VO@iQ`O7+$VO9kQ!0LrO7+$VO%<yQ`O7+$VO%[QlO1G6jO%[QlO1G6kO%=OQ!0LrO1G6jO%=YQlO1G3iO%=aQ`O1G3iO%=fQlO1G3iOOQ[7+)R7+)RO9kQ!0LrO7+)]O`QlO7+)_OOQ['#Kf'#KfOOQ['#JQ'#JQO%=mQlO,5>^OOQ[,5>^,5>^O%[QlO'#HsO%=zQ`O'#HuOOQ[,5>d,5>dO9ZQ`O,5>dOOQ[,5>f,5>fOOQ[7+)h7+)hOOQ[7+)n7+)nOOQ[7+)r7+)rOOQ[7+)t7+)tO%>PQpO1G5zO%>kQ?MtO1G0xO%>uQ`O1G0xOOQO1G/q1G/qO%?QQ?MtO1G/qO>wQ`O1G/qO!(yQlO'#DkOOQO,5>},5>}OOQO-E<a-E<aOOQO,5?T,5?TOOQO-E<g-E<gO!BeQpO1G/qOOQO-E<c-E<cOOQ!0Ln1G0Z1G0ZOOQ!0Lf7+%s7+%sO#'cQ`O7+%sOOQ!0Lf7+&^7+&^O>wQ`O7+&^O!BeQpO7+&^OOQO7+%v7+%vO$?{Q!0MxO7+&VOOQO7+&V7+&VO%[QlO7+&VO%?[Q!0LrO7+&VO!BYQ!0LrO7+%vO!BeQpO7+%vO%?gQ!0LrO7+&VO%?uQ!0MxO7++pO%[QlO7++pO%@VQ`O7++oO%@VQ`O7++oOOQO1G4q1G4qO9ZQ`O1G4qO%@_Q`O1G4qOOQS7+%{7+%{O#'cQ`O<<LOO4UQ!fO<<LOO%@mQ`O<<LOOOQ[<<LO<<LOO!&iQMhO<<LOO%[QlO<<LOO%@uQ`O<<LOO%AQQ!0MzO,5?_O%C]Q!0MzO,5?aO%EhQ!0MzO1G2_O%GyQ!0MzO1G2rO%JUQ!0MzO1G2tO%LaQ!fO,5?OO%[QlO,5?OOOQO-E<b-E<bO%LkQ`O1G5{OOQ!0Lf<<JS<<JSO%LsQ?MtO1G0sO%NzQ?MtO1G0}O& RQ?MtO1G0}O&#SQ?MtO1G0}O&#ZQ?MtO1G0}O&%[Q?MtO1G0}O&']Q?MtO1G0}O&'dQ?MtO1G0}O&'kQ?MtO1G0}O&)lQ?MtO1G0}O&)sQ?MtO1G0}O&)zQ!0MxO<<JeO&+rQ?MtO1G0}O&,oQ?MvO1G0}O&-rQ?MvO'#JjO&/xQ?MtO1G1bO&0VQ?MtO1G0SO&0aQMjO,5?ROOQO-E<e-E<eO!(yQlO'#FpOOQO'#KX'#KXOOQO1G1t1G1tO&0kQ`O1G1sO&0pQ?MtO,5?YOOOW7+'g7+'gOOOO1G/X1G/XO&0zQ!dO1G4vOOQ!0Lh7+(P7+(PP!&iQMhO,5?[O!+rQMhO7+(bO&1RQ`O,5?ZO9ZQ`O,5?ZOOQO-E<m-E<mO&1aQ`O1G6`O&1aQ`O1G6`O&1iQ`O1G6`O&1tQMjO7+'yO&2UQ!dO,5?]O&2`Q`O,5?]O!&iQMhO,5?]OOQO-E<o-E<oO&2eQ!dO1G6aO&2oQ`O1G6aO&2wQ`O1G2jO!&iQMhO1G2jOOQ!0Lb1G2h1G2hOOQ!0Lb1G2i1G2iO%2qQpO1G2hO!BeQpO1G2hOCfQ`O1G2hOOQ!0Lb1G2p1G2pO&2|QpO1G2hO&3[Q`O1G2jO$)iQ`O1G2iOCfQ`O1G2iO$#^QlO1G2jO&3dQ`O1G2iO&4WQMjO,5?_OOQ!0Lh-E<r-E<rO&4yQMjO,5?aOOQ!0Lh-E<t-E<tO!+rQMhO7++ZOOQ!0Lh1G/a1G/aO&5TQ`O1G/aOOQ!0Lh7+'t7+'tO&5YQMjO7+'{O&5jQMjO7++ZO&5tQMjO7++ZO&6RQ!0MxO<<KWOOQ!0Lf<<KW<<KWO&6uQ`O1G0xO!&iQMhO'#IxO&6zQ`O,5@vO&8|Q!fO<<LOO!&iQMhO1G2mO&9TQ!0LrO1G2mOOQ[<<G{<<G{O!BYQ!0LrO<<G{O&9fQ!0MxO<<IyOOQ!0Lf<<Iy<<IyOOQO,5?j,5?jO&:YQ`O,5?jO&:_Q`O,5?jOOQO-E<|-E<|O&:mQ`O1G6iO&:mQ`O1G6iO9aQ`O1G6iO@iQ`O<<LkOOQ[<<Lk<<LkO&:uQ`O<<LkO9kQ!0LrO<<LkOOQ[<<LW<<LWO%9gQ!0MvO<<LWOOQ[<<LX<<LXO!DfQ`O<<LXO&:zQpO'#IzO&;VQ`O,5@zO!(yQlO,5@zOOQ[1G3V1G3VOOQO'#I|'#I|O9kQ!0LrO'#I|O&;_QpO,5=tOOQ[,5=t,5=tO&;fQpO'#EeO&;mQpO'#GdO&;rQ`O7+(yO&;wQ`O7+(yOOQ[7+(y7+(yO!&iQMhO7+(yO%[QlO7+(yO&<PQ`O7+(yOOQ[7+({7+({O9kQ!0LrO7+({O$#yQ`O7+({O9UQ`O7+({O!BeQpO7+({O&<[Q`O,5?iOOQO-E<{-E<{OOQO'#H]'#H]O&<gQ`O1G6gO9kQ!0LrO<<GqOOQ[<<Gq<<GqO@iQ`O<<GqO&<oQ`O7+,UO&<tQ`O7+,VO%[QlO7+,UO%[QlO7+,VOOQ[7+)T7+)TO&<yQ`O7+)TO&=OQlO7+)TO&=VQ`O7+)TOOQ[<<Lw<<LwOOQ[<<Ly<<LyOOQ[-E=O-E=OOOQ[1G3x1G3xO&=[Q`O,5>_OOQ[,5>a,5>aO&=aQ`O1G4OO9ZQ`O7+&dO!(yQlO7+&dOOQO7+%]7+%]O&=fQ?MtO1G6XO>wQ`O7+%]OOQ!0Lf<<I_<<I_OOQ!0Lf<<Ix<<IxO>wQ`O<<IxOOQO<<Iq<<IqO$?{Q!0MxO<<IqO%[QlO<<IqOOQO<<Ib<<IbO!BYQ!0LrO<<IbO&=pQ!0LrO<<IqO&={Q!0MxO<= [O&>]Q`O<= ZOOQO7+*]7+*]O9ZQ`O7+*]OOQ[ANAjANAjO&>eQ!fOANAjO!&iQMhOANAjO#'cQ`OANAjO4UQ!fOANAjO&>lQ`OANAjO%[QlOANAjO&>tQ!0MzO7+'yO&AVQ!0MzO,5?_O&CbQ!0MzO,5?aO&EmQ!0MzO7+'{O&HOQ!fO1G4jO&HYQ?MtO7+&_O&J^Q?MvO,5=WO&LeQ?MvO,5=YO&LuQ?MvO,5=WO&MVQ?MvO,5=YO&MgQ?MvO,59sO' mQ?MvO,5<jO'#pQ?MvO,5<lO'&UQ?MvO,5<zO''zQ?MtO7+'jO'(XQ?MtO7+'lO'(fQ`O,5<[OOQO7+'_7+'_OOQ!0Lh7+*b7+*bO'(kQMjO<<K|OOQO1G4u1G4uO'(rQ`O1G4uO'(}Q`O1G4uO')]Q`O7++zO')]Q`O7++zO!&iQMhO1G4wO')eQ!dO1G4wO')oQ`O7++{O')wQ`O7+(UO'*SQ!dO7+(UOOQ!0Lb7+(S7+(SOOQ!0Lb7+(T7+(TO!BeQpO7+(SOCfQ`O7+(SO'*^Q`O7+(UO!&iQMhO7+(UO$)iQ`O7+(TO'*cQ`O7+(UOCfQ`O7+(TO'*kQMjO<<NuOOQ!0Lh7+${7+${O!+rQMhO<<NuO'*uQ!dO,5?dOOQO-E<v-E<vO'+PQ!0MvO7+(XO!&iQMhO7+(XOOQ[AN=gAN=gO9aQ`O1G5UOOQO1G5U1G5UO'+aQ`O1G5UO'+fQ`O7+,TO'+fQ`O7+,TO9kQ!0LrOANBVO@iQ`OANBVOOQ[ANBVANBVOOQ[ANArANArOOQ[ANAsANAsO'+nQ`O,5?fOOQO-E<x-E<xO'+yQ?MtO1G6fOOQO,5?h,5?hOOQO-E<z-E<zOOQ[1G3`1G3`O',TQ`O,5=OOOQ[<<Le<<LeO!&iQMhO<<LeO&;rQ`O<<LeO',YQ`O<<LeO%[QlO<<LeOOQ[<<Lg<<LgO9kQ!0LrO<<LgO$#yQ`O<<LgO9UQ`O<<LgO',bQpO1G5TO',mQ`O7+,ROOQ[AN=]AN=]O9kQ!0LrOAN=]OOQ[<= p<= pOOQ[<= q<= qO',uQ`O<= pO',zQ`O<= qOOQ[<<Lo<<LoO'-PQ`O<<LoO'-UQlO<<LoOOQ[1G3y1G3yO>wQ`O7+)jO'-]Q`O<<JOO'-hQ?MtO<<JOOOQO<<Hw<<HwOOQ!0LfAN?dAN?dOOQOAN?]AN?]O$?{Q!0MxOAN?]OOQOAN>|AN>|O%[QlOAN?]OOQO<<Mw<<MwOOQ[G27UG27UO!&iQMhOG27UO#'cQ`OG27UO'-rQ!fOG27UO4UQ!fOG27UO'-yQ`OG27UO'.RQ?MtO<<JeO'.`Q?MvO1G2_O'0UQ?MvO,5?_O'2XQ?MvO,5?aO'4[Q?MvO1G2rO'6_Q?MvO1G2tO'8bQ?MtO<<KWO'8oQ?MtO<<IyOOQO1G1v1G1vO!+rQMhOANAhOOQO7+*a7+*aO'8|Q`O7+*aO'9XQ`O<= fO'9aQ!dO7+*cOOQ!0Lb<<Kp<<KpO$)iQ`O<<KpOCfQ`O<<KpO'9kQ`O<<KpO!&iQMhO<<KpOOQ!0Lb<<Kn<<KnO!BeQpO<<KnO'9vQ!dO<<KpOOQ!0Lb<<Ko<<KoO':QQ`O<<KpO!&iQMhO<<KpO$)iQ`O<<KoO':VQMjOANDaO':aQ!0MvO<<KsOOQO7+*p7+*pO9aQ`O7+*pO':qQ`O<= oOOQ[G27qG27qO9kQ!0LrOG27qO!(yQlO1G5QO':yQ`O7+,QO';RQ`O1G2jO&;rQ`OANBPOOQ[ANBPANBPO!&iQMhOANBPO';WQ`OANBPOOQ[ANBRANBRO9kQ!0LrOANBRO$#yQ`OANBROOQO'#H^'#H^OOQO7+*o7+*oOOQ[G22wG22wOOQ[ANE[ANE[OOQ[ANE]ANE]OOQ[ANBZANBZO';`Q`OANBZOOQ[<<MU<<MUO!(yQlOAN?jOOQOG24wG24wO$?{Q!0MxOG24wO#'cQ`OLD,pOOQ[LD,pLD,pO!&iQMhOLD,pO';eQ!fOLD,pO';lQ?MvO7+'yO'=bQ?MvO,5?_O'?eQ?MvO,5?aO'AhQ?MvO7+'{O'C^QMjOG27SOOQO<<M{<<M{OOQ!0LbANA[ANA[O$)iQ`OANA[OCfQ`OANA[O'CnQ!dOANA[OOQ!0LbANAYANAYO'CuQ`OANA[O!&iQMhOANA[O'DQQ!dOANA[OOQ!0LbANAZANAZOOQO<<N[<<N[OOQ[LD-]LD-]O'D[Q?MtO7+*lOOQO'#Ge'#GeOOQ[G27kG27kO&;rQ`OG27kO!&iQMhOG27kOOQ[G27mG27mO9kQ!0LrOG27mOOQ[G27uG27uO'DfQ?MtOG25UOOQOLD*cLD*cOOQ[!$(![!$(![O#'cQ`O!$(![O!&iQMhO!$(![O'DpQ!0MzOG27SOOQ!0LbG26vG26vO$)iQ`OG26vO'GRQ`OG26vOCfQ`OG26vO'G^Q!dOG26vO!&iQMhOG26vOOQ[LD-VLD-VO&;rQ`OLD-VOOQ[LD-XLD-XOOQ[!)9Ev!)9EvO#'cQ`O!)9EvOOQ!0LbLD,bLD,bO$)iQ`OLD,bOCfQ`OLD,bO'GeQ`OLD,bO'GpQ!dOLD,bOOQ[!$(!q!$(!qOOQ[!.K;b!.K;bO'GwQ?MvOG27SOOQ!0Lb!$( |!$( |O$)iQ`O!$( |OCfQ`O!$( |O'ImQ`O!$( |OOQ!0Lb!)9Eh!)9EhO$)iQ`O!)9EhOCfQ`O!)9EhOOQ!0Lb!.K;S!.K;SO$)iQ`O!.K;SOOQ!0Lb!4/0n!4/0nO!(yQlO'#DxO1PQ`O'#EVO'IxQ!fO'#JpO'JPQ!L^O'#DtO'JWQlO'#D|O'J_Q!fO'#CiO'LuQ!fO'#CiO!(yQlO'#EOO'MVQlO,5;XO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO'#InO( YQ`O,5<hO!(yQlO,5;cO( bQMhO,5;cO(!{QMhO,5;cO!(yQlO,5;vO!&iQMhO'#GlO( bQMhO'#GlO!&iQMhO'#GnO( bQMhO'#GnO1SQ`O'#DXO1SQ`O'#DXO!&iQMhO'#GOO( bQMhO'#GOO!&iQMhO'#GQO( bQMhO'#GQO!&iQMhO'#G`O( bQMhO'#G`O!(yQlO,5:hO(#SQpO'#D]O(#^QpO'#JtO!(yQlO,5@mO'MVQlO1G0sO(#hQ?MtO'#CiO!(yQlO1G2OO!&iQMhO'#IsO( bQMhO'#IsO!&iQMhO'#IuO( bQMhO'#IuO(#rQ!dO'#CrO!&iQMhO,5<sO( bQMhO,5<sO'MVQlO1G2QO!(yQlO7+&yO!&iQMhO1G2_O( bQMhO1G2_O!&iQMhO'#IsO( bQMhO'#IsO!&iQMhO'#IuO( bQMhO'#IuO!&iQMhO1G2aO( bQMhO1G2aO'MVQlO7+'lO'MVQlO7+&_O!&iQMhOANAhO( bQMhOANAhO($VQ`O'#EmO($[Q`O'#EmO($dQ`O'#F[O($iQ`O'#EwO($nQ`O'#KRO($yQ`O'#KPO(%UQ`O,5;XO(%ZQMjO,5<dO(%bQ`O'#GXO(%gQ`O'#GXO(%lQ`O,5<fO(%tQ`O,5;XO(%|Q?MtO1G1_O(&TQ`O,5<sO(&YQ`O,5<sO(&_Q`O,5<uO(&dQ`O,5<uO(&iQ`O1G2QO(&nQ`O1G0sO(&sQMjO<<K|O(&zQMjO<<K|O7eQMhO'#F{O9UQ`O'#FzOAdQ`O'#ElO!(yQlO,5;sO!3^Q`O'#GXO!3^Q`O'#GXO!3^Q`O'#GZO!3^Q`O'#GZO!+rQMhO7+(bO!+rQMhO7+(bO%-ZQ!dO1G2vO%-ZQ!dO1G2vO!&iQMhO,5=[O!&iQMhO,5=[",
  stateData: "((P~O'zOS'{OSTOS'|RQ~OPYOQYOSfOY!VOaqOdzOeyOj!POnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]XO!guO!jZO!mYO!nYO!oYO!qvO!swO!vxO!z]O$V|O$miO%g}O%i!QO%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO%x!UO&U!WO&[!XO&^!YO&`!ZO&b![O&e!]O&k!^O&q!_O&s!`O&u!aO&w!bO&y!cO(RSO(TTO(WUO(_VO(m[O~OWtO~P`OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oa!wOq!nO!Q!oO!`!yO!a!vO!b!vO!z;wO#R!pO#S!pO#T!xO#U!pO#V!pO#Y!zO#Z!zO(S!lO(TTO(WUO(c!mO(m!sO~O'|!{O~OP]XR]X[]Xa]Xp]X!O]X!Q]X!Z]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X'x]X(_]X(p]X(w]X(x]X~O!e%QX~P(qO_!}O(T#PO(U!}O(V#PO~O_#QO(V#PO(W#PO(X#QO~Ov#SO!S#TO(`#TO(a#VO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R;{O(TTO(WUO(_VO(m[O~O!Y#ZO!Z#WO!W(fP!W(tP~P+}O![#cO~P`OPYOQYOSfOd!jOe!iOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(TTO(WUO(_VO(m[O~On#mO!Y#iO!z]O#g#lO#h#iO(R;|O!i(qP~P.iO!j#oO(R#nO~O!v#sO!z]O%g#tO~O#i#uO~O!e#vO#i#uO~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!Z$_O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~Oa(dX'x(dX'u(dX!i(dX!W(dX!](dX%h(dX!e(dX~P1qO#Q$dO#^$eO$P$eOP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#t(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX!](eX%h(eX~Oa(eX'x(eX'u(eX!W(eX!i(eXt(eX!e(eX~P4UO#^$eO~O$[$hO$^$gO$e$mO~OSfO!]$nO$h$oO$j$qO~Oh%VOj%cOn%WOp%XOq$tOr$tOx%YOz%ZO|%[O!Q${O!]$|O!g%aO!j$xO#h%bO$V%_O$s%]O$u%^O$x%`O(R$sO(TTO(WUO(_$uO(w$}O(x%POg([P~O!j%dO~O!Q%gO!]%hO(R%fO~O!e%lO~Oa%mO'x%mO~O!O%qO~P%[O(S!lO~P%[O%m%uO~P%[Oh%VO!j%dO(R%fO(S!lO~Oe%|O!j%dO(R%fO~O#t$RO~O!O&RO!]&OO!j&QO%i&UO(R%fO(S!lO(TTO(WUO`)UP~O!v#sO~O%r&WO!Q)QX!])QX(R)QX~O(R&XO~Oj!PO!s&^O%i!QO%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO~Od&cOe&bO!v&`O%g&aO%z&_O~P<POd&fOeyOj!PO!]&eO!s&^O!vxO!z]O%g}O%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO%x!UO~Ob&iO#^&lO%i&gO(S!lO~P=UO!j&mO!s&qO~O!j#oO~O!]XO~Oa%mO'v&yO'x%mO~Oa%mO'v&|O'x%mO~Oa%mO'v'OO'x%mO~O'u]X!W]Xt]X!i]X&Y]X!]]X%h]X!e]X~P(qO!`']O!a'UO!b'UO(S!lO(TTO(WUO~Oq'SO!Q'RO!Y'VO(c'QO![(gP![(vP~P@]Ol'`O!]'^O(R%fO~Oe'eO!j%dO(R%fO~O!O&RO!j&QO~Oq!nO!Q!oO!z;wO#R!pO#S!pO#U!pO#V!pO(S!lO(TTO(WUO(c!mO(m!sO~O!`'kO!a'jO!b'jO#T!pO#Y'lO#Z'lO~PAwOa%mOh%VO!e#vO!j%dO'x%mO(p'nO~O!n'rO#^'pO~PCVOq!nO!Q!oO(TTO(WUO(c!mO(m!sO~O!]XOq(kX!Q(kX!`(kX!a(kX!b(kX!z(kX#R(kX#S(kX#T(kX#U(kX#V(kX#Y(kX#Z(kX(S(kX(T(kX(W(kX(c(kX(m(kX~O!a'jO!b'jO(S!lO~PCuO'}'vO(O'vO(P'xO~O_!}O(T'zO(U!}O(V'zO~O_#QO(V'zO(W'zO(X#QO~Ot'|O~P%[Ov#SO!S#TO(`#TO(a(PO~O!Y(RO!W'UX!W'[X!Z'UX!Z'[X~P+}O!Z(TO!W(fX~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!Z(TO!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~O!W(fX~PGpO!W(YO~O!W(sX!Z(sX!e(sX!i(sX(p(sX~O#^(sX#i#bX![(sX~PIsO#^(ZO!W(uX!Z(uX~O!Z([O!W(tX~O!W(_O~O#^$eO~PIsO![(`O~P`OR#zO!O#yO!Q#{O!j#xO(_VOP!la[!lap!la!Z!la!n!la#P!la#l!la#m!la#n!la#o!la#p!la#q!la#r!la#s!la#t!la#u!la#w!la#y!la#z!la(p!la(w!la(x!la~Oa!la'x!la'u!la!W!la!i!lat!la!]!la%h!la!e!la~PKZO!i(aO~O!e#vO#^(bO(p'nO!Z(rXa(rX'x(rX~O!i(rX~PMvO!Q%gO!]%hO!z]O#g(gO#h(fO(R%fO~O!Z(hO!i(qX~O!i(jO~O!Q%gO!]%hO#h(fO(R%fO~OP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#t(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX~O!e#vO!i(eX~P! dOR(lO!O(kO!j#xO#Q$dO!z!ya!Q!ya~O!v!ya%g!ya!]!ya#g!ya#h!ya(R!ya~P!#eO!v(pO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]XO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~O#i(vO~O!Y(xO!i(iP~P%[O(c(zO(m[O~O!Q(|O!j#xO(c(zO(m[O~OP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]!eO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(R)ZO(TTO(WUO(_VO(m[O~O!Z$_Oa$pa'x$pa'u$pa!i$pa!W$pa!]$pa%h$pa!e$pa~Oj)bO~P!&iOh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|%[O!Q${O!]$|O!g%aO!j$xO#h%bO$V%_O$s%]O$u%^O$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~Og(nP~P!+rO!O)gO!e)fO!]$]X$Y$]X$[$]X$^$]X$e$]X~O!e)fO!](yX$Y(yX$[(yX$^(yX$e(yX~O!O)gO~P!-{O!O)gO!](yX$Y(yX$[(yX$^(yX$e(yX~O!])iO$Y)mO$[)hO$^)hO$e)nO~O!Y)qO~P!(yO$[$hO$^$gO$e)uO~Ol$yX!O$yX#Q$yX'w$yX(w$yX(x$yX~OgkXg$yXlkX!ZkX#^kX~P!/qOv)wO(`)xO(a)zO~Ol*TO!O)|O'w)}O(w$}O(x%PO~Og){O~P!0uOg*UO~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q*WO!]*XO!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(TTO(WUO(_$uO(w$}O(x%PO~O!Y*[O(R*VO!i(|P~P!1dO#i*^O~O!j*_O~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(R*aO(TTO(WUO(_$uO(w$}O(x%PO~O!Y*dO!W(}P~P!3cOp*pOq!nO!Q*fO!`*nO!a*hO!b*hO!j*_O#Y*oO%_*jO(S!lO(TTO(WUO(c!mO~O![*mO~P!5WO#Q$dOl(^X!O(^X'w(^X(w(^X(x(^X!Z(^X#^(^X~Og(^X#}(^X~P!6YOl*uO#^*tOg(]X!Z(]X~O!Z*vOg([X~Oj%cO(R&XOg([P~Oq*yO~O!j+OO~O(R(tO~On+TO!Q%gO!Y#iO!]%hO!z]O#g#lO#h#iO(R%fO!i(qP~O!e#vO#i+UO~O!Q%gO!Y+WO!Z([O!]%hO(R%fO!W(tP~Oq'YO!Q+YO!Y+XO(TTO(WUO(c(zO~O![(vP~P!9]O!Z+ZOa)RX'x)RX~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~Oa!ha!Z!ha'x!ha'u!ha!W!ha!i!hat!ha!]!ha%h!ha!e!ha~P!:TOR#zO!O#yO!Q#{O!j#xO(_VOP!pa[!pap!pa!Z!pa!n!pa#P!pa#l!pa#m!pa#n!pa#o!pa#p!pa#q!pa#r!pa#s!pa#t!pa#u!pa#w!pa#y!pa#z!pa(p!pa(w!pa(x!pa~Oa!pa'x!pa'u!pa!W!pa!i!pat!pa!]!pa%h!pa!e!pa~P!<kOR#zO!O#yO!Q#{O!j#xO(_VOP!ra[!rap!ra!Z!ra!n!ra#P!ra#l!ra#m!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#w!ra#y!ra#z!ra(p!ra(w!ra(x!ra~Oa!ra'x!ra'u!ra!W!ra!i!rat!ra!]!ra%h!ra!e!ra~P!?ROh%VOl+dO!]'^O%h+cO~O!e+fOa(ZX!](ZX'x(ZX!Z(ZX~Oa%mO!]XO'x%mO~Oh%VO!j%dO~Oh%VO!j%dO(R%fO~O!e#vO#i(vO~Ob+qO%i+rO(R+nO(TTO(WUO![)VP~O!Z+sO`)UX~O[+wO~O`+xO~O!]&OO(R%fO(S!lO`)UP~Oh%VO#^+}O~Oh%VOl,QO!]$|O~O!],SO~O!O,UO!]XO~O%m%uO~O!v,ZO~Oe,`O~Ob,aO(R#nO(TTO(WUO![)TP~Oe%|O~O%i!QO(R&XO~P=UO[,fO`,eO~OPYOQYOSfOdzOeyOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!guO!jZO!mYO!nYO!oYO!qvO!vxO!z]O$miO%g}O(TTO(WUO(_VO(m[O~O!]!eO!s!gO$V!kO(R!dO~P!FRO`,eOa%mO'x%mO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oa,kOj!OO!swO%k!OO%l!OO%m!OO~P!HkO!j&mO~O&[,qO~O!],sO~O&m,uO&o,vOP&jaQ&jaS&jaY&jaa&jad&jae&jaj&jan&jap&jaq&jar&jax&jaz&ja|&ja!Q&ja!U&ja!V&ja!]&ja!g&ja!j&ja!m&ja!n&ja!o&ja!q&ja!s&ja!v&ja!z&ja$V&ja$m&ja%g&ja%i&ja%k&ja%l&ja%m&ja%p&ja%r&ja%u&ja%v&ja%x&ja&U&ja&[&ja&^&ja&`&ja&b&ja&e&ja&k&ja&q&ja&s&ja&u&ja&w&ja&y&ja'u&ja(R&ja(T&ja(W&ja(_&ja(m&ja![&ja&c&jab&ja&h&ja~O(R,{O~Oh!cX!Z!PX![!PX!e!PX!e!cX!j!cX#^!PX~O!Z!cX![!cX~P# qO!e-QO#^-POh(hX!Z#fX![#fX!e(hX!j(hX~O!Z(hX![(hX~P#!dOh%VO!e-SO!j%dO!Z!_X![!_X~Oq!nO!Q!oO(TTO(WUO(c!mO~OP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]!eO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(TTO(WUO(_VO(m[O~O(R<rO~P##yO!Z-WO![(gX~O![-YO~O!e-QO#^-PO!Z#fX![#fX~O!Z-ZO![(vX~O![-]O~O!a-^O!b-^O(S!lO~P##hO![-aO~P'_Ol-dO!]'^O~O!W-iO~Oq!ya!`!ya!a!ya!b!ya#R!ya#S!ya#T!ya#U!ya#V!ya#Y!ya#Z!ya(S!ya(T!ya(W!ya(c!ya(m!ya~P!#eO!n-nO#^-lO~PCVO!a-pO!b-pO(S!lO~PCuOa%mO#^-lO'x%mO~Oa%mO!e#vO#^-lO'x%mO~Oa%mO!e#vO!n-nO#^-lO'x%mO(p'nO~O'}'vO(O'vO(P-uO~Ot-vO~O!W'Ua!Z'Ua~P!:TO!Y-zO!W'UX!Z'UX~P%[O!Z(TO!W(fa~O!W(fa~PGpO!Z([O!W(ta~O!Q%gO!Y.OO!]%hO(R%fO!W'[X!Z'[X~O#^.QO!Z(ra!i(raa(ra'x(ra~O!e#vO~P#,PO!Z(hO!i(qa~O!Q%gO!]%hO#h.UO(R%fO~On.ZO!Q%gO!Y.WO!]%hO!z]O#g.YO#h.WO(R%fO!Z'_X!i'_X~OR._O!j#xO~Oh%VOl.bO!]'^O%h.aO~Oa#ai!Z#ai'x#ai'u#ai!W#ai!i#ait#ai!]#ai%h#ai!e#ai~P!:TOl=|O!O)|O'w)}O(w$}O(x%PO~O#i#]aa#]a#^#]a'x#]a!Z#]a!i#]a!]#]a!W#]a~P#.{O#i(^XP(^XR(^X[(^Xa(^Xp(^X!Q(^X!j(^X!n(^X#P(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#s(^X#t(^X#u(^X#w(^X#y(^X#z(^X'x(^X(_(^X(p(^X!i(^X!W(^X'u(^Xt(^X!](^X%h(^X!e(^X~P!6YO!Z.oO!i(iX~P!:TO!i.rO~O!W.tO~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O(_VO[#kia#kip#ki!Z#ki#P#ki#m#ki#n#ki#o#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#l#ki~P#2kO#l$OO~P#2kOP$[OR#zOp$aO!O#yO!Q#{O!j#xO!n$[O#l$OO#m$PO#n$PO#o$PO(_VO[#kia#ki!Z#ki#P#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#p#ki~P#5YO#p$QO~P#5YOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO(_VOa#ki!Z#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#u#ki~P#7wOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO(_VO(x#}Oa#ki!Z#ki#y#ki#z#ki'x#ki(p#ki(w#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#w$UO~P#:_O#w#ki~P#:_O#u$SO~P#7wOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO(_VO(w#|O(x#}Oa#ki!Z#ki#z#ki'x#ki(p#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#y#ki~P#=TO#y$WO~P#=TOP]XR]X[]Xp]X!O]X!Q]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X!Z]X![]X~O#}]X~P#?rOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO#w<VO#y<XO#z<YO(_VO(p$YO(w#|O(x#}O~O#}.vO~P#BPO#Q$dO#^<`O$P<`O#}(eX![(eX~P! dOa'ba!Z'ba'x'ba'u'ba!i'ba!W'bat'ba!]'ba%h'ba!e'ba~P!:TO[#kia#kip#ki!Z#ki#P#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O#l$OO#m$PO#n$PO#o$PO(_VO(w#ki(x#ki~P#EROl=|O!O)|O'w)}O(w$}O(x%POP#kiR#ki!Q#ki!j#ki!n#ki#l#ki#m#ki#n#ki#o#ki(_#ki~P#ERO!Z.zOg(nX~P!0uOg.|O~Oa$Oi!Z$Oi'x$Oi'u$Oi!W$Oi!i$Oit$Oi!]$Oi%h$Oi!e$Oi~P!:TO$[.}O$^.}O~O$[/OO$^/OO~O!e)fO#^/PO!]$bX$Y$bX$[$bX$^$bX$e$bX~O!Y/QO~O!])iO$Y/SO$[)hO$^)hO$e/TO~O!Z<ZO![(dX~P#BPO![/UO~O!e)fO$e(yX~O$e/WO~Ot/XO~P!&iOv)wO(`)xO(a/[O~O!Q/_O~O(w$}Ol%`a!O%`a'w%`a(x%`a!Z%`a#^%`a~Og%`a#}%`a~P#LTO(x%POl%ba!O%ba'w%ba(w%ba!Z%ba#^%ba~Og%ba#}%ba~P#LvO!ZfX!efX!ifX!i$yX(pfX~P!/qO!Y/hO!Z([O(R/gO!W(tP!W(}P~P!1dOp*pO!`*nO!a*hO!b*hO!j*_O#Y*oO%_*jO(S!lO(TTO(WUO~Oq<oO!Q/iO!Y+XO![*mO(c<nO![(vP~P#NaO!i/jO~P#.{O!Z/kO!e#vO(p'nO!i(|X~O!i/pO~O!Q%gO!Y*[O!]%hO(R%fO!i(|P~O#i/rO~O!W$yX!Z$yX!e%QX~P!/qO!Z/sO!W(}X~P#.{O!e/uO~O!W/wO~OnkO(R/xO~P.iOh%VOp/}O!e#vO!j%dO(p'nO~O!e+fO~Oa%mO!Z0RO'x%mO~O![0TO~P!5WO!a0UO!b0UO(S!lO~P##hOq!nO!Q0VO(TTO(WUO(c!mO~O#Y0XO~Og%`a!Z%`a#^%`a#}%`a~P!0uOg%ba!Z%ba#^%ba#}%ba~P!0uOj%cO(R&XOg'kX!Z'kX~O!Z*vOg([a~Og0bO~OR0cO!O0cO!Q0dO#Q$dOl{a'w{a(w{a(x{a!Z{a#^{a~Og{a#}{a~P$&dO!O)|O'w)}Ol$ra(w$ra(x$ra!Z$ra#^$ra~Og$ra#}$ra~P$'`O!O)|O'w)}Ol$ta(w$ta(x$ta!Z$ta#^$ta~Og$ta#}$ta~P$(RO#i0gO~Og%Sa!Z%Sa#^%Sa#}%Sa~P!0uOl0iO#^0hOg(]a!Z(]a~O!e#vO~O#i0lO~O!Z+ZOa)Ra'x)Ra~OR#zO!O#yO!Q#{O!j#xO(_VOP!pi[!pip!pi!Z!pi!n!pi#P!pi#l!pi#m!pi#n!pi#o!pi#p!pi#q!pi#r!pi#s!pi#t!pi#u!pi#w!pi#y!pi#z!pi(p!pi(w!pi(x!pi~Oa!pi'x!pi'u!pi!W!pi!i!pit!pi!]!pi%h!pi!e!pi~P$*OOh%VOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(TTO(WUO(_$uO(w$}O(x%PO~On0vO%[0wO(R0tO~P$,fO!e+fOa(Za!](Za'x(Za!Z(Za~O#i0|O~O[]X!ZfX![fX~O!Z0}O![)VX~O![1PO~O[1QO~Ob1SO(R+nO(TTO(WUO~O!]&OO(R%fO`'sX!Z'sX~O!Z+sO`)Ua~O!i1VO~P!:TO[1YO~O`1ZO~O#^1^O~Ol1aO!]$|O~O(c(zO![)SP~Oh%VOl1jO!]1gO%h1iO~O[1tO!Z1rO![)TX~O![1uO~O`1wOa%mO'x%mO~O(R#nO(TTO(WUO~O#Q$dO#^$eO$P$eOP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX~O#t1zO&Y1{Oa(eX~P$2PO#^$eO#t1zO&Y1{O~Oa1}O~P%[Oa2PO~O&c2SOP&aiQ&aiS&aiY&aia&aid&aie&aij&ain&aip&aiq&air&aix&aiz&ai|&ai!Q&ai!U&ai!V&ai!]&ai!g&ai!j&ai!m&ai!n&ai!o&ai!q&ai!s&ai!v&ai!z&ai$V&ai$m&ai%g&ai%i&ai%k&ai%l&ai%m&ai%p&ai%r&ai%u&ai%v&ai%x&ai&U&ai&[&ai&^&ai&`&ai&b&ai&e&ai&k&ai&q&ai&s&ai&u&ai&w&ai&y&ai'u&ai(R&ai(T&ai(W&ai(_&ai(m&ai![&aib&ai&h&ai~Ob2YO![2WO&h2XO~P`O!]XO!j2[O~O&o,vOP&jiQ&jiS&jiY&jia&jid&jie&jij&jin&jip&jiq&jir&jix&jiz&ji|&ji!Q&ji!U&ji!V&ji!]&ji!g&ji!j&ji!m&ji!n&ji!o&ji!q&ji!s&ji!v&ji!z&ji$V&ji$m&ji%g&ji%i&ji%k&ji%l&ji%m&ji%p&ji%r&ji%u&ji%v&ji%x&ji&U&ji&[&ji&^&ji&`&ji&b&ji&e&ji&k&ji&q&ji&s&ji&u&ji&w&ji&y&ji'u&ji(R&ji(T&ji(W&ji(_&ji(m&ji![&ji&c&jib&ji&h&ji~O!W2bO~O!Z!_a![!_a~P#BPOq!nO!Q!oO!Y2hO(c!mO!Z'VX!['VX~P@]O!Z-WO![(ga~O!Z']X![']X~P!9]O!Z-ZO![(va~O![2oO~P'_Oa%mO#^2xO'x%mO~Oa%mO!e#vO#^2xO'x%mO~Oa%mO!e#vO!n2|O#^2xO'x%mO(p'nO~Oa%mO'x%mO~P!:TO!Z$_Ot$pa~O!W'Ui!Z'Ui~P!:TO!Z(TO!W(fi~O!Z([O!W(ti~O!W(ui!Z(ui~P!:TO!Z(ri!i(ria(ri'x(ri~P!:TO#^3OO!Z(ri!i(ria(ri'x(ri~O!Z(hO!i(qi~O!Q%gO!]%hO!z]O#g3TO#h3SO(R%fO~O!Q%gO!]%hO#h3SO(R%fO~Ol3[O!]'^O%h3ZO~Oh%VOl3[O!]'^O%h3ZO~O#i%`aP%`aR%`a[%`aa%`ap%`a!Q%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a'x%`a(_%`a(p%`a!i%`a!W%`a'u%`at%`a!]%`a%h%`a!e%`a~P#LTO#i%baP%baR%ba[%baa%bap%ba!Q%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba'x%ba(_%ba(p%ba!i%ba!W%ba'u%bat%ba!]%ba%h%ba!e%ba~P#LvO#i%`aP%`aR%`a[%`aa%`ap%`a!Q%`a!Z%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a'x%`a(_%`a(p%`a!i%`a!W%`a'u%`a#^%`at%`a!]%`a%h%`a!e%`a~P#.{O#i%baP%baR%ba[%baa%bap%ba!Q%ba!Z%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba'x%ba(_%ba(p%ba!i%ba!W%ba'u%ba#^%bat%ba!]%ba%h%ba!e%ba~P#.{O#i{aP{a[{aa{ap{a!j{a!n{a#P{a#l{a#m{a#n{a#o{a#p{a#q{a#r{a#s{a#t{a#u{a#w{a#y{a#z{a'x{a(_{a(p{a!i{a!W{a'u{at{a!]{a%h{a!e{a~P$&dO#i$raP$raR$ra[$raa$rap$ra!Q$ra!j$ra!n$ra#P$ra#l$ra#m$ra#n$ra#o$ra#p$ra#q$ra#r$ra#s$ra#t$ra#u$ra#w$ra#y$ra#z$ra'x$ra(_$ra(p$ra!i$ra!W$ra'u$rat$ra!]$ra%h$ra!e$ra~P$'`O#i$taP$taR$ta[$taa$tap$ta!Q$ta!j$ta!n$ta#P$ta#l$ta#m$ta#n$ta#o$ta#p$ta#q$ta#r$ta#s$ta#t$ta#u$ta#w$ta#y$ta#z$ta'x$ta(_$ta(p$ta!i$ta!W$ta'u$tat$ta!]$ta%h$ta!e$ta~P$(RO#i%SaP%SaR%Sa[%Saa%Sap%Sa!Q%Sa!Z%Sa!j%Sa!n%Sa#P%Sa#l%Sa#m%Sa#n%Sa#o%Sa#p%Sa#q%Sa#r%Sa#s%Sa#t%Sa#u%Sa#w%Sa#y%Sa#z%Sa'x%Sa(_%Sa(p%Sa!i%Sa!W%Sa'u%Sa#^%Sat%Sa!]%Sa%h%Sa!e%Sa~P#.{Oa#aq!Z#aq'x#aq'u#aq!W#aq!i#aqt#aq!]#aq%h#aq!e#aq~P!:TO!Y3dO!Z'WX!i'WX~P%[O!Z.oO!i(ia~O!Z.oO!i(ia~P!:TO!W3gO~O#}!la![!la~PKZO#}!ha!Z!ha![!ha~P#BPO#}!pa![!pa~P!<kO#}!ra![!ra~P!?ROg'ZX!Z'ZX~P!+rO!Z.zOg(na~OSfO!]3{O$c3|O~O![4QO~Ot4RO~P#.{Oa$lq!Z$lq'x$lq'u$lq!W$lq!i$lqt$lq!]$lq%h$lq!e$lq~P!:TO!W4TO~P!&iO!Q4UO~O!O)|O'w)}O(x%POl'ga(w'ga!Z'ga#^'ga~Og'ga#}'ga~P%+uO!O)|O'w)}Ol'ia(w'ia(x'ia!Z'ia#^'ia~Og'ia#}'ia~P%,hO(p$YO~P#.{O!WfX!W$yX!ZfX!Z$yX!e%QX#^fX~P!/qO(R<xO~P!1dO!Q%gO!Y4XO!]%hO(R%fO!Z'cX!i'cX~O!Z/kO!i(|a~O!Z/kO!e#vO!i(|a~O!Z/kO!e#vO(p'nO!i(|a~Og${i!Z${i#^${i#}${i~P!0uO!Y4aO!W'eX!Z'eX~P!3cO!Z/sO!W(}a~O!Z/sO!W(}a~P#.{OP]XR]X[]Xp]X!O]X!Q]X!W]X!Z]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X~O!e%XX#t%XX~P%0XO!e#vO#t4fO~Oh%VO!e#vO!j%dO~Oh%VOp4kO!j%dO(p'nO~Op4pO!e#vO(p'nO~Oq!nO!Q4qO(TTO(WUO(c!mO~O(w$}Ol%`i!O%`i'w%`i(x%`i!Z%`i#^%`i~Og%`i#}%`i~P%3xO(x%POl%bi!O%bi'w%bi(w%bi!Z%bi#^%bi~Og%bi#}%bi~P%4kOg(]i!Z(]i~P!0uO#^4wOg(]i!Z(]i~P!0uO!i4zO~Oa$nq!Z$nq'x$nq'u$nq!W$nq!i$nqt$nq!]$nq%h$nq!e$nq~P!:TO!W5QO~O!Z5RO!])OX~P#.{Oa]Xa$yX!]]X!]$yX%]]X'x]X'x$yX!Z]X!Z$yX~P!/qO%]5UOa%Za!]%Za'x%Za!Z%Za~OlmX!OmX'wmX(wmX(xmX~P%7nOn5VO(R#nO~Ob5]O%i5^O(R+nO(TTO(WUO!Z'rX!['rX~O!Z0}O![)Va~O[5bO~O`5cO~Oa%mO'x%mO~P#.{O!Z5kO#^5mO![)SX~O![5nO~Op5tOq!nO!Q*fO!`!yO!a!vO!b!vO!z;wO#R!pO#S!pO#T!pO#U!pO#V!pO#Y5sO#Z!zO(S!lO(TTO(WUO(c!mO(m!sO~O![5rO~P%:ROl5yO!]1gO%h5xO~Oh%VOl5yO!]1gO%h5xO~Ob6QO(R#nO(TTO(WUO!Z'qX!['qX~O!Z1rO![)Ta~O(TTO(WUO(c6SO~O`6WO~O#t6ZO&Y6[O~PMvO!i6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO![6dO&h2XO~P`O!e6fO~O!e6hOh(hi!Z(hi![(hi!e(hi!j(hip(hi(p(hi~O!Z#fi![#fi~P#BPO#^6iO!Z#fi![#fi~O!Z!_i![!_i~P#BPOa%mO#^6rO'x%mO~Oa%mO!e#vO#^6rO'x%mO~O!Z(rq!i(rqa(rq'x(rq~P!:TO!Z(hO!i(qq~O!Q%gO!]%hO#h6yO(R%fO~O!]'^O%h6|O~Ol7QO!]'^O%h6|O~O#i'gaP'gaR'ga['gaa'gap'ga!Q'ga!j'ga!n'ga#P'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#t'ga#u'ga#w'ga#y'ga#z'ga'x'ga(_'ga(p'ga!i'ga!W'ga'u'gat'ga!]'ga%h'ga!e'ga~P%+uO#i'iaP'iaR'ia['iaa'iap'ia!Q'ia!j'ia!n'ia#P'ia#l'ia#m'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#w'ia#y'ia#z'ia'x'ia(_'ia(p'ia!i'ia!W'ia'u'iat'ia!]'ia%h'ia!e'ia~P%,hO#i${iP${iR${i[${ia${ip${i!Q${i!Z${i!j${i!n${i#P${i#l${i#m${i#n${i#o${i#p${i#q${i#r${i#s${i#t${i#u${i#w${i#y${i#z${i'x${i(_${i(p${i!i${i!W${i'u${i#^${it${i!]${i%h${i!e${i~P#.{O#i%`iP%`iR%`i[%`ia%`ip%`i!Q%`i!j%`i!n%`i#P%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#t%`i#u%`i#w%`i#y%`i#z%`i'x%`i(_%`i(p%`i!i%`i!W%`i'u%`it%`i!]%`i%h%`i!e%`i~P%3xO#i%biP%biR%bi[%bia%bip%bi!Q%bi!j%bi!n%bi#P%bi#l%bi#m%bi#n%bi#o%bi#p%bi#q%bi#r%bi#s%bi#t%bi#u%bi#w%bi#y%bi#z%bi'x%bi(_%bi(p%bi!i%bi!W%bi'u%bit%bi!]%bi%h%bi!e%bi~P%4kO!Z'Wa!i'Wa~P!:TO!Z.oO!i(ii~O#}#ai!Z#ai![#ai~P#BPOP$[OR#zO!O#yO!Q#{O!j#xO!n$[O(_VO[#kip#ki#P#ki#m#ki#n#ki#o#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#l#ki~P%MQO#l<PO~P%MQOP$[OR#zOp<]O!O#yO!Q#{O!j#xO!n$[O#l<PO#m<QO#n<QO#o<QO(_VO[#ki#P#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#p#ki~P& YO#p<RO~P& YOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO(_VO#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#u#ki~P&#bOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO(_VO(x#}O#y#ki#z#ki#}#ki(p#ki(w#ki!Z#ki![#ki~O#w<VO~P&%cO#w#ki~P&%cO#u<TO~P&#bOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO#w<VO(_VO(w#|O(x#}O#z#ki#}#ki(p#ki!Z#ki![#ki~O#y#ki~P&'rO#y<XO~P&'rOa#{y!Z#{y'x#{y'u#{y!W#{y!i#{yt#{y!]#{y%h#{y!e#{y~P!:TO[#kip#ki#P#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki!Z#ki![#ki~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O#l<PO#m<QO#n<QO#o<QO(_VO(w#ki(x#ki~P&*nOl=}O!O)|O'w)}O(w$}O(x%POP#kiR#ki!Q#ki!j#ki!n#ki#l#ki#m#ki#n#ki#o#ki(_#ki~P&*nO#Q$dOP(^XR(^X[(^Xl(^Xp(^X!O(^X!Q(^X!j(^X!n(^X#P(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#s(^X#t(^X#u(^X#w(^X#y(^X#z(^X#}(^X'w(^X(_(^X(p(^X(w(^X(x(^X!Z(^X![(^X~O#}$Oi!Z$Oi![$Oi~P#BPO#}!pi![!pi~P$*OOg'Za!Z'Za~P!0uO![7dO~O!Z'ba!['ba~P#BPO!W7eO~P#.{O!e#vO(p'nO!Z'ca!i'ca~O!Z/kO!i(|i~O!Z/kO!e#vO!i(|i~Og${q!Z${q#^${q#}${q~P!0uO!W'ea!Z'ea~P#.{O!e7lO~O!Z/sO!W(}i~P#.{O!Z/sO!W(}i~O!W7oO~Oh%VOp7tO!j%dO(p'nO~O!e#vO#t7vO~Op7yO!e#vO(p'nO~O!O)|O'w)}O(x%POl'ha(w'ha!Z'ha#^'ha~Og'ha#}'ha~P&3oO!O)|O'w)}Ol'ja(w'ja(x'ja!Z'ja#^'ja~Og'ja#}'ja~P&4bO!W7{O~Og$}q!Z$}q#^$}q#}$}q~P!0uOg(]q!Z(]q~P!0uO#^7|Og(]q!Z(]q~P!0uOa$ny!Z$ny'x$ny'u$ny!W$ny!i$nyt$ny!]$ny%h$ny!e$ny~P!:TO!e6hO~O!Z5RO!])Oa~O!]'^OP$SaR$Sa[$Sap$Sa!O$Sa!Q$Sa!Z$Sa!j$Sa!n$Sa#P$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#t$Sa#u$Sa#w$Sa#y$Sa#z$Sa(_$Sa(p$Sa(w$Sa(x$Sa~O%h6|O~P&7SO%]8QOa%Zi!]%Zi'x%Zi!Z%Zi~Oa#ay!Z#ay'x#ay'u#ay!W#ay!i#ayt#ay!]#ay%h#ay!e#ay~P!:TO[8SO~Ob8UO(R+nO(TTO(WUO~O!Z0}O![)Vi~O`8YO~O(c(zO!Z'nX!['nX~O!Z5kO![)Sa~O![8cO~P%:RO(m!sO~P$$oO#Y8dO~O!]1gO~O!]1gO%h8fO~Ol8iO!]1gO%h8fO~O[8nO!Z'qa!['qa~O!Z1rO![)Ti~O!i8rO~O!i8sO~O!i8vO~O!i8vO~P%[Oa8xO~O!e8yO~O!i8zO~O!Z(ui![(ui~P#BPOa%mO#^9SO'x%mO~O!Z(ry!i(rya(ry'x(ry~P!:TO!Z(hO!i(qy~O%h9VO~P&7SO!]'^O%h9VO~O#i${qP${qR${q[${qa${qp${q!Q${q!Z${q!j${q!n${q#P${q#l${q#m${q#n${q#o${q#p${q#q${q#r${q#s${q#t${q#u${q#w${q#y${q#z${q'x${q(_${q(p${q!i${q!W${q'u${q#^${qt${q!]${q%h${q!e${q~P#.{O#i'haP'haR'ha['haa'hap'ha!Q'ha!j'ha!n'ha#P'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#w'ha#y'ha#z'ha'x'ha(_'ha(p'ha!i'ha!W'ha'u'hat'ha!]'ha%h'ha!e'ha~P&3oO#i'jaP'jaR'ja['jaa'jap'ja!Q'ja!j'ja!n'ja#P'ja#l'ja#m'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#w'ja#y'ja#z'ja'x'ja(_'ja(p'ja!i'ja!W'ja'u'jat'ja!]'ja%h'ja!e'ja~P&4bO#i$}qP$}qR$}q[$}qa$}qp$}q!Q$}q!Z$}q!j$}q!n$}q#P$}q#l$}q#m$}q#n$}q#o$}q#p$}q#q$}q#r$}q#s$}q#t$}q#u$}q#w$}q#y$}q#z$}q'x$}q(_$}q(p$}q!i$}q!W$}q'u$}q#^$}qt$}q!]$}q%h$}q!e$}q~P#.{O!Z'Wi!i'Wi~P!:TO#}#aq!Z#aq![#aq~P#BPO(w$}OP%`aR%`a[%`ap%`a!Q%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a#}%`a(_%`a(p%`a!Z%`a![%`a~Ol%`a!O%`a'w%`a(x%`a~P&HgO(x%POP%baR%ba[%bap%ba!Q%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba#}%ba(_%ba(p%ba!Z%ba![%ba~Ol%ba!O%ba'w%ba(w%ba~P&JnOl=}O!O)|O'w)}O(x%PO~P&HgOl=}O!O)|O'w)}O(w$}O~P&JnOR0cO!O0cO!Q0dO#Q$dOP{a[{al{ap{a!j{a!n{a#P{a#l{a#m{a#n{a#o{a#p{a#q{a#r{a#s{a#t{a#u{a#w{a#y{a#z{a#}{a'w{a(_{a(p{a(w{a(x{a!Z{a![{a~O!O)|O'w)}OP$raR$ra[$ral$rap$ra!Q$ra!j$ra!n$ra#P$ra#l$ra#m$ra#n$ra#o$ra#p$ra#q$ra#r$ra#s$ra#t$ra#u$ra#w$ra#y$ra#z$ra#}$ra(_$ra(p$ra(w$ra(x$ra!Z$ra![$ra~O!O)|O'w)}OP$taR$ta[$tal$tap$ta!Q$ta!j$ta!n$ta#P$ta#l$ta#m$ta#n$ta#o$ta#p$ta#q$ta#r$ta#s$ta#t$ta#u$ta#w$ta#y$ta#z$ta#}$ta(_$ta(p$ta(w$ta(x$ta!Z$ta![$ta~Ol=}O!O)|O'w)}O(w$}O(x%PO~OP%SaR%Sa[%Sap%Sa!Q%Sa!j%Sa!n%Sa#P%Sa#l%Sa#m%Sa#n%Sa#o%Sa#p%Sa#q%Sa#r%Sa#s%Sa#t%Sa#u%Sa#w%Sa#y%Sa#z%Sa#}%Sa(_%Sa(p%Sa!Z%Sa![%Sa~P'%sO#}$lq!Z$lq![$lq~P#BPO#}$nq!Z$nq![$nq~P#BPO![9dO~O#}9eO~P!0uO!e#vO!Z'ci!i'ci~O!e#vO(p'nO!Z'ci!i'ci~O!Z/kO!i(|q~O!W'ei!Z'ei~P#.{O!Z/sO!W(}q~Op9lO!e#vO(p'nO~O[9nO!W9mO~P#.{O!W9mO~O!e#vO#t9tO~Og(]y!Z(]y~P!0uO!Z'la!]'la~P#.{Oa%Zq!]%Zq'x%Zq!Z%Zq~P#.{O[9yO~O!Z0}O![)Vq~O#^9}O!Z'na!['na~O!Z5kO![)Si~P#BPO!Q:PO~O!]1gO%h:SO~O(TTO(WUO(c:XO~O!Z1rO![)Tq~O!i:[O~O!i:]O~O!i:^O~O!i:^O~P%[O#^:aO!Z#fy![#fy~O!Z#fy![#fy~P#BPO%h:fO~P&7SO!]'^O%h:fO~O#}#{y!Z#{y![#{y~P#BPOP${iR${i[${ip${i!Q${i!j${i!n${i#P${i#l${i#m${i#n${i#o${i#p${i#q${i#r${i#s${i#t${i#u${i#w${i#y${i#z${i#}${i(_${i(p${i!Z${i![${i~P'%sO!O)|O'w)}O(x%POP'gaR'ga['gal'gap'ga!Q'ga!j'ga!n'ga#P'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#t'ga#u'ga#w'ga#y'ga#z'ga#}'ga(_'ga(p'ga(w'ga!Z'ga!['ga~O!O)|O'w)}OP'iaR'ia['ial'iap'ia!Q'ia!j'ia!n'ia#P'ia#l'ia#m'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#w'ia#y'ia#z'ia#}'ia(_'ia(p'ia(w'ia(x'ia!Z'ia!['ia~O(w$}OP%`iR%`i[%`il%`ip%`i!O%`i!Q%`i!j%`i!n%`i#P%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#t%`i#u%`i#w%`i#y%`i#z%`i#}%`i'w%`i(_%`i(p%`i(x%`i!Z%`i![%`i~O(x%POP%biR%bi[%bil%bip%bi!O%bi!Q%bi!j%bi!n%bi#P%bi#l%bi#m%bi#n%bi#o%bi#p%bi#q%bi#r%bi#s%bi#t%bi#u%bi#w%bi#y%bi#z%bi#}%bi'w%bi(_%bi(p%bi(w%bi!Z%bi![%bi~O#}$ny!Z$ny![$ny~P#BPO#}#ay!Z#ay![#ay~P#BPO!e#vO!Z'cq!i'cq~O!Z/kO!i(|y~O!W'eq!Z'eq~P#.{Op:pO!e#vO(p'nO~O[:tO!W:sO~P#.{O!W:sO~Og(]!R!Z(]!R~P!0uOa%Zy!]%Zy'x%Zy!Z%Zy~P#.{O!Z0}O![)Vy~O!Z5kO![)Sq~O(R:zO~O!]1gO%h:}O~O!i;QO~O%h;VO~P&7SOP${qR${q[${qp${q!Q${q!j${q!n${q#P${q#l${q#m${q#n${q#o${q#p${q#q${q#r${q#s${q#t${q#u${q#w${q#y${q#z${q#}${q(_${q(p${q!Z${q![${q~P'%sO!O)|O'w)}O(x%POP'haR'ha['hal'hap'ha!Q'ha!j'ha!n'ha#P'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#w'ha#y'ha#z'ha#}'ha(_'ha(p'ha(w'ha!Z'ha!['ha~O!O)|O'w)}OP'jaR'ja['jal'jap'ja!Q'ja!j'ja!n'ja#P'ja#l'ja#m'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#w'ja#y'ja#z'ja#}'ja(_'ja(p'ja(w'ja(x'ja!Z'ja!['ja~OP$}qR$}q[$}qp$}q!Q$}q!j$}q!n$}q#P$}q#l$}q#m$}q#n$}q#o$}q#p$}q#q$}q#r$}q#s$}q#t$}q#u$}q#w$}q#y$}q#z$}q#}$}q(_$}q(p$}q!Z$}q![$}q~P'%sOg%d!Z!Z%d!Z#^%d!Z#}%d!Z~P!0uO!W;ZO~P#.{Op;[O!e#vO(p'nO~O[;^O!W;ZO~P#.{O!Z'nq!['nq~P#BPO!Z#f!Z![#f!Z~P#BPO#i%d!ZP%d!ZR%d!Z[%d!Za%d!Zp%d!Z!Q%d!Z!Z%d!Z!j%d!Z!n%d!Z#P%d!Z#l%d!Z#m%d!Z#n%d!Z#o%d!Z#p%d!Z#q%d!Z#r%d!Z#s%d!Z#t%d!Z#u%d!Z#w%d!Z#y%d!Z#z%d!Z'x%d!Z(_%d!Z(p%d!Z!i%d!Z!W%d!Z'u%d!Z#^%d!Zt%d!Z!]%d!Z%h%d!Z!e%d!Z~P#.{Op;fO!e#vO(p'nO~O!W;gO~P#.{Op;nO!e#vO(p'nO~O!W;oO~P#.{OP%d!ZR%d!Z[%d!Zp%d!Z!Q%d!Z!j%d!Z!n%d!Z#P%d!Z#l%d!Z#m%d!Z#n%d!Z#o%d!Z#p%d!Z#q%d!Z#r%d!Z#s%d!Z#t%d!Z#u%d!Z#w%d!Z#y%d!Z#z%d!Z#}%d!Z(_%d!Z(p%d!Z!Z%d!Z![%d!Z~P'%sOp;rO!e#vO(p'nO~Ot(dX~P1qO!O%qO~P!(yO(S!lO~P!(yO!WfX!ZfX#^fX~P%0XOP]XR]X[]Xp]X!O]X!Q]X!Z]X!ZfX!j]X!n]X#P]X#Q]X#^]X#^fX#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X~O!efX!i]X!ifX(pfX~P'JlOP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]XO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(R)ZO(TTO(WUO(_VO(m[O~O!Z<ZO![$pa~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<fO!Q${O!]$|O!g=wO!j$xO#h<lO$V%_O$s<hO$u<jO$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~Oj)bO~P( bOp!cX(p!cX~P# qOp(hX(p(hX~P#!dO![]X![fX~P'JlO!WfX!W$yX!ZfX!Z$yX#^fX~P!/qO#i<OO~O!e#vO#i<OO~O#^<`O~O#t<SO~O#^<pO!Z(uX![(uX~O#^<`O!Z(sX![(sX~O#i<qO~Og<sO~P!0uO#i<yO~O#i<zO~O!e#vO#i<{O~O!e#vO#i<qO~O#}<|O~P#BPO#i<}O~O#i=OO~O#i=TO~O#i=UO~O#i=VO~O#i=WO~O#}=XO~P!0uO#}=YO~P!0uO#Q#R#S#U#V#Y#g#h#s$m$s$u$x%[%]%g%h%i%p%r%u%v%x%z~'|T#m!V'z(S#nq#l#op!O'{$['{(R$^(c~",
  goto: "$8f)ZPPPPPP)[PP)_P)pP+Q/VPPPP6aPP6wPP<oP@cP@yP@yPPP@yPCRP@yP@yP@yPCVPC[PCyPHsPPPHwPPPPHwKzPPPLQLrPHwPHwPP! QHwPPPHwPHwP!#XHwP!&o!'t!'}P!(q!(u!(q!,SPPPPPPP!,s!'tPP!-T!.uP!2RHwHw!2W!5d!:Q!:Q!>PPPP!>XHwPPPPPPPPPP!AhP!BuPPHw!DWPHwPHwHwHwHwHwPHw!EjP!HtP!KzP!LO!LY!L^!L^P!HqP!Lb!LbP# hP# lHwPHw# r#$wCV@yP@yP@y@yP#&U@y@y#(h@y#+`@y#-l@y@y#.[#0p#0p#0u#1O#0p#1ZPP#0pP@y#1s@y#5r@y@y6aPPP#9wPPP#:b#:bP#:bP#:x#:bPP#;OP#:uP#:u#;c#:u#;}#<T#<W)_#<Z)_P#<b#<b#<bP)_P)_P)_P)_PP)_P#<h#<kP#<k)_P#<oP#<rP)_P)_P)_P)_P)_P)_)_PP#<x#=O#=Z#=a#=g#=m#=s#>R#>X#>c#>i#>s#>y#?Z#?a#@R#@e#@k#@q#AP#Af#CZ#Ci#Cp#E[#Ej#G[#Gj#Gp#Gv#G|#HW#H^#Hd#Hn#IQ#IWPPPPPPPPPPP#I^PPPPPPP#JR#MY#Nr#Ny$ RPPP$&mP$&v$)o$0Y$0]$0`$1_$1b$1i$1qP$1w$1zP$2h$2l$3d$4r$4w$5_PP$5d$5j$5n$5q$5u$5y$6u$7^$7u$7y$7|$8P$8V$8Y$8^$8bR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0u+fQ1S+rQ1y,fQ3W.bQ5V0wQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 378,
  context: trackNewline,
  nodeProps: [
    ["isolate", -8,5,6,14,35,37,49,51,53,""],
    ["group", -26,9,17,19,66,206,210,214,215,217,220,223,233,235,241,243,245,247,250,256,262,264,266,268,270,272,273,"Statement",-34,13,14,30,33,34,40,49,52,53,55,60,68,70,74,78,80,82,83,108,109,118,119,135,138,140,141,142,143,144,146,147,166,168,170,"Expression",-23,29,31,35,39,41,43,172,174,176,177,179,180,181,183,184,185,187,188,189,200,202,204,205,"Type",-3,86,101,107,"ClassItem"],
    ["openedBy", 23,"<",36,"InterpolationStart",54,"[",58,"{",71,"(",159,"JSXStartCloseTag"],
    ["closedBy", -2,24,167,">",38,"InterpolationEnd",48,"]",59,"}",72,")",164,"JSXEndTag"]
  ],
  propSources: [jsHighlight],
  skippedNodes: [0,5,6,276],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(X!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(X!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(UpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(UpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Up(X!b'z0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(V#S$h&j'{0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Up(X!b'{0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!n),Q(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(T':f$h&j(X!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(X!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(X!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(X!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(X!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Up(X!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Up(X!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(X!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(X!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(UpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(UpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Up(X!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(m%1l(Up(X!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Up(X!b$[#t(R,2j(c$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Up(X!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Up(X!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(x+JY$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(W';W$h&j(UpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(UpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(UpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(UpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(UpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!j/.^$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!i!Lf$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Up(X!b(S%&f#o(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Up(X!b#l(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Up(X!bp+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Z+Jf$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Up(X!b!O.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!Y!L^$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Up(X!b#m(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(X!b!V7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!V7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!V7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!V7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!V7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(X!b!V7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(X!b!V7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(X!b!V7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(X!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(X!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Up!V7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Up!V7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Up!V7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Up!V7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(UpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(UpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Up(X!b!V7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Up(X!b!V7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Up(X!b!V7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Up(X!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Up(X!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Up(X!b'|0/l!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Up(X!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(X!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(X!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(UpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(UpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Up(X!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!e$b$h&j#})Lv(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#P-<U(Up(X!b$m7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#p(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#q(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#^*!Y$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#i(Cl$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#q(Ch$e#|$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#q(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#p(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#p(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(p(Ct$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!z$Ip$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!Q0,v$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!W#)l$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Up(X!b(_+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Up(X!b(R,2j$^#t(c$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Up(X!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!]#Hb(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(w+JY$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_![(CdtBr$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!o7`$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Up(X!b'z0/l$[#t(R,2j(c$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Up(X!b'{0/l$[#t(R,2j(c$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [noSemicolon, noSemicolonType, operatorToken, jsx, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, insertSemicolon, new lr.LocalTokenGroup("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOv~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!S~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(a~~", 141, 338), new lr.LocalTokenGroup("j~RQYZXz{^~^O(O~~aP!P!Qd~iO(P~~", 25, 321)],
  topRules: {"Script":[0,7],"SingleExpression":[1,274],"SingleClassItem":[2,275]},
  dialects: {jsx: 0, ts: 15091},
  dynamicPrecedences: {"78":1,"80":1,"92":1,"168":1,"198":1},
  specialized: [{term: 325, get: (value) => spec_identifier[value] || -1},{term: 341, get: (value) => spec_word[value] || -1},{term: 93, get: (value) => spec_LessThan[value] || -1}],
  tokenPrec: 15116
});

exports.parser = parser;


/***/ }),

/***/ "./node_modules/@lezer/lr/dist/index.cjs":
/*!***********************************************!*\
  !*** ./node_modules/@lezer/lr/dist/index.cjs ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var common = __webpack_require__(/*! @lezer/common */ "./node_modules/@lezer/common/dist/index.cjs");

/**
A parse stack. These are used internally by the parser to track
parsing progress. They also provide some properties and methods
that external code such as a tokenizer can use to get information
about the parse state.
*/
class Stack {
    /**
    @internal
    */
    constructor(
    /**
    The parse that this stack is part of @internal
    */
    p, 
    /**
    Holds state, input pos, buffer index triplets for all but the
    top state @internal
    */
    stack, 
    /**
    The current parse state @internal
    */
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /**
    @internal
    */
    reducePos, 
    /**
    The input position up to which this stack has parsed.
    */
    pos, 
    /**
    The dynamic score of the stack, including dynamic precedence
    and error-recovery penalties
    @internal
    */
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /**
    @internal
    */
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /**
    @internal
    */
    bufferBase, 
    /**
    @internal
    */
    curContext, 
    /**
    @internal
    */
    lookAhead = 0, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /**
    @internal
    */
    parent) {
        this.p = p;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
    }
    /**
    @internal
    */
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /**
    @internal
    */
    static start(p, state, pos = 0) {
        let cx = p.parser.context;
        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /**
    The stack's current [context](#lr.ContextTracker) value, if
    any. Its type will depend on the context tracker's type
    parameter, or it will be `null` if there is no context
    tracker.
    */
    get context() { return this.curContext ? this.curContext.context : null; }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /**
    @internal
    */
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /**
    @internal
    */
    reduce(action) {
        var _a;
        let depth = action >> 19 /* Action.ReduceDepthShift */, type = action & 65535 /* Action.ValueMask */;
        let { parser } = this.p;
        let lookaheadRecord = this.reducePos < this.pos - 25 /* Lookahead.Margin */;
        if (lookaheadRecord)
            this.setLookAhead(this.pos);
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            // Zero-depth reductions are a special case—they add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
            this.reduceContext(type, this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* Action.StayFlag */ ? 6 : 0);
        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;
        // This is a kludge to try and detect overly deep left-associative
        // trees, which will not increase the parse stack depth and thus
        // won't be caught by the regular stack-depth limit check.
        if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {
            if (start == this.p.lastBigReductionStart) {
                this.p.bigReductionCount++;
                this.p.lastBigReductionSize = size;
            }
            else if (this.p.lastBigReductionSize < size) {
                this.p.bigReductionCount = 1;
                this.p.lastBigReductionStart = start;
                this.p.lastBigReductionSize = size;
            }
        }
        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* Action.RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* Action.StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
        this.reduceContext(type, start);
    }
    // Shift a value into the buffer
    /**
    @internal
    */
    storeNode(term, start, end, size = 4, mustSink = false) {
        if (term == 0 /* Term.Err */ &&
            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
            // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!mustSink || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */) {
                let mustMove = false;
                for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
                    if (this.buffer[scan - 1] >= 0) {
                        mustMove = true;
                        break;
                    }
                }
                if (mustMove)
                    while (index > 0 && this.buffer[index - 2] > end) {
                        // Move this record forward
                        this.buffer[index] = this.buffer[index - 4];
                        this.buffer[index + 1] = this.buffer[index - 3];
                        this.buffer[index + 2] = this.buffer[index - 2];
                        this.buffer[index + 3] = this.buffer[index - 1];
                        index -= 4;
                        if (size > 4)
                            size -= 4;
                    }
            }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /**
    @internal
    */
    shift(action, type, start, end) {
        if (action & 131072 /* Action.GotoFlag */) {
            this.pushState(action & 65535 /* Action.ValueMask */, this.pos);
        }
        else if ((action & 262144 /* Action.StayFlag */) == 0) { // Regular shift
            let nextState = action, { parser } = this.p;
            if (end > this.pos || type <= parser.maxNode) {
                this.pos = end;
                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))
                    this.reducePos = end;
            }
            this.pushState(nextState, start);
            this.shiftContext(type, start);
            if (type <= parser.maxNode)
                this.buffer.push(type, start, end, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            this.pos = end;
            this.shiftContext(type, start);
            if (type <= this.p.parser.maxNode)
                this.buffer.push(type, start, end, 4);
        }
    }
    // Apply an action
    /**
    @internal
    */
    apply(action, next, nextStart, nextEnd) {
        if (action & 65536 /* Action.ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextStart, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /**
    @internal
    */
    useNode(value, next) {
        let index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /**
    @internal
    */
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /**
    @internal
    */
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190 /* Recover.Delete */;
    }
    /**
    Check if the given term would be able to be shifted (optionally
    after some reductions) on this stack. This can be useful for
    external tokenizers that want to make sure they only provide a
    given token when it applies.
    */
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);
            if (action == 0)
                return false;
            if ((action & 65536 /* Action.ReduceFlag */) == 0)
                return true;
            sim.reduce(action);
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /**
    @internal
    */
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */)
            return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {
            let best = [];
            for (let i = 0, s; i < nextStates.length; i += 2) {
                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                    best.push(nextStates[i], s);
            }
            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {
                    let s = nextStates[i + 1];
                    if (!best.some((v, i) => (i & 1) && v == s))
                        best.push(nextStates[i], s);
                }
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {
            let s = nextStates[i + 1];
            if (s == this.state)
                continue;
            let stack = this.split();
            stack.pushState(s, this.pos);
            stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);
            stack.shiftContext(nextStates[i], this.pos);
            stack.reducePos = this.pos;
            stack.score -= 200 /* Recover.Insert */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /**
    @internal
    */
    forceReduce() {
        let { parser } = this.p;
        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);
        if ((reduce & 65536 /* Action.ReduceFlag */) == 0)
            return false;
        if (!parser.validAction(this.state, reduce)) {
            let depth = reduce >> 19 /* Action.ReduceDepthShift */, term = reduce & 65535 /* Action.ValueMask */;
            let target = this.stack.length - depth * 3;
            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {
                let backup = this.findForcedReduction();
                if (backup == null)
                    return false;
                reduce = backup;
            }
            this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);
            this.score -= 100 /* Recover.Reduce */;
        }
        this.reducePos = this.pos;
        this.reduce(reduce);
        return true;
    }
    /**
    Try to scan through the automaton to find some kind of reduction
    that can be applied. Used when the regular ForcedReduce field
    isn't a valid action. @internal
    */
    findForcedReduction() {
        let { parser } = this.p, seen = [];
        let explore = (state, depth) => {
            if (seen.includes(state))
                return;
            seen.push(state);
            return parser.allActions(state, (action) => {
                if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;
                else if (action & 65536 /* Action.ReduceFlag */) {
                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;
                    if (rDepth > 1) {
                        let term = action & 65535 /* Action.ValueMask */, target = this.stack.length - rDepth * 3;
                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0)
                            return (rDepth << 19 /* Action.ReduceDepthShift */) | 65536 /* Action.ReduceFlag */ | term;
                    }
                }
                else {
                    let found = explore(action, depth + 1);
                    if (found != null)
                        return found;
                }
            });
        };
        return explore(this.state, 0);
    }
    /**
    @internal
    */
    forceAll() {
        while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {
            if (!this.forceReduce()) {
                this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);
                break;
            }
        }
        return this;
    }
    /**
    Check whether this state has no further actions (assumed to be a direct descendant of the
    top state, since any other states must be able to continue
    somehow). @internal
    */
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.p;
        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ &&
            !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);
    }
    /**
    Restart the stack (put it back in its start state). Only safe
    when this.stack.length == 3 (state is directly below the top
    state). @internal
    */
    restart() {
        this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /**
    @internal
    */
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /**
    Get the parser used by this stack.
    */
    get parser() { return this.p.parser; }
    /**
    Test whether a given dialect (by numeric ID, as exported from
    the terms file) is enabled.
    */
    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }
    shiftContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    /**
    @internal
    */
    emitContext() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3)
            this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
    }
    /**
    @internal
    */
    emitLookAhead() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4)
            this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
    }
    updateContext(context) {
        if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash)
                this.emitContext();
            this.curContext = newCx;
        }
    }
    /**
    @internal
    */
    setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
        }
    }
    /**
    @internal
    */
    close() {
        if (this.curContext && this.curContext.tracker.strict)
            this.emitContext();
        if (this.lookAhead > 0)
            this.emitLookAhead();
    }
}
class StackContext {
    constructor(tracker, context) {
        this.tracker = tracker;
        this.context = context;
        this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
}
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(start) {
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
    }
    reduce(action) {
        let term = action & 65535 /* Action.ValueMask */, depth = action >> 19 /* Action.ReduceDepthShift */;
        if (depth == 0) {
            if (this.stack == this.start.stack)
                this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
        }
        else {
            this.base -= (depth - 1) * 3;
        }
        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* Encode.BigValCode */) {
                value = 65535 /* Encode.BigVal */;
                break;
            }
            if (next >= 92 /* Encode.Gap2 */)
                next--;
            if (next >= 34 /* Encode.Gap1 */)
                next--;
            let digit = next - 32 /* Encode.Start */;
            if (digit >= 46 /* Encode.Base */) {
                digit -= 46 /* Encode.Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Encode.Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

class CachedToken {
    constructor() {
        this.start = -1;
        this.value = -1;
        this.end = -1;
        this.extended = -1;
        this.lookAhead = 0;
        this.mask = 0;
        this.context = 0;
    }
}
const nullToken = new CachedToken;
/**
[Tokenizers](#lr.ExternalTokenizer) interact with the input
through this interface. It presents the input as a stream of
characters, tracking lookahead and hiding the complexity of
[ranges](#common.Parser.parse^ranges) from tokenizer code.
*/
class InputStream {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    input, 
    /**
    @internal
    */
    ranges) {
        this.input = input;
        this.ranges = ranges;
        /**
        @internal
        */
        this.chunk = "";
        /**
        @internal
        */
        this.chunkOff = 0;
        /**
        Backup chunk
        */
        this.chunk2 = "";
        this.chunk2Pos = 0;
        /**
        The character code of the next code unit in the input, or -1
        when the stream is at the end of the input.
        */
        this.next = -1;
        /**
        @internal
        */
        this.token = nullToken;
        this.rangeIndex = 0;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
    }
    /**
    @internal
    */
    resolveOffset(offset, assoc) {
        let range = this.range, index = this.rangeIndex;
        let pos = this.pos + offset;
        while (pos < range.from) {
            if (!index)
                return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
            if (index == this.ranges.length - 1)
                return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
        }
        return pos;
    }
    /**
    @internal
    */
    clipPos(pos) {
        if (pos >= this.range.from && pos < this.range.to)
            return pos;
        for (let range of this.ranges)
            if (range.to > pos)
                return Math.max(pos, range.from);
        return this.end;
    }
    /**
    Look at a code unit near the stream position. `.peek(0)` equals
    `.next`, `.peek(-1)` gives you the previous character, and so
    on.
    
    Note that looking around during tokenizing creates dependencies
    on potentially far-away content, which may reduce the
    effectiveness incremental parsing—when looking forward—or even
    cause invalid reparses when looking backward more than 25 code
    units, since the library does not track lookbehind.
    */
    peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
        }
        else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null)
                return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            }
            else {
                let i = this.rangeIndex, range = this.range;
                while (range.to <= pos)
                    range = this.ranges[++i];
                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                if (pos + this.chunk2.length > range.to)
                    this.chunk2 = this.chunk2.slice(0, range.to - pos);
                result = this.chunk2.charCodeAt(0);
            }
        }
        if (pos >= this.token.lookAhead)
            this.token.lookAhead = pos + 1;
        return result;
    }
    /**
    Accept a token. By default, the end of the token is set to the
    current stream position, but you can pass an offset (relative to
    the stream position) to change that.
    */
    acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start)
            throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
    }
    /**
    Accept a token ending at a specific given position.
    */
    acceptTokenTo(token, endPos) {
        this.token.value = token;
        this.token.end = endPos;
    }
    getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk, chunkPos } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
        }
        else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
        }
    }
    readNext() {
        if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length)
                return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /**
    Move the stream forward N (defaults to 1) code units. Returns
    the new value of [`next`](#lr.InputStream.next).
    */
    advance(n = 1) {
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
            if (this.rangeIndex == this.ranges.length - 1)
                return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead)
            this.token.lookAhead = this.pos + 1;
        return this.readNext();
    }
    setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
    }
    /**
    @internal
    */
    reset(pos, token) {
        if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
        }
        else {
            this.token = nullToken;
        }
        if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
                this.setDone();
                return this;
            }
            while (pos < this.range.from)
                this.range = this.ranges[--this.rangeIndex];
            while (pos >= this.range.to)
                this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                this.chunkOff = pos - this.chunkPos;
            }
            else {
                this.chunk = "";
                this.chunkOff = 0;
            }
            this.readNext();
        }
        return this;
    }
    /**
    @internal
    */
    read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
        if (from >= this.range.from && to <= this.range.to)
            return this.input.read(from, to);
        let result = "";
        for (let r of this.ranges) {
            if (r.from >= to)
                break;
            if (r.to > from)
                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
        }
        return result;
    }
}
/**
@internal
*/
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, stack) {
        let { parser } = stack.p;
        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);
    }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/**
@hide
*/
class LocalTokenGroup {
    constructor(data, precTable, elseToken) {
        this.precTable = precTable;
        this.elseToken = elseToken;
        this.data = typeof data == "string" ? decodeArray(data) : data;
    }
    token(input, stack) {
        let start = input.pos, skipped = 0;
        for (;;) {
            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
            readToken(this.data, input, stack, 0, this.data, this.precTable);
            if (input.token.value > -1)
                break;
            if (this.elseToken == null)
                return;
            if (!atEof)
                skipped++;
            if (nextPos == null)
                break;
            input.reset(nextPos, input.token);
        }
        if (skipped) {
            input.reset(start, input.token);
            input.acceptToken(this.elseToken, skipped);
        }
    }
}
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/**
`@external tokens` declarations in the grammar should resolve to
an instance of this class.
*/
class ExternalTokenizer {
    /**
    Create a tokenizer. The first argument is the function that,
    given an input stream, scans for the types of tokens it
    recognizes at the stream's position, and calls
    [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    one.
    */
    constructor(
    /**
    @internal
    */
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `input.token` when it matches a token.
function readToken(data, input, stack, group, precTable, precOffset) {
    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
    scan: for (;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (input.token.value == -1 || input.token.value == term ||
                        overrides(term, input.token.value, precTable, precOffset))) {
                    input.acceptToken(term);
                    break;
                }
            }
        let next = input.next, low = 0, high = data[state + 2];
        // Special case for EOF
        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {
            state = data[accEnd + high * 3 - 1];
            continue scan;
        }
        // Do a binary search on the state's edges
        for (; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1] || 0x10000;
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                input.advance();
                continue scan;
            }
        }
        break;
    }
}
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function overrides(token, prev, tableData, tableOffset) {
    let iPrev = findOffset(tableData, tableOffset, prev);
    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}

// Environment variable used to control console output
const verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
let stackIDs = null;
function cutAt(tree, pos, side) {
    let cursor = tree.cursor(common.IterMode.IncludeAnonymous);
    cursor.moveTo(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Lookahead.Margin */))
                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Lookahead.Margin */));
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments, nodeSet) {
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            if (next instanceof common.Tree) {
                if (start == pos) {
                    if (start < this.safeFrom)
                        return null;
                    let end = start + next.length;
                    if (end <= this.safeTo) {
                        let lookAhead = next.prop(common.NodeProp.lookAhead);
                        if (!lookAhead || end + lookAhead < this.fragment.to)
                            return next;
                    }
                }
                this.index[last]++;
                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
            else {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
        }
    }
}
class TokenCache {
    constructor(parser, stream) {
        this.stream = stream;
        this.tokens = [];
        this.mainToken = null;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.p, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);
        let context = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                this.updateCachedToken(token, tokenizer, stack);
                token.mask = mask;
                token.context = context;
            }
            if (token.lookAhead > token.end + 25 /* Lookahead.Margin */)
                lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != 0 /* Term.Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (lookAhead)
            stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
            main = new CachedToken;
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
    }
    getMainToken(stack) {
        if (this.mainToken)
            return this.mainToken;
        let main = new CachedToken, { pos, p } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;
        return main;
    }
    updateCachedToken(token, tokenizer, stack) {
        let start = this.stream.clipPos(stack.pos);
        tokenizer.token(this.stream.reset(start, token), stack);
        if (token.value > -1) {
            let { parser } = stack.p;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize.Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else {
            token.value = 0 /* Term.Err */;
            token.end = this.stream.clipPos(start + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.p, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {
                if (data[i] == 65535 /* Seq.End */) {
                    if (data[i + 1] == 1 /* Seq.Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */)
                            index = this.putAction(pair(data, i + 2), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
class Parse {
    constructor(parser, input, fragments, ranges) {
        this.parser = parser;
        this.input = input;
        this.ranges = ranges;
        this.recovering = 0;
        this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧
        this.minStackPos = 0;
        this.reused = [];
        this.stoppedAt = null;
        this.lastBigReductionStart = -1;
        this.lastBigReductionSize = 0;
        this.bigReductionCount = 0;
        this.stream = new InputStream(input, ranges);
        this.tokens = new TokenCache(parser, this.stream);
        this.topTerm = parser.top[1];
        let { from } = ranges[0];
        this.stacks = [Stack.start(this, parser.top[0], from)];
        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4
            ? new FragmentCursor(fragments, parser.nodeSet) : null;
    }
    get parsedPos() {
        return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        // If a large amount of reductions happened with the same start
        // position, force the stack out of that production in order to
        // avoid creating a tree too deep to recurse through.
        // (This is an ugly kludge, because unfortunately there is no
        // straightforward, cheap way to check for this happening, due to
        // the history of reductions only being available in an
        // expensive-to-access format in the stack buffers.)
        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {
            let [s] = stacks;
            while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) { }
            this.bigReductionCount = this.lastBigReductionSize = 0;
        }
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i];
            for (;;) {
                this.tokens.mainToken = null;
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.getMainToken(stack);
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished) {
                if (verbose)
                    console.log("Finish with " + this.stackID(finished));
                return this.stackToTree(finished);
            }
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Rec.Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]
                : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished) {
                if (verbose)
                    console.log("Force-finish " + this.stackID(finished));
                return this.stackToTree(finished.forceAll());
            }
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
            if (newStacks.length > 12 /* Rec.MaxStackCount */)
                newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);
        }
        this.minStackPos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.minStackPos)
                this.minStackPos = newStacks[i].pos;
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt)
            return stack.forceReduce() ? stack : null;
        if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length && (!strictCx || (cached.prop(common.NodeProp.contextHash) || 0) == cxHash)) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof common.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof common.Tree && cached.positions[0] == 0)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);
            return true;
        }
        if (stack.stack.length >= 8400 /* Rec.CutDepth */) {
            while (stack.stack.length > 6000 /* Rec.CutTo */ && stack.forceReduce()) { }
        }
        let actions = this.tokens.getActions(stack);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            let main = this.tokens.mainToken;
            localStack.apply(action, term, main ? main.start : localStack.pos, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done)
                    continue;
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done)
                    break;
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.stream.end > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Term.Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
        stack.close();
        return common.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm });
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
const id = x => x;
/**
Context trackers are used to track stateful context (such as
indentation in the Python grammar, or parent elements in the XML
grammar) needed by external tokenizers. You declare them in a
grammar file as `@context exportName from "module"`.

Context values should be immutable, and can be updated (replaced)
on shift or reduce actions.

The export used in a `@context` declaration should be of this
type.
*/
class ContextTracker {
    /**
    Define a context tracker.
    */
    constructor(spec) {
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (() => 0);
        this.strict = spec.strict !== false;
    }
}
/**
Holds the parse tables for a given grammar, as generated by
`lezer-generator`, and provides [methods](#common.Parser) to parse
content with.
*/
class LRParser extends common.Parser {
    /**
    @internal
    */
    constructor(spec) {
        super();
        /**
        @internal
        */
        this.wrappers = [];
        if (spec.version != 14 /* File.Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                if (typeof prop == "string")
                    prop = common.NodeProp[prop];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.nodeSet = new common.NodeSet(nodeNames.map((name, i) => common.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        if (spec.propSources)
            this.nodeSet = this.nodeSet.extend(...spec.propSources);
        this.strict = false;
        this.bufferLength = common.DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specializerSpecs = spec.specialized || [];
        this.specialized = new Uint16Array(this.specializerSpecs.length);
        for (let i = 0; i < this.specializerSpecs.length; i++)
            this.specialized[i] = this.specializerSpecs[i].term;
        this.specializers = this.specializerSpecs.map(getSpecializer);
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
        let parse = new Parse(this, input, fragments, ranges);
        for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
        return parse;
    }
    /**
    Get a goto table entry @internal
    */
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /**
    Check if this state has an action for a given terminal @internal
    */
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* Seq.End */) {
                    if (data[i + 1] == 1 /* Seq.Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Seq.Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Term.Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /**
    @internal
    */
    stateSlot(state, slot) {
        return this.states[(state * 6 /* ParseState.Size */) + slot];
    }
    /**
    @internal
    */
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;
    }
    /**
    @internal
    */
    validAction(state, action) {
        return !!this.allActions(state, a => a == action ? true : null);
    }
    /**
    @internal
    */
    allActions(state, action) {
        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);
        let result = deflt ? action(deflt) : undefined;
        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {
            if (this.data[i] == 65535 /* Seq.End */) {
                if (this.data[i + 1] == 1 /* Seq.Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            result = action(pair(this.data, i + 1));
        }
        return result;
    }
    /**
    Get the states that can follow this one through shift actions or
    goto jumps. @internal
    */
    nextStates(state) {
        let result = [];
        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {
            if (this.data[i] == 65535 /* Seq.End */) {
                if (this.data[i + 1] == 1 /* Seq.Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* Action.ReduceFlag */ >> 16)) == 0) {
                let value = this.data[i + 1];
                if (!result.some((v, i) => (i & 1) && v == value))
                    result.push(this.data[i], value);
            }
        }
        return result;
    }
    /**
    Configure the parser. Returns a new parser instance that has the
    given settings modified. Settings not provided in `config` are
    kept from the original parser.
    */
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(LRParser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.specializers) {
            copy.specializers = this.specializers.slice();
            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
                let found = config.specializers.find(r => r.from == s.external);
                if (!found)
                    return s;
                let spec = Object.assign(Object.assign({}, s), { external: found.to });
                copy.specializers[i] = getSpecializer(spec);
                return spec;
            });
        }
        if (config.contextTracker)
            copy.context = config.contextTracker;
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.wrap)
            copy.wrappers = copy.wrappers.concat(config.wrap);
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /**
    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
    are registered for this parser.
    */
    hasWrappers() {
        return this.wrappers.length > 0;
    }
    /**
    Returns the name associated with a given term. This will only
    work for all terms when the parser was generated with the
    `--names` option. By default, only the names of tagged terms are
    stored.
    */
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /**
    The eof term id is always allocated directly after the node
    types. @internal
    */
    get eofTerm() { return this.maxNode + 1; }
    /**
    The type of top node produced by the parser.
    */
    get topNode() { return this.nodeSet.types[this.top[1]]; }
    /**
    @internal
    */
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /**
    @internal
    */
    parseDialect(dialect) {
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return new Dialect(dialect, flags, disabled);
    }
    /**
    Used by the output of the parser generator. Not available to
    user code. @hide
    */
    static deserialize(spec) {
        return new LRParser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        let stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&
            stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}
function getSpecializer(spec) {
    if (spec.external) {
        let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;
        return (value, stack) => (spec.external(value, stack) << 1) | mask;
    }
    return spec.get;
}

exports.ContextTracker = ContextTracker;
exports.ExternalTokenizer = ExternalTokenizer;
exports.InputStream = InputStream;
exports.LRParser = LRParser;
exports.LocalTokenGroup = LocalTokenGroup;
exports.Stack = Stack;


/***/ }),

/***/ "./node_modules/codemirror/dist/index.cjs":
/*!************************************************!*\
  !*** ./node_modules/codemirror/dist/index.cjs ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var view = __webpack_require__(/*! @codemirror/view */ "./node_modules/@codemirror/view/dist/index.cjs");
var state = __webpack_require__(/*! @codemirror/state */ "./node_modules/@codemirror/state/dist/index.cjs");
var language = __webpack_require__(/*! @codemirror/language */ "./node_modules/@codemirror/language/dist/index.cjs");
var commands = __webpack_require__(/*! @codemirror/commands */ "./node_modules/@codemirror/commands/dist/index.cjs");
var search = __webpack_require__(/*! @codemirror/search */ "./node_modules/@codemirror/search/dist/index.cjs");
var autocomplete = __webpack_require__(/*! @codemirror/autocomplete */ "./node_modules/@codemirror/autocomplete/dist/index.cjs");
var lint = __webpack_require__(/*! @codemirror/lint */ "./node_modules/@codemirror/lint/dist/index.cjs");

// (The superfluous function calls around the list of extensions work
// around current limitations in tree-shaking software.)
/**
This is an extension value that just pulls together a number of
extensions that you might want in a basic editor. It is meant as a
convenient helper to quickly set up CodeMirror without installing
and importing a lot of separate packages.

Specifically, it includes...

 - [the default command bindings](https://codemirror.net/6/docs/ref/#commands.defaultKeymap)
 - [line numbers](https://codemirror.net/6/docs/ref/#view.lineNumbers)
 - [special character highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars)
 - [the undo history](https://codemirror.net/6/docs/ref/#commands.history)
 - [a fold gutter](https://codemirror.net/6/docs/ref/#language.foldGutter)
 - [custom selection drawing](https://codemirror.net/6/docs/ref/#view.drawSelection)
 - [drop cursor](https://codemirror.net/6/docs/ref/#view.dropCursor)
 - [multiple selections](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
 - [reindentation on input](https://codemirror.net/6/docs/ref/#language.indentOnInput)
 - [the default highlight style](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle) (as fallback)
 - [bracket matching](https://codemirror.net/6/docs/ref/#language.bracketMatching)
 - [bracket closing](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets)
 - [autocompletion](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion)
 - [rectangular selection](https://codemirror.net/6/docs/ref/#view.rectangularSelection) and [crosshair cursor](https://codemirror.net/6/docs/ref/#view.crosshairCursor)
 - [active line highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLine)
 - [active line gutter highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLineGutter)
 - [selection match highlighting](https://codemirror.net/6/docs/ref/#search.highlightSelectionMatches)
 - [search](https://codemirror.net/6/docs/ref/#search.searchKeymap)
 - [linting](https://codemirror.net/6/docs/ref/#lint.lintKeymap)

(You'll probably want to add some language package to your setup
too.)

This extension does not allow customization. The idea is that,
once you decide you want to configure your editor more precisely,
you take this package's source (which is just a bunch of imports
and an array literal), copy it into your own code, and adjust it
as desired.
*/
const basicSetup = (() => [
    view.lineNumbers(),
    view.highlightActiveLineGutter(),
    view.highlightSpecialChars(),
    commands.history(),
    language.foldGutter(),
    view.drawSelection(),
    view.dropCursor(),
    state.EditorState.allowMultipleSelections.of(true),
    language.indentOnInput(),
    language.syntaxHighlighting(language.defaultHighlightStyle, { fallback: true }),
    language.bracketMatching(),
    autocomplete.closeBrackets(),
    autocomplete.autocompletion(),
    view.rectangularSelection(),
    view.crosshairCursor(),
    view.highlightActiveLine(),
    search.highlightSelectionMatches(),
    view.keymap.of([
        ...autocomplete.closeBracketsKeymap,
        ...commands.defaultKeymap,
        ...search.searchKeymap,
        ...commands.historyKeymap,
        ...language.foldKeymap,
        ...autocomplete.completionKeymap,
        ...lint.lintKeymap
    ])
])();
/**
A minimal set of extensions to create a functional editor. Only
includes [the default keymap](https://codemirror.net/6/docs/ref/#commands.defaultKeymap), [undo
history](https://codemirror.net/6/docs/ref/#commands.history), [special character
highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars), [custom selection
drawing](https://codemirror.net/6/docs/ref/#view.drawSelection), and [default highlight
style](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle).
*/
const minimalSetup = (() => [
    view.highlightSpecialChars(),
    commands.history(),
    view.drawSelection(),
    language.syntaxHighlighting(language.defaultHighlightStyle, { fallback: true }),
    view.keymap.of([
        ...commands.defaultKeymap,
        ...commands.historyKeymap,
    ])
])();

Object.defineProperty(exports, "EditorView", ({
    enumerable: true,
    get: function () { return view.EditorView; }
}));
exports.basicSetup = basicSetup;
exports.minimalSetup = minimalSetup;


/***/ }),

/***/ "./node_modules/crelt/dist/index.cjs":
/*!*******************************************!*\
  !*** ./node_modules/crelt/dist/index.cjs ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string") elt = document.createElement(elt);
  var i = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
      var value = next[name];
      if (typeof value == "string") elt.setAttribute(name, value);
      else if (value != null) elt[name] = value;
    }
    i++;
  }
  for (; i < arguments.length; i++) add(elt, arguments[i]);
  return elt
}

function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) ; else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add(elt, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child)
  }
}

module.exports = crelt;


/***/ }),

/***/ "./node_modules/style-mod/dist/style-mod.cjs":
/*!***************************************************!*\
  !*** ./node_modules/style-mod/dist/style-mod.cjs ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

var C = "\u037c"
var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C)
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet")
var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {}

// :: - Style modules encapsulate a set of CSS rules defined from
// JavaScript. Their definitions are only available in a given DOM
// root after it has been _mounted_ there with `StyleModule.mount`.
//
// Style modules should be created once and stored somewhere, as
// opposed to re-creating them every time you need them. The amount of
// CSS rules generated for a given DOM root is bounded by the amount
// of style modules that were used. So to avoid leaking rules, don't
// create these dynamically, but treat them as one-time allocations.
var StyleModule = exports.StyleModule = function StyleModule(spec, options) {
  this.rules = []
  var ref = options || {};
  var finish = ref.finish;

  function splitSelector(selector) {
    return /^@/.test(selector) ? [selector] : selector.split(/,\s*/)
  }

  function render(selectors, spec, target, isKeyframes) {
    var local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes"
    if (isAt && spec == null) { return target.push(selectors[0] + ";") }
    for (var prop in spec) {
      var value = spec[prop]
      if (/&/.test(prop)) {
        render(prop.split(/,\s*/).map(function (part) { return selectors.map(function (sel) { return part.replace(/&/, sel); }); }).reduce(function (a, b) { return a.concat(b); }),
               value, target)
      } else if (value && typeof value == "object") {
        if (!isAt) { throw new RangeError("The value of a property (" + prop + ") should be a primitive value.") }
        render(splitSelector(prop), value, local, keyframes)
      } else if (value != null) {
        local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, function (l) { return "-" + l.toLowerCase(); }) + ": " + value + ";")
      }
    }
    if (local.length || keyframes) {
      target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") +
                  " {" + local.join(" ") + "}")
    }
  }

  for (var prop in spec) { render(splitSelector(prop), spec[prop], this.rules) }
};

// :: () → string
// Returns a string containing the module's CSS rules.
StyleModule.prototype.getRules = function getRules () { return this.rules.join("\n") };

// :: () → string
// Generate a new unique CSS class name.
StyleModule.newName = function newName () {
  var id = top[COUNT] || 1
  top[COUNT] = id + 1
  return C + id.toString(36)
};

// :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
//
// Mount the given set of modules in the given DOM root, which ensures
// that the CSS rules defined by the module are available in that
// context.
//
// Rules are only added to the document once per root.
//
// Rule order will follow the order of the modules, so that rules from
// modules later in the array take precedence of those from earlier
// modules. If you call this function multiple times for the same root
// in a way that changes the order of already mounted modules, the old
// order will be changed.
//
// If a Content Security Policy nonce is provided, it is added to
// the `<style>` tag generated by the library.
StyleModule.mount = function mount (root, modules, options) {
  var set = root[SET], nonce = options && options.nonce
  if (!set) { set = new StyleSet(root, nonce) }
  else if (nonce) { set.setNonce(nonce) }
  set.mount(Array.isArray(modules) ? modules : [modules], root)
};

var adoptedSet = new Map //<Document, StyleSet>

var StyleSet = function StyleSet(root, nonce) {
  var doc = root.ownerDocument || root, win = doc.defaultView
  if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
    var adopted = adoptedSet.get(doc)
    if (adopted) { return root[SET] = adopted }
    this.sheet = new win.CSSStyleSheet
    adoptedSet.set(doc, this)
  } else {
    this.styleTag = doc.createElement("style")
    if (nonce) { this.styleTag.setAttribute("nonce", nonce) }
  }
  this.modules = []
  root[SET] = this
};

StyleSet.prototype.mount = function mount (modules, root) {
  var sheet = this.sheet
  var pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */
  for (var i = 0; i < modules.length; i++) {
    var mod = modules[i], index = this.modules.indexOf(mod)
    if (index < j && index > -1) { // Ordering conflict
      this.modules.splice(index, 1)
      j--
      index = -1
    }
    if (index == -1) {
      this.modules.splice(j++, 0, mod)
      if (sheet) { for (var k = 0; k < mod.rules.length; k++)
        { sheet.insertRule(mod.rules[k], pos++) } }
    } else {
      while (j < index) { pos += this.modules[j++].rules.length }
      pos += mod.rules.length
      j++
    }
  }

  if (sheet) {
    if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
      { root.adoptedStyleSheets = [this.sheet ].concat( root.adoptedStyleSheets) }
  } else {
    var text = ""
    for (var i$1 = 0; i$1 < this.modules.length; i$1++)
      { text += this.modules[i$1].getRules() + "\n" }
    this.styleTag.textContent = text
    var target = root.head || root
    if (this.styleTag.parentNode != target)
      { target.insertBefore(this.styleTag, target.firstChild) }
  }
};

StyleSet.prototype.setNonce = function setNonce (nonce) {
  if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
    { this.styleTag.setAttribute("nonce", nonce) }
};

// Style::Object<union<Style,string>>
//
// A style is an object that, in the simple case, maps CSS property
// names to strings holding their values, as in `{color: "red",
// fontWeight: "bold"}`. The property names can be given in
// camel-case—the library will insert a dash before capital letters
// when converting them to CSS.
//
// If you include an underscore in a property name, it and everything
// after it will be removed from the output, which can be useful when
// providing a property multiple times, for browser compatibility
// reasons.
//
// A property in a style object can also be a sub-selector, which
// extends the current context to add a pseudo-selector or a child
// selector. Such a property should contain a `&` character, which
// will be replaced by the current selector. For example `{"&:before":
// {content: '"hi"'}}`. Sub-selectors and regular properties can
// freely be mixed in a given object. Any property containing a `&` is
// assumed to be a sub-selector.
//
// Finally, a property can specify an @-block to be wrapped around the
// styles defined inside the object that's the property's value. For
// example to create a media query you can do `{"@media screen and
// (min-width: 400px)": {...}}`.



/***/ }),

/***/ "./node_modules/w3c-keyname/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/w3c-keyname/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\""
};

var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

function keyName(event) {
  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.
  // On IE, shift effect is never included in `.key`.
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||
      ie && event.shiftKey && event.key && event.key.length == 1 ||
      event.key == "Unidentified";
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified";
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name
}

exports.base = base;
exports.keyName = keyName;
exports.shift = shift;


/***/ }),

/***/ "./src/levels.json":
/*!*************************!*\
  !*** ./src/levels.json ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"levels":[{"html":"<div class=\\"pokemons\\">\\n    <pikachu />\\n</div>","title":"Catch Pikachu","menuTitle":"1. I choose you!","pokemons":[1],"correctAnswers":[{"css":"pikachu","pokemons":[1]}],"done":false},{"html":"<div class=\\"pokemons\\">\\n    <pikachu />\\n    <charmander />\\n    <pikachu />\\n</div>","title":"Catch 2 Pikachu","menuTitle":"2. Catch more Pikachu","pokemons":[1,3,1],"correctAnswers":[{"css":"pikachu","pokemons":[1]}],"done":false},{"html":"<div class=\\"pokemons\\">\\n    <charmander />\\n    <bulbasaur />\\n    <charmander  id=\\"shiny\\"/>\\n    <pikachu />\\n</div>","title":"Catch Shiny Charmander","menuTitle":"3. Shiny Charmander","pokemons":[3,2,6,1],"correctAnswers":[{"css":"#shiny","pokemons":[6]},{"css":"charmander#shiny","pokemons":[6]}],"done":false},{"html":"<div class=\\"pokemons\\">\\n    <pikachu />\\n    <bulbasaur />\\n    <charmander />\\n    <cage>\\n        <pikachu />\\n    </cage>\\n</div>","title":"Free Pikachu","menuTitle":"4. Free Pikachu","pokemons":[1,2,3,7],"correctAnswers":[{"css":"cage pikachu","pokemons":[7]}],"done":false},{"html":"<div class=\\"pokemons\\">\\n    <pikachu />\\n    <bulbasaur class=\\"tiny\\" />\\n    <bulbasaur />\\n</div>","title":"Catch little Bulbasaur","menuTitle":"5. It\'s tiny!","pokemons":[1,8,2],"correctAnswers":[{"css":".tiny","pokemons":[8]}],"done":false},{"html":"<div class=\\"pokemons\\">\\n    <charmander class=\\"tiny\\" />\\n    <bulbasaur class=\\"tiny\\" />\\n    <charmander class=\\"tiny\\" />\\n    <charmander />\\n</div>","title":"Catch all little Charmander","menuTitle":"6. Catch all tinys\'","pokemons":[9,8,9,3],"correctAnswers":[{"css":"charmander.tiny","pokemons":[9]}],"done":false},{"html":"<div class=\\"pokemons\\">\\n    <cage>\\n        <pikachu class=\\"tiny\\"/>\\n    </cage>\\n    <pikachu />\\n    <cage>\\n        <pikachu class=\\"tiny\\" />\\n    </cage>\\n    <bulbasaur class=\\"tiny\\" />\\n    <cage>\\n        <pikachu />\\n    </cage>\\n</div>","title":"Free all tiny Pikachu in cages","menuTitle":"7. Free all tinys\'","pokemons":[7,10,11,8,11],"correctAnswers":[{"css":"cage pikachu.tiny","pokemons":[11]}],"done":false},{"html":"<div class=\\"pokemons\\">\\n    <charmander class=\\"shiny\\" />\\n    <squirtle class=\\"tiny\\" />\\n    <squirtle />\\n</div>","title":"Catch shiny Charmander and tiny Sqirtle","menuTitle":"8. Combine shiny & tiny","pokemons":[6,12,4],"correctAnswers":[{"css":".tiny, .shiny","pokemons":[6,12]},{"css":".shiny, .tiny","pokemons":[6,12]}],"done":false},{"html":"<div class=\\"pokemons\\">\\n    <bulbasaur />\\n    <charmander />\\n    <bulbasaur />\\n    <squirtle />\\n</div>","title":"Catch first pokemon","menuTitle":"9. Cath first","pokemons":[14,3,2,4],"correctAnswers":[{"css":".pokemons bulbasaur:first-child","pokemons":[14]},{"css":"bulbasaur:first-child","pokemons":[14]},{"css":"div bulbasaur:first-child","pokemons":[14]}],"done":false},{"html":"<div class=\\"pokemons\\">\\n    <pikachu />\\n    <charmander />\\n    <bulbasaur />\\n    <pikachu />\\n</div>","title":"Catch last pokemon","menuTitle":"10. Catch lasts","pokemons":[1,3,2,13],"correctAnswers":[{"css":".pokemons pikachu:last-child","pokemons":[13]},{"css":"pikachu:last-child","pokemons":[13]},{"css":"div pikachu:last-child","pokemons":[13]}],"done":false}]}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sS0FBSyxLQUFLLFVBQVUsTUFBTSxRQUFRLEtBQUssTUFBTSxVQUFVLFVBQVUsV0FBVyxXQUFXLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxNQUFNLE1BQU0sS0FBSyxLQUFLLFdBQVcsT0FBTyxNQUFNLE1BQU0sT0FBTyxLQUFLLFNBQVMscUJBQXFCLG9CQUFvQixxQkFBcUIsb0JBQW9CLE9BQU8sUUFBUSxLQUFLLEtBQUssVUFBVSxXQUFXLE9BQU8sUUFBUSxLQUFLLEtBQUssVUFBVSxXQUFXLE9BQU8sT0FBTyxLQUFLLFFBQVEsV0FBVyxPQUFPLE9BQU8sS0FBSyxRQUFRLFdBQVcsVUFBVSxPQUFPLE9BQU8sS0FBSyxRQUFRLFdBQVcsT0FBTyxPQUFPLEtBQUssS0FBSyxXQUFXLE9BQU8sVUFBVSxLQUFLLEtBQUsscUJBQXFCLG9CQUFvQixvQkFBb0Isb0JBQW9CLG9CQUFvQixxQkFBcUIsT0FBTyxPQUFPLEtBQUssS0FBSyxXQUFXLE9BQU8sT0FBTyxLQUFLLEtBQUssVUFBVSxPQUFPLFFBQVEsS0FBSyxNQUFNLHFCQUFxQixvQkFBb0IsT0FBTyxPQUFPLEtBQUssTUFBTSxVQUFVLE9BQU8sUUFBUSxLQUFLLEtBQUsscUJBQXFCLHFCQUFxQixPQUFPLE9BQU8sS0FBSyxLQUFLLFdBQVcsT0FBTyxRQUFRLEtBQUssS0FBSyxxQkFBcUIsb0JBQW9CLE9BQU8sTUFBTSxNQUFNLE1BQU0sS0FBSyxLQUFLLFVBQVUsT0FBTyxPQUFPLEtBQUssS0FBSyxXQUFXLE9BQU8sTUFBTSxNQUFNLE1BQU0sS0FBSyxLQUFLLFVBQVUsT0FBTyxPQUFPLEtBQUssS0FBSyxVQUFVLE9BQU8sTUFBTSxXQUFXLE9BQU8sTUFBTSxXQUFXLE9BQU8sTUFBTSxVQUFVLE9BQU8sTUFBTSxZQUFZLGFBQWEsYUFBYSxhQUFhLFFBQVEsTUFBTSxVQUFVLFdBQVcsVUFBVSxPQUFPLE1BQU0sV0FBVyxXQUFXLFlBQVksT0FBTyxNQUFNLFVBQVUsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLE9BQU8sTUFBTSxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsT0FBTyxNQUFNLFlBQVksWUFBWSxPQUFPLFFBQVEsV0FBVyxXQUFXLFdBQVcsT0FBTyxNQUFNLFVBQVUsVUFBVSxPQUFPLFlBQVksS0FBSyxXQUFXLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxPQUFPLE1BQU0sV0FBVyxPQUFPLE9BQU8sVUFBVSxXQUFXLE9BQU8sTUFBTSxVQUFVLFVBQVUsVUFBVSxPQUFPLE1BQU0sV0FBVyxVQUFVLFVBQVUsV0FBVyxPQUFPLE1BQU0sV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLE9BQU8sV0FBVyxLQUFLLEtBQUssV0FBVyxNQUFNLE1BQU0sV0FBVyxNQUFNLEtBQUssTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxLQUFLLE1BQU0sS0FBSyxVQUFVLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxVQUFVLE1BQU0sS0FBSyxNQUFNLFVBQVUsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLE9BQU8sTUFBTSxVQUFVLFVBQVUsV0FBVyxXQUFXLFdBQVcsT0FBTyxNQUFNLFVBQVUsY0FBYyxjQUFjLGNBQWMsYUFBYSxRQUFRLE1BQU0sVUFBVSxPQUFPLE1BQU0sVUFBVSxXQUFXLFdBQVcsVUFBVSxPQUFPLE1BQU0sVUFBVSxXQUFXLFdBQVcsT0FBTyxNQUFNLFVBQVUsV0FBVyxXQUFXLFVBQVUsT0FBTyxNQUFNLFVBQVUsT0FBTyxNQUFNLEtBQUssVUFBVSxXQUFXLE1BQU0sTUFBTSxVQUFVLE1BQU0sS0FBSyxNQUFNLEtBQUssVUFBVSxNQUFNLE1BQU0sVUFBVSxXQUFXLE1BQU0sS0FBSyxPQUFPLFVBQVUsVUFBVSxXQUFXLFdBQVcsVUFBVSxPQUFPLE9BQU8sV0FBVyxVQUFVLFdBQVcsVUFBVSxRQUFRLFFBQVEsVUFBVSxXQUFXLFFBQVEsT0FBTyxZQUFZLFdBQVcsVUFBVSxRQUFRLE9BQU8sS0FBSyxXQUFXLE9BQU8sT0FBTyxXQUFXLE9BQU8sT0FBTyxXQUFXLE9BQU8sT0FBTyxXQUFXLE9BQU8sT0FBTyxXQUFXLE9BQU8sT0FBTyxXQUFXLE9BQU8sS0FBSyxPQUFPLFdBQVcsUUFBUSxPQUFPLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxRQUFRLE9BQU8sS0FBSyxVQUFVLE9BQU8sS0FBSyxPQUFPLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsUUFBUSxPQUFPLFVBQVUsT0FBTyxPQUFPLFdBQVcsUUFBUSxPQUFPLFVBQVUsVUFBVSxXQUFXLFdBQVcsUUFBUSxPQUFPLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxRQUFRLE9BQU8sV0FBVyxRQUFRLE9BQU8sVUFBVSxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFVBQVUsT0FBTyxPQUFPLFVBQVUsVUFBVSxRQUFRLE9BQU8sVUFBVSxXQUFXLFdBQVcsWUFBWSxZQUFZLFVBQVUsUUFBUSxPQUFPLFVBQVUsV0FBVyxXQUFXLFFBQVEsT0FBTyxVQUFVLFFBQVEsT0FBTyxVQUFVLFVBQVUsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFFBQVEsT0FBTyxZQUFZLFlBQVksUUFBUSxPQUFPLFdBQVcsUUFBUSxPQUFPLFVBQVUsV0FBVyxXQUFXLFdBQVcsVUFBVSxRQUFRLE9BQU8sV0FBVyxXQUFXLFFBQVEsT0FBTyxXQUFXLFFBQVEsT0FBTyxVQUFVLFVBQVUsV0FBVyxVQUFVLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsT0FBTyxPQUFPLFVBQVUsVUFBVSxXQUFXLE9BQU8sT0FBTyxXQUFXLFFBQVEsT0FBTyxVQUFVLFdBQVcsVUFBVSxVQUFVLE9BQU8sT0FBTyxXQUFXLE9BQU8sT0FBTyxXQUFXLFVBQVUsV0FBVyxPQUFPLE9BQU8sV0FBVyxZQUFZLE9BQU8s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cUI7QUFDckI7QUFDQTtBQUNBLHVCQUF1QixnR0FBZ0c7QUFDdkg7QUFDQTtBQUNBLEtBQUssTUFBTSxtREFBbUQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHFCQUFxQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLHdCQUF3QjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLLElBQUksZ0JBQWdCLElBQUksYUFBYSxrQkFBa0I7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDZDQUE2QztBQUMzRjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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LDRCQUE0QixRQUFRLCtHQUErRztBQUNuSjtBQUNBO0FBQ0EsYUFBYTtBQUNiLDREQUE0RCx1QkFBdUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0NBQWtDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxXQUFXLFdBQVc7QUFDNUUsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVksaUNBQWlDLGVBQWU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3Q0FBd0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0Esc0ZBQXNGLGNBQWMscUNBQXFDO0FBQ3pJO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQkFBMEI7QUFDMUQsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxjQUFjO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFD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QUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDhCQUE4QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUNBQXVDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixJQUFJO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCLG9CQUFvQixLQUFLO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLElBQUksT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVyw4Q0FBOEM7QUFDdkcscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFdBQVcseUdBQXlHO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDBCQUEwQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJDQUEyQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLHdDQUF3QyxZQUFZLGtCQUFr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cUYsTUFBTTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkJBQTJCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFEQUFxRDtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQTREO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywyREFBMkQ7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFpRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUE4QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0Isd0RBQXdELGlDQUFpQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtREFBbUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDZCQUE2QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUJBQXlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCLFdBQVcseUJBQXlCO0FBQ3pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVcsbURBQW1EO0FBQ25GO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9DQUFvQztBQUNyRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWEsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQ0FBb0M7QUFDekUsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQSxZQUFZLG1EQUFtRDtBQUMvRCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUVBQXVFO0FBQzVGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOERBQThEO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJDQUEyQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRCxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0IsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwrQkFBK0I7QUFDL0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZLEVBQUUsc0NBQXNDLEVBQUUsaURBQWlEO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYyx3Q0FBd0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWMsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2QkFBNkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSSxzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSx3QkFBd0IsZUFBZTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixTQUFTO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0IsSUFBSSxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsUUFBUTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSyx5QkFBeUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSywyQkFBMkI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE9BQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtREFBbUQ7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw0QkFBNEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsUUFBUTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUksZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTCxDQUFDO0FBQ0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUIsZ0JBQWdCLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEI7QUFDN0Q7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMs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L3NyYy9zYXNzL3N0eWxlcy5zY3NzIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFVybC5qcyIsIndlYnBhY2s6Ly9ycy1jc3MvLi9zcmMvc2Fzcy9zdHlsZXMuc2Nzcz8xOGZlIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9ycy1jc3MvLi9zcmMvY29uc3RzLnRzIiwid2VicGFjazovL3JzLWNzcy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9ycy1jc3MvLi9zcmMvbW9kdWxlcy9lZGl0b3IudHMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vc3JjL21vZHVsZXMvZm9vdGVyLnRzIiwid2VicGFjazovL3JzLWNzcy8uL3NyYy9tb2R1bGVzL2hlYWRlci50cyIsIndlYnBhY2s6Ly9ycy1jc3MvLi9zcmMvbW9kdWxlcy9sZXZlbC50cyIsIndlYnBhY2s6Ly9ycy1jc3MvLi9zcmMvbW9kdWxlcy9tYWluLnRzIiwid2VicGFjazovL3JzLWNzcy8uL3NyYy9tb2R1bGVzL21lbnUudHMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vc3JjL21vZHVsZXMvbW9kYWwudHMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vc3JjL21vZHVsZXMvcG9rZWJhbGwudHMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vc3JjL21vZHVsZXMvcmVuZGVyLnRzIiwid2VicGFjazovL3JzLWNzcy8uL3NyYy9yZXBvL3Bva2Vtb25SZXBvc2l0b3J5LnRzIiwid2VicGFjazovL3JzLWNzcy8uL3NyYy90eXBlcy9wb2tlbW9uLnRzIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9hdXRvY29tcGxldGUvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2NvbW1hbmRzL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLWNzcy9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly9ycy1jc3MvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1odG1sL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLWphdmFzY3JpcHQvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmd1YWdlL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9saW50L2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zZWFyY2gvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3N0YXRlL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci92aWV3L2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY3NzL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvaGlnaGxpZ2h0L2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3JzLWNzcy8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvaHRtbC9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly9ycy1jc3MvLi9ub2RlX21vZHVsZXMvQGxlemVyL2phdmFzY3JpcHQvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vbm9kZV9tb2R1bGVzL0BsZXplci9sci9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly9ycy1jc3MvLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly9ycy1jc3MvLi9ub2RlX21vZHVsZXMvY3JlbHQvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vbm9kZV9tb2R1bGVzL3N0eWxlLW1vZC9kaXN0L3N0eWxlLW1vZC5janMiLCJ3ZWJwYWNrOi8vcnMtY3NzLy4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmNqcyIsIndlYnBhY2s6Ly9ycy1jc3Mvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcnMtY3NzL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3JzLWNzcy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcnMtY3NzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vcnMtY3NzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcnMtY3NzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcnMtY3NzL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL3JzLWNzcy93ZWJwYWNrL3J1bnRpbWUvbm9uY2UiLCJ3ZWJwYWNrOi8vcnMtY3NzL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vcnMtY3NzL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9ycy1jc3Mvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyBmcm9tIFwiLi4vYXNzZXRzL2xhbmRzY2FwZS5qcGdcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyBmcm9tIFwiLi4vYXNzZXRzL3Bva8OpbW9uX2xvZ28ucG5nXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzJfX18gZnJvbSBcIi4uL2Fzc2V0cy9teXN0aWMtbG9nby5wbmdcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfM19fXyBmcm9tIFwiLi4vYXNzZXRzL3Jzcy5zdmdcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzJfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8zX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfM19fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbi8qISBub3JtYWxpemUuY3NzIHY4LjAuMSB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9cXG4vKiBEb2N1bWVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW4gaU9TLlxcbiAqL1xcbmh0bWwge1xcbiAgbGluZS1oZWlnaHQ6IDEuMTU7IC8qIDEgKi9cXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xcbn1cXG5cXG4vKiBTZWN0aW9uc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBtYXJnaW4gaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcbmJvZHkge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG4vKipcXG4gKiBSZW5kZXIgdGhlIGBtYWluYCBlbGVtZW50IGNvbnNpc3RlbnRseSBpbiBJRS5cXG4gKi9cXG5tYWluIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBmb250IHNpemUgYW5kIG1hcmdpbiBvbiBgaDFgIGVsZW1lbnRzIHdpdGhpbiBgc2VjdGlvbmAgYW5kXFxuICogYGFydGljbGVgIGNvbnRleHRzIGluIENocm9tZSwgRmlyZWZveCwgYW5kIFNhZmFyaS5cXG4gKi9cXG5oMSB7XFxuICBmb250LXNpemU6IDJlbTtcXG4gIG1hcmdpbjogMC42N2VtIDA7XFxufVxcblxcbi8qIEdyb3VwaW5nIGNvbnRlbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIEZpcmVmb3guXFxuICogMi4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZSBhbmQgSUUuXFxuICovXFxuaHIge1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7IC8qIDEgKi9cXG4gIGhlaWdodDogMDsgLyogMSAqL1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2UgYW5kIHNjYWxpbmcgb2YgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxucHJlIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2UsIG1vbm9zcGFjZTsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxZW07IC8qIDIgKi9cXG59XFxuXFxuLyogVGV4dC1sZXZlbCBzZW1hbnRpY3NcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qKlxcbiAqIFJlbW92ZSB0aGUgZ3JheSBiYWNrZ3JvdW5kIG9uIGFjdGl2ZSBsaW5rcyBpbiBJRSAxMC5cXG4gKi9cXG5hIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4vKipcXG4gKiAxLiBSZW1vdmUgdGhlIGJvdHRvbSBib3JkZXIgaW4gQ2hyb21lIDU3LVxcbiAqIDIuIEFkZCB0aGUgY29ycmVjdCB0ZXh0IGRlY29yYXRpb24gaW4gQ2hyb21lLCBFZGdlLCBJRSwgT3BlcmEsIGFuZCBTYWZhcmkuXFxuICovXFxuYWJiclt0aXRsZV0ge1xcbiAgYm9yZGVyLWJvdHRvbTogbm9uZTsgLyogMSAqL1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7IC8qIDIgKi9cXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCB3ZWlnaHQgaW4gQ2hyb21lLCBFZGdlLCBhbmQgU2FmYXJpLlxcbiAqL1xcbmIsXFxuc3Ryb25nIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIGFuZCBzY2FsaW5nIG9mIGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXFxuICogMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcbmNvZGUsXFxua2JkLFxcbnNhbXAge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gKi9cXG5zbWFsbCB7XFxuICBmb250LXNpemU6IDgwJTtcXG59XFxuXFxuLyoqXFxuICogUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluXFxuICogYWxsIGJyb3dzZXJzLlxcbiAqL1xcbnN1YixcXG5zdXAge1xcbiAgZm9udC1zaXplOiA3NSU7XFxuICBsaW5lLWhlaWdodDogMDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuc3ViIHtcXG4gIGJvdHRvbTogLTAuMjVlbTtcXG59XFxuXFxuc3VwIHtcXG4gIHRvcDogLTAuNWVtO1xcbn1cXG5cXG4vKiBFbWJlZGRlZCBjb250ZW50XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGJvcmRlciBvbiBpbWFnZXMgaW5zaWRlIGxpbmtzIGluIElFIDEwLlxcbiAqL1xcbmltZyB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxufVxcblxcbi8qIEZvcm1zXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gKiAxLiBDaGFuZ2UgdGhlIGZvbnQgc3R5bGVzIGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXFxuICovXFxuYnV0dG9uLFxcbmlucHV0LFxcbm9wdGdyb3VwLFxcbnNlbGVjdCxcXG50ZXh0YXJlYSB7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxMDAlOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMSAqL1xcbiAgbWFyZ2luOiAwOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFNob3cgdGhlIG92ZXJmbG93IGluIElFLlxcbiAqIDEuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UuXFxuICovXFxuYnV0dG9uLFxcbmlucHV0IHsgLyogMSAqL1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSwgRmlyZWZveCwgYW5kIElFLlxcbiAqIDEuIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRmlyZWZveC5cXG4gKi9cXG5idXR0b24sXFxuc2VsZWN0IHsgLyogMSAqL1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxufVxcblxcbi8qKlxcbiAqIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuICovXFxuYnV0dG9uLFxcblt0eXBlPWJ1dHRvbl0sXFxuW3R5cGU9cmVzZXRdLFxcblt0eXBlPXN1Ym1pdF0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5uZXIgYm9yZGVyIGFuZCBwYWRkaW5nIGluIEZpcmVmb3guXFxuICovXFxuYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPWJ1dHRvbl06Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9cmVzZXRdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPXN1Ym1pdF06Oi1tb3otZm9jdXMtaW5uZXIge1xcbiAgYm9yZGVyLXN0eWxlOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLyoqXFxuICogUmVzdG9yZSB0aGUgZm9jdXMgc3R5bGVzIHVuc2V0IGJ5IHRoZSBwcmV2aW91cyBydWxlLlxcbiAqL1xcbmJ1dHRvbjotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1idXR0b25dOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPXJlc2V0XTotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1zdWJtaXRdOi1tb3otZm9jdXNyaW5nIHtcXG4gIG91dGxpbmU6IDFweCBkb3R0ZWQgQnV0dG9uVGV4dDtcXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgcGFkZGluZyBpbiBGaXJlZm94LlxcbiAqL1xcbmZpZWxkc2V0IHtcXG4gIHBhZGRpbmc6IDAuMzVlbSAwLjc1ZW0gMC42MjVlbTtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgdGV4dCB3cmFwcGluZyBpbiBFZGdlIGFuZCBJRS5cXG4gKiAyLiBDb3JyZWN0IHRoZSBjb2xvciBpbmhlcml0YW5jZSBmcm9tIGBmaWVsZHNldGAgZWxlbWVudHMgaW4gSUUuXFxuICogMy4gUmVtb3ZlIHRoZSBwYWRkaW5nIHNvIGRldmVsb3BlcnMgYXJlIG5vdCBjYXVnaHQgb3V0IHdoZW4gdGhleSB6ZXJvIG91dFxcbiAqICAgIGBmaWVsZHNldGAgZWxlbWVudHMgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcbmxlZ2VuZCB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgZGlzcGxheTogdGFibGU7IC8qIDEgKi9cXG4gIG1heC13aWR0aDogMTAwJTsgLyogMSAqL1xcbiAgcGFkZGluZzogMDsgLyogMyAqL1xcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDsgLyogMSAqL1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSwgRmlyZWZveCwgYW5kIE9wZXJhLlxcbiAqL1xcbnByb2dyZXNzIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBkZWZhdWx0IHZlcnRpY2FsIHNjcm9sbGJhciBpbiBJRSAxMCsuXFxuICovXFxudGV4dGFyZWEge1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIElFIDEwLlxcbiAqIDIuIFJlbW92ZSB0aGUgcGFkZGluZyBpbiBJRSAxMC5cXG4gKi9cXG5bdHlwZT1jaGVja2JveF0sXFxuW3R5cGU9cmFkaW9dIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIHBhZGRpbmc6IDA7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gQ2hyb21lLlxcbiAqL1xcblt0eXBlPW51bWJlcl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuW3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxcbiAqIDIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxcbiAqL1xcblt0eXBlPXNlYXJjaF0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7IC8qIDEgKi9cXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4OyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXG4gKi9cXG5bdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKiAyLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXFxuICovXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKiBJbnRlcmFjdGl2ZVxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLypcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBFZGdlLCBJRSAxMCssIGFuZCBGaXJlZm94LlxcbiAqL1xcbmRldGFpbHMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbi8qXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcbnN1bW1hcnkge1xcbiAgZGlzcGxheTogbGlzdC1pdGVtO1xcbn1cXG5cXG4vKiBNaXNjXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSAxMCsuXFxuICovXFxudGVtcGxhdGUge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgMTAuXFxuICovXFxuW2hpZGRlbl0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuYm9keSB7XFxuICBmb250LWZhbWlseTogXFxcIllzYWJlYXUgSW5mYW50XFxcIiwgc2Fucy1zZXJpZjtcXG59XFxuXFxuLnJlc2V0LWJ0biwgLm1vZGFsLWJ0biwgLmZvb3Rlcl9fbGluaywgLmJ0biB7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlLW91dDtcXG59XFxuXFxuaHRtbCB7XFxuICBmb250LXNpemU6IDEwcHg7XFxufVxcblxcbmJvZHkge1xcbiAgZm9udC1zaXplOiAxLjZyZW07XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgbGluZS1oZWlnaHQ6IDIuNnJlbTtcXG59XFxuXFxuLmNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGhlaWdodDogMTAwdmg7XFxufVxcblxcbiNyb290IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyZjhiY2M7XFxuICBjb2xvcjogIzExMTA0MjtcXG4gIHRleHQtc2hhZG93OiAwcHggMHB4IDNweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxufVxcblxcbi5iYWNrZ3JvdW5kIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZmxleDogMSAwIGF1dG87XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fICsgXCIpO1xcbiAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbi5idG4ge1xcbiAgYm9yZGVyOiAycHggc29saWQgIzExMTA0MjtcXG4gIGJvcmRlci1yYWRpdXM6IDFyZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGZvbnQtc2l6ZTogbGFyZ2VyO1xcbn1cXG5cXG4uYnRuOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMxMTEwNDI7XFxuICBjb2xvcjogI2ZmZmZmZjtcXG59XFxuXFxuKixcXG4qOmJlZm9yZSxcXG4qOmFmdGVyIHtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbi5wb2tlYmFsbF9fY29udGFpbmVyIHtcXG4gIHotaW5kZXg6IDEwO1xcbiAgbWFyZ2luOiAwIDNyZW07XFxufVxcblxcbi8qIFBva8OpIFN0eWxlcyAqL1xcbi5wb2tlYmFsbCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogMjAwcHg7XFxuICBoZWlnaHQ6IDIwMHB4O1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIGJvcmRlcjogMTBweCBzb2xpZCAjMDAwO1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGJveC1zaGFkb3c6IGluc2V0IC0xMHB4IDEwcHggMCAxMHB4ICNjY2M7XFxuICBhbmltYXRpb246IGZhbGwgMC4yNXMgZWFzZS1pbi1vdXQsIHNoYWtlIDEuMjVzIGN1YmljLWJlemllcigwLjM2LCAwLjA3LCAwLjE5LCAwLjk3KSAyO1xcbn1cXG5cXG4uZmluaXNoIHtcXG4gIGFuaW1hdGlvbjogYWN0aXZlQW5pbWF0aW9uIDFzIGluZmluaXRlIGVhc2UtaW4tb3V0O1xcbn1cXG5cXG4ucG9rZWJhbGw6OmJlZm9yZSxcXG4ucG9rZWJhbGw6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG4ucG9rZWJhbGw6OmJlZm9yZSB7XFxuICBiYWNrZ3JvdW5kOiByZWQ7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogNTAlO1xcbn1cXG5cXG4ucG9rZWJhbGw6OmFmdGVyIHtcXG4gIHRvcDogY2FsYyg1MCUgLSAxMHB4KTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgYmFja2dyb3VuZDogIzAwMDtcXG59XFxuXFxuLnBva2ViYWxsX19idXR0b24ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiBjYWxjKDUwJSAtIDMwcHgpO1xcbiAgbGVmdDogY2FsYyg1MCUgLSAzMHB4KTtcXG4gIHdpZHRoOiA2MHB4O1xcbiAgaGVpZ2h0OiA2MHB4O1xcbiAgYmFja2dyb3VuZDogIzdmOGM4ZDtcXG4gIGJvcmRlcjogMTBweCBzb2xpZCAjZmZmO1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgei1pbmRleDogMTA7XFxuICBib3gtc2hhZG93OiAwIDAgMCAxMHB4IGJsYWNrO1xcbiAgYW5pbWF0aW9uOiBibGluayAwLjVzIGFsdGVybmF0ZSA1O1xcbn1cXG5cXG4vKiBBbmltYXRpb24gKi9cXG5Aa2V5ZnJhbWVzIGJsaW5rIHtcXG4gIGZyb20ge1xcbiAgICBiYWNrZ3JvdW5kOiAjZWVlO1xcbiAgfVxcbiAgdG8ge1xcbiAgICBiYWNrZ3JvdW5kOiAjZTc0YzNjO1xcbiAgfVxcbn1cXG5Aa2V5ZnJhbWVzIHNoYWtlIHtcXG4gIDAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCkgcm90YXRlKDApO1xcbiAgfVxcbiAgMjAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwcHgsIDApIHJvdGF0ZSgtMjBkZWcpO1xcbiAgfVxcbiAgMzAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMTBweCwgMCkgcm90YXRlKDIwZGVnKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC0xMHB4LCAwKSByb3RhdGUoLTEwZGVnKTtcXG4gIH1cXG4gIDYwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDEwcHgsIDApIHJvdGF0ZSgxMGRlZyk7XFxuICB9XFxuICAxMDAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCkgcm90YXRlKDApO1xcbiAgfVxcbn1cXG5Aa2V5ZnJhbWVzIGZhbGwge1xcbiAgMCUge1xcbiAgICB0b3A6IC0yMDBweDtcXG4gIH1cXG4gIDYwJSB7XFxuICAgIHRvcDogMDtcXG4gIH1cXG4gIDgwJSB7XFxuICAgIHRvcDogLTIwcHg7XFxuICB9XFxuICAxMDAlIHtcXG4gICAgdG9wOiAwO1xcbiAgfVxcbn1cXG4uaGVhZGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZmxleC1zaHJpbms6IDA7XFxuICBwYWRkaW5nOiAxcmVtO1xcbn1cXG5cXG4uaGVhZGVyX19sb2dvIHtcXG4gIHdpZHRoOiAyMHJlbTtcXG4gIGhlaWdodDogN3JlbTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gKyBcIik7XFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG4uaGVhZGVyX190aXRsZSB7XFxuICBtYXJnaW46IDA7XFxuICBmb250LXNpemU6IDIuNXJlbTtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgbGluZS1oZWlnaHQ6IDIuNnJlbTtcXG59XFxuXFxuLmhlYWRlcl9fbGluayB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5tYWluIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGZsZXgtZ3JvdzogMTtcXG59XFxuXFxuLnRhc2stdGl0bGUge1xcbiAgZm9udC1zaXplOiA3cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDdyZW07XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5wb2tlbW9ucyB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgcGFkZGluZzogMnJlbSAwO1xcbn1cXG5cXG4ucG9rZW1vbiB7XFxuICB3aWR0aDogMjByZW07XFxufVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtaGVpZ2h0OiA4MDBweCkge1xcbiAgLnRhc2stdGl0bGUge1xcbiAgICBmb250LXNpemU6IDVyZW07XFxuICAgIGxpbmUtaGVpZ2h0OiA2cmVtO1xcbiAgfVxcbiAgLnBva2Vtb24ge1xcbiAgICB3aWR0aDogMTVyZW07XFxuICB9XFxufVxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc4MHB4KSB7XFxuICAucG9rZW1vbiB7XFxuICAgIHdpZHRoOiAxMHJlbTtcXG4gIH1cXG4gIC50YXNrLXRpdGxlIHtcXG4gICAgZm9udC1zaXplOiA1cmVtO1xcbiAgICBsaW5lLWhlaWdodDogNnJlbTtcXG4gIH1cXG59XFxuLmVkaXRvciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgbWluLXdpZHRoOiA4MCU7XFxuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoM3B4KTtcXG4gIGJveC1zaGFkb3c6IDRweCA0cHggMTBweCAwcHggcmdiYSgxNywgMTYsIDY2LCAwLjUpO1xcbiAgcGFkZGluZzogMXJlbTtcXG59XFxuLmVkaXRvcl9faGVhZGVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XFxuICBtYXJnaW46IDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBjb2xvcjogIzExMTA0MjtcXG59XFxuXFxuI2Nzcy1lZGl0b3IsXFxuI2h0bWwtdmlld2VyIHtcXG4gIGZsZXg6IDEgMSA1MCU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi5jbS1lZGl0b3Ige1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAzMHJlbTtcXG59XFxuXFxuQGtleWZyYW1lcyBzaGFrZUVkaXRvciB7XFxuICAwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gIH1cXG4gIDIwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTBweCk7XFxuICB9XFxuICA0MCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTBweCk7XFxuICB9XFxuICA2MCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwcHgpO1xcbiAgfVxcbiAgODAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwcHgpO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gIH1cXG59XFxuLnNoYWtlIHtcXG4gIGFuaW1hdGlvbjogc2hha2VFZGl0b3IgMC41cyBpbmZpbml0ZTtcXG59XFxuXFxuLmVudGVyLWJ0biB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3R0b206IDFyZW07XFxuICByaWdodDogMXJlbTtcXG4gIHdpZHRoOiA4cmVtO1xcbiAgaGVpZ2h0OiAzcmVtO1xcbn1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LWhlaWdodDogODAwcHgpIHtcXG4gIC5jbS1lZGl0b3Ige1xcbiAgICBoZWlnaHQ6IDIwcmVtO1xcbiAgfVxcbn1cXG4uZm9vdGVyIHtcXG4gIGZsZXgtc2hyaW5rOiAwO1xcbiAgY29sb3I6ICMxMTEwNDI7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgYm94LXNoYWRvdzogMCAtMXB4IDEwcHggNXB4IHJnYmEoMTcsIDE2LCA2NiwgMC41KTtcXG4gIGJhY2tkcm9wLWZpbHRlcjogYmx1cigzcHgpO1xcbn1cXG5cXG4uZm9vdGVyX19saW5rIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmZvb3Rlcl9fbGluazpob3ZlciB7XFxuICB0cmFuc2Zvcm06IHNjYWxlKDEuMDUpO1xcbn1cXG5cXG4uZ2l0aHViLWljb24ge1xcbiAgd2lkdGg6IDRyZW07XFxuICBoZWlnaHQ6IDRyZW07XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fICsgXCIpO1xcbiAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbn1cXG5cXG4ucnNzLWljb24ge1xcbiAgd2lkdGg6IDhyZW07XFxuICBoZWlnaHQ6IDRyZW07XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8zX19fICsgXCIpO1xcbiAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLmZvb3Rlcl9feWVhciB7XFxuICB0ZXh0LXNoYWRvdzogMHB4IDBweCAzcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcbn1cXG5cXG4ub3ZlcmxheS1tb2RhbCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDNweCk7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHotaW5kZXg6IC0yO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjVzIGVhc2U7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG4ub3ZlcmxheS1tb2RhbC5hY3RpdmUge1xcbiAgb3BhY2l0eTogMTtcXG4gIHotaW5kZXg6IDI7XFxufVxcblxcbi5tb2RhbC1jb250ZW50IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XFxuICBib3JkZXItcmFkaXVzOiAxcmVtO1xcbiAgcGFkZGluZzogMXJlbTtcXG59XFxuXFxuLm1vZGFsIHtcXG4gIHdpZHRoOiA3MCU7XFxuICBib3JkZXItcmFkaXVzOiAxcmVtO1xcbiAgYm94LXNoYWRvdzogNHB4IDRweCAxMHB4IDBweCByZ2JhKDE3LCAxNiwgNjYsIDAuNSk7XFxufVxcblxcbi5tb2RhbC1idG4tY29udGFpbmVyIHtcXG4gIHBhZGRpbmc6IDJyZW07XFxufVxcblxcbi5tb2RhbC1idG4ge1xcbiAgd2lkdGg6IDI1cmVtO1xcbiAgaGVpZ2h0OiA0cmVtO1xcbiAgYm9yZGVyOiAycHggc29saWQgIzExMTA0MjtcXG4gIGJvcmRlci1yYWRpdXM6IDFyZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGZvbnQtc2l6ZTogbGFyZ2VyO1xcbn1cXG5cXG4ubW9kYWwtYnRuOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMxMTEwNDI7XFxuICBjb2xvcjogI2ZmZmZmZjtcXG59XFxuXFxuLm1vZGFsLWNvbnRlbnRfX2ltYWdlIHtcXG4gIHBhZGRpbmctdG9wOiAxcmVtO1xcbn1cXG5cXG4ubW9kYWwtY29udGVudF9faW5mbyB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBwYWRkaW5nLXRvcDogMXJlbTtcXG4gIHdpZHRoOiA4MCU7XFxufVxcblxcbi5tb2RhbC1jb250ZW50X19pbmZvLXRpdGxlIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgZm9udC1zaXplOiBsYXJnZXI7XFxufVxcblxcbi5tb2RhbC1jb250ZW50X19pbmZvLXRleHQge1xcbiAgdGV4dC1hbGlnbjoganVzdGlmeTtcXG59XFxuXFxuLmJ1cmdlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGhlaWdodDogMjJweDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMzVweDtcXG4gIHJpZ2h0OiAyMHB4O1xcbiAgd2lkdGg6IDI5cHg7XFxuICB6LWluZGV4OiAyO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuNHMgZWFzZTtcXG59XFxuLmJ1cmdlciAuYmFyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAycHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTExMDQyO1xcbn1cXG4uYnVyZ2VyLmFjdGl2ZSB7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZykgdHJhbnNsYXRlKDE0cHgsIDApO1xcbn1cXG5cXG4ubmF2LWxpbmtzIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG59XFxuLm5hdi1saW5rcyBsaSB7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbn1cXG4ubmF2LWxpbmtzX19pdGVtIHtcXG4gIGZvbnQtc2l6ZTogbGFyZ2VyO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgdHJhbnNpdGlvbjogMC4zcztcXG59XFxuLm5hdi1saW5rc19faXRlbTpob3ZlciB7XFxuICBjb2xvcjogIzJmOGJjYztcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG4ubmF2LWxpbmtzX19pdGVtLWFjdGl2ZSB7XFxuICBjb2xvcjogIzJmOGJjYztcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgcGFkZGluZy1ib3R0b206IDNweDtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuXFxuLm1lbnUtY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgd2lkdGg6IDI1cmVtO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgcmlnaHQ6IC0yNXJlbTtcXG4gIHRvcDogMDtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjVzIGVhc2U7XFxuICB6LWluZGV4OiAxO1xcbiAgYmFja2dyb3VuZDogI2ZmZmZmZjtcXG4gIHBhZGRpbmc6IDAgNXJlbTtcXG59XFxuXFxuLm1lbnUtY29udGFpbmVyLmFjdGl2ZSB7XFxuICByaWdodDogMDtcXG4gIGJveC1zaGFkb3c6IC0xcHggMHB4IDVweCAwcHggIzExMTA0MjtcXG59XFxuXFxuLm1lbnUge1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLm92ZXJsYXkge1xcbiAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDNweCk7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHotaW5kZXg6IC0xO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjVzIGVhc2U7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG4ub3ZlcmxheS5hY3RpdmUge1xcbiAgb3BhY2l0eTogMTtcXG4gIHotaW5kZXg6IDE7XFxufVxcblxcbi5ib2R5LW92ZXJmbG93IHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi5tZW51LXRpdGxlIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLnJlc2V0LWJ0biB7XFxuICB3aWR0aDogMTVyZW07XFxuICBoZWlnaHQ6IDRyZW07XFxuICBib3JkZXI6IDJweCBzb2xpZCAjMTExMDQyO1xcbiAgYm9yZGVyLXJhZGl1czogMXJlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZm9udC1zaXplOiBsYXJnZXI7XFxufVxcblxcbi5yZXNldC1idG46aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzExMTA0MjtcXG4gIGNvbG9yOiAjZmZmZmZmO1xcbn1cXG5cXG4uYWN0aXZlLWltYWdlIHtcXG4gIGFuaW1hdGlvbjogYWN0aXZlQW5pbWF0aW9uIDFzIGluZmluaXRlIGVhc2UtaW4tb3V0O1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIGFjdGl2ZUFuaW1hdGlvbiB7XFxuICAwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICB9XFxuICA1MCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSk7XFxuICB9XFxuICAxMDAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gIH1cXG59XFxuLmFjdGl2ZSB7XFxuICBhbmltYXRpb24tcGxheS1zdGF0ZTogcnVubmluZztcXG59XFxuXFxuLnRpbnkge1xcbiAgd2lkdGg6IDEwcmVtO1xcbiAgbWFyZ2luOiAwIDJyZW07XFxufVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc4MHB4KSB7XFxuICAudGlueSB7XFxuICAgIHdpZHRoOiA3cmVtO1xcbiAgICBtYXJnaW46IDAgMXJlbTtcXG4gIH1cXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3Nhc3Mvc3R5bGVzLnNjc3NcIixcIndlYnBhY2s6Ly8uL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL2Fic3RyYWN0L19wbGFjZWhvbGRlcnMuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3Nhc3MvYmFzZS9fYmFzZS5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc2Fzcy9hYnN0cmFjdC9fbWl4aW5zLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL2Fic3RyYWN0L19jb25zdGFudHMuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3Nhc3MvaXRlbXMvX3Bva2ViYWxsLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL2xheW91dHMvX2hlYWRlci5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc2Fzcy9sYXlvdXRzL19tYWluLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL2xheW91dHMvX2VkaXRvci5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc2Fzcy9sYXlvdXRzL19mb290ZXIuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3Nhc3MvbGF5b3V0cy9fbW9kYWwuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3Nhc3MvbGF5b3V0cy9fbWVudS5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc2Fzcy9sYXlvdXRzL19wb2tlbW9uLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsZ0JBQWdCO0FDQWhCLDJFQUFBO0FBRUE7K0VBQUE7QUFHQTs7O0VBQUE7QUFLQTtFQUNFLGlCQUFBLEVBQUEsTUFBQTtFQUNBLDhCQUFBLEVBQUEsTUFBQTtBRERGOztBQ0lBOytFQUFBO0FBR0E7O0VBQUE7QUFJQTtFQUNFLFNBQUE7QURIRjs7QUNNQTs7RUFBQTtBQUlBO0VBQ0UsY0FBQTtBREpGOztBQ09BOzs7RUFBQTtBQUtBO0VBQ0UsY0FBQTtFQUNBLGdCQUFBO0FETEY7O0FDUUE7K0VBQUE7QUFHQTs7O0VBQUE7QUFLQTtFQUNFLHVCQUFBLEVBQUEsTUFBQTtFQUNBLFNBQUEsRUFBQSxNQUFBO0VBQ0EsaUJBQUEsRUFBQSxNQUFBO0FEUEY7O0FDVUE7OztFQUFBO0FBS0E7RUFDRSxpQ0FBQSxFQUFBLE1BQUE7RUFDQSxjQUFBLEVBQUEsTUFBQTtBRFJGOztBQ1dBOytFQUFBO0FBR0E7O0VBQUE7QUFJQTtFQUNFLDZCQUFBO0FEVkY7O0FDYUE7OztFQUFBO0FBS0E7RUFDRSxtQkFBQSxFQUFBLE1BQUE7RUFDQSwwQkFBQSxFQUFBLE1BQUE7RUFDQSxpQ0FBQSxFQUFBLE1BQUE7QURYRjs7QUNjQTs7RUFBQTtBQUlBOztFQUVFLG1CQUFBO0FEWkY7O0FDZUE7OztFQUFBO0FBS0E7OztFQUdFLGlDQUFBLEVBQUEsTUFBQTtFQUNBLGNBQUEsRUFBQSxNQUFBO0FEYkY7O0FDZ0JBOztFQUFBO0FB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LG1CQUFBO0VidXpCRjtBQUNGO0FhcHpCQTtFQUNFLDZCQUFBO0Fic3pCRjs7QWFuekJBO0VBQ0UsWUFBQTtFQUNBLGNBQUE7QWJzekJGOztBYW56QkE7RUFDRTtJQUNFLFdBQUE7SUFDQSxjQUFBO0Vic3pCRjtBQUNGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyohIG5vcm1hbGl6ZS5jc3MgdjguMC4xIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcyAqL1xcbi8qIERvY3VtZW50XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBsaW5lIGhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXFxuICogMi4gUHJldmVudCBhZGp1c3RtZW50cyBvZiBmb250IHNpemUgYWZ0ZXIgb3JpZW50YXRpb24gY2hhbmdlcyBpbiBpT1MuXFxuICovXFxuaHRtbCB7XFxuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMSAqL1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAyICovXFxufVxcblxcbi8qIFNlY3Rpb25zXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gKiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuYm9keSB7XFxuICBtYXJnaW46IDA7XFxufVxcblxcbi8qKlxcbiAqIFJlbmRlciB0aGUgYG1haW5gIGVsZW1lbnQgY29uc2lzdGVudGx5IGluIElFLlxcbiAqL1xcbm1haW4ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbi8qKlxcbiAqIENvcnJlY3QgdGhlIGZvbnQgc2l6ZSBhbmQgbWFyZ2luIG9uIGBoMWAgZWxlbWVudHMgd2l0aGluIGBzZWN0aW9uYCBhbmRcXG4gKiBgYXJ0aWNsZWAgY29udGV4dHMgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgU2FmYXJpLlxcbiAqL1xcbmgxIHtcXG4gIGZvbnQtc2l6ZTogMmVtO1xcbiAgbWFyZ2luOiAwLjY3ZW0gMDtcXG59XFxuXFxuLyogR3JvdXBpbmcgY29udGVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gRmlyZWZveC5cXG4gKiAyLiBTaG93IHRoZSBvdmVyZmxvdyBpbiBFZGdlIGFuZCBJRS5cXG4gKi9cXG5ociB7XFxuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDsgLyogMSAqL1xcbiAgaGVpZ2h0OiAwOyAvKiAxICovXFxuICBvdmVyZmxvdzogdmlzaWJsZTsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBhbmQgc2NhbGluZyBvZiBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIENvcnJlY3QgdGhlIG9kZCBgZW1gIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2Vycy5cXG4gKi9cXG5wcmUge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcbn1cXG5cXG4vKiBUZXh0LWxldmVsIHNlbWFudGljc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBncmF5IGJhY2tncm91bmQgb24gYWN0aXZlIGxpbmtzIGluIElFIDEwLlxcbiAqL1xcbmEge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcblxcbi8qKlxcbiAqIDEuIFJlbW92ZSB0aGUgYm90dG9tIGJvcmRlciBpbiBDaHJvbWUgNTctXFxuICogMi4gQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIElFLCBPcGVyYSwgYW5kIFNhZmFyaS5cXG4gKi9cXG5hYmJyW3RpdGxlXSB7XFxuICBib3JkZXItYm90dG9tOiBub25lOyAvKiAxICovXFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgLyogMiAqL1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxuICovXFxuYixcXG5zdHJvbmcge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2UgYW5kIHNjYWxpbmcgb2YgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuY29kZSxcXG5rYmQsXFxuc2FtcCB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlLCBtb25vc3BhY2U7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMWVtOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcbnNtYWxsIHtcXG4gIGZvbnQtc2l6ZTogODAlO1xcbn1cXG5cXG4vKipcXG4gKiBQcmV2ZW50IGBzdWJgIGFuZCBgc3VwYCBlbGVtZW50cyBmcm9tIGFmZmVjdGluZyB0aGUgbGluZSBoZWlnaHQgaW5cXG4gKiBhbGwgYnJvd3NlcnMuXFxuICovXFxuc3ViLFxcbnN1cCB7XFxuICBmb250LXNpemU6IDc1JTtcXG4gIGxpbmUtaGVpZ2h0OiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG5zdWIge1xcbiAgYm90dG9tOiAtMC4yNWVtO1xcbn1cXG5cXG5zdXAge1xcbiAgdG9wOiAtMC41ZW07XFxufVxcblxcbi8qIEVtYmVkZGVkIGNvbnRlbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qKlxcbiAqIFJlbW92ZSB0aGUgYm9yZGVyIG9uIGltYWdlcyBpbnNpZGUgbGlua3MgaW4gSUUgMTAuXFxuICovXFxuaW1nIHtcXG4gIGJvcmRlci1zdHlsZTogbm9uZTtcXG59XFxuXFxuLyogRm9ybXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qKlxcbiAqIDEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cXG4gKi9cXG5idXR0b24sXFxuaW5wdXQsXFxub3B0Z3JvdXAsXFxuc2VsZWN0LFxcbnRleHRhcmVhIHtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0OyAvKiAxICovXFxuICBmb250LXNpemU6IDEwMCU7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiAxLjE1OyAvKiAxICovXFxuICBtYXJnaW46IDA7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogU2hvdyB0aGUgb3ZlcmZsb3cgaW4gSUUuXFxuICogMS4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZS5cXG4gKi9cXG5idXR0b24sXFxuaW5wdXQgeyAvKiAxICovXFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlLCBGaXJlZm94LCBhbmQgSUUuXFxuICogMS4gUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBGaXJlZm94LlxcbiAqL1xcbmJ1dHRvbixcXG5zZWxlY3QgeyAvKiAxICovXFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKi9cXG5idXR0b24sXFxuW3R5cGU9YnV0dG9uXSxcXG5bdHlwZT1yZXNldF0sXFxuW3R5cGU9c3VibWl0XSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBib3JkZXIgYW5kIHBhZGRpbmcgaW4gRmlyZWZveC5cXG4gKi9cXG5idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9YnV0dG9uXTo6LW1vei1mb2N1cy1pbm5lcixcXG5bdHlwZT1yZXNldF06Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9c3VibWl0XTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4vKipcXG4gKiBSZXN0b3JlIHRoZSBmb2N1cyBzdHlsZXMgdW5zZXQgYnkgdGhlIHByZXZpb3VzIHJ1bGUuXFxuICovXFxuYnV0dG9uOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPWJ1dHRvbl06LW1vei1mb2N1c3JpbmcsXFxuW3R5cGU9cmVzZXRdOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPXN1Ym1pdF06LW1vei1mb2N1c3Jpbmcge1xcbiAgb3V0bGluZTogMXB4IGRvdHRlZCBCdXR0b25UZXh0O1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBwYWRkaW5nIGluIEZpcmVmb3guXFxuICovXFxuZmllbGRzZXQge1xcbiAgcGFkZGluZzogMC4zNWVtIDAuNzVlbSAwLjYyNWVtO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSB0ZXh0IHdyYXBwaW5nIGluIEVkZ2UgYW5kIElFLlxcbiAqIDIuIENvcnJlY3QgdGhlIGNvbG9yIGluaGVyaXRhbmNlIGZyb20gYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBJRS5cXG4gKiAzLiBSZW1vdmUgdGhlIHBhZGRpbmcgc28gZGV2ZWxvcGVycyBhcmUgbm90IGNhdWdodCBvdXQgd2hlbiB0aGV5IHplcm8gb3V0XFxuICogICAgYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxubGVnZW5kIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBkaXNwbGF5OiB0YWJsZTsgLyogMSAqL1xcbiAgbWF4LXdpZHRoOiAxMDAlOyAvKiAxICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxuICB3aGl0ZS1zcGFjZTogbm9ybWFsOyAvKiAxICovXFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgT3BlcmEuXFxuICovXFxucHJvZ3Jlc3Mge1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGRlZmF1bHQgdmVydGljYWwgc2Nyb2xsYmFyIGluIElFIDEwKy5cXG4gKi9cXG50ZXh0YXJlYSB7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuLyoqXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gSUUgMTAuXFxuICogMi4gUmVtb3ZlIHRoZSBwYWRkaW5nIGluIElFIDEwLlxcbiAqL1xcblt0eXBlPWNoZWNrYm94XSxcXG5bdHlwZT1yYWRpb10ge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xcbiAgcGFkZGluZzogMDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBDaHJvbWUuXFxuICovXFxuW3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG5bdHlwZT1udW1iZXJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgb2RkIGFwcGVhcmFuY2UgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxuICogMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXFxuICovXFxuW3R5cGU9c2VhcmNoXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGluIENocm9tZSBhbmQgU2FmYXJpIG9uIG1hY09TLlxcbiAqL1xcblt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbiAqIDIuIENoYW5nZSBmb250IHByb3BlcnRpZXMgdG8gYGluaGVyaXRgIGluIFNhZmFyaS5cXG4gKi9cXG46Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxuICBmb250OiBpbmhlcml0OyAvKiAyICovXFxufVxcblxcbi8qIEludGVyYWN0aXZlXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIEVkZ2UsIElFIDEwKywgYW5kIEZpcmVmb3guXFxuICovXFxuZGV0YWlscyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLypcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxufVxcblxcbi8qIE1pc2NcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDEwKy5cXG4gKi9cXG50ZW1wbGF0ZSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSAxMC5cXG4gKi9cXG5baGlkZGVuXSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG5ib2R5IHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiWXNhYmVhdSBJbmZhbnRcXFwiLCBzYW5zLXNlcmlmO1xcbn1cXG5cXG4ucmVzZXQtYnRuLCAubW9kYWwtYnRuLCAuZm9vdGVyX19saW5rLCAuYnRuIHtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2Utb3V0O1xcbn1cXG5cXG5odG1sIHtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG59XFxuXFxuYm9keSB7XFxuICBmb250LXNpemU6IDEuNnJlbTtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBsaW5lLWhlaWdodDogMi42cmVtO1xcbn1cXG5cXG4uY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG59XFxuXFxuI3Jvb3Qge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzJmOGJjYztcXG4gIGNvbG9yOiAjMTExMDQyO1xcbiAgdGV4dC1zaGFkb3c6IDBweCAwcHggM3B4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXG59XFxuXFxuLmJhY2tncm91bmQge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBmbGV4OiAxIDAgYXV0bztcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiLi4vYXNzZXRzL2xhbmRzY2FwZS5qcGdcXFwiKTtcXG4gIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG4uYnRuIHtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICMxMTEwNDI7XFxuICBib3JkZXItcmFkaXVzOiAxcmVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBmb250LXNpemU6IGxhcmdlcjtcXG59XFxuXFxuLmJ0bjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTExMDQyO1xcbiAgY29sb3I6ICNmZmZmZmY7XFxufVxcblxcbiosXFxuKjpiZWZvcmUsXFxuKjphZnRlciB7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5cXG4ucG9rZWJhbGxfX2NvbnRhaW5lciB7XFxuICB6LWluZGV4OiAxMDtcXG4gIG1hcmdpbjogMCAzcmVtO1xcbn1cXG5cXG4vKiBQb2vDqSBTdHlsZXMgKi9cXG4ucG9rZWJhbGwge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDIwMHB4O1xcbiAgaGVpZ2h0OiAyMDBweDtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBib3JkZXI6IDEwcHggc29saWQgIzAwMDtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBib3gtc2hhZG93OiBpbnNldCAtMTBweCAxMHB4IDAgMTBweCAjY2NjO1xcbiAgYW5pbWF0aW9uOiBmYWxsIDAuMjVzIGVhc2UtaW4tb3V0LCBzaGFrZSAxLjI1cyBjdWJpYy1iZXppZXIoMC4zNiwgMC4wNywgMC4xOSwgMC45NykgMjtcXG59XFxuXFxuLmZpbmlzaCB7XFxuICBhbmltYXRpb246IGFjdGl2ZUFuaW1hdGlvbiAxcyBpbmZpbml0ZSBlYXNlLWluLW91dDtcXG59XFxuXFxuLnBva2ViYWxsOjpiZWZvcmUsXFxuLnBva2ViYWxsOjphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLnBva2ViYWxsOjpiZWZvcmUge1xcbiAgYmFja2dyb3VuZDogcmVkO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDUwJTtcXG59XFxuXFxuLnBva2ViYWxsOjphZnRlciB7XFxuICB0b3A6IGNhbGMoNTAlIC0gMTBweCk7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMjBweDtcXG4gIGJhY2tncm91bmQ6ICMwMDA7XFxufVxcblxcbi5wb2tlYmFsbF9fYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogY2FsYyg1MCUgLSAzMHB4KTtcXG4gIGxlZnQ6IGNhbGMoNTAlIC0gMzBweCk7XFxuICB3aWR0aDogNjBweDtcXG4gIGhlaWdodDogNjBweDtcXG4gIGJhY2tncm91bmQ6ICM3ZjhjOGQ7XFxuICBib3JkZXI6IDEwcHggc29saWQgI2ZmZjtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIHotaW5kZXg6IDEwO1xcbiAgYm94LXNoYWRvdzogMCAwIDAgMTBweCBibGFjaztcXG4gIGFuaW1hdGlvbjogYmxpbmsgMC41cyBhbHRlcm5hdGUgNTtcXG59XFxuXFxuLyogQW5pbWF0aW9uICovXFxuQGtleWZyYW1lcyBibGluayB7XFxuICBmcm9tIHtcXG4gICAgYmFja2dyb3VuZDogI2VlZTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgYmFja2dyb3VuZDogI2U3NGMzYztcXG4gIH1cXG59XFxuQGtleWZyYW1lcyBzaGFrZSB7XFxuICAwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDApIHJvdGF0ZSgwKTtcXG4gIH1cXG4gIDIwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC0xMHB4LCAwKSByb3RhdGUoLTIwZGVnKTtcXG4gIH1cXG4gIDMwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDEwcHgsIDApIHJvdGF0ZSgyMGRlZyk7XFxuICB9XFxuICA1MCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTBweCwgMCkgcm90YXRlKC0xMGRlZyk7XFxuICB9XFxuICA2MCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxMHB4LCAwKSByb3RhdGUoMTBkZWcpO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDApIHJvdGF0ZSgwKTtcXG4gIH1cXG59XFxuQGtleWZyYW1lcyBmYWxsIHtcXG4gIDAlIHtcXG4gICAgdG9wOiAtMjAwcHg7XFxuICB9XFxuICA2MCUge1xcbiAgICB0b3A6IDA7XFxuICB9XFxuICA4MCUge1xcbiAgICB0b3A6IC0yMHB4O1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIHRvcDogMDtcXG4gIH1cXG59XFxuLmhlYWRlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGZsZXgtc2hyaW5rOiAwO1xcbiAgcGFkZGluZzogMXJlbTtcXG59XFxuXFxuLmhlYWRlcl9fbG9nbyB7XFxuICB3aWR0aDogMjByZW07XFxuICBoZWlnaHQ6IDdyZW07XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcIi4uL2Fzc2V0cy9wb2vDqW1vbl9sb2dvLnBuZ1xcXCIpO1xcbiAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLmhlYWRlcl9fdGl0bGUge1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC1zaXplOiAyLjVyZW07XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGxpbmUtaGVpZ2h0OiAyLjZyZW07XFxufVxcblxcbi5oZWFkZXJfX2xpbmsge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4ubWFpbiB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBmbGV4LWdyb3c6IDE7XFxufVxcblxcbi50YXNrLXRpdGxlIHtcXG4gIGZvbnQtc2l6ZTogN3JlbTtcXG4gIGxpbmUtaGVpZ2h0OiA3cmVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4ucG9rZW1vbnMge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDJyZW0gMDtcXG59XFxuXFxuLnBva2Vtb24ge1xcbiAgd2lkdGg6IDIwcmVtO1xcbn1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LWhlaWdodDogODAwcHgpIHtcXG4gIC50YXNrLXRpdGxlIHtcXG4gICAgZm9udC1zaXplOiA1cmVtO1xcbiAgICBsaW5lLWhlaWdodDogNnJlbTtcXG4gIH1cXG4gIC5wb2tlbW9uIHtcXG4gICAgd2lkdGg6IDE1cmVtO1xcbiAgfVxcbn1cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3ODBweCkge1xcbiAgLnBva2Vtb24ge1xcbiAgICB3aWR0aDogMTByZW07XFxuICB9XFxuICAudGFzay10aXRsZSB7XFxuICAgIGZvbnQtc2l6ZTogNXJlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDZyZW07XFxuICB9XFxufVxcbi5lZGl0b3Ige1xcbiAgZGlzcGxheTogZmxleDtcXG4gIG1pbi13aWR0aDogODAlO1xcbiAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDNweCk7XFxuICBib3gtc2hhZG93OiA0cHggNHB4IDEwcHggMHB4IHJnYmEoMTcsIDE2LCA2NiwgMC41KTtcXG4gIHBhZGRpbmc6IDFyZW07XFxufVxcbi5lZGl0b3JfX2hlYWRlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xcbiAgbWFyZ2luOiAwO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgY29sb3I6ICMxMTEwNDI7XFxufVxcblxcbiNjc3MtZWRpdG9yLFxcbiNodG1sLXZpZXdlciB7XFxuICBmbGV4OiAxIDEgNTAlO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4uY20tZWRpdG9yIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMzByZW07XFxufVxcblxcbkBrZXlmcmFtZXMgc2hha2VFZGl0b3Ige1xcbiAgMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICB9XFxuICAyMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwcHgpO1xcbiAgfVxcbiAgNDAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwcHgpO1xcbiAgfVxcbiAgNjAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xMHB4KTtcXG4gIH1cXG4gIDgwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMHB4KTtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICB9XFxufVxcbi5zaGFrZSB7XFxuICBhbmltYXRpb246IHNoYWtlRWRpdG9yIDAuNXMgaW5maW5pdGU7XFxufVxcblxcbi5lbnRlci1idG4ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYm90dG9tOiAxcmVtO1xcbiAgcmlnaHQ6IDFyZW07XFxuICB3aWR0aDogOHJlbTtcXG4gIGhlaWdodDogM3JlbTtcXG59XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC1oZWlnaHQ6IDgwMHB4KSB7XFxuICAuY20tZWRpdG9yIHtcXG4gICAgaGVpZ2h0OiAyMHJlbTtcXG4gIH1cXG59XFxuLmZvb3RlciB7XFxuICBmbGV4LXNocmluazogMDtcXG4gIGNvbG9yOiAjMTExMDQyO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGJveC1zaGFkb3c6IDAgLTFweCAxMHB4IDVweCByZ2JhKDE3LCAxNiwgNjYsIDAuNSk7XFxuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoM3B4KTtcXG59XFxuXFxuLmZvb3Rlcl9fbGluayB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5mb290ZXJfX2xpbms6aG92ZXIge1xcbiAgdHJhbnNmb3JtOiBzY2FsZSgxLjA1KTtcXG59XFxuXFxuLmdpdGh1Yi1pY29uIHtcXG4gIHdpZHRoOiA0cmVtO1xcbiAgaGVpZ2h0OiA0cmVtO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCIuLi9hc3NldHMvbXlzdGljLWxvZ28ucG5nXFxcIik7XFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxufVxcblxcbi5yc3MtaWNvbiB7XFxuICB3aWR0aDogOHJlbTtcXG4gIGhlaWdodDogNHJlbTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiLi4vYXNzZXRzL3Jzcy5zdmdcXFwiKTtcXG4gIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbi5mb290ZXJfX3llYXIge1xcbiAgdGV4dC1zaGFkb3c6IDBweCAwcHggM3B4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXG59XFxuXFxuLm92ZXJsYXktbW9kYWwge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGJhY2tkcm9wLWZpbHRlcjogYmx1cigzcHgpO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB6LWluZGV4OiAtMjtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC41cyBlYXNlO1xcbiAgb3BhY2l0eTogMDtcXG59XFxuLm92ZXJsYXktbW9kYWwuYWN0aXZlIHtcXG4gIG9wYWNpdHk6IDE7XFxuICB6LWluZGV4OiAyO1xcbn1cXG5cXG4ubW9kYWwtY29udGVudCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xcbiAgYm9yZGVyLXJhZGl1czogMXJlbTtcXG4gIHBhZGRpbmc6IDFyZW07XFxufVxcblxcbi5tb2RhbCB7XFxuICB3aWR0aDogNzAlO1xcbiAgYm9yZGVyLXJhZGl1czogMXJlbTtcXG4gIGJveC1zaGFkb3c6IDRweCA0cHggMTBweCAwcHggcmdiYSgxNywgMTYsIDY2LCAwLjUpO1xcbn1cXG5cXG4ubW9kYWwtYnRuLWNvbnRhaW5lciB7XFxuICBwYWRkaW5nOiAycmVtO1xcbn1cXG5cXG4ubW9kYWwtYnRuIHtcXG4gIHdpZHRoOiAyNXJlbTtcXG4gIGhlaWdodDogNHJlbTtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICMxMTEwNDI7XFxuICBib3JkZXItcmFkaXVzOiAxcmVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBmb250LXNpemU6IGxhcmdlcjtcXG59XFxuXFxuLm1vZGFsLWJ0bjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTExMDQyO1xcbiAgY29sb3I6ICNmZmZmZmY7XFxufVxcblxcbi5tb2RhbC1jb250ZW50X19pbWFnZSB7XFxuICBwYWRkaW5nLXRvcDogMXJlbTtcXG59XFxuXFxuLm1vZGFsLWNvbnRlbnRfX2luZm8ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgcGFkZGluZy10b3A6IDFyZW07XFxuICB3aWR0aDogODAlO1xcbn1cXG5cXG4ubW9kYWwtY29udGVudF9faW5mby10aXRsZSB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGZvbnQtc2l6ZTogbGFyZ2VyO1xcbn1cXG5cXG4ubW9kYWwtY29udGVudF9faW5mby10ZXh0IHtcXG4gIHRleHQtYWxpZ246IGp1c3RpZnk7XFxufVxcblxcbi5idXJnZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBoZWlnaHQ6IDIycHg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDM1cHg7XFxuICByaWdodDogMjBweDtcXG4gIHdpZHRoOiAyOXB4O1xcbiAgei1pbmRleDogMjtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjRzIGVhc2U7XFxufVxcbi5idXJnZXIgLmJhciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMnB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzExMTA0MjtcXG59XFxuLmJ1cmdlci5hY3RpdmUge1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpIHRyYW5zbGF0ZSgxNHB4LCAwKTtcXG59XFxuXFxuLm5hdi1saW5rcyB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7XFxufVxcbi5uYXYtbGlua3MgbGkge1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG59XFxuLm5hdi1saW5rc19faXRlbSB7XFxuICBmb250LXNpemU6IGxhcmdlcjtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHRyYW5zaXRpb246IDAuM3M7XFxufVxcbi5uYXYtbGlua3NfX2l0ZW06aG92ZXIge1xcbiAgY29sb3I6ICMyZjhiY2M7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuLm5hdi1saW5rc19faXRlbS1hY3RpdmUge1xcbiAgY29sb3I6ICMyZjhiY2M7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHBhZGRpbmctYm90dG9tOiAzcHg7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbi5tZW51LWNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtZXZlbmx5O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHdpZHRoOiAyNXJlbTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHJpZ2h0OiAtMjVyZW07XFxuICB0b3A6IDA7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC41cyBlYXNlO1xcbiAgei1pbmRleDogMTtcXG4gIGJhY2tncm91bmQ6ICNmZmZmZmY7XFxuICBwYWRkaW5nOiAwIDVyZW07XFxufVxcblxcbi5tZW51LWNvbnRhaW5lci5hY3RpdmUge1xcbiAgcmlnaHQ6IDA7XFxuICBib3gtc2hhZG93OiAtMXB4IDBweCA1cHggMHB4ICMxMTEwNDI7XFxufVxcblxcbi5tZW51IHtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblxcbi5vdmVybGF5IHtcXG4gIGJhY2tkcm9wLWZpbHRlcjogYmx1cigzcHgpO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB6LWluZGV4OiAtMTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC41cyBlYXNlO1xcbiAgb3BhY2l0eTogMDtcXG59XFxuLm92ZXJsYXkuYWN0aXZlIHtcXG4gIG9wYWNpdHk6IDE7XFxuICB6LWluZGV4OiAxO1xcbn1cXG5cXG4uYm9keS1vdmVyZmxvdyB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4ubWVudS10aXRsZSB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5yZXNldC1idG4ge1xcbiAgd2lkdGg6IDE1cmVtO1xcbiAgaGVpZ2h0OiA0cmVtO1xcbiAgYm9yZGVyOiAycHggc29saWQgIzExMTA0MjtcXG4gIGJvcmRlci1yYWRpdXM6IDFyZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGZvbnQtc2l6ZTogbGFyZ2VyO1xcbn1cXG5cXG4ucmVzZXQtYnRuOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMxMTEwNDI7XFxuICBjb2xvcjogI2ZmZmZmZjtcXG59XFxuXFxuLmFjdGl2ZS1pbWFnZSB7XFxuICBhbmltYXRpb246IGFjdGl2ZUFuaW1hdGlvbiAxcyBpbmZpbml0ZSBlYXNlLWluLW91dDtcXG59XFxuXFxuQGtleWZyYW1lcyBhY3RpdmVBbmltYXRpb24ge1xcbiAgMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICB9XFxufVxcbi5hY3RpdmUge1xcbiAgYW5pbWF0aW9uLXBsYXktc3RhdGU6IHJ1bm5pbmc7XFxufVxcblxcbi50aW55IHtcXG4gIHdpZHRoOiAxMHJlbTtcXG4gIG1hcmdpbjogMCAycmVtO1xcbn1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3ODBweCkge1xcbiAgLnRpbnkge1xcbiAgICB3aWR0aDogN3JlbTtcXG4gICAgbWFyZ2luOiAwIDFyZW07XFxuICB9XFxufVwiLFwiLyohIG5vcm1hbGl6ZS5jc3MgdjguMC4xIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcyAqL1xcblxcbi8qIERvY3VtZW50XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBsaW5lIGhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXFxuICogMi4gUHJldmVudCBhZGp1c3RtZW50cyBvZiBmb250IHNpemUgYWZ0ZXIgb3JpZW50YXRpb24gY2hhbmdlcyBpbiBpT1MuXFxuICovXFxuXFxuaHRtbCB7XFxuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMSAqL1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAyICovXFxufVxcblxcbi8qIFNlY3Rpb25zXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxuYm9keSB7XFxuICBtYXJnaW46IDA7XFxufVxcblxcbi8qKlxcbiAqIFJlbmRlciB0aGUgYG1haW5gIGVsZW1lbnQgY29uc2lzdGVudGx5IGluIElFLlxcbiAqL1xcblxcbm1haW4ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbi8qKlxcbiAqIENvcnJlY3QgdGhlIGZvbnQgc2l6ZSBhbmQgbWFyZ2luIG9uIGBoMWAgZWxlbWVudHMgd2l0aGluIGBzZWN0aW9uYCBhbmRcXG4gKiBgYXJ0aWNsZWAgY29udGV4dHMgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgU2FmYXJpLlxcbiAqL1xcblxcbmgxIHtcXG4gIGZvbnQtc2l6ZTogMmVtO1xcbiAgbWFyZ2luOiAwLjY3ZW0gMDtcXG59XFxuXFxuLyogR3JvdXBpbmcgY29udGVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gRmlyZWZveC5cXG4gKiAyLiBTaG93IHRoZSBvdmVyZmxvdyBpbiBFZGdlIGFuZCBJRS5cXG4gKi9cXG5cXG5ociB7XFxuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDsgLyogMSAqL1xcbiAgaGVpZ2h0OiAwOyAvKiAxICovXFxuICBvdmVyZmxvdzogdmlzaWJsZTsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBhbmQgc2NhbGluZyBvZiBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIENvcnJlY3QgdGhlIG9kZCBgZW1gIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2Vycy5cXG4gKi9cXG5cXG5wcmUge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcbn1cXG5cXG4vKiBUZXh0LWxldmVsIHNlbWFudGljc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBncmF5IGJhY2tncm91bmQgb24gYWN0aXZlIGxpbmtzIGluIElFIDEwLlxcbiAqL1xcblxcbmEge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcblxcbi8qKlxcbiAqIDEuIFJlbW92ZSB0aGUgYm90dG9tIGJvcmRlciBpbiBDaHJvbWUgNTctXFxuICogMi4gQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIElFLCBPcGVyYSwgYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5hYmJyW3RpdGxlXSB7XFxuICBib3JkZXItYm90dG9tOiBub25lOyAvKiAxICovXFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgLyogMiAqL1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYixcXG5zdHJvbmcge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2UgYW5kIHNjYWxpbmcgb2YgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxuY29kZSxcXG5rYmQsXFxuc2FtcCB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlLCBtb25vc3BhY2U7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMWVtOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbnNtYWxsIHtcXG4gIGZvbnQtc2l6ZTogODAlO1xcbn1cXG5cXG4vKipcXG4gKiBQcmV2ZW50IGBzdWJgIGFuZCBgc3VwYCBlbGVtZW50cyBmcm9tIGFmZmVjdGluZyB0aGUgbGluZSBoZWlnaHQgaW5cXG4gKiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxuc3ViLFxcbnN1cCB7XFxuICBmb250LXNpemU6IDc1JTtcXG4gIGxpbmUtaGVpZ2h0OiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG5zdWIge1xcbiAgYm90dG9tOiAtMC4yNWVtO1xcbn1cXG5cXG5zdXAge1xcbiAgdG9wOiAtMC41ZW07XFxufVxcblxcbi8qIEVtYmVkZGVkIGNvbnRlbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgYm9yZGVyIG9uIGltYWdlcyBpbnNpZGUgbGlua3MgaW4gSUUgMTAuXFxuICovXFxuXFxuaW1nIHtcXG4gIGJvcmRlci1zdHlsZTogbm9uZTtcXG59XFxuXFxuLyogRm9ybXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIDEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5idXR0b24sXFxuaW5wdXQsXFxub3B0Z3JvdXAsXFxuc2VsZWN0LFxcbnRleHRhcmVhIHtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0OyAvKiAxICovXFxuICBmb250LXNpemU6IDEwMCU7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiAxLjE1OyAvKiAxICovXFxuICBtYXJnaW46IDA7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogU2hvdyB0aGUgb3ZlcmZsb3cgaW4gSUUuXFxuICogMS4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZS5cXG4gKi9cXG5cXG5idXR0b24sXFxuaW5wdXQgeyAvKiAxICovXFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlLCBGaXJlZm94LCBhbmQgSUUuXFxuICogMS4gUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBGaXJlZm94LlxcbiAqL1xcblxcbmJ1dHRvbixcXG5zZWxlY3QgeyAvKiAxICovXFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5idXR0b24sXFxuW3R5cGU9XFxcImJ1dHRvblxcXCJdLFxcblt0eXBlPVxcXCJyZXNldFxcXCJdLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBib3JkZXIgYW5kIHBhZGRpbmcgaW4gRmlyZWZveC5cXG4gKi9cXG5cXG5idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcImJ1dHRvblxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJyZXNldFxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4vKipcXG4gKiBSZXN0b3JlIHRoZSBmb2N1cyBzdHlsZXMgdW5zZXQgYnkgdGhlIHByZXZpb3VzIHJ1bGUuXFxuICovXFxuXFxuYnV0dG9uOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPVxcXCJidXR0b25cXFwiXTotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwicmVzZXRcXFwiXTotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl06LW1vei1mb2N1c3Jpbmcge1xcbiAgb3V0bGluZTogMXB4IGRvdHRlZCBCdXR0b25UZXh0O1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBwYWRkaW5nIGluIEZpcmVmb3guXFxuICovXFxuXFxuZmllbGRzZXQge1xcbiAgcGFkZGluZzogMC4zNWVtIDAuNzVlbSAwLjYyNWVtO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSB0ZXh0IHdyYXBwaW5nIGluIEVkZ2UgYW5kIElFLlxcbiAqIDIuIENvcnJlY3QgdGhlIGNvbG9yIGluaGVyaXRhbmNlIGZyb20gYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBJRS5cXG4gKiAzLiBSZW1vdmUgdGhlIHBhZGRpbmcgc28gZGV2ZWxvcGVycyBhcmUgbm90IGNhdWdodCBvdXQgd2hlbiB0aGV5IHplcm8gb3V0XFxuICogICAgYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxubGVnZW5kIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBkaXNwbGF5OiB0YWJsZTsgLyogMSAqL1xcbiAgbWF4LXdpZHRoOiAxMDAlOyAvKiAxICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxuICB3aGl0ZS1zcGFjZTogbm9ybWFsOyAvKiAxICovXFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgT3BlcmEuXFxuICovXFxuXFxucHJvZ3Jlc3Mge1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGRlZmF1bHQgdmVydGljYWwgc2Nyb2xsYmFyIGluIElFIDEwKy5cXG4gKi9cXG5cXG50ZXh0YXJlYSB7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuLyoqXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gSUUgMTAuXFxuICogMi4gUmVtb3ZlIHRoZSBwYWRkaW5nIGluIElFIDEwLlxcbiAqL1xcblxcblt0eXBlPVxcXCJjaGVja2JveFxcXCJdLFxcblt0eXBlPVxcXCJyYWRpb1xcXCJdIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIHBhZGRpbmc6IDA7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gQ2hyb21lLlxcbiAqL1xcblxcblt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG5bdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBvZGQgYXBwZWFyYW5jZSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXG4gKiAyLiBDb3JyZWN0IHRoZSBvdXRsaW5lIHN0eWxlIGluIFNhZmFyaS5cXG4gKi9cXG5cXG5bdHlwZT1cXFwic2VhcmNoXFxcIl0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7IC8qIDEgKi9cXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4OyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXG4gKi9cXG5cXG5bdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbiAqIDIuIENoYW5nZSBmb250IHByb3BlcnRpZXMgdG8gYGluaGVyaXRgIGluIFNhZmFyaS5cXG4gKi9cXG5cXG46Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxuICBmb250OiBpbmhlcml0OyAvKiAyICovXFxufVxcblxcbi8qIEludGVyYWN0aXZlXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIEVkZ2UsIElFIDEwKywgYW5kIEZpcmVmb3guXFxuICovXFxuXFxuZGV0YWlscyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLypcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxuc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxufVxcblxcbi8qIE1pc2NcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDEwKy5cXG4gKi9cXG5cXG50ZW1wbGF0ZSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSAxMC5cXG4gKi9cXG5cXG5baGlkZGVuXSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cIixcIiVmb250LXByaW0ge1xcclxcbiAgZm9udC1mYW1pbHk6ICdZc2FiZWF1IEluZmFudCcsIHNhbnMtc2VyaWY7XFxyXFxufVxcclxcblxcclxcbiV0cmFuc2l0aW9uIHtcXHJcXG4gIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZS1vdXQ7XFxyXFxufVwiLFwiaHRtbCB7XFxyXFxuICBmb250LXNpemU6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbmJvZHkge1xcclxcbiAgQGV4dGVuZCAlZm9udC1wcmltO1xcclxcbiAgQGluY2x1ZGUgZm9udCgkc2l6ZTogMS42cmVtLCAkaGVpZ2h0OiAyLjZyZW0sICR3ZWlnaHQ6IG5vcm1hbCk7XFxyXFxufVxcclxcblxcclxcbi5jb250YWluZXIge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBoZWlnaHQ6IDEwMHZoO1xcclxcbn1cXHJcXG5cXHJcXG4jcm9vdCB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAkY29sb3Itc2t5O1xcclxcbiAgY29sb3I6ICRjb2xvci1kYXJrO1xcclxcbiAgdGV4dC1zaGFkb3c6IDBweCAwcHggM3B4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXHJcXG59XFxyXFxuXFxyXFxuLmJhY2tncm91bmQge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBmbGV4OiAxIDAgYXV0bztcXHJcXG5cXHJcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnLi4vYXNzZXRzL2xhbmRzY2FwZS5qcGcnKTtcXHJcXG4gIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxyXFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcbn1cXHJcXG5cXHJcXG4uYnRuIHtcXHJcXG4gIGJvcmRlcjogMnB4IHNvbGlkICRjb2xvci1kYXJrO1xcclxcbiAgYm9yZGVyLXJhZGl1czogMXJlbTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgQGV4dGVuZCAldHJhbnNpdGlvbjtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIGZvbnQtc2l6ZTogbGFyZ2VyO1xcclxcbn1cXHJcXG5cXHJcXG4uYnRuOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRjb2xvci1kYXJrO1xcclxcbiAgY29sb3I6ICRjb2xvci1saWdodDtcXHJcXG59XCIsXCJAbWl4aW4gZm9udCAoJHNpemUsICRoZWlnaHQ6ICRzaXplLCAkd2VpZ2h0OiBib2xkLCAkc3R5bGU6IG5vcm1hbCkge1xcclxcbiAgZm9udC1zaXplOiAkc2l6ZTtcXHJcXG4gIGZvbnQtc3R5bGU6ICRzdHlsZTtcXHJcXG4gIGZvbnQtd2VpZ2h0OiAkd2VpZ2h0O1xcclxcbiAgbGluZS1oZWlnaHQ6ICRoZWlnaHQ7XFxyXFxufVxcclxcblxcclxcbkBtaXhpbiBncmlkU2l6ZSgkc2l6ZSkge1xcclxcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoJHNpemUsIDNyZW0pO1xcclxcbn1cIixcIiRjb2xvci1saWdodDogI2ZmZmZmZjtcXHJcXG4kY29sb3Itc2t5OiAjMmY4YmNjO1xcclxcbiRjb2xvci1kYXJrOiAjMTExMDQyO1wiLFwiKixcXHJcXG4qOmJlZm9yZSxcXHJcXG4qOmFmdGVyIHtcXHJcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG4gIC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxufVxcclxcblxcclxcbi5wb2tlYmFsbF9fY29udGFpbmVyIHtcXHJcXG4gIHotaW5kZXg6IDEwO1xcclxcbiAgbWFyZ2luOiAwIDNyZW07XFxyXFxufVxcclxcblxcclxcbi8qIFBva8OpIFN0eWxlcyAqL1xcclxcbi5wb2tlYmFsbCB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICB3aWR0aDogMjAwcHg7XFxyXFxuICBoZWlnaHQ6IDIwMHB4O1xcclxcbiAgYmFja2dyb3VuZDogI2ZmZjtcXHJcXG4gIGJvcmRlcjogMTBweCBzb2xpZCAjMDAwO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcclxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gIGJveC1zaGFkb3c6IGluc2V0IC0xMHB4IDEwcHggMCAxMHB4ICNjY2M7XFxyXFxuICBhbmltYXRpb246IGZhbGwgLjI1cyBlYXNlLWluLW91dCxcXHJcXG4gICAgc2hha2UgMS4yNXMgY3ViaWMtYmV6aWVyKC4zNiwgLjA3LCAuMTksIC45NykgMjtcXHJcXG59XFxyXFxuXFxyXFxuLmZpbmlzaCB7XFxyXFxuICBhbmltYXRpb246IGFjdGl2ZUFuaW1hdGlvbiAxcyBpbmZpbml0ZSBlYXNlLWluLW91dDtcXHJcXG59XFxyXFxuXFxyXFxuLnBva2ViYWxsOjpiZWZvcmUsXFxyXFxuLnBva2ViYWxsOjphZnRlciB7XFxyXFxuICBjb250ZW50OiBcXFwiXFxcIjtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLnBva2ViYWxsOjpiZWZvcmUge1xcclxcbiAgYmFja2dyb3VuZDogcmVkO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDUwJTtcXHJcXG59XFxyXFxuXFxyXFxuLnBva2ViYWxsOjphZnRlciB7XFxyXFxuICB0b3A6IGNhbGMoNTAlIC0gMTBweCk7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGhlaWdodDogMjBweDtcXHJcXG4gIGJhY2tncm91bmQ6ICMwMDA7XFxyXFxufVxcclxcblxcclxcbi5wb2tlYmFsbF9fYnV0dG9uIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHRvcDogY2FsYyg1MCUgLSAzMHB4KTtcXHJcXG4gIGxlZnQ6IGNhbGMoNTAlIC0gMzBweCk7XFxyXFxuICB3aWR0aDogNjBweDtcXHJcXG4gIGhlaWdodDogNjBweDtcXHJcXG4gIGJhY2tncm91bmQ6ICM3ZjhjOGQ7XFxyXFxuICBib3JkZXI6IDEwcHggc29saWQgI2ZmZjtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXHJcXG4gIHotaW5kZXg6IDEwO1xcclxcbiAgYm94LXNoYWRvdzogMCAwIDAgMTBweCBibGFjaztcXHJcXG4gIGFuaW1hdGlvbjogYmxpbmsgLjVzIGFsdGVybmF0ZSA1O1xcclxcbn1cXHJcXG5cXHJcXG4vKiBBbmltYXRpb24gKi9cXHJcXG5Aa2V5ZnJhbWVzIGJsaW5rIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZWVlO1xcclxcbiAgfVxcclxcblxcclxcbiAgdG8ge1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZTc0YzNjO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHNoYWtlIHtcXHJcXG4gIDAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCkgcm90YXRlKDApO1xcclxcbiAgfVxcclxcblxcclxcbiAgMjAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwcHgsIDApIHJvdGF0ZSgtMjBkZWcpO1xcclxcbiAgfVxcclxcblxcclxcbiAgMzAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMTBweCwgMCkgcm90YXRlKDIwZGVnKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIDUwJSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC0xMHB4LCAwKSByb3RhdGUoLTEwZGVnKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIDYwJSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDEwcHgsIDApIHJvdGF0ZSgxMGRlZyk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAxMDAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCkgcm90YXRlKDApO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIGZhbGwge1xcclxcbiAgMCUge1xcclxcbiAgICB0b3A6IC0yMDBweFxcclxcbiAgfVxcclxcblxcclxcbiAgNjAlIHtcXHJcXG4gICAgdG9wOiAwXFxyXFxuICB9XFxyXFxuXFxyXFxuICA4MCUge1xcclxcbiAgICB0b3A6IC0yMHB4XFxyXFxuICB9XFxyXFxuXFxyXFxuICAxMDAlIHtcXHJcXG4gICAgdG9wOiAwXFxyXFxuICB9XFxyXFxufVwiLFwiLmhlYWRlciB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGZsZXgtc2hyaW5rOiAwO1xcclxcbiAgcGFkZGluZzogMXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlcl9fbG9nbyB7XFxyXFxuICB3aWR0aDogMjByZW07XFxyXFxuICBoZWlnaHQ6IDdyZW07XFxyXFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy4uL2Fzc2V0cy9wb2vDqW1vbl9sb2dvLnBuZycpO1xcclxcbiAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcclxcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlcl9fdGl0bGUge1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgQGluY2x1ZGUgZm9udCgkc2l6ZTogMi41cmVtLCAkaGVpZ2h0OiAyLjZyZW0sICR3ZWlnaHQ6IGJvbGQpO1xcclxcbn1cXHJcXG5cXHJcXG4uaGVhZGVyX19saW5rIHtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XCIsXCIubWFpbiB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBmbGV4LWdyb3c6IDE7XFxyXFxufVxcclxcblxcclxcbi50YXNrLXRpdGxlIHtcXHJcXG4gIGZvbnQtc2l6ZTogN3JlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiA3cmVtO1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4ucG9rZW1vbnMge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIHBhZGRpbmc6IDJyZW0gMDtcXHJcXG59XFxyXFxuXFxyXFxuLnBva2Vtb24ge1xcclxcbiAgd2lkdGg6IDIwcmVtO1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LWhlaWdodDogODAwcHgpIHtcXHJcXG4gIC50YXNrLXRpdGxlIHtcXHJcXG4gICAgZm9udC1zaXplOiA1cmVtO1xcclxcbiAgICBsaW5lLWhlaWdodDogNnJlbTtcXHJcXG4gIH1cXHJcXG5cXHJcXG5cXHJcXG4gIC5wb2tlbW9uIHtcXHJcXG4gICAgd2lkdGg6IDE1cmVtO1xcclxcbiAgfVxcclxcblxcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3ODBweCkge1xcclxcbiAgLnBva2Vtb24ge1xcclxcbiAgICB3aWR0aDogMTByZW07XFxyXFxuICB9XFxyXFxuXFxyXFxuICAudGFzay10aXRsZSB7XFxyXFxuICAgIGZvbnQtc2l6ZTogNXJlbTtcXHJcXG4gICAgbGluZS1oZWlnaHQ6IDZyZW07XFxyXFxuICB9XFxyXFxufVwiLFwiLmVkaXRvciB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgbWluLXdpZHRoOiA4MCU7XFxyXFxuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoM3B4KTtcXHJcXG4gIGJveC1zaGFkb3c6IDRweCA0cHggMTBweCAwcHggcmdiYSgxNywgMTYsIDY2LCAwLjUpO1xcclxcbiAgcGFkZGluZzogMXJlbTtcXHJcXG5cXHJcXG4gICZfX2hlYWRlciB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICRjb2xvci1saWdodDtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAgIGNvbG9yOiAkY29sb3ItZGFyaztcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuI2Nzcy1lZGl0b3IsXFxyXFxuI2h0bWwtdmlld2VyIHtcXHJcXG4gIGZsZXg6IDEgMSA1MCU7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcblxcclxcbi5jbS1lZGl0b3Ige1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogJGNvbG9yLWxpZ2h0O1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDMwcmVtO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHNoYWtlRWRpdG9yIHtcXHJcXG4gIDAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcclxcbiAgfVxcclxcblxcclxcbiAgMjAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xMHB4KTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIDQwJSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMHB4KTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIDYwJSB7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTBweCk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICA4MCUge1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTBweCk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAxMDAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uc2hha2Uge1xcclxcbiAgYW5pbWF0aW9uOiBzaGFrZUVkaXRvciAwLjVzIGluZmluaXRlO1xcclxcbn1cXHJcXG5cXHJcXG4uZW50ZXItYnRuIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGJvdHRvbTogMXJlbTtcXHJcXG4gIHJpZ2h0OiAxcmVtO1xcclxcbiAgd2lkdGg6IDhyZW07XFxyXFxuICBoZWlnaHQ6IDNyZW07XFxyXFxufVxcclxcblxcclxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtaGVpZ2h0OiA4MDBweCkge1xcclxcbiAgLmNtLWVkaXRvciB7XFxyXFxuICAgIGhlaWdodDogMjByZW07XFxyXFxuICB9XFxyXFxufVwiLFwiLmZvb3RlciB7XFxyXFxuICBmbGV4LXNocmluazogMDtcXHJcXG5cXHJcXG4gIGNvbG9yOiAkY29sb3ItZGFyaztcXHJcXG5cXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBib3gtc2hhZG93OiAwIC0xcHggMTBweCA1cHggcmdiYSgxNywgMTYsIDY2LCAwLjUpO1xcclxcbiAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDNweCk7XFxyXFxufVxcclxcblxcclxcbi5mb290ZXJfX2xpbmsge1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgQGV4dGVuZCAldHJhbnNpdGlvbjtcXHJcXG5cXHJcXG5cXHJcXG4gICY6aG92ZXIge1xcclxcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMDUpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uZ2l0aHViLWljb24ge1xcclxcbiAgd2lkdGg6IDRyZW07XFxyXFxuICBoZWlnaHQ6IDRyZW07XFxyXFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcIi4uL2Fzc2V0cy9teXN0aWMtbG9nby5wbmdcXFwiKTtcXHJcXG4gIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXHJcXG59XFxyXFxuXFxyXFxuLnJzcy1pY29uIHtcXHJcXG4gIHdpZHRoOiA4cmVtO1xcclxcbiAgaGVpZ2h0OiA0cmVtO1xcclxcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCIuLi9hc3NldHMvcnNzLnN2Z1xcXCIpO1xcclxcbiAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcclxcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXHJcXG59XFxyXFxuXFxyXFxuLmZvb3Rlcl9feWVhciB7XFxyXFxuICB0ZXh0LXNoYWRvdzogMHB4IDBweCAzcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcclxcbn1cIixcIi5vdmVybGF5LW1vZGFsIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoM3B4KTtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgcG9zaXRpb246IGZpeGVkO1xcclxcbiAgei1pbmRleDogLTI7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgdHJhbnNpdGlvbjogYWxsIDAuNXMgZWFzZTtcXHJcXG4gIG9wYWNpdHk6IDA7XFxyXFxuXFxyXFxuICAmLmFjdGl2ZSB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIHotaW5kZXg6IDI7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1jb250ZW50IHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRjb2xvci1saWdodDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDFyZW07XFxyXFxuICBwYWRkaW5nOiAxcmVtO1xcclxcbn1cXHJcXG5cXHJcXG4ubW9kYWwge1xcclxcbiAgd2lkdGg6IDcwJTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDFyZW07XFxyXFxuICBib3gtc2hhZG93OiA0cHggNHB4IDEwcHggMHB4IHJnYmEoMTcsIDE2LCA2NiwgMC41KTtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWJ0bi1jb250YWluZXIge1xcclxcbiAgcGFkZGluZzogMnJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWJ0biB7XFxyXFxuICB3aWR0aDogMjVyZW07XFxyXFxuICBoZWlnaHQ6IDRyZW07XFxyXFxuICBib3JkZXI6IDJweCBzb2xpZCAkY29sb3ItZGFyaztcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDFyZW07XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG4gIEBleHRlbmQgJXRyYW5zaXRpb247XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICBmb250LXNpemU6IGxhcmdlcjtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWJ0bjpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAkY29sb3ItZGFyaztcXHJcXG4gIGNvbG9yOiAkY29sb3ItbGlnaHQ7XFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1jb250ZW50X19pbWFnZSB7XFxyXFxuICBwYWRkaW5nLXRvcDogMXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWNvbnRlbnRfX2luZm8ge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgcGFkZGluZy10b3A6IDFyZW07XFxyXFxuICB3aWR0aDogODAlO1xcclxcbn1cXHJcXG5cXHJcXG4ubW9kYWwtY29udGVudF9faW5mby10aXRsZSB7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG4gIGZvbnQtc2l6ZTogbGFyZ2VyO1xcclxcbn1cXHJcXG5cXHJcXG4ubW9kYWwtY29udGVudF9faW5mby10ZXh0IHtcXHJcXG4gIHRleHQtYWxpZ246IGp1c3RpZnk7XFxyXFxufVwiLFwiLmJ1cmdlciB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGhlaWdodDogMjJweDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXHJcXG4gIHRvcDogMzVweDtcXHJcXG4gIHJpZ2h0OiAyMHB4O1xcclxcbiAgd2lkdGg6IDI5cHg7XFxyXFxuICB6LWluZGV4OiAyO1xcclxcbiAgdHJhbnNpdGlvbjogYWxsIDAuNHMgZWFzZTtcXHJcXG5cXHJcXG4gIC5iYXIge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAycHg7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICRjb2xvci1kYXJrO1xcclxcbiAgfVxcclxcblxcclxcbiAgJi5hY3RpdmUge1xcclxcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZykgdHJhbnNsYXRlKDE0cHgsIDApO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4ubmF2LWxpbmtzIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBsaXN0LXN0eWxlOiBub25lO1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG5cXHJcXG4gIGxpIHtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXHJcXG4gIH1cXHJcXG5cXHJcXG5cXHJcXG4gICZfX2l0ZW0ge1xcclxcbiAgICBmb250LXNpemU6IGxhcmdlcjtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgICB0cmFuc2l0aW9uOiAwLjNzO1xcclxcblxcclxcbiAgICAmOmhvdmVyIHtcXHJcXG4gICAgICBjb2xvcjogJGNvbG9yLXNreTtcXHJcXG4gICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAmLWFjdGl2ZSB7XFxyXFxuICAgICAgY29sb3I6ICRjb2xvci1za3k7XFxyXFxuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuICAgICAgcGFkZGluZy1ib3R0b206IDNweDtcXHJcXG4gICAgICBjdXJzb3I6IGRlZmF1bHQ7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLm1lbnUtY29udGFpbmVyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgd2lkdGg6IDI1cmVtO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgcG9zaXRpb246IGZpeGVkO1xcclxcbiAgcmlnaHQ6IC0yNXJlbTtcXHJcXG4gIHRvcDogMDtcXHJcXG4gIHRyYW5zaXRpb246IGFsbCAwLjVzIGVhc2U7XFxyXFxuICB6LWluZGV4OiAxO1xcclxcbiAgYmFja2dyb3VuZDogJGNvbG9yLWxpZ2h0O1xcclxcbiAgcGFkZGluZzogMCA1cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4ubWVudS1jb250YWluZXIuYWN0aXZlIHtcXHJcXG4gIHJpZ2h0OiAwO1xcclxcbiAgYm94LXNoYWRvdzogLTFweCAwcHggNXB4IDBweCAkY29sb3ItZGFyaztcXHJcXG59XFxyXFxuXFxyXFxuLm1lbnUge1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG59XFxyXFxuXFxyXFxuLy9PdmVybGF5IG1lbnVcXHJcXG4ub3ZlcmxheSB7XFxyXFxuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoM3B4KTtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgcG9zaXRpb246IGZpeGVkO1xcclxcbiAgei1pbmRleDogLTE7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgdHJhbnNpdGlvbjogYWxsIDAuNXMgZWFzZTtcXHJcXG4gIG9wYWNpdHk6IDA7XFxyXFxuXFxyXFxuICAmLmFjdGl2ZSB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIHotaW5kZXg6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5ib2R5LW92ZXJmbG93IHtcXHJcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxyXFxufVxcclxcblxcclxcbi5tZW51LXRpdGxlIHtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLnJlc2V0LWJ0biB7XFxyXFxuICB3aWR0aDogMTVyZW07XFxyXFxuICBoZWlnaHQ6IDRyZW07XFxyXFxuICBib3JkZXI6IDJweCBzb2xpZCAkY29sb3ItZGFyaztcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDFyZW07XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG4gIEBleHRlbmQgJXRyYW5zaXRpb247XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICBmb250LXNpemU6IGxhcmdlcjtcXHJcXG59XFxyXFxuXFxyXFxuLnJlc2V0LWJ0bjpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAkY29sb3ItZGFyaztcXHJcXG4gIGNvbG9yOiAkY29sb3ItbGlnaHQ7XFxyXFxufVwiLFwiLmFjdGl2ZS1pbWFnZSB7XFxyXFxuICBhbmltYXRpb246IGFjdGl2ZUFuaW1hdGlvbiAxcyBpbmZpbml0ZSBlYXNlLWluLW91dDtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBhY3RpdmVBbmltYXRpb24ge1xcclxcbiAgMCUge1xcclxcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgfVxcclxcblxcclxcbiAgNTAlIHtcXHJcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcclxcbiAgfVxcclxcblxcclxcbiAgMTAwJSB7XFxyXFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5hY3RpdmUge1xcclxcbiAgYW5pbWF0aW9uLXBsYXktc3RhdGU6IHJ1bm5pbmc7XFxyXFxufVxcclxcblxcclxcbi50aW55IHtcXHJcXG4gIHdpZHRoOiAxMHJlbTtcXHJcXG4gIG1hcmdpbjogMCAycmVtO1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3ODBweCkge1xcclxcbiAgLnRpbnkge1xcclxcbiAgICB3aWR0aDogN3JlbTtcXHJcXG4gICAgbWFyZ2luOiAwIDFyZW07XFxyXFxuICB9XFxyXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgJiYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXSk7IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKSB7XG4gIHZhciBfaXRlbSA9IF9zbGljZWRUb0FycmF5KGl0ZW0sIDQpLFxuICAgICAgY29udGVudCA9IF9pdGVtWzFdLFxuICAgICAgY3NzTWFwcGluZyA9IF9pdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBvcHRpb25zID0ge307XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBuby1wYXJhbS1yZWFzc2lnblxuXG5cbiAgdXJsID0gdXJsICYmIHVybC5fX2VzTW9kdWxlID8gdXJsLmRlZmF1bHQgOiB1cmw7XG5cbiAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9IC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuXG5cbiAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB1cmwgKz0gb3B0aW9ucy5oYXNoO1xuICB9IC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcblxuXG4gIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSB8fCBvcHRpb25zLm5lZWRRdW90ZXMpIHtcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIiksIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59OyIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlcy5zY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG52YXIgc3R5bGVzSW5Eb20gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgfTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbnZhciByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICB2YXIgdGV4dFN0b3JlID0gW107XG4gIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIikuY29uY2F0KG9iai5jc3MsIFwifVwiKSA6IG9iai5jc3M7IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzO1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQVBQX0lOVklURV9URVhUID0gZXhwb3J0cy5BUFBfREVTQ1JJUFRJT04gPSBleHBvcnRzLkFQUF9NT0RBTF9USVRMRSA9IGV4cG9ydHMuUE9LRU1PTl9DT01fTElOSyA9IGV4cG9ydHMuUlNTX0xJTksgPSBleHBvcnRzLkdJVEhVQl9MSU5LID0gdm9pZCAwO1xuZXhwb3J0cy5HSVRIVUJfTElOSyA9ICdodHRwczovL2dpdGh1Yi5jb20vT0tpdGVsJztcbmV4cG9ydHMuUlNTX0xJTksgPSAnaHR0cHM6Ly9ycy5zY2hvb2wvanMvJztcbmV4cG9ydHMuUE9LRU1PTl9DT01fTElOSyA9ICdodHRwczovL3d3dy5wb2tlbW9uLmNvbS91cyc7XG4vLyBNb2RhbCBpbmZvIHRleHRcbmV4cG9ydHMuQVBQX01PREFMX1RJVExFID0gJ/CflKUgQ2FsbGluZyBhbGwgYXNwaXJpbmcgdHJhaW5lcnMgYW5kIENTUyBlbnRodXNpYXN0cyEg8J+UpSc7XG5leHBvcnRzLkFQUF9ERVNDUklQVElPTiA9IFwiRGl2ZSBpbnRvIHRoZSB3b3JsZCBvZiBQb2tlbW9uIGFuZCBzaGFycGVuIHlvdXIgd2ViIHN0eWxpbmcgYWJpbGl0aWVzIGluIGFuIGV4Y2l0aW5nIG5ldyB3YXkuIFdpdGggdGhpcyBpbW1lcnNpdmUgc2ltdWxhdG9yLCB5b3UnbGwgZW1iYXJrIG9uIGEgYnJlYXRoLWNhdGNoaW5nIGpvdXJuZXkgd2hlcmUgeW91ciBDU1Mgc2VsZWN0b3JzIGFyZSB5b3VyIHVsdGltYXRlIFBva2Vtb24tY2F0Y2hpbmcgdG9vbHMhXCI7XG5leHBvcnRzLkFQUF9JTlZJVEVfVEVYVCA9ICdBcmUgeW91IHJlYWR5IHRvIHRha2UgeW91ciBDU1Mgc2VsZWN0b3Igc2tpbGxzIHRvIHRoZSBuZXh0IGxldmVsPyc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnJlcXVpcmUoXCIuL3Nhc3Mvc3R5bGVzLnNjc3NcIik7XG5jb25zdCBtZW51XzEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL21lbnVcIik7XG5jb25zdCBtb2RhbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21vZHVsZXMvbW9kYWxcIikpO1xuY29uc3QgaGVhZGVyXzEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2hlYWRlclwiKTtcbmNvbnN0IGZvb3Rlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21vZHVsZXMvZm9vdGVyXCIpKTtcbmNvbnN0IG1haW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tb2R1bGVzL21haW5cIikpO1xuY29uc3QgbGV2ZWxfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvbGV2ZWxcIik7XG5jb25zdCByZW5kZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tb2R1bGVzL3JlbmRlclwiKSk7XG5jb25zdCBjcmVhdGVWaWV3ID0gKCkgPT4ge1xuICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjb250YWluZXInKTtcbiAgICBjb25zdCBoZWFkZXIgPSAoMCwgaGVhZGVyXzEuY3JlYXRlSGVhZGVyVmlldykoKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICBjb25zdCBtYWluID0gKDAsIG1haW5fMS5kZWZhdWx0KSgpO1xuICAgIGNvbnN0IGZvb3RlciA9ICgwLCBmb290ZXJfMS5kZWZhdWx0KSgpO1xuICAgIGNvbnN0IGJhY2tncm91bmRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBiYWNrZ3JvdW5kQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdiYWNrZ3JvdW5kJztcbiAgICBiYWNrZ3JvdW5kQ29udGFpbmVyLmFwcGVuZENoaWxkKG1haW4pO1xuICAgIGJhY2tncm91bmRDb250YWluZXIuYXBwZW5kQ2hpbGQoZm9vdGVyKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZENvbnRhaW5lcik7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIH1cbiAgICAoMCwgbWVudV8xLmluaXRNZW51KSgpO1xuICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc3RhcnQnKSAhPT0gJ3JlYWQnKSB7XG4gICAgICAgICgwLCBtb2RhbF8xLmRlZmF1bHQpKCk7XG4gICAgfVxufTtcbmNyZWF0ZVZpZXcoKTtcbmNvbnN0IGN1cnJlbnRMZXZlbCA9ICgwLCBsZXZlbF8xLmdldEN1cnJlbnRMZXZlbCkoKTtcbigwLCByZW5kZXJfMS5kZWZhdWx0KShjdXJyZW50TGV2ZWwpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYWtlRWRpdG9yID0gZXhwb3J0cy5pbml0SHRtbEVkaXRvciA9IGV4cG9ydHMuZ2V0RWRpdG9yVmFsdWUgPSBleHBvcnRzLmluaXRDc3NFZGl0b3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlbWlycm9yXzEgPSByZXF1aXJlKFwiY29kZW1pcnJvclwiKTtcbmNvbnN0IHZpZXdfMSA9IHJlcXVpcmUoXCJAY29kZW1pcnJvci92aWV3XCIpO1xuY29uc3QgbGFuZ19jc3NfMSA9IHJlcXVpcmUoXCJAY29kZW1pcnJvci9sYW5nLWNzc1wiKTtcbmNvbnN0IGxhbmdfaHRtbF8xID0gcmVxdWlyZShcIkBjb2RlbWlycm9yL2xhbmctaHRtbFwiKTtcbmNvbnN0IGxldmVsXzEgPSByZXF1aXJlKFwiLi9sZXZlbFwiKTtcbmNvbnN0IGhhbmRsZVN1Ym1pdCA9ICh0YXJnZXQpID0+IHtcbiAgICBjb25zdCB1c2VyQW5zd2VyID0gdGFyZ2V0LnN0YXRlLmRvYy50b1N0cmluZygpO1xuICAgICgwLCBsZXZlbF8xLmNoZWNrQW5zd2VyKSh1c2VyQW5zd2VyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBrZXlzTWFwID0gdmlld18xLmtleW1hcC5vZihbXG4gICAge1xuICAgICAgICBrZXk6ICdFbnRlcicsXG4gICAgICAgIHJ1bjogaGFuZGxlU3VibWl0LFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuXSk7XG5sZXQgY3NzRWRpdG9yVmlldztcbmNvbnN0IGluaXRDc3NFZGl0b3IgPSAocGFyZW50KSA9PiB7XG4gICAgY3NzRWRpdG9yVmlldyA9IG5ldyBjb2RlbWlycm9yXzEuRWRpdG9yVmlldyh7XG4gICAgICAgIGV4dGVuc2lvbnM6IFtrZXlzTWFwLCBjb2RlbWlycm9yXzEuYmFzaWNTZXR1cCwgKDAsIGxhbmdfY3NzXzEuY3NzKSgpLCAoMCwgdmlld18xLnBsYWNlaG9sZGVyKShgVHlwZSB5b3VyIENTUyBoZXJlIGFuZCBoaXQgRW50ZXJgKV0sXG4gICAgICAgIHBhcmVudCxcbiAgICB9KTtcbn07XG5leHBvcnRzLmluaXRDc3NFZGl0b3IgPSBpbml0Q3NzRWRpdG9yO1xuY29uc3QgZ2V0RWRpdG9yVmFsdWUgPSAoKSA9PiBjc3NFZGl0b3JWaWV3LnN0YXRlLmRvYy50b1N0cmluZygpO1xuZXhwb3J0cy5nZXRFZGl0b3JWYWx1ZSA9IGdldEVkaXRvclZhbHVlO1xubGV0IGh0bWxFZGl0b3JWaWV3O1xuY29uc3QgaW5pdEh0bWxFZGl0b3IgPSAocGFyZW50LCBodG1sRGVzY3JpcHRpb24pID0+IHtcbiAgICBodG1sRWRpdG9yVmlldyA9IG5ldyBjb2RlbWlycm9yXzEuRWRpdG9yVmlldyh7XG4gICAgICAgIGRvYzogaHRtbERlc2NyaXB0aW9uLFxuICAgICAgICBleHRlbnNpb25zOiBbY29kZW1pcnJvcl8xLmJhc2ljU2V0dXAsICgwLCBsYW5nX2h0bWxfMS5odG1sKSgpXSxcbiAgICAgICAgcGFyZW50LFxuICAgIH0pO1xuICAgIHJldHVybiBodG1sRWRpdG9yVmlldztcbn07XG5leHBvcnRzLmluaXRIdG1sRWRpdG9yID0gaW5pdEh0bWxFZGl0b3I7XG5jb25zdCBzaGFrZUVkaXRvciA9ICgpID0+IHtcbiAgICBjb25zdCBlZGl0b3JGaWVsZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5lZGl0b3InKTtcbiAgICBpZiAoZWRpdG9yRmllbGQpIHtcbiAgICAgICAgZWRpdG9yRmllbGQuY2xhc3NMaXN0LmFkZCgnc2hha2UnKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3JGaWVsZC5jbGFzc0xpc3QucmVtb3ZlKCdzaGFrZScpO1xuICAgICAgICB9LCA1MDApO1xuICAgIH1cbn07XG5leHBvcnRzLnNoYWtlRWRpdG9yID0gc2hha2VFZGl0b3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4uL2NvbnN0c1wiKTtcbmNvbnN0IGNyZWF0ZUZvb3RlclZpZXcgPSAoKSA9PiB7XG4gICAgY29uc3QgZm9vdGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9vdGVyJyk7XG4gICAgZm9vdGVyLmNsYXNzTmFtZSA9ICdmb290ZXInO1xuICAgIGNvbnN0IGdpdGh1YkxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgZ2l0aHViTGluay5jbGFzc05hbWUgPSAnZm9vdGVyX19saW5rJztcbiAgICBnaXRodWJMaW5rLmhyZWYgPSBjb25zdHNfMS5HSVRIVUJfTElOSztcbiAgICBnaXRodWJMaW5rLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgIGNvbnN0IGdpdGh1Ykljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBnaXRodWJJY29uLmNsYXNzTmFtZSA9ICdnaXRodWItaWNvbic7XG4gICAgZ2l0aHViTGluay5hcHBlbmRDaGlsZChnaXRodWJJY29uKTtcbiAgICBjb25zdCB5ZWFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICB5ZWFyLmNsYXNzTmFtZSA9ICdmb290ZXJfX3llYXInO1xuICAgIHllYXIudGV4dENvbnRlbnQgPSAnMjAyMyc7XG4gICAgY29uc3QgcnNzTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICByc3NMaW5rLmNsYXNzTmFtZSA9ICdmb290ZXJfX2xpbmsnO1xuICAgIHJzc0xpbmsuaHJlZiA9IGNvbnN0c18xLlJTU19MSU5LO1xuICAgIHJzc0xpbmsudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgY29uc3QgcnNzSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJzc0ljb24uY2xhc3NOYW1lID0gJ3Jzcy1pY29uJztcbiAgICByc3NMaW5rLmFwcGVuZENoaWxkKHJzc0ljb24pO1xuICAgIGZvb3Rlci5hcHBlbmRDaGlsZChnaXRodWJMaW5rKTtcbiAgICBmb290ZXIuYXBwZW5kQ2hpbGQoeWVhcik7XG4gICAgZm9vdGVyLmFwcGVuZENoaWxkKHJzc0xpbmspO1xuICAgIHJldHVybiBmb290ZXI7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlRm9vdGVyVmlldztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVIZWFkZXJWaWV3ID0gZXhwb3J0cy5jcmVhdGVMb2dvV2l0aExpbmsgPSB2b2lkIDA7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG5jb25zdCBjcmVhdGVMb2dvV2l0aExpbmsgPSAoKSA9PiB7XG4gICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBsaW5rLmNsYXNzTmFtZSA9ICdoZWFkZXJfX2xpbmsnO1xuICAgIGxpbmsuaHJlZiA9IGNvbnN0c18xLlBPS0VNT05fQ09NX0xJTks7XG4gICAgbGluay50YXJnZXQgPSAnX2JsYW5rJztcbiAgICBjb25zdCBsb2dvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbG9nby5jbGFzc05hbWUgPSAnaGVhZGVyX19sb2dvJztcbiAgICBsaW5rLmFwcGVuZENoaWxkKGxvZ28pO1xuICAgIHJldHVybiBsaW5rO1xufTtcbmV4cG9ydHMuY3JlYXRlTG9nb1dpdGhMaW5rID0gY3JlYXRlTG9nb1dpdGhMaW5rO1xuY29uc3QgY3JlYXRlSGVhZGVyVmlldyA9ICgpID0+IHtcbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoZWFkZXInKTtcbiAgICBoZWFkZXIuY2xhc3NOYW1lID0gJ2hlYWRlcic7XG4gICAgY29uc3QgbGluayA9ICgwLCBleHBvcnRzLmNyZWF0ZUxvZ29XaXRoTGluaykoKTtcbiAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gxJyk7XG4gICAgdGl0bGUuY2xhc3NOYW1lID0gJ2hlYWRlcl9fdGl0bGUnO1xuICAgIHRpdGxlLnRleHRDb250ZW50ID0gJ0NTUyBMZWFndWUnO1xuICAgIGNvbnN0IGJ1cmdlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJ1cmdlci5jbGFzc05hbWUgPSAnYnVyZ2VyJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYmFyLmNsYXNzTmFtZSA9ICdiYXInO1xuICAgICAgICBidXJnZXIuYXBwZW5kQ2hpbGQoYmFyKTtcbiAgICB9XG4gICAgaGVhZGVyLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIGhlYWRlci5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgaGVhZGVyLmFwcGVuZENoaWxkKGJ1cmdlcik7XG4gICAgcmV0dXJuIGhlYWRlcjtcbn07XG5leHBvcnRzLmNyZWF0ZUhlYWRlclZpZXcgPSBjcmVhdGVIZWFkZXJWaWV3O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tBbnN3ZXIgPSBleHBvcnRzLnNldExldmVsID0gZXhwb3J0cy5nZXRDdXJyZW50TGV2ZWwgPSBleHBvcnRzLmxldmVscyA9IGV4cG9ydHMuY3JlYXRlTGV2ZWxzID0gdm9pZCAwO1xuY29uc3QgcG9rZW1vblJlcG9zaXRvcnlfMSA9IHJlcXVpcmUoXCIuLi9yZXBvL3Bva2Vtb25SZXBvc2l0b3J5XCIpO1xuY29uc3QgZGF0YUJhc2UgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2xldmVscy5qc29uXCIpKTtcbmNvbnN0IHJlbmRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlbmRlclwiKSk7XG5jb25zdCBwb2tlYmFsbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Bva2ViYWxsXCIpKTtcbmNvbnN0IGZpbmlzaF9wbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYXNzZXRzL2ZpbmlzaC5wbmdcIikpO1xuY29uc3QgZWRpdG9yXzEgPSByZXF1aXJlKFwiLi9lZGl0b3JcIik7XG5jb25zdCBtYWluXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFpblwiKSk7XG5jb25zdCBqc29uRGF0YSA9IGRhdGFCYXNlO1xuY29uc3QgY3JlYXRlTGV2ZWxzID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gZGF0YS5sZXZlbHMubWFwKChsZXZlbCkgPT4ge1xuICAgICAgICBjb25zdCBwb2tlbW9uc3RlcnMgPSAoMCwgcG9rZW1vblJlcG9zaXRvcnlfMS5nZXRQb2tlbW9uc0J5SWRzKShsZXZlbC5wb2tlbW9ucyk7XG4gICAgICAgIGNvbnN0IGNvckFucyA9IGxldmVsLmNvcnJlY3RBbnN3ZXJzLm1hcCgoeyBjc3MsIHBva2Vtb25zIH0pID0+ICh7XG4gICAgICAgICAgICBjc3MsXG4gICAgICAgICAgICBwb2tlbW9uczogKDAsIHBva2Vtb25SZXBvc2l0b3J5XzEuZ2V0UG9rZW1vbnNCeUlkcykocG9rZW1vbnMpLFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHdyb25nQW5zID0gbGV2ZWwud3JvbmdBbnN3ZXJzPy5tYXAoKHsgY3NzLCBwb2tlbW9ucyB9KSA9PiAoe1xuICAgICAgICAgICAgY3NzLFxuICAgICAgICAgICAgcG9rZW1vbnM6ICgwLCBwb2tlbW9uUmVwb3NpdG9yeV8xLmdldFBva2Vtb25zQnlJZHMpKHBva2Vtb25zKSxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4geyAuLi5sZXZlbCwgcG9rZW1vbnM6IHBva2Vtb25zdGVycywgY29ycmVjdEFuc3dlcnM6IGNvckFucywgd3JvbmdBbnN3ZXJzOiB3cm9uZ0FucyB9O1xuICAgIH0pO1xufTtcbmV4cG9ydHMuY3JlYXRlTGV2ZWxzID0gY3JlYXRlTGV2ZWxzO1xuZXhwb3J0cy5sZXZlbHMgPSAoMCwgZXhwb3J0cy5jcmVhdGVMZXZlbHMpKGpzb25EYXRhKTtcbmNvbnN0IGdldEN1cnJlbnRMZXZlbCA9ICgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbGV2ZWwnKSB8fCAnMCc7XG4gICAgY29uc3QgbGV2ZWwgPSBleHBvcnRzLmxldmVsc1srY3VycmVudExldmVsXTtcbiAgICByZXR1cm4gbGV2ZWw7XG59O1xuZXhwb3J0cy5nZXRDdXJyZW50TGV2ZWwgPSBnZXRDdXJyZW50TGV2ZWw7XG5jb25zdCBzaG93RmluaXNoID0gKCkgPT4ge1xuICAgIGNvbnN0IG1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbicpO1xuICAgIGlmIChtYWluKSB7XG4gICAgICAgIG1haW4uaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGNvbnN0IGZpbmlzaEltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBmaW5pc2hJbWcuc3JjID0gZmluaXNoX3BuZ18xLmRlZmF1bHQ7XG4gICAgICAgIGZpbmlzaEltZy5jbGFzc05hbWUgPSAnZmluaXNoJztcbiAgICAgICAgbWFpbi5hcHBlbmRDaGlsZChmaW5pc2hJbWcpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG1haW4ucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IG5ld01haW4gPSAoMCwgbWFpbl8xLmRlZmF1bHQpKCk7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChuZXdNYWluLCBtYWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCByZW5kZXJfMS5kZWZhdWx0KShleHBvcnRzLmxldmVsc1swXSk7XG4gICAgICAgIH0sIDMwMDApO1xuICAgIH1cbn07XG5jb25zdCBzZXRMZXZlbCA9IChsZXZlbCkgPT4ge1xuICAgIGlmIChsZXZlbCA8IGV4cG9ydHMubGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbGV2ZWwnLCBgJHtsZXZlbH1gKTtcbiAgICAgICAgY29uc3QgbCA9IGV4cG9ydHMubGV2ZWxzW2xldmVsXTtcbiAgICAgICAgKDAsIHJlbmRlcl8xLmRlZmF1bHQpKGwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2hvd0ZpbmlzaCgpO1xuICAgIH1cbn07XG5leHBvcnRzLnNldExldmVsID0gc2V0TGV2ZWw7XG5jb25zdCBzZXROZXh0TGV2ZWwgPSAoKSA9PiB7XG4gICAgY29uc3QgbCA9ICsobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2xldmVsJykgfHwgJzAnKTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgbGV2ZWwgJHtsfWAsICdkb25lJyk7XG4gICAgKDAsIGV4cG9ydHMuc2V0TGV2ZWwpKGwgKyAxKTtcbn07XG5jb25zdCBjaGVja0Fuc3dlciA9IChhbnN3ZXIpID0+IHtcbiAgICBjb25zdCBsZXZlbCA9ICgwLCBleHBvcnRzLmdldEN1cnJlbnRMZXZlbCkoKTtcbiAgICBjb25zdCB7IGNvcnJlY3RBbnN3ZXJzIH0gPSBsZXZlbDtcbiAgICBjb25zdCBtYXRjaCA9IGNvcnJlY3RBbnN3ZXJzLmZpbmQoKGFucykgPT4gYW5zLmNzcyA9PT0gYW5zd2VyLnRyaW0oKSk7XG4gICAgY29uc3QgY2F0Y2hlZFBva2Vtb25zID0gbWF0Y2g/LnBva2Vtb25zO1xuICAgIGNvbnN0IHZhbmlzaGVkUG9rZW1vbnMgPSBsZXZlbC5wb2tlbW9ucy5maWx0ZXIoKHBva2Vtb24pID0+ICFjYXRjaGVkUG9rZW1vbnM/LmluY2x1ZGVzKHBva2Vtb24pKTtcbiAgICBpZiAoY2F0Y2hlZFBva2Vtb25zKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUltYWdlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5hY3RpdmUtaW1hZ2UnKTtcbiAgICAgICAgYWN0aXZlSW1hZ2VzLmZvckVhY2goKGltZykgPT4ge1xuICAgICAgICAgICAgaWYgKGltZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGltZy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBva2ViYWxsID0gKDAsIHBva2ViYWxsXzEuZGVmYXVsdCkoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQocG9rZWJhbGwsIGltZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV2ZWwuZG9uZSA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0TmV4dExldmVsKCksIDMwMDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbmlzaGVkUG9rZW1vbnMpIHtcbiAgICAgICAgKDAsIGVkaXRvcl8xLnNoYWtlRWRpdG9yKSgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0cy5jaGVja0Fuc3dlciA9IGNoZWNrQW5zd2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBlZGl0b3JfMSA9IHJlcXVpcmUoXCIuL2VkaXRvclwiKTtcbmNvbnN0IGxldmVsXzEgPSByZXF1aXJlKFwiLi9sZXZlbFwiKTtcbmNvbnN0IGNyZWF0ZUNzc0VkaXRvclZpZXcgPSAoKSA9PiB7XG4gICAgY29uc3QgY3NzRWRpdG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY3NzRWRpdG9yRGl2LmlkID0gJ2Nzcy1lZGl0b3InO1xuICAgIGNvbnN0IGNzc0VkaXRvckhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gICAgY3NzRWRpdG9ySGVhZGVyLmNsYXNzTmFtZSA9ICdlZGl0b3JfX2hlYWRlcic7XG4gICAgY3NzRWRpdG9ySGVhZGVyLnRleHRDb250ZW50ID0gJ0NTUyBFZGl0b3InO1xuICAgIGNvbnN0IGNzc1ZpZXdlckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNzc1ZpZXdlckNvbnRhaW5lci5jbGFzc05hbWUgPSAnY3NzLXZpZXdlcl9fY29udGFpbmVyJztcbiAgICBjb25zdCBlbnRlckJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGVudGVyQnRuLmNsYXNzTmFtZSA9ICdlbnRlci1idG4gYnRuJztcbiAgICBlbnRlckJ0bi50ZXh0Q29udGVudCA9ICdFbnRlcic7XG4gICAgZW50ZXJCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZXJBbnN3ZXIgPSAoMCwgZWRpdG9yXzEuZ2V0RWRpdG9yVmFsdWUpKCk7XG4gICAgICAgICgwLCBsZXZlbF8xLmNoZWNrQW5zd2VyKSh1c2VyQW5zd2VyKTtcbiAgICB9KTtcbiAgICBjc3NFZGl0b3JEaXYuYXBwZW5kQ2hpbGQoY3NzRWRpdG9ySGVhZGVyKTtcbiAgICBjc3NFZGl0b3JEaXYuYXBwZW5kQ2hpbGQoY3NzVmlld2VyQ29udGFpbmVyKTtcbiAgICBjc3NFZGl0b3JEaXYuYXBwZW5kQ2hpbGQoZW50ZXJCdG4pO1xuICAgIHJldHVybiBjc3NFZGl0b3JEaXY7XG59O1xuY29uc3QgY3JlYXRlSHRtbEVkaXRvclZpZXcgPSAoKSA9PiB7XG4gICAgY29uc3QgaHRtbFZpZXdlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGh0bWxWaWV3ZXJEaXYuaWQgPSAnaHRtbC12aWV3ZXInO1xuICAgIGNvbnN0IGh0bWxWaWV3ZXJIZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xuICAgIGh0bWxWaWV3ZXJIZWFkZXIuY2xhc3NOYW1lID0gJ2VkaXRvcl9faGVhZGVyJztcbiAgICBodG1sVmlld2VySGVhZGVyLnRleHRDb250ZW50ID0gJ0hUTUwgVmlld2VyJztcbiAgICBjb25zdCBodG1sVmlld2VyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaHRtbFZpZXdlckNvbnRhaW5lci5jbGFzc05hbWUgPSAnaHRtbC12aWV3ZXJfX2NvbnRhaW5lcic7XG4gICAgaHRtbFZpZXdlckRpdi5hcHBlbmRDaGlsZChodG1sVmlld2VySGVhZGVyKTtcbiAgICBodG1sVmlld2VyRGl2LmFwcGVuZENoaWxkKGh0bWxWaWV3ZXJDb250YWluZXIpO1xuICAgIHJldHVybiBodG1sVmlld2VyRGl2O1xufTtcbmNvbnN0IGNyZWF0ZU1haW5WaWV3ID0gKCkgPT4ge1xuICAgIGNvbnN0IG1haW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtYWluJyk7XG4gICAgbWFpbi5jbGFzc05hbWUgPSAnbWFpbic7XG4gICAgY29uc3QgZWRpdG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWRpdG9yRGl2LmNsYXNzTmFtZSA9ICdlZGl0b3InO1xuICAgIGNvbnN0IGNzc0VkaXRvckRpdiA9IGNyZWF0ZUNzc0VkaXRvclZpZXcoKTtcbiAgICBjb25zdCBodG1sVmlld2VyRGl2ID0gY3JlYXRlSHRtbEVkaXRvclZpZXcoKTtcbiAgICBlZGl0b3JEaXYuYXBwZW5kQ2hpbGQoY3NzRWRpdG9yRGl2KTtcbiAgICBlZGl0b3JEaXYuYXBwZW5kQ2hpbGQoaHRtbFZpZXdlckRpdik7XG4gICAgY29uc3QgcG9rZW1vbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwb2tlbW9uc0Rpdi5jbGFzc05hbWUgPSAncG9rZW1vbnMnO1xuICAgIG1haW4uYXBwZW5kQ2hpbGQoZWRpdG9yRGl2KTtcbiAgICBtYWluLmFwcGVuZENoaWxkKHBva2Vtb25zRGl2KTtcbiAgICByZXR1cm4gbWFpbjtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNYWluVmlldztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbml0TWVudSA9IGV4cG9ydHMuY3JlYXRlTWVudSA9IGV4cG9ydHMuY3JlYXRlVWwgPSB2b2lkIDA7XG5jb25zdCBsZXZlbF8xID0gcmVxdWlyZShcIi4vbGV2ZWxcIik7XG5jb25zdCBNQVJLX0VNT0pJID0gJ+KclO+4jyc7XG5jb25zdCBjcmVhdGVVbCA9ICgpID0+IHtcbiAgICBjb25zdCB1bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgdWwuY2xhc3NOYW1lID0gJ25hdi1saW5rcyBtZW51JztcbiAgICBsZXZlbF8xLmxldmVscy5mb3JFYWNoKCh7IG1lbnVUaXRsZSB9LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIGEuY2xhc3NOYW1lID0gJ25hdi1saW5rc19faXRlbSc7XG4gICAgICAgIGNvbnN0IGRvbmUgPSAhIWxvY2FsU3RvcmFnZS5nZXRJdGVtKGBsZXZlbCAke2luZGV4fWApO1xuICAgICAgICBjb25zdCBtYXJrID0gZG9uZSA/IE1BUktfRU1PSkkgOiAnJztcbiAgICAgICAgYS50ZXh0Q29udGVudCA9IGAke21lbnVUaXRsZX0gJHttYXJrfWA7XG4gICAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAoMCwgbGV2ZWxfMS5zZXRMZXZlbCkoaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGkuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICAgIHVsLmFwcGVuZENoaWxkKGxpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdWw7XG59O1xuZXhwb3J0cy5jcmVhdGVVbCA9IGNyZWF0ZVVsO1xuY29uc3QgY3JlYXRlTWVudSA9ICgpID0+IHtcbiAgICBjb25zdCBvdmVybGF5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgb3ZlcmxheURpdi5jbGFzc05hbWUgPSAnb3ZlcmxheSc7XG4gICAgY29uc3QgbWVudUNvbnRhaW5lckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG1lbnVDb250YWluZXJEaXYuY2xhc3NOYW1lID0gJ21lbnUtY29udGFpbmVyJztcbiAgICBjb25zdCBuYXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCduYXYnKTtcbiAgICBjb25zdCBoMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gICAgaDMuY2xhc3NOYW1lID0gJ21lbnUtdGl0bGUnO1xuICAgIGgzLnRleHRDb250ZW50ID0gJ0Nob29zZSBhIGxldmVsJztcbiAgICBjb25zdCB1bCA9ICgwLCBleHBvcnRzLmNyZWF0ZVVsKSgpO1xuICAgIG5hdi5hcHBlbmRDaGlsZChoMyk7XG4gICAgbmF2LmFwcGVuZENoaWxkKHVsKTtcbiAgICBtZW51Q29udGFpbmVyRGl2LmFwcGVuZENoaWxkKG5hdik7XG4gICAgY29uc3QgcmVzZXRCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICByZXNldEJ0bi50ZXh0Q29udGVudCA9ICdSZXNldCBwcm9ncmVzcyc7XG4gICAgcmVzZXRCdG4uY2xhc3NOYW1lID0gJ3Jlc2V0LWJ0bic7XG4gICAgcmVzZXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpO1xuICAgICAgICAoMCwgbGV2ZWxfMS5zZXRMZXZlbCkoMCk7XG4gICAgfSk7XG4gICAgbWVudUNvbnRhaW5lckRpdi5hcHBlbmRDaGlsZChyZXNldEJ0bik7XG4gICAgb3ZlcmxheURpdi5hcHBlbmRDaGlsZChtZW51Q29udGFpbmVyRGl2KTtcbiAgICByZXR1cm4gb3ZlcmxheURpdjtcbn07XG5leHBvcnRzLmNyZWF0ZU1lbnUgPSBjcmVhdGVNZW51O1xuY29uc3QgaW5pdE1lbnUgPSAoKSA9PiB7XG4gICAgY29uc3Qgcm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290Jyk7XG4gICAgaWYgKHJvb3QpXG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoKDAsIGV4cG9ydHMuY3JlYXRlTWVudSkoKSk7XG4gICAgY29uc3QgeyBib2R5IH0gPSBkb2N1bWVudDtcbiAgICBjb25zdCBhZGFwdE1lbnUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWVudS1jb250YWluZXInKTtcbiAgICBjb25zdCBvdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm92ZXJsYXknKTtcbiAgICBjb25zdCBidXJnZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYnVyZ2VyJyk7XG4gICAgaWYgKGFkYXB0TWVudSkge1xuICAgICAgICBjb25zdCBtZW51TGlua3NBcnJheSA9IEFycmF5LmZyb20oYWRhcHRNZW51LnF1ZXJ5U2VsZWN0b3JBbGwoJy5uYXYtbGlua3NfX2l0ZW0nKSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZU1lbnUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWNrZWRFbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGNsaWNrZWRFbGVtZW50ICYmIGJ1cmdlciAmJiBvdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDbGlja09uQmFyID0gY2xpY2tlZEVsZW1lbnQuY2xvc2VzdCgnLmJ1cmdlcicpID09PSBidXJnZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDbGlja091dHNpZGVPZkFkYXB0TWVudSA9ICFhZGFwdE1lbnUuY29udGFpbnMoY2xpY2tlZEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2xpY2tPbkJ1cmdlckljb24gPSBjbGlja2VkRWxlbWVudCA9PT0gYnVyZ2VyIHx8IGlzQ2xpY2tPbkJhcjtcbiAgICAgICAgICAgICAgICBpZiAoKGlzQ2xpY2tPdXRzaWRlT2ZBZGFwdE1lbnUgJiYgIWlzQ2xpY2tPbkJ1cmdlckljb24pIHx8IG1lbnVMaW5rc0FycmF5LmluY2x1ZGVzKGNsaWNrZWRFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBidXJnZXIuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIGFkYXB0TWVudS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdib2R5LW92ZXJmbG93Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0NsaWNrT25CdXJnZXJJY29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1cmdlci5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgYWRhcHRNZW51LmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LmNsYXNzTGlzdC50b2dnbGUoJ2JvZHktb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChidXJnZXIpXG4gICAgICAgICAgICBidXJnZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVNZW51KTtcbiAgICAgICAgaWYgKG92ZXJsYXkpXG4gICAgICAgICAgICBvdmVybGF5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlTWVudSk7XG4gICAgfVxufTtcbmV4cG9ydHMuaW5pdE1lbnUgPSBpbml0TWVudTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuY29uc3QgcGlrYWNodV9wbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYXNzZXRzL3Bpa2FjaHUucG5nXCIpKTtcbmNvbnN0IGhlYWRlcl8xID0gcmVxdWlyZShcIi4vaGVhZGVyXCIpO1xuY29uc3QgY3JlYXRlTW9kYWxDb250ZW50SW5mbyA9ICgpID0+IHtcbiAgICBjb25zdCBtb2RhbENvbnRlbnRJbmZvRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbW9kYWxDb250ZW50SW5mb0Rpdi5jbGFzc05hbWUgPSAnbW9kYWwtY29udGVudF9faW5mbyc7XG4gICAgY29uc3QgbW9kYWxDb250ZW50SW5mb1RpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICBtb2RhbENvbnRlbnRJbmZvVGl0bGUuY2xhc3NOYW1lID0gJ21vZGFsLWNvbnRlbnRfX2luZm8tdGl0bGUnO1xuICAgIG1vZGFsQ29udGVudEluZm9UaXRsZS50ZXh0Q29udGVudCA9IGNvbnN0c18xLkFQUF9NT0RBTF9USVRMRTtcbiAgICBjb25zdCBtb2RhbENvbnRlbnRJbmZvVGV4dDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoNCcpO1xuICAgIG1vZGFsQ29udGVudEluZm9UZXh0MS5jbGFzc05hbWUgPSAnbW9kYWwtY29udGVudF9faW5mby10ZXh0JztcbiAgICBtb2RhbENvbnRlbnRJbmZvVGV4dDEudGV4dENvbnRlbnQgPSBjb25zdHNfMS5BUFBfREVTQ1JJUFRJT047XG4gICAgY29uc3QgbW9kYWxDb250ZW50SW5mb1RleHQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDQnKTtcbiAgICBtb2RhbENvbnRlbnRJbmZvVGV4dDIuY2xhc3NOYW1lID0gJ21vZGFsLWNvbnRlbnRfX2luZm8tdGV4dCc7XG4gICAgbW9kYWxDb250ZW50SW5mb1RleHQyLnRleHRDb250ZW50ID0gY29uc3RzXzEuQVBQX0lOVklURV9URVhUO1xuICAgIGNvbnN0IG1vZGFsQnRuQ29udGFpbmVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbW9kYWxCdG5Db250YWluZXJEaXYuY2xhc3NOYW1lID0gJ21vZGFsLWJ0bi1jb250YWluZXInO1xuICAgIGNvbnN0IG1vZGFsQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgbW9kYWxCdG4uY2xhc3NOYW1lID0gJ21vZGFsLWJ0bic7XG4gICAgbW9kYWxCdG4udGV4dENvbnRlbnQgPSAnU3RhcnQgeW91ciBhZHZlbnR1cmUgbm93ISc7XG4gICAgbW9kYWxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzdGFydCcsICdyZWFkJyk7XG4gICAgfSk7XG4gICAgbW9kYWxCdG5Db250YWluZXJEaXYuYXBwZW5kQ2hpbGQobW9kYWxCdG4pO1xuICAgIG1vZGFsQ29udGVudEluZm9EaXYuYXBwZW5kQ2hpbGQobW9kYWxDb250ZW50SW5mb1RpdGxlKTtcbiAgICBtb2RhbENvbnRlbnRJbmZvRGl2LmFwcGVuZENoaWxkKG1vZGFsQ29udGVudEluZm9UZXh0MSk7XG4gICAgbW9kYWxDb250ZW50SW5mb0Rpdi5hcHBlbmRDaGlsZChtb2RhbENvbnRlbnRJbmZvVGV4dDIpO1xuICAgIG1vZGFsQ29udGVudEluZm9EaXYuYXBwZW5kQ2hpbGQobW9kYWxCdG5Db250YWluZXJEaXYpO1xuICAgIHJldHVybiBtb2RhbENvbnRlbnRJbmZvRGl2O1xufTtcbmNvbnN0IGNyZWF0ZU1vZGFsVmlldyA9ICgpID0+IHtcbiAgICBjb25zdCBvdmVybGF5TW9kYWxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBvdmVybGF5TW9kYWxEaXYuY2xhc3NOYW1lID0gJ292ZXJsYXktbW9kYWwnO1xuICAgIGNvbnN0IG1vZGFsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbW9kYWxEaXYuY2xhc3NOYW1lID0gJ21vZGFsJztcbiAgICBjb25zdCBtb2RhbENvbnRlbnREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBtb2RhbENvbnRlbnREaXYuY2xhc3NOYW1lID0gJ21vZGFsLWNvbnRlbnQnO1xuICAgIGNvbnN0IGxpbmsgPSAoMCwgaGVhZGVyXzEuY3JlYXRlTG9nb1dpdGhMaW5rKSgpO1xuICAgIGNvbnN0IG1vZGFsQ29udGVudEltYWdlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbW9kYWxDb250ZW50SW1hZ2VEaXYuY2xhc3NOYW1lID0gJ21vZGFsLWNvbnRlbnRfX2ltYWdlJztcbiAgICBjb25zdCBtb2RhbEltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgbW9kYWxJbWFnZS5zcmMgPSBwaWthY2h1X3BuZ18xLmRlZmF1bHQ7XG4gICAgbW9kYWxDb250ZW50SW1hZ2VEaXYuYXBwZW5kQ2hpbGQobW9kYWxJbWFnZSk7XG4gICAgY29uc3QgbW9kYWxDb250ZW50SW5mb0RpdiA9IGNyZWF0ZU1vZGFsQ29udGVudEluZm8oKTtcbiAgICBtb2RhbENvbnRlbnREaXYuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgbW9kYWxDb250ZW50RGl2LmFwcGVuZENoaWxkKG1vZGFsQ29udGVudEltYWdlRGl2KTtcbiAgICBtb2RhbENvbnRlbnREaXYuYXBwZW5kQ2hpbGQobW9kYWxDb250ZW50SW5mb0Rpdik7XG4gICAgbW9kYWxEaXYuYXBwZW5kQ2hpbGQobW9kYWxDb250ZW50RGl2KTtcbiAgICBvdmVybGF5TW9kYWxEaXYuYXBwZW5kQ2hpbGQobW9kYWxEaXYpO1xuICAgIHJldHVybiBvdmVybGF5TW9kYWxEaXY7XG59O1xuY29uc3QgaW5pdE1vZGFsID0gKCkgPT4ge1xuICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpO1xuICAgIGlmIChyb290KVxuICAgICAgICByb290LmFwcGVuZENoaWxkKGNyZWF0ZU1vZGFsVmlldygpKTtcbiAgICBjb25zdCB7IGJvZHkgfSA9IGRvY3VtZW50O1xuICAgIGNvbnN0IG1vZGFsQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1vZGFsLWJ0bicpO1xuICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm92ZXJsYXktbW9kYWwnKTtcbiAgICBjb25zdCBtb2RhbENvbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubW9kYWwtY29udGVudCcpO1xuICAgIGlmIChtb2RhbCAmJiBib2R5ICYmIG1vZGFsQ29udCkge1xuICAgICAgICBjb25zdCBvcGVuTW9kYWwgPSAoKSA9PiB7XG4gICAgICAgICAgICBtb2RhbC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIGJvZHkuY2xhc3NMaXN0LmFkZCgnYm9keS1vdmVyZmxvdycpO1xuICAgICAgICB9O1xuICAgICAgICBvcGVuTW9kYWwoKTtcbiAgICAgICAgY29uc3QgY2xvc2VNb2RhbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnYm9keS1vdmVyZmxvdycpO1xuICAgICAgICAgICAgbW9kYWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZU1vZGFsID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGlja2VkRWxlbWVudCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGlzQ2xpY2tPdXRzaWRlT2ZNb2RhbCA9ICFtb2RhbENvbnQuY29udGFpbnMoY2xpY2tlZEVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgaXNDbGlja09uTW9kYWxCdG4gPSBjbGlja2VkRWxlbWVudCA9PT0gbW9kYWxCdG47XG4gICAgICAgICAgICBpZiAoaXNDbGlja091dHNpZGVPZk1vZGFsIHx8IGlzQ2xpY2tPbk1vZGFsQnRuKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VNb2RhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAobW9kYWxCdG4pXG4gICAgICAgICAgICBtb2RhbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZU1vZGFsKTtcbiAgICAgICAgaWYgKG1vZGFsKVxuICAgICAgICAgICAgbW9kYWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVNb2RhbCk7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaXRNb2RhbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY3JlYXRlUG9rZWJhbGxWaWV3ID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSAncG9rZWJhbGxfX2NvbnRhaW5lcic7XG4gICAgY29uc3QgcG9rZWJhbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwb2tlYmFsbC5jbGFzc05hbWUgPSAncG9rZWJhbGwnO1xuICAgIGNvbnN0IHBva2ViYWxsQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcG9rZWJhbGxCdXR0b24uY2xhc3NOYW1lID0gJ3Bva2ViYWxsX19idXR0b24nO1xuICAgIHBva2ViYWxsLmFwcGVuZENoaWxkKHBva2ViYWxsQnV0dG9uKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocG9rZWJhbGwpO1xuICAgIHJldHVybiBjb250YWluZXI7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlUG9rZWJhbGxWaWV3O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBlZGl0b3JfMSA9IHJlcXVpcmUoXCIuL2VkaXRvclwiKTtcbmNvbnN0IG1lbnVfMSA9IHJlcXVpcmUoXCIuL21lbnVcIik7XG5jb25zdCByZW5kZXJUaXRsZSA9IChsZXZlbCkgPT4ge1xuICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRhc2stdGl0bGUnKTtcbiAgICBpZiAodGl0bGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICB0aXRsZS5pbm5lclRleHQgPSBsZXZlbC50aXRsZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbicpO1xuICAgICAgICBjb25zdCBsZXZlbFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICAgICAgbGV2ZWxUaXRsZS5jbGFzc05hbWUgPSAndGFzay10aXRsZSc7XG4gICAgICAgIGxldmVsVGl0bGUuaW5uZXJUZXh0ID0gbGV2ZWwudGl0bGU7XG4gICAgICAgIGlmIChtYWluKSB7XG4gICAgICAgICAgICBtYWluLnByZXBlbmQobGV2ZWxUaXRsZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcmVuZGVyQ3NzVmlld2VyID0gKCkgPT4ge1xuICAgIGNvbnN0IGVkaXRvckZpZWxkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmVkaXRvcicpO1xuICAgIGlmIChlZGl0b3JGaWVsZCkge1xuICAgICAgICBjb25zdCBjc3NFZGl0b3JGaWVsZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jc3Mtdmlld2VyX19jb250YWluZXInKTtcbiAgICAgICAgaWYgKGNzc0VkaXRvckZpZWxkIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNzc0VkaXRvckZpZWxkLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgKDAsIGVkaXRvcl8xLmluaXRDc3NFZGl0b3IpKGNzc0VkaXRvckZpZWxkKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCByZW5kZXJIdG1sVmlld2VyID0gKGxldmVsKSA9PiB7XG4gICAgY29uc3QgaHRtbFZpZXdlckZpZWxkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmh0bWwtdmlld2VyX19jb250YWluZXInKTtcbiAgICBpZiAoaHRtbFZpZXdlckZpZWxkIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgaHRtbFZpZXdlckZpZWxkLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAoMCwgZWRpdG9yXzEuaW5pdEh0bWxFZGl0b3IpKGh0bWxWaWV3ZXJGaWVsZCwgbGV2ZWwuaHRtbCk7XG4gICAgfVxufTtcbmNvbnN0IHJlbmRlclBva2Vtb25zID0gKGxldmVsKSA9PiB7XG4gICAgY29uc3QgcG9rZW1vbnNGaWVsZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wb2tlbW9ucycpO1xuICAgIGNvbnN0IGNvcnJlY3RQb2tlbW9uSWRzID0gbGV2ZWwuY29ycmVjdEFuc3dlcnMuZmxhdE1hcCgoYW5zKSA9PiBhbnMucG9rZW1vbnMubWFwKChwKSA9PiBwLmlkKSk7XG4gICAgaWYgKHBva2Vtb25zRmllbGQpIHtcbiAgICAgICAgcG9rZW1vbnNGaWVsZC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgY29uc3QgeyBwb2tlbW9ucyB9ID0gbGV2ZWw7XG4gICAgICAgIHBva2Vtb25zLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIHBJbWcuc3JjID0gcC5zcmM7XG4gICAgICAgICAgICBwSW1nLmNsYXNzTGlzdC5hZGQoJ3Bva2Vtb24nKTtcbiAgICAgICAgICAgIGlmIChjb3JyZWN0UG9rZW1vbklkcy5pbmNsdWRlcyhwLmlkKSkge1xuICAgICAgICAgICAgICAgIHBJbWcuY2xhc3NMaXN0LmFkZCgnYWN0aXZlLWltYWdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5hdHRyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBwSW1nLmNsYXNzTGlzdC5hZGQoJ3RpbnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBva2Vtb25zRmllbGQuYXBwZW5kQ2hpbGQocEltZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCByZW5kZXJNZW51ID0gKCkgPT4ge1xuICAgIGNvbnN0IG5hdkxpbmtzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm5hdi1saW5rcycpO1xuICAgIGNvbnN0IHVsID0gKDAsIG1lbnVfMS5jcmVhdGVVbCkoKTtcbiAgICBpZiAobmF2TGlua3MpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbmF2TGlua3MucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh1bCwgbmF2TGlua3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lbnVMaW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5uYXYtbGlua3NfX2l0ZW0nKTtcbiAgICBpZiAobWVudUxpbmtzKSB7XG4gICAgICAgIG1lbnVMaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICBsaW5rLmNsYXNzTGlzdC5yZW1vdmUoJ25hdi1saW5rc19faXRlbS1hY3RpdmUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdsZXZlbCcpIHx8ICcwJztcbiAgICAgICAgbWVudUxpbmtzWytjdXJyZW50TGV2ZWxdLmNsYXNzTGlzdC5hZGQoJ25hdi1saW5rc19faXRlbS1hY3RpdmUnKTtcbiAgICB9XG59O1xuY29uc3QgcmVuZGVyID0gKGxldmVsKSA9PiB7XG4gICAgcmVuZGVyVGl0bGUobGV2ZWwpO1xuICAgIHJlbmRlckNzc1ZpZXdlcigpO1xuICAgIHJlbmRlckh0bWxWaWV3ZXIobGV2ZWwpO1xuICAgIHJlbmRlclBva2Vtb25zKGxldmVsKTtcbiAgICByZW5kZXJNZW51KCk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVuZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFBva2Vtb25zQnlJZHMgPSBleHBvcnRzLmdldFBva2Vtb25CeUlkID0gdm9pZCAwO1xuY29uc3QgY2hhcm1hbmRlcl9wbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYXNzZXRzL2NoYXJtYW5kZXIucG5nXCIpKTtcbmNvbnN0IGJ1bGJhc2F1cl9wbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYXNzZXRzL2J1bGJhc2F1ci5wbmdcIikpO1xuY29uc3QgcGlrYWNodV9wbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYXNzZXRzL3Bpa2FjaHUucG5nXCIpKTtcbmNvbnN0IHNxdWlydGxlX3BuZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9hc3NldHMvc3F1aXJ0bGUucG5nXCIpKTtcbmNvbnN0IGxhcHJhc19wbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYXNzZXRzL2xhcHJhcy5wbmdcIikpO1xuY29uc3QgcG9rZW1vbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi90eXBlcy9wb2tlbW9uXCIpKTtcbmNvbnN0IHNoaW55X2NoYXJtYW5kZXJfcG5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2Fzc2V0cy9zaGlueS1jaGFybWFuZGVyLnBuZ1wiKSk7XG5jb25zdCBzYWRfcGlrYWNodV9wbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYXNzZXRzL3NhZC1waWthY2h1LnBuZ1wiKSk7XG5jb25zdCBwaWthY2h1ID0gbmV3IHBva2Vtb25fMS5kZWZhdWx0KHtcbiAgICBpZDogMSxcbiAgICBuYW1lOiAncGlrYWNodScsXG4gICAgc3JjOiBwaWthY2h1X3BuZ18xLmRlZmF1bHQsXG59KTtcbmNvbnN0IGJ1bGJhc2F1ciA9IG5ldyBwb2tlbW9uXzEuZGVmYXVsdCh7XG4gICAgaWQ6IDIsXG4gICAgbmFtZTogJ2J1bGJhc2F1cicsXG4gICAgc3JjOiBidWxiYXNhdXJfcG5nXzEuZGVmYXVsdCxcbn0pO1xuY29uc3QgY2hhcm1hbmRlciA9IG5ldyBwb2tlbW9uXzEuZGVmYXVsdCh7XG4gICAgaWQ6IDMsXG4gICAgbmFtZTogJ2NoYXJtYW5kZXInLFxuICAgIHNyYzogY2hhcm1hbmRlcl9wbmdfMS5kZWZhdWx0LFxufSk7XG5jb25zdCBzcXVpcnRsZSA9IG5ldyBwb2tlbW9uXzEuZGVmYXVsdCh7XG4gICAgaWQ6IDQsXG4gICAgbmFtZTogJ3NxdWlydGxlJyxcbiAgICBzcmM6IHNxdWlydGxlX3BuZ18xLmRlZmF1bHQsXG59KTtcbmNvbnN0IGxhcHJhcyA9IG5ldyBwb2tlbW9uXzEuZGVmYXVsdCh7XG4gICAgaWQ6IDUsXG4gICAgbmFtZTogJ2xhcHJhcycsXG4gICAgc3JjOiBsYXByYXNfcG5nXzEuZGVmYXVsdCxcbn0pO1xuY29uc3Qgc2hpbnlDaGFybWFuZGVyID0gbmV3IHBva2Vtb25fMS5kZWZhdWx0KHtcbiAgICBpZDogNixcbiAgICBuYW1lOiAnY2hhcm1hbmRlcicsXG4gICAgc3JjOiBzaGlueV9jaGFybWFuZGVyX3BuZ18xLmRlZmF1bHQsXG59KTtcbmNvbnN0IGNhZ2VkUGlrYWNodSA9IG5ldyBwb2tlbW9uXzEuZGVmYXVsdCh7XG4gICAgaWQ6IDcsXG4gICAgbmFtZTogJ3Bpa2FjaHUnLFxuICAgIHNyYzogc2FkX3Bpa2FjaHVfcG5nXzEuZGVmYXVsdCxcbn0pO1xuY29uc3QgdGlueUJ1bGJhc2F1ciA9IG5ldyBwb2tlbW9uXzEuZGVmYXVsdCh7XG4gICAgaWQ6IDgsXG4gICAgbmFtZTogJ2J1bGJhc2F1cicsXG4gICAgc3JjOiBidWxiYXNhdXJfcG5nXzEuZGVmYXVsdCxcbiAgICBhdHRyQ2xhc3M6ICd0aW55Jyxcbn0pO1xuY29uc3QgdGlueUNoYXJtYW5kZXIgPSBuZXcgcG9rZW1vbl8xLmRlZmF1bHQoe1xuICAgIGlkOiA5LFxuICAgIG5hbWU6ICdjaGFybWFuZGVyJyxcbiAgICBzcmM6IGNoYXJtYW5kZXJfcG5nXzEuZGVmYXVsdCxcbiAgICBhdHRyQ2xhc3M6ICd0aW55Jyxcbn0pO1xuY29uc3QgdGlueVBpa2FjaHUgPSBuZXcgcG9rZW1vbl8xLmRlZmF1bHQoe1xuICAgIGlkOiAxMCxcbiAgICBuYW1lOiAncGlrYWNodScsXG4gICAgc3JjOiBwaWthY2h1X3BuZ18xLmRlZmF1bHQsXG4gICAgYXR0ckNsYXNzOiAndGlueScsXG59KTtcbmNvbnN0IHRpbnlDYWdlZFBpa2FjaHUgPSBuZXcgcG9rZW1vbl8xLmRlZmF1bHQoe1xuICAgIGlkOiAxMSxcbiAgICBuYW1lOiAncGlrYWNodScsXG4gICAgc3JjOiBzYWRfcGlrYWNodV9wbmdfMS5kZWZhdWx0LFxuICAgIGF0dHJDbGFzczogJ3RpbnknLFxufSk7XG5jb25zdCB0aW55U3F1aXJ0bGUgPSBuZXcgcG9rZW1vbl8xLmRlZmF1bHQoe1xuICAgIGlkOiAxMixcbiAgICBuYW1lOiAnc3F1aXJ0bGUnLFxuICAgIHNyYzogc3F1aXJ0bGVfcG5nXzEuZGVmYXVsdCxcbiAgICBhdHRyQ2xhc3M6ICd0aW55Jyxcbn0pO1xuY29uc3QgY2xvbmVQaWthY2h1ID0gbmV3IHBva2Vtb25fMS5kZWZhdWx0KHtcbiAgICBpZDogMTMsXG4gICAgbmFtZTogJ3Bpa2FjaHUnLFxuICAgIHNyYzogcGlrYWNodV9wbmdfMS5kZWZhdWx0LFxufSk7XG5jb25zdCBjbG9uZUJ1bGJhc2F1ciA9IG5ldyBwb2tlbW9uXzEuZGVmYXVsdCh7XG4gICAgaWQ6IDE0LFxuICAgIG5hbWU6ICdidWxiYXNhdXInLFxuICAgIHNyYzogYnVsYmFzYXVyX3BuZ18xLmRlZmF1bHQsXG59KTtcbmNvbnN0IGRhdGFCYXNlID0gW1xuICAgIHBpa2FjaHUsXG4gICAgYnVsYmFzYXVyLFxuICAgIGNoYXJtYW5kZXIsXG4gICAgc3F1aXJ0bGUsXG4gICAgbGFwcmFzLFxuICAgIHNoaW55Q2hhcm1hbmRlcixcbiAgICBjYWdlZFBpa2FjaHUsXG4gICAgdGlueUJ1bGJhc2F1cixcbiAgICB0aW55Q2hhcm1hbmRlcixcbiAgICB0aW55UGlrYWNodSxcbiAgICB0aW55Q2FnZWRQaWthY2h1LFxuICAgIHRpbnlTcXVpcnRsZSxcbiAgICBjbG9uZVBpa2FjaHUsXG4gICAgY2xvbmVCdWxiYXNhdXIsXG5dO1xuY29uc3QgZ2V0UG9rZW1vbkJ5SWQgPSAoaWQpID0+IHtcbiAgICByZXR1cm4gZGF0YUJhc2UuZmluZCgocG9rZW1vbikgPT4gcG9rZW1vbi5pZCA9PT0gaWQpO1xufTtcbmV4cG9ydHMuZ2V0UG9rZW1vbkJ5SWQgPSBnZXRQb2tlbW9uQnlJZDtcbmNvbnN0IGdldFBva2Vtb25zQnlJZHMgPSAoaWRzKSA9PiB7XG4gICAgY29uc3QgcG9rZW1vbnMgPSBbXTtcbiAgICBpZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgY29uc3QgcG9rZW1vbiA9ICgwLCBleHBvcnRzLmdldFBva2Vtb25CeUlkKShpZCk7XG4gICAgICAgIGlmIChwb2tlbW9uKVxuICAgICAgICAgICAgcG9rZW1vbnMucHVzaChwb2tlbW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcG9rZW1vbnM7XG59O1xuZXhwb3J0cy5nZXRQb2tlbW9uc0J5SWRzID0gZ2V0UG9rZW1vbnNCeUlkcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgUG9rZW1vbiB7XG4gICAgY29uc3RydWN0b3IocCkge1xuICAgICAgICB0aGlzLmlkID0gcC5pZDtcbiAgICAgICAgdGhpcy5uYW1lID0gcC5uYW1lO1xuICAgICAgICB0aGlzLnNyYyA9IHAuc3JjO1xuICAgICAgICB0aGlzLmF0dHJJZCA9IHAuYXR0cklkO1xuICAgICAgICB0aGlzLmF0dHJDbGFzcyA9IHAuYXR0ckNsYXNzO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBva2Vtb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG52YXIgdmlldyA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3ZpZXcnKTtcbnZhciBsYW5ndWFnZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJyk7XG5cbi8qKlxuQW4gaW5zdGFuY2Ugb2YgdGhpcyBpcyBwYXNzZWQgdG8gY29tcGxldGlvbiBzb3VyY2UgZnVuY3Rpb25zLlxuKi9cbmNsYXNzIENvbXBsZXRpb25Db250ZXh0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgY29tcGxldGlvbiBjb250ZXh0LiAoTW9zdGx5IHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgIGNvbXBsZXRpb24gc291cmNlc+KAlGluIHRoZSBlZGl0b3IsIHRoZSBleHRlbnNpb24gd2lsbCBjcmVhdGVcbiAgICB0aGVzZSBmb3IgeW91LilcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUgdGhhdCB0aGUgY29tcGxldGlvbiBoYXBwZW5zIGluLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgY29tcGxldGlvbiBpcyBoYXBwZW5pbmcuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIGNvbXBsZXRpb24gd2FzIGFjdGl2YXRlZCBleHBsaWNpdGx5LCBvclxuICAgIGltcGxpY2l0bHkgYnkgdHlwaW5nLiBUaGUgdXN1YWwgd2F5IHRvIHJlc3BvbmQgdG8gdGhpcyBpcyB0b1xuICAgIG9ubHkgcmV0dXJuIGNvbXBsZXRpb25zIHdoZW4gZWl0aGVyIHRoZXJlIGlzIHBhcnQgb2YgYVxuICAgIGNvbXBsZXRhYmxlIGVudGl0eSBiZWZvcmUgdGhlIGN1cnNvciwgb3IgYGV4cGxpY2l0YCBpcyB0cnVlLlxuICAgICovXG4gICAgZXhwbGljaXQsIFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igdmlldy4gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgY29udGV4dCB3YXMgY3JlYXRlZFxuICAgIGluIGEgc2l0dWF0aW9uIHdoZXJlIHRoZXJlIGlzIG5vIHN1Y2ggdmlldyBhdmFpbGFibGUsIHN1Y2ggYXNcbiAgICBpbiBzeW5jaHJvbm91cyB1cGRhdGVzIHZpYVxuICAgIFtgQ29tcGxldGlvblJlc3VsdC51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uUmVzdWx0LnVwZGF0ZSlcbiAgICBvciB3aGVuIGNhbGxlZCBieSB0ZXN0IGNvZGUuXG4gICAgKi9cbiAgICB2aWV3KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hYm9ydE9uRG9jQ2hhbmdlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50LCBjb250ZW50LCBhbmQgKGlmIHRoZXJlIGlzIGEgdG9rZW4pIHR5cGUgb2YgdGhlXG4gICAgdG9rZW4gYmVmb3JlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICB0b2tlbkJlZm9yZSh0eXBlcykge1xuICAgICAgICBsZXQgdG9rZW4gPSBsYW5ndWFnZS5zeW50YXhUcmVlKHRoaXMuc3RhdGUpLnJlc29sdmVJbm5lcih0aGlzLnBvcywgLTEpO1xuICAgICAgICB3aGlsZSAodG9rZW4gJiYgdHlwZXMuaW5kZXhPZih0b2tlbi5uYW1lKSA8IDApXG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuID8geyBmcm9tOiB0b2tlbi5mcm9tLCB0bzogdGhpcy5wb3MsXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnN0YXRlLnNsaWNlRG9jKHRva2VuLmZyb20sIHRoaXMucG9zKSxcbiAgICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUgfSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWF0Y2ggb2YgdGhlIGdpdmVuIGV4cHJlc3Npb24gZGlyZWN0bHkgYmVmb3JlIHRoZVxuICAgIGN1cnNvci5cbiAgICAqL1xuICAgIG1hdGNoQmVmb3JlKGV4cHIpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIHRoaXMucG9zIC0gMjUwKTtcbiAgICAgICAgbGV0IHN0ciA9IGxpbmUudGV4dC5zbGljZShzdGFydCAtIGxpbmUuZnJvbSwgdGhpcy5wb3MgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgZm91bmQgPSBzdHIuc2VhcmNoKGVuc3VyZUFuY2hvcihleHByLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHsgZnJvbTogc3RhcnQgKyBmb3VuZCwgdG86IHRoaXMucG9zLCB0ZXh0OiBzdHIuc2xpY2UoZm91bmQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFlpZWxkcyB0cnVlIHdoZW4gdGhlIHF1ZXJ5IGhhcyBiZWVuIGFib3J0ZWQuIENhbiBiZSB1c2VmdWwgaW5cbiAgICBhc3luY2hyb25vdXMgcXVlcmllcyB0byBhdm9pZCBkb2luZyB3b3JrIHRoYXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgICovXG4gICAgZ2V0IGFib3J0ZWQoKSB7IHJldHVybiB0aGlzLmFib3J0TGlzdGVuZXJzID09IG51bGw7IH1cbiAgICAvKipcbiAgICBBbGxvd3MgeW91IHRvIHJlZ2lzdGVyIGFib3J0IGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgdGhlIHF1ZXJ5IGlzXG4gICAgW2Fib3J0ZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25Db250ZXh0LmFib3J0ZWQpLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHJ1bm5pbmcgcXVlcmllcyB3aWxsIG5vdCBiZSBhYm9ydGVkIGZvciByZWd1bGFyXG4gICAgdHlwaW5nIG9yIGJhY2tzcGFjaW5nLCBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZXkgYXJlIGxpa2VseSB0b1xuICAgIHJldHVybiBhIHJlc3VsdCB3aXRoIGFcbiAgICBbYHZhbGlkRm9yYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvblJlc3VsdC52YWxpZEZvcikgZmllbGQgdGhhdFxuICAgIGFsbG93cyB0aGUgcmVzdWx0IHRvIGJlIHVzZWQgYWZ0ZXIgYWxsLiBQYXNzaW5nIGBvbkRvY0NoYW5nZTpcbiAgICB0cnVlYCB3aWxsIGNhdXNlIHRoaXMgcXVlcnkgdG8gYmUgYWJvcnRlZCBmb3IgYW55IGRvY3VtZW50XG4gICAgY2hhbmdlLlxuICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZSA9PSBcImFib3J0XCIgJiYgdGhpcy5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5hYm9ydExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub25Eb2NDaGFuZ2UpXG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydE9uRG9jQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU2V0KGNoYXJzKSB7XG4gICAgbGV0IGZsYXQgPSBPYmplY3Qua2V5cyhjaGFycykuam9pbihcIlwiKTtcbiAgICBsZXQgd29yZHMgPSAvXFx3Ly50ZXN0KGZsYXQpO1xuICAgIGlmICh3b3JkcylcbiAgICAgICAgZmxhdCA9IGZsYXQucmVwbGFjZSgvXFx3L2csIFwiXCIpO1xuICAgIHJldHVybiBgWyR7d29yZHMgPyBcIlxcXFx3XCIgOiBcIlwifSR7ZmxhdC5yZXBsYWNlKC9bXlxcd1xcc10vZywgXCJcXFxcJCZcIil9XWA7XG59XG5mdW5jdGlvbiBwcmVmaXhNYXRjaChvcHRpb25zKSB7XG4gICAgbGV0IGZpcnN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmVzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgeyBsYWJlbCB9IG9mIG9wdGlvbnMpIHtcbiAgICAgICAgZmlyc3RbbGFiZWxbMF1dID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3RbbGFiZWxbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHNvdXJjZSA9IHRvU2V0KGZpcnN0KSArIHRvU2V0KHJlc3QpICsgXCIqJFwiO1xuICAgIHJldHVybiBbbmV3IFJlZ0V4cChcIl5cIiArIHNvdXJjZSksIG5ldyBSZWdFeHAoc291cmNlKV07XG59XG4vKipcbkdpdmVuIGEgYSBmaXhlZCBhcnJheSBvZiBvcHRpb25zLCByZXR1cm4gYW4gYXV0b2NvbXBsZXRlciB0aGF0XG5jb21wbGV0ZXMgdGhlbS5cbiovXG5mdW5jdGlvbiBjb21wbGV0ZUZyb21MaXN0KGxpc3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGxpc3QubWFwKG8gPT4gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IHsgbGFiZWw6IG8gfSA6IG8pO1xuICAgIGxldCBbdmFsaWRGb3IsIG1hdGNoXSA9IG9wdGlvbnMuZXZlcnkobyA9PiAvXlxcdyskLy50ZXN0KG8ubGFiZWwpKSA/IFsvXFx3KiQvLCAvXFx3KyQvXSA6IHByZWZpeE1hdGNoKG9wdGlvbnMpO1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuIHx8IGNvbnRleHQuZXhwbGljaXQgPyB7IGZyb206IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zLCBvcHRpb25zLCB2YWxpZEZvciB9IDogbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgb25seSBmaXJlIHdoZW4gdGhlXG5jdXJzb3IgaXMgaW4gYSBzeW50YXggbm9kZSB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbmFtZXMuXG4qL1xuZnVuY3Rpb24gaWZJbihub2Rlcywgc291cmNlKSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGxhbmd1YWdlLnN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YocG9zLm5hbWUpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZShjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgbm90IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZk5vdEluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgIH07XG59XG5jbGFzcyBPcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBsZXRpb24sIHNvdXJjZSwgbWF0Y2gsIHNjb3JlKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbiA9IGNvbXBsZXRpb247XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjdXIoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb207IH1cbi8vIE1ha2Ugc3VyZSB0aGUgZ2l2ZW4gcmVnZXhwIGhhcyBhICQgYXQgaXRzIGVuZCBhbmQsIGlmIGBzdGFydGAgaXNcbi8vIHRydWUsIGEgXiBhdCBpdHMgc3RhcnQuXG5mdW5jdGlvbiBlbnN1cmVBbmNob3IoZXhwciwgc3RhcnQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgc291cmNlIH0gPSBleHByO1xuICAgIGxldCBhZGRTdGFydCA9IHN0YXJ0ICYmIHNvdXJjZVswXSAhPSBcIl5cIiwgYWRkRW5kID0gc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPSBcIiRcIjtcbiAgICBpZiAoIWFkZFN0YXJ0ICYmICFhZGRFbmQpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGAke2FkZFN0YXJ0ID8gXCJeXCIgOiBcIlwifSg/OiR7c291cmNlfSkke2FkZEVuZCA/IFwiJFwiIDogXCJcIn1gLCAoX2EgPSBleHByLmZsYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoZXhwci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSk7XG59XG4vKipcblRoaXMgYW5ub3RhdGlvbiBpcyBhZGRlZCB0byB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgcHJvZHVjZWQgYnlcbnBpY2tpbmcgYSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IHBpY2tlZENvbXBsZXRpb24gPSBzdGF0ZS5Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5IZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdHJhbnNhY3Rpb24gc3BlYyB3aGljaCBpbnNlcnRzIGFcbmNvbXBsZXRpb24ncyB0ZXh0IGluIHRoZSBtYWluIHNlbGVjdGlvbiByYW5nZSwgYW5kIGFueSBvdGhlclxuc2VsZWN0aW9uIHJhbmdlIHRoYXQgaGFzIHRoZSBzYW1lIHRleHQgaW4gZnJvbnQgb2YgaXQuXG4qL1xuZnVuY3Rpb24gaW5zZXJ0Q29tcGxldGlvblRleHQoc3RhdGUkMSwgdGV4dCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgeyBtYWluIH0gPSBzdGF0ZSQxLnNlbGVjdGlvbiwgZnJvbU9mZiA9IGZyb20gLSBtYWluLmZyb20sIHRvT2ZmID0gdG8gLSBtYWluLmZyb207XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUkMS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlICE9IG1haW4gJiYgZnJvbSAhPSB0byAmJlxuICAgICAgICAgICAgc3RhdGUkMS5zbGljZURvYyhyYW5nZS5mcm9tICsgZnJvbU9mZiwgcmFuZ2UuZnJvbSArIHRvT2ZmKSAhPSBzdGF0ZSQxLnNsaWNlRG9jKGZyb20sIHRvKSlcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgIGxldCBsaW5lcyA9IHN0YXRlJDEudG9UZXh0KHRleHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tICsgZnJvbU9mZiwgdG86IHRvID09IG1haW4uZnJvbSA/IHJhbmdlLnRvIDogcmFuZ2UuZnJvbSArIHRvT2ZmLCBpbnNlcnQ6IGxpbmVzIH0sXG4gICAgICAgICAgICByYW5nZTogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgZnJvbU9mZiArIGxpbmVzLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICB9KSksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiIH0pO1xufVxuY29uc3QgU291cmNlQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gYXNTb3VyY2Uoc291cmNlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgbGV0IGtub3duID0gU291cmNlQ2FjaGUuZ2V0KHNvdXJjZSk7XG4gICAgaWYgKCFrbm93bilcbiAgICAgICAgU291cmNlQ2FjaGUuc2V0KHNvdXJjZSwga25vd24gPSBjb21wbGV0ZUZyb21MaXN0KHNvdXJjZSkpO1xuICAgIHJldHVybiBrbm93bjtcbn1cbmNvbnN0IHN0YXJ0Q29tcGxldGlvbkVmZmVjdCA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgY2xvc2VDb21wbGV0aW9uRWZmZWN0ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5cbi8vIEEgcGF0dGVybiBtYXRjaGVyIGZvciBmdXp6eSBjb21wbGV0aW9uIG1hdGNoaW5nLiBDcmVhdGUgYW4gaW5zdGFuY2Vcbi8vIG9uY2UgZm9yIGEgcGF0dGVybiwgYW5kIHRoZW4gdXNlIHRoYXQgdG8gbWF0Y2ggYW55IG51bWJlciBvZlxuLy8gY29tcGxldGlvbnMuXG5jbGFzcyBGdXp6eU1hdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5jaGFycyA9IFtdO1xuICAgICAgICB0aGlzLmZvbGRlZCA9IFtdO1xuICAgICAgICAvLyBCdWZmZXJzIHJldXNlZCBieSBjYWxscyB0byBgbWF0Y2hgIHRvIHRyYWNrIG1hdGNoZWQgY2hhcmFjdGVyXG4gICAgICAgIC8vIHBvc2l0aW9ucy5cbiAgICAgICAgdGhpcy5hbnkgPSBbXTtcbiAgICAgICAgdGhpcy5wcmVjaXNlID0gW107XG4gICAgICAgIHRoaXMuYnlXb3JkID0gW107XG4gICAgICAgIHRoaXMuc2NvcmUgPSAwO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwYXR0ZXJuLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBjaGFyID0gc3RhdGUuY29kZVBvaW50QXQocGF0dGVybiwgcCksIHNpemUgPSBzdGF0ZS5jb2RlUG9pbnRTaXplKGNoYXIpO1xuICAgICAgICAgICAgdGhpcy5jaGFycy5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBwYXR0ZXJuLnNsaWNlKHAsIHAgKyBzaXplKSwgdXBwZXIgPSBwYXJ0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLmZvbGRlZC5wdXNoKHN0YXRlLmNvZGVQb2ludEF0KHVwcGVyID09IHBhcnQgPyBwYXJ0LnRvTG93ZXJDYXNlKCkgOiB1cHBlciwgMCkpO1xuICAgICAgICAgICAgcCArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXN0cmFsID0gcGF0dGVybi5sZW5ndGggIT0gdGhpcy5jaGFycy5sZW5ndGg7XG4gICAgfVxuICAgIHJldChzY29yZSwgbWF0Y2hlZCkge1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IG1hdGNoZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBNYXRjaGVzIGEgZ2l2ZW4gd29yZCAoY29tcGxldGlvbikgYWdhaW5zdCB0aGUgcGF0dGVybiAoaW5wdXQpLlxuICAgIC8vIFdpbGwgcmV0dXJuIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlcmUgd2FzIGEgbWF0Y2ggYW5kLFxuICAgIC8vIG9uIHN1Y2Nlc3MsIHNldCBgdGhpcy5zY29yZWAgdG8gdGhlIHNjb3JlLCBgdGhpcy5tYXRjaGVkYCB0byBhblxuICAgIC8vIGFycmF5IG9mIGBmcm9tLCB0b2AgcGFpcnMgaW5kaWNhdGluZyB0aGUgbWF0Y2hlZCBwYXJ0cyBvZiBgd29yZGAuXG4gICAgLy9cbiAgICAvLyBUaGUgc2NvcmUgaXMgYSBudW1iZXIgdGhhdCBpcyBtb3JlIG5lZ2F0aXZlIHRoZSB3b3JzZSB0aGUgbWF0Y2hcbiAgICAvLyBpcy4gU2VlIGBQZW5hbHR5YCBhYm92ZS5cbiAgICBtYXRjaCh3b3JkKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdHRlcm4ubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi8sIFtdKTtcbiAgICAgICAgaWYgKHdvcmQubGVuZ3RoIDwgdGhpcy5wYXR0ZXJuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgeyBjaGFycywgZm9sZGVkLCBhbnksIHByZWNpc2UsIGJ5V29yZCB9ID0gdGhpcztcbiAgICAgICAgLy8gRm9yIHNpbmdsZS1jaGFyYWN0ZXIgcXVlcmllcywgb25seSBtYXRjaCB3aGVuIHRoZXkgb2NjdXIgcmlnaHRcbiAgICAgICAgLy8gYXQgdGhlIHN0YXJ0XG4gICAgICAgIGlmIChjaGFycy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gc3RhdGUuY29kZVBvaW50QXQod29yZCwgMCksIGZpcnN0U2l6ZSA9IHN0YXRlLmNvZGVQb2ludFNpemUoZmlyc3QpO1xuICAgICAgICAgICAgbGV0IHNjb3JlID0gZmlyc3RTaXplID09IHdvcmQubGVuZ3RoID8gMCA6IC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovO1xuICAgICAgICAgICAgaWYgKGZpcnN0ID09IGNoYXJzWzBdKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChmaXJzdCA9PSBmb2xkZWRbMF0pXG4gICAgICAgICAgICAgICAgc2NvcmUgKz0gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KHNjb3JlLCBbMCwgZmlyc3RTaXplXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpcmVjdCA9IHdvcmQuaW5kZXhPZih0aGlzLnBhdHRlcm4pO1xuICAgICAgICBpZiAoZGlyZWN0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQod29yZC5sZW5ndGggPT0gdGhpcy5wYXR0ZXJuLmxlbmd0aCA/IDAgOiAtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLywgWzAsIHRoaXMucGF0dGVybi5sZW5ndGhdKTtcbiAgICAgICAgbGV0IGxlbiA9IGNoYXJzLmxlbmd0aCwgYW55VG8gPSAwO1xuICAgICAgICBpZiAoZGlyZWN0IDwgMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGUgPSBNYXRoLm1pbih3b3JkLmxlbmd0aCwgMjAwKTsgaSA8IGUgJiYgYW55VG8gPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBzdGF0ZS5jb2RlUG9pbnRBdCh3b3JkLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSBjaGFyc1thbnlUb10gfHwgbmV4dCA9PSBmb2xkZWRbYW55VG9dKVxuICAgICAgICAgICAgICAgICAgICBhbnlbYW55VG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGkgKz0gc3RhdGUuY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIG1hdGNoLCBleGl0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoYW55VG8gPCBsZW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB0cmFja3MgdGhlIGV4dGVudCBvZiB0aGUgcHJlY2lzZSAobm9uLWZvbGRlZCwgbm90XG4gICAgICAgIC8vIG5lY2Vzc2FyaWx5IGFkamFjZW50KSBtYXRjaFxuICAgICAgICBsZXQgcHJlY2lzZVRvID0gMDtcbiAgICAgICAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlcmUgaXMgYSBtYXRjaCB0aGF0IGhpdHMgb25seSBjaGFyYWN0ZXJzIHRoYXRcbiAgICAgICAgLy8gYXBwZWFyIHRvIGJlIHN0YXJ0aW5nIHdvcmRzLiBgYnlXb3JkRm9sZGVkYCBpcyBzZXQgdG8gdHJ1ZSB3aGVuXG4gICAgICAgIC8vIGEgY2FzZSBmb2xkZWQgY2hhcmFjdGVyIGlzIGVuY291bnRlcmVkIGluIHN1Y2ggYSBtYXRjaFxuICAgICAgICBsZXQgYnlXb3JkVG8gPSAwLCBieVdvcmRGb2xkZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgd2UndmUgZm91bmQgYSBwYXJ0aWFsIGFkamFjZW50IG1hdGNoLCB0aGVzZSB0cmFjayBpdHMgc3RhdGVcbiAgICAgICAgbGV0IGFkamFjZW50VG8gPSAwLCBhZGphY2VudFN0YXJ0ID0gLTEsIGFkamFjZW50RW5kID0gLTE7XG4gICAgICAgIGxldCBoYXNMb3dlciA9IC9bYS16XS8udGVzdCh3b3JkKSwgd29yZEFkamFjZW50ID0gdHJ1ZTtcbiAgICAgICAgLy8gR28gb3ZlciB0aGUgb3B0aW9uJ3MgdGV4dCwgc2Nhbm5pbmcgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIG1hdGNoZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGUgPSBNYXRoLm1pbih3b3JkLmxlbmd0aCwgMjAwKSwgcHJldlR5cGUgPSAwIC8qIFRwLk5vbldvcmQgKi87IGkgPCBlICYmIGJ5V29yZFRvIDwgbGVuOykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBzdGF0ZS5jb2RlUG9pbnRBdCh3b3JkLCBpKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3QgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWNpc2VUbyA8IGxlbiAmJiBuZXh0ID09IGNoYXJzW3ByZWNpc2VUb10pXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2VbcHJlY2lzZVRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnRUbyA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSBjaGFyc1thZGphY2VudFRvXSB8fCBuZXh0ID09IGZvbGRlZFthZGphY2VudFRvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50RW5kID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFRvKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFRvID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaCwgdHlwZSA9IG5leHQgPCAweGZmXG4gICAgICAgICAgICAgICAgPyAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3IHx8IG5leHQgPj0gOTcgJiYgbmV4dCA8PSAxMjIgPyAyIC8qIFRwLkxvd2VyICovIDogbmV4dCA+PSA2NSAmJiBuZXh0IDw9IDkwID8gMSAvKiBUcC5VcHBlciAqLyA6IDAgLyogVHAuTm9uV29yZCAqLylcbiAgICAgICAgICAgICAgICA6ICgoY2ggPSBzdGF0ZS5mcm9tQ29kZVBvaW50KG5leHQpKSAhPSBjaC50b0xvd2VyQ2FzZSgpID8gMSAvKiBUcC5VcHBlciAqLyA6IGNoICE9IGNoLnRvVXBwZXJDYXNlKCkgPyAyIC8qIFRwLkxvd2VyICovIDogMCAvKiBUcC5Ob25Xb3JkICovKTtcbiAgICAgICAgICAgIGlmICghaSB8fCB0eXBlID09IDEgLyogVHAuVXBwZXIgKi8gJiYgaGFzTG93ZXIgfHwgcHJldlR5cGUgPT0gMCAvKiBUcC5Ob25Xb3JkICovICYmIHR5cGUgIT0gMCAvKiBUcC5Ob25Xb3JkICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJzW2J5V29yZFRvXSA9PSBuZXh0IHx8IChmb2xkZWRbYnlXb3JkVG9dID09IG5leHQgJiYgKGJ5V29yZEZvbGRlZCA9IHRydWUpKSlcbiAgICAgICAgICAgICAgICAgICAgYnlXb3JkW2J5V29yZFRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChieVdvcmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB3b3JkQWRqYWNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIGkgKz0gc3RhdGUuY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnlXb3JkVG8gPT0gbGVuICYmIGJ5V29yZFswXSA9PSAwICYmIHdvcmRBZGphY2VudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgtMTAwIC8qIFBlbmFsdHkuQnlXb3JkICovICsgKGJ5V29yZEZvbGRlZCA/IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyA6IDApLCBieVdvcmQsIHdvcmQpO1xuICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSBsZW4gJiYgYWRqYWNlbnRTdGFydCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyAtIHdvcmQubGVuZ3RoICsgKGFkamFjZW50RW5kID09IHdvcmQubGVuZ3RoID8gMCA6IC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovKSwgWzAsIGFkamFjZW50RW5kXSk7XG4gICAgICAgIGlmIChkaXJlY3QgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gLSB3b3JkLmxlbmd0aCwgW2RpcmVjdCwgZGlyZWN0ICsgdGhpcy5wYXR0ZXJuLmxlbmd0aF0pO1xuICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSBsZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovICsgLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIC0gd29yZC5sZW5ndGgsIFthZGphY2VudFN0YXJ0LCBhZGphY2VudEVuZF0pO1xuICAgICAgICBpZiAoYnlXb3JkVG8gPT0gbGVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogUGVuYWx0eS5CeVdvcmQgKi8gKyAoYnlXb3JkRm9sZGVkID8gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIDogMCkgKyAtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gK1xuICAgICAgICAgICAgICAgICh3b3JkQWRqYWNlbnQgPyAwIDogLTExMDAgLyogUGVuYWx0eS5HYXAgKi8pLCBieVdvcmQsIHdvcmQpO1xuICAgICAgICByZXR1cm4gY2hhcnMubGVuZ3RoID09IDIgPyBudWxsXG4gICAgICAgICAgICA6IHRoaXMucmVzdWx0KChhbnlbMF0gPyAtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gOiAwKSArIC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyArIC0xMTAwIC8qIFBlbmFsdHkuR2FwICovLCBhbnksIHdvcmQpO1xuICAgIH1cbiAgICByZXN1bHQoc2NvcmUsIHBvc2l0aW9ucywgd29yZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKSB7XG4gICAgICAgICAgICBsZXQgdG8gPSBwb3MgKyAodGhpcy5hc3RyYWwgPyBzdGF0ZS5jb2RlUG9pbnRTaXplKHN0YXRlLmNvZGVQb2ludEF0KHdvcmQsIHBvcykpIDogMSk7XG4gICAgICAgICAgICBpZiAoaSAmJiByZXN1bHRbaSAtIDFdID09IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHRbaSAtIDFdID0gdG87XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IHBvcztcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJldChzY29yZSAtIHdvcmQubGVuZ3RoLCByZXN1bHQpO1xuICAgIH1cbn1cbmNsYXNzIFN0cmljdE1hdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gW107XG4gICAgICAgIHRoaXMuc2NvcmUgPSAwO1xuICAgICAgICB0aGlzLmZvbGRlZCA9IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgbWF0Y2god29yZCkge1xuICAgICAgICBpZiAod29yZC5sZW5ndGggPCB0aGlzLnBhdHRlcm4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzdGFydCA9IHdvcmQuc2xpY2UoMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgIGxldCBtYXRjaCA9IHN0YXJ0ID09IHRoaXMucGF0dGVybiA/IDAgOiBzdGFydC50b0xvd2VyQ2FzZSgpID09IHRoaXMuZm9sZGVkID8gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIDogbnVsbDtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gWzAsIHN0YXJ0Lmxlbmd0aF07XG4gICAgICAgIHRoaXMuc2NvcmUgPSBtYXRjaCArICh3b3JkLmxlbmd0aCA9PSB0aGlzLnBhdHRlcm4ubGVuZ3RoID8gMCA6IC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jb25zdCBjb21wbGV0aW9uQ29uZmlnID0gc3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWN0aXZhdGVPblR5cGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGFjdGl2YXRlT25Db21wbGV0aW9uOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgICAgIGFjdGl2YXRlT25UeXBpbmdEZWxheTogMTAwLFxuICAgICAgICAgICAgc2VsZWN0T25PcGVuOiB0cnVlLFxuICAgICAgICAgICAgb3ZlcnJpZGU6IG51bGwsXG4gICAgICAgICAgICBjbG9zZU9uQmx1cjogdHJ1ZSxcbiAgICAgICAgICAgIG1heFJlbmRlcmVkT3B0aW9uczogMTAwLFxuICAgICAgICAgICAgZGVmYXVsdEtleW1hcDogdHJ1ZSxcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKCkgPT4gXCJcIixcbiAgICAgICAgICAgIG9wdGlvbkNsYXNzOiAoKSA9PiBcIlwiLFxuICAgICAgICAgICAgYWJvdmVDdXJzb3I6IGZhbHNlLFxuICAgICAgICAgICAgaWNvbnM6IHRydWUsXG4gICAgICAgICAgICBhZGRUb09wdGlvbnM6IFtdLFxuICAgICAgICAgICAgcG9zaXRpb25JbmZvOiBkZWZhdWx0UG9zaXRpb25JbmZvLFxuICAgICAgICAgICAgZmlsdGVyU3RyaWN0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbXBhcmVDb21wbGV0aW9uczogKGEsIGIpID0+IGEubGFiZWwubG9jYWxlQ29tcGFyZShiLmxhYmVsKSxcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGVsYXk6IDc1LFxuICAgICAgICAgICAgdXBkYXRlU3luY1RpbWU6IDEwMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICBpY29uczogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKGEsIGIpID0+IGMgPT4gam9pbkNsYXNzKGEoYyksIGIoYykpLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6IChhLCBiKSA9PiBjID0+IGpvaW5DbGFzcyhhKGMpLCBiKGMpKSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogKGEsIGIpID0+IGEuY29uY2F0KGIpLFxuICAgICAgICAgICAgZmlsdGVyU3RyaWN0OiAoYSwgYikgPT4gYSB8fCBiLFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGpvaW5DbGFzcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyBiID8gYSArIFwiIFwiICsgYiA6IGEgOiBiO1xufVxuZnVuY3Rpb24gZGVmYXVsdFBvc2l0aW9uSW5mbyh2aWV3JDEsIGxpc3QsIG9wdGlvbiwgaW5mbywgc3BhY2UsIHRvb2x0aXApIHtcbiAgICBsZXQgcnRsID0gdmlldyQxLnRleHREaXJlY3Rpb24gPT0gdmlldy5EaXJlY3Rpb24uUlRMLCBsZWZ0ID0gcnRsLCBuYXJyb3cgPSBmYWxzZTtcbiAgICBsZXQgc2lkZSA9IFwidG9wXCIsIG9mZnNldCwgbWF4V2lkdGg7XG4gICAgbGV0IHNwYWNlTGVmdCA9IGxpc3QubGVmdCAtIHNwYWNlLmxlZnQsIHNwYWNlUmlnaHQgPSBzcGFjZS5yaWdodCAtIGxpc3QucmlnaHQ7XG4gICAgbGV0IGluZm9XaWR0aCA9IGluZm8ucmlnaHQgLSBpbmZvLmxlZnQsIGluZm9IZWlnaHQgPSBpbmZvLmJvdHRvbSAtIGluZm8udG9wO1xuICAgIGlmIChsZWZ0ICYmIHNwYWNlTGVmdCA8IE1hdGgubWluKGluZm9XaWR0aCwgc3BhY2VSaWdodCkpXG4gICAgICAgIGxlZnQgPSBmYWxzZTtcbiAgICBlbHNlIGlmICghbGVmdCAmJiBzcGFjZVJpZ2h0IDwgTWF0aC5taW4oaW5mb1dpZHRoLCBzcGFjZUxlZnQpKVxuICAgICAgICBsZWZ0ID0gdHJ1ZTtcbiAgICBpZiAoaW5mb1dpZHRoIDw9IChsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCkpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoc3BhY2UudG9wLCBNYXRoLm1pbihvcHRpb24udG9wLCBzcGFjZS5ib3R0b20gLSBpbmZvSGVpZ2h0KSkgLSBsaXN0LnRvcDtcbiAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgbGVmdCA/IHNwYWNlTGVmdCA6IHNwYWNlUmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmFycm93ID0gdHJ1ZTtcbiAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgKHJ0bCA/IGxpc3QucmlnaHQgOiBzcGFjZS5yaWdodCAtIGxpc3QubGVmdCkgLSAzMCAvKiBJbmZvLk1hcmdpbiAqLyk7XG4gICAgICAgIGxldCBzcGFjZUJlbG93ID0gc3BhY2UuYm90dG9tIC0gbGlzdC5ib3R0b207XG4gICAgICAgIGlmIChzcGFjZUJlbG93ID49IGluZm9IZWlnaHQgfHwgc3BhY2VCZWxvdyA+IGxpc3QudG9wKSB7IC8vIEJlbG93IHRoZSBjb21wbGV0aW9uXG4gICAgICAgICAgICBvZmZzZXQgPSBvcHRpb24uYm90dG9tIC0gbGlzdC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIEFib3ZlIGl0XG4gICAgICAgICAgICBzaWRlID0gXCJib3R0b21cIjtcbiAgICAgICAgICAgIG9mZnNldCA9IGxpc3QuYm90dG9tIC0gb3B0aW9uLnRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2NhbGVZID0gKGxpc3QuYm90dG9tIC0gbGlzdC50b3ApIC8gdG9vbHRpcC5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IHNjYWxlWCA9IChsaXN0LnJpZ2h0IC0gbGlzdC5sZWZ0KSAvIHRvb2x0aXAub2Zmc2V0V2lkdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGU6IGAke3NpZGV9OiAke29mZnNldCAvIHNjYWxlWX1weDsgbWF4LXdpZHRoOiAke21heFdpZHRoIC8gc2NhbGVYfXB4YCxcbiAgICAgICAgY2xhc3M6IFwiY20tY29tcGxldGlvbkluZm8tXCIgKyAobmFycm93ID8gKHJ0bCA/IFwibGVmdC1uYXJyb3dcIiA6IFwicmlnaHQtbmFycm93XCIpIDogbGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwiKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG9wdGlvbkNvbnRlbnQoY29uZmlnKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBjb25maWcuYWRkVG9PcHRpb25zLnNsaWNlKCk7XG4gICAgaWYgKGNvbmZpZy5pY29ucylcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25JY29uXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0aW9uLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZCguLi5jb21wbGV0aW9uLnR5cGUuc3BsaXQoL1xccysvZykubWFwKGNscyA9PiBcImNtLWNvbXBsZXRpb25JY29uLVwiICsgY2xzKSk7XG4gICAgICAgICAgICAgICAgaWNvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IDIwXG4gICAgICAgIH0pO1xuICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uLCBfcywgX3YsIG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgbGFiZWxFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGxhYmVsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkxhYmVsXCI7XG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBjb21wbGV0aW9uLmRpc3BsYXlMYWJlbCB8fCBjb21wbGV0aW9uLmxhYmVsLCBvZmYgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaC5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBtYXRjaFtqKytdLCB0byA9IG1hdGNoW2orK107XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBvZmYpXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKG9mZiwgZnJvbSkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3BhbiA9IGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKGZyb20sIHRvKSkpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjtcbiAgICAgICAgICAgICAgICBvZmYgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmYgPCBsYWJlbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogNTBcbiAgICB9LCB7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRpb24uZGV0YWlsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IGRldGFpbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgZGV0YWlsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkRldGFpbFwiO1xuICAgICAgICAgICAgZGV0YWlsRWx0LnRleHRDb250ZW50ID0gY29tcGxldGlvbi5kZXRhaWw7XG4gICAgICAgICAgICByZXR1cm4gZGV0YWlsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogODBcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudC5zb3J0KChhLCBiKSA9PiBhLnBvc2l0aW9uIC0gYi5wb3NpdGlvbikubWFwKGEgPT4gYS5yZW5kZXIpO1xufVxuZnVuY3Rpb24gcmFuZ2VBcm91bmRTZWxlY3RlZCh0b3RhbCwgc2VsZWN0ZWQsIG1heCkge1xuICAgIGlmICh0b3RhbCA8PSBtYXgpXG4gICAgICAgIHJldHVybiB7IGZyb206IDAsIHRvOiB0b3RhbCB9O1xuICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgIHNlbGVjdGVkID0gMDtcbiAgICBpZiAoc2VsZWN0ZWQgPD0gKHRvdGFsID4+IDEpKSB7XG4gICAgICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKHNlbGVjdGVkIC8gbWF4KTtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2ZmICogbWF4LCB0bzogKG9mZiArIDEpICogbWF4IH07XG4gICAgfVxuICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKCh0b3RhbCAtIHNlbGVjdGVkKSAvIG1heCk7XG4gICAgcmV0dXJuIHsgZnJvbTogdG90YWwgLSAob2ZmICsgMSkgKiBtYXgsIHRvOiB0b3RhbCAtIG9mZiAqIG1heCB9O1xufVxuY2xhc3MgQ29tcGxldGlvblRvb2x0aXAge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXRlRmllbGQgPSBzdGF0ZUZpZWxkO1xuICAgICAgICB0aGlzLmFwcGx5Q29tcGxldGlvbiA9IGFwcGx5Q29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhY2VJbmZvUmVxID0ge1xuICAgICAgICAgICAgcmVhZDogKCkgPT4gdGhpcy5tZWFzdXJlSW5mbygpLFxuICAgICAgICAgICAgd3JpdGU6IChwb3MpID0+IHRoaXMucGxhY2VJbmZvKHBvcyksXG4gICAgICAgICAgICBrZXk6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zcGFjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudENsYXNzID0gXCJcIjtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCk7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkIH0gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMub3B0aW9uQ29udGVudCA9IG9wdGlvbkNvbnRlbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25DbGFzcyA9IGNvbmZpZy5vcHRpb25DbGFzcztcbiAgICAgICAgdGhpcy50b29sdGlwQ2xhc3MgPSBjb25maWcudG9vbHRpcENsYXNzO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcHRpb25zLmxlbmd0aCwgc2VsZWN0ZWQsIGNvbmZpZy5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwQ2xhc3Modmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCkub3BlbjtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSA9IGUudGFyZ2V0LCBtYXRjaDsgZG9tICYmIGRvbSAhPSB0aGlzLmRvbTsgZG9tID0gZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiTElcIiAmJiAobWF0Y2ggPSAvLShcXGQrKSQvLmV4ZWMoZG9tLmlkKSkgJiYgK21hdGNoWzFdIDwgb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uc1srbWF0Y2hbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIChlKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvb2x0aXAgJiYgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jbG9zZU9uQmx1ciAmJlxuICAgICAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCAhPSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2hvd09wdGlvbnMob3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICB9XG4gICAgbW91bnQoKSB7IHRoaXMudXBkYXRlU2VsKCk7IH1cbiAgICBzaG93T3B0aW9ucyhvcHRpb25zLCBpZCkge1xuICAgICAgICBpZiAodGhpcy5saXN0KVxuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHRoaXMucmFuZ2UpKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm9SZXEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjU3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcbiAgICAgICAgbGV0IHByZXZTdGF0ZSA9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCk7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcENsYXNzKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChjU3RhdGUgIT0gcHJldlN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCBzZWxlY3RlZCwgZGlzYWJsZWQgfSA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICAgICAgaWYgKCFwcmV2U3RhdGUub3BlbiB8fCBwcmV2U3RhdGUub3Blbi5vcHRpb25zICE9IG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcHRpb25zLmxlbmd0aCwgc2VsZWN0ZWQsIHVwZGF0ZS5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd09wdGlvbnMob3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsKCk7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgIT0gKChfYSA9IHByZXZTdGF0ZS5vcGVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzYWJsZWQpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZFwiLCAhIWRpc2FibGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVUb29sdGlwQ2xhc3Moc3RhdGUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMudG9vbHRpcENsYXNzKHN0YXRlKTtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmN1cnJlbnRDbGFzcykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLmN1cnJlbnRDbGFzcy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNscy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mb1JlcSk7XG4gICAgfVxuICAgIHVwZGF0ZVNlbCgpIHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpLCBvcGVuID0gY1N0YXRlLm9wZW47XG4gICAgICAgIGlmIChvcGVuLnNlbGVjdGVkID4gLTEgJiYgb3Blbi5zZWxlY3RlZCA8IHRoaXMucmFuZ2UuZnJvbSB8fCBvcGVuLnNlbGVjdGVkID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wZW4ub3B0aW9ucy5sZW5ndGgsIG9wZW4uc2VsZWN0ZWQsIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcGVuLm9wdGlvbnMsIGNTdGF0ZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU2VsZWN0ZWRPcHRpb24ob3Blbi5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUluZm8oKTtcbiAgICAgICAgICAgIGxldCB7IGNvbXBsZXRpb24gfSA9IG9wZW4ub3B0aW9uc1tvcGVuLnNlbGVjdGVkXTtcbiAgICAgICAgICAgIGxldCB7IGluZm8gfSA9IGNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGluZm9SZXN1bHQgPSB0eXBlb2YgaW5mbyA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGluZm8pIDogaW5mbyhjb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGlmICghaW5mb1Jlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoXCJ0aGVuXCIgaW4gaW5mb1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgIGluZm9SZXN1bHQudGhlbihvYmogPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqICYmIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQsIGZhbHNlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEluZm9QYW5lKG9iaiwgY29tcGxldGlvbik7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiB2aWV3LmxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUsIFwiY29tcGxldGlvbiBpbmZvXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUoaW5mb1Jlc3VsdCwgY29tcGxldGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSW5mb1BhbmUoY29udGVudCwgY29tcGxldGlvbikge1xuICAgICAgICB0aGlzLmRlc3Ryb3lJbmZvKCk7XG4gICAgICAgIGxldCB3cmFwID0gdGhpcy5pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm9cIjtcbiAgICAgICAgaWYgKGNvbnRlbnQubm9kZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgZG9tLCBkZXN0cm95IH0gPSBjb250ZW50O1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IGRlc3Ryb3kgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh3cmFwKTtcbiAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0ZWRPcHRpb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgbGV0IHNldCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IG9wdCA9IHRoaXMubGlzdC5maXJzdENoaWxkLCBpID0gdGhpcy5yYW5nZS5mcm9tOyBvcHQ7IG9wdCA9IG9wdC5uZXh0U2libGluZywgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3B0Lm5vZGVOYW1lICE9IFwiTElcIiB8fCAhb3B0LmlkKSB7XG4gICAgICAgICAgICAgICAgaS0tOyAvLyBBIHNlY3Rpb24gaGVhZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IG9wdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpXG4gICAgICAgICAgICAgICAgICAgIG9wdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQpXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLmxpc3QsIHNldCk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIG1lYXN1cmVJbmZvKCkge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcihcIlthcmlhLXNlbGVjdGVkXVwiKTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIXRoaXMuaW5mbylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGlzdFJlY3QgPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGluZm9SZWN0ID0gdGhpcy5pbmZvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2VsUmVjdCA9IHNlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNwYWNlID0gdGhpcy5zcGFjZTtcbiAgICAgICAgaWYgKCFzcGFjZSkge1xuICAgICAgICAgICAgbGV0IHdpbiA9IHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgICAgICAgICAgc3BhY2UgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoLCBib3R0b206IHdpbi5pbm5lckhlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxSZWN0LnRvcCA+IE1hdGgubWluKHNwYWNlLmJvdHRvbSwgbGlzdFJlY3QuYm90dG9tKSAtIDEwIHx8XG4gICAgICAgICAgICBzZWxSZWN0LmJvdHRvbSA8IE1hdGgubWF4KHNwYWNlLnRvcCwgbGlzdFJlY3QudG9wKSArIDEwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykucG9zaXRpb25JbmZvKHRoaXMudmlldywgbGlzdFJlY3QsIHNlbFJlY3QsIGluZm9SZWN0LCBzcGFjZSwgdGhpcy5kb20pO1xuICAgIH1cbiAgICBwbGFjZUluZm8ocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnN0eWxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUuY3NzVGV4dCA9IHBvcy5zdHlsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvIFwiICsgKHBvcy5jbGFzcyB8fCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS5jc3NUZXh0ID0gXCJ0b3A6IC0xZTZweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICB1bC5pZCA9IGlkO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIkNvbXBsZXRpb25zXCIpKTtcbiAgICAgICAgbGV0IGN1clNlY3Rpb24gPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2UuZnJvbTsgaSA8IHJhbmdlLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBsZXRpb24sIG1hdGNoIH0gPSBvcHRpb25zW2ldLCB7IHNlY3Rpb24gfSA9IGNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT0gY3VyU2VjdGlvbiAmJiAoaSA+IHJhbmdlLmZyb20gfHwgcmFuZ2UuZnJvbSA9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJTZWN0aW9uID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWN0aW9uICE9IFwic3RyaW5nXCIgJiYgc2VjdGlvbi5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVsLmFwcGVuZENoaWxkKHNlY3Rpb24uaGVhZGVyKHNlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoZWFkZXIgPSB1bC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY29tcGxldGlvbi1zZWN0aW9uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaSA9IHVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSk7XG4gICAgICAgICAgICBsaS5pZCA9IGlkICsgXCItXCIgKyBpO1xuICAgICAgICAgICAgbGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIGxldCBjbHMgPSB0aGlzLm9wdGlvbkNsYXNzKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBsaS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgdGhpcy5vcHRpb25Db250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBzb3VyY2UoY29tcGxldGlvbiwgdGhpcy52aWV3LnN0YXRlLCB0aGlzLnZpZXcsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLmZyb20pXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wXCIpO1xuICAgICAgICBpZiAocmFuZ2UudG8gPCBvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b21cIik7XG4gICAgICAgIHJldHVybiB1bDtcbiAgICB9XG4gICAgZGVzdHJveUluZm8oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm9EZXN0cm95KVxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5mby5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBsZXRpb25Ub29sdGlwKHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbikge1xuICAgIHJldHVybiAodmlldykgPT4gbmV3IENvbXBsZXRpb25Ub29sdGlwKHZpZXcsIHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBzZWxmID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc2NhbGVZID0gcGFyZW50LmhlaWdodCAvIGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKHNlbGYudG9wIDwgcGFyZW50LnRvcClcbiAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCAtPSAocGFyZW50LnRvcCAtIHNlbGYudG9wKSAvIHNjYWxlWTtcbiAgICBlbHNlIGlmIChzZWxmLmJvdHRvbSA+IHBhcmVudC5ib3R0b20pXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gKHNlbGYuYm90dG9tIC0gcGFyZW50LmJvdHRvbSkgLyBzY2FsZVk7XG59XG5cbi8vIFVzZWQgdG8gcGljayBhIHByZWZlcnJlZCBvcHRpb24gd2hlbiB0d28gb3B0aW9ucyB3aXRoIHRoZSBzYW1lXG4vLyBsYWJlbCBvY2N1ciBpbiB0aGUgcmVzdWx0LlxuZnVuY3Rpb24gc2NvcmUob3B0aW9uKSB7XG4gICAgcmV0dXJuIChvcHRpb24uYm9vc3QgfHwgMCkgKiAxMDAgKyAob3B0aW9uLmFwcGx5ID8gMTAgOiAwKSArIChvcHRpb24uaW5mbyA/IDUgOiAwKSArXG4gICAgICAgIChvcHRpb24udHlwZSA/IDEgOiAwKTtcbn1cbmZ1bmN0aW9uIHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IFtdO1xuICAgIGxldCBzZWN0aW9ucyA9IG51bGw7XG4gICAgbGV0IGFkZE9wdGlvbiA9IChvcHRpb24pID0+IHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKG9wdGlvbik7XG4gICAgICAgIGxldCB7IHNlY3Rpb24gfSA9IG9wdGlvbi5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgaWYgKCFzZWN0aW9ucylcbiAgICAgICAgICAgICAgICBzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSB0eXBlb2Ygc2VjdGlvbiA9PSBcInN0cmluZ1wiID8gc2VjdGlvbiA6IHNlY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIGlmICghc2VjdGlvbnMuc29tZShzID0+IHMubmFtZSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHR5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyB7IG5hbWUgfSA6IHNlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgY29uZiA9IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xuICAgIGZvciAobGV0IGEgb2YgYWN0aXZlKVxuICAgICAgICBpZiAoYS5oYXNSZXN1bHQoKSkge1xuICAgICAgICAgICAgbGV0IGdldE1hdGNoID0gYS5yZXN1bHQuZ2V0TWF0Y2g7XG4gICAgICAgICAgICBpZiAoYS5yZXN1bHQuZmlsdGVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBhLnJlc3VsdC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9wdGlvbihuZXcgT3B0aW9uKG9wdGlvbiwgYS5zb3VyY2UsIGdldE1hdGNoID8gZ2V0TWF0Y2gob3B0aW9uKSA6IFtdLCAxZTkgLSBvcHRpb25zLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gc3RhdGUuc2xpY2VEb2MoYS5mcm9tLCBhLnRvKSwgbWF0Y2g7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXIgPSBjb25mLmZpbHRlclN0cmljdCA/IG5ldyBTdHJpY3RNYXRjaGVyKHBhdHRlcm4pIDogbmV3IEZ1enp5TWF0Y2hlcihwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgYS5yZXN1bHQub3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID0gbWF0Y2hlci5tYXRjaChvcHRpb24ubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlZCA9ICFvcHRpb24uZGlzcGxheUxhYmVsID8gbWF0Y2gubWF0Y2hlZCA6IGdldE1hdGNoID8gZ2V0TWF0Y2gob3B0aW9uLCBtYXRjaC5tYXRjaGVkKSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW9uKG5ldyBPcHRpb24ob3B0aW9uLCBhLnNvdXJjZSwgbWF0Y2hlZCwgbWF0Y2guc2NvcmUgKyAob3B0aW9uLmJvb3N0IHx8IDApKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGlmIChzZWN0aW9ucykge1xuICAgICAgICBsZXQgc2VjdGlvbk9yZGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcG9zID0gMDtcbiAgICAgICAgbGV0IGNtcCA9IChhLCBiKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoKF9hID0gYS5yYW5rKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxZTkpIC0gKChfYiA9IGIucmFuaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMWU5KSB8fCAoYS5uYW1lIDwgYi5uYW1lID8gLTEgOiAxKTsgfTtcbiAgICAgICAgZm9yIChsZXQgcyBvZiBzZWN0aW9ucy5zb3J0KGNtcCkpIHtcbiAgICAgICAgICAgIHBvcyAtPSAxZTU7XG4gICAgICAgICAgICBzZWN0aW9uT3JkZXJbcy5uYW1lXSA9IHBvcztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHsgc2VjdGlvbiB9ID0gb3B0aW9uLmNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoc2VjdGlvbilcbiAgICAgICAgICAgICAgICBvcHRpb24uc2NvcmUgKz0gc2VjdGlvbk9yZGVyW3R5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyBzZWN0aW9uIDogc2VjdGlvbi5uYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW10sIHByZXYgPSBudWxsO1xuICAgIGxldCBjb21wYXJlID0gY29uZi5jb21wYXJlQ29tcGxldGlvbnM7XG4gICAgZm9yIChsZXQgb3B0IG9mIG9wdGlvbnMuc29ydCgoYSwgYikgPT4gKGIuc2NvcmUgLSBhLnNjb3JlKSB8fCBjb21wYXJlKGEuY29tcGxldGlvbiwgYi5jb21wbGV0aW9uKSkpIHtcbiAgICAgICAgbGV0IGN1ciA9IG9wdC5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5sYWJlbCAhPSBjdXIubGFiZWwgfHwgcHJldi5kZXRhaWwgIT0gY3VyLmRldGFpbCB8fFxuICAgICAgICAgICAgKHByZXYudHlwZSAhPSBudWxsICYmIGN1ci50eXBlICE9IG51bGwgJiYgcHJldi50eXBlICE9IGN1ci50eXBlKSB8fFxuICAgICAgICAgICAgcHJldi5hcHBseSAhPSBjdXIuYXBwbHkgfHwgcHJldi5ib29zdCAhPSBjdXIuYm9vc3QpXG4gICAgICAgICAgICByZXN1bHQucHVzaChvcHQpO1xuICAgICAgICBlbHNlIGlmIChzY29yZShvcHQuY29tcGxldGlvbikgPiBzY29yZShwcmV2KSlcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBvcHQ7XG4gICAgICAgIHByZXYgPSBvcHQuY29tcGxldGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIENvbXBsZXRpb25EaWFsb2cge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGF0dHJzLCB0b29sdGlwLCB0aW1lc3RhbXAsIHNlbGVjdGVkLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMudG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIGlkKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZCA9PSB0aGlzLnNlbGVjdGVkIHx8IHNlbGVjdGVkID49IHRoaXMub3B0aW9ucy5sZW5ndGggPyB0aGlzXG4gICAgICAgICAgICA6IG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCksIHRoaXMudG9vbHRpcCwgdGhpcy50aW1lc3RhbXAsIHNlbGVjdGVkLCB0aGlzLmRpc2FibGVkKTtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKGFjdGl2ZSwgc3RhdGUsIGlkLCBwcmV2LCBjb25mLCBkaWRTZXRBY3RpdmUpIHtcbiAgICAgICAgaWYgKHByZXYgJiYgIWRpZFNldEFjdGl2ZSAmJiBhY3RpdmUuc29tZShzID0+IHMuaXNQZW5kaW5nKSlcbiAgICAgICAgICAgIHJldHVybiBwcmV2LnNldERpc2FibGVkKCk7XG4gICAgICAgIGxldCBvcHRpb25zID0gc29ydE9wdGlvbnMoYWN0aXZlLCBzdGF0ZSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gcHJldiAmJiBhY3RpdmUuc29tZShhID0+IGEuaXNQZW5kaW5nKSA/IHByZXYuc2V0RGlzYWJsZWQoKSA6IG51bGw7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLnNlbGVjdE9uT3BlbiA/IDAgOiAtMTtcbiAgICAgICAgaWYgKHByZXYgJiYgcHJldi5zZWxlY3RlZCAhPSBzZWxlY3RlZCAmJiBwcmV2LnNlbGVjdGVkICE9IC0xKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRWYWx1ZSA9IHByZXYub3B0aW9uc1twcmV2LnNlbGVjdGVkXS5jb21wbGV0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zW2ldLmNvbXBsZXRpb24gPT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2cob3B0aW9ucywgbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCksIHtcbiAgICAgICAgICAgIHBvczogYWN0aXZlLnJlZHVjZSgoYSwgYikgPT4gYi5oYXNSZXN1bHQoKSA/IE1hdGgubWluKGEsIGIuZnJvbSkgOiBhLCAxZTgpLFxuICAgICAgICAgICAgY3JlYXRlOiBjcmVhdGVUb29sdGlwLFxuICAgICAgICAgICAgYWJvdmU6IGNvbmYuYWJvdmVDdXJzb3IsXG4gICAgICAgIH0sIHByZXYgPyBwcmV2LnRpbWVzdGFtcCA6IERhdGUubm93KCksIHNlbGVjdGVkLCBmYWxzZSk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvbkRpYWxvZyh0aGlzLm9wdGlvbnMsIHRoaXMuYXR0cnMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy50b29sdGlwKSwgeyBwb3M6IGNoYW5nZXMubWFwUG9zKHRoaXMudG9vbHRpcC5wb3MpIH0pLCB0aGlzLnRpbWVzdGFtcCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5kaXNhYmxlZCk7XG4gICAgfVxuICAgIHNldERpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCB0aGlzLmF0dHJzLCB0aGlzLnRvb2x0aXAsIHRoaXMudGltZXN0YW1wLCB0aGlzLnNlbGVjdGVkLCB0cnVlKTtcbiAgICB9XG59XG5jbGFzcyBDb21wbGV0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2ZSwgaWQsIG9wZW4pIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgc3RhdGljIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25TdGF0ZShub25lLCBcImNtLWFjLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMmU2KS50b1N0cmluZygzNiksIG51bGwpO1xuICAgIH1cbiAgICB1cGRhdGUodHIpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRyLCBjb25mID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIGxldCBzb3VyY2VzID0gY29uZi5vdmVycmlkZSB8fFxuICAgICAgICAgICAgc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJhdXRvY29tcGxldGVcIiwgY3VyKHN0YXRlKSkubWFwKGFzU291cmNlKTtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHNvdXJjZXMubWFwKHNvdXJjZSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmFjdGl2ZS5maW5kKHMgPT4gcy5zb3VyY2UgPT0gc291cmNlKSB8fFxuICAgICAgICAgICAgICAgIG5ldyBBY3RpdmVTb3VyY2Uoc291cmNlLCB0aGlzLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCA9PSB0aGlzLmFjdGl2ZS5sZW5ndGggJiYgYWN0aXZlLmV2ZXJ5KChhLCBpKSA9PiBhID09IHRoaXMuYWN0aXZlW2ldKSlcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMub3BlbiwgZGlkU2V0ID0gdHIuZWZmZWN0cy5zb21lKGUgPT4gZS5pcyhzZXRBY3RpdmVFZmZlY3QpKTtcbiAgICAgICAgaWYgKG9wZW4gJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIG9wZW4gPSBvcGVuLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbiB8fCBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkgJiYgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UoYS5mcm9tLCBhLnRvKSkgfHxcbiAgICAgICAgICAgICFzYW1lUmVzdWx0cyhhY3RpdmUsIHRoaXMuYWN0aXZlKSB8fCBkaWRTZXQpXG4gICAgICAgICAgICBvcGVuID0gQ29tcGxldGlvbkRpYWxvZy5idWlsZChhY3RpdmUsIHN0YXRlLCB0aGlzLmlkLCBvcGVuLCBjb25mLCBkaWRTZXQpO1xuICAgICAgICBlbHNlIGlmIChvcGVuICYmIG9wZW4uZGlzYWJsZWQgJiYgIWFjdGl2ZS5zb21lKGEgPT4gYS5pc1BlbmRpbmcpKVxuICAgICAgICAgICAgb3BlbiA9IG51bGw7XG4gICAgICAgIGlmICghb3BlbiAmJiBhY3RpdmUuZXZlcnkoYSA9PiAhYS5pc1BlbmRpbmcpICYmIGFjdGl2ZS5zb21lKGEgPT4gYS5oYXNSZXN1bHQoKSkpXG4gICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUubWFwKGEgPT4gYS5oYXNSZXN1bHQoKSA/IG5ldyBBY3RpdmVTb3VyY2UoYS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogYSk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWxlY3RlZEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgb3BlbiA9IG9wZW4gJiYgb3Blbi5zZXRTZWxlY3RlZChlZmZlY3QudmFsdWUsIHRoaXMuaWQpO1xuICAgICAgICByZXR1cm4gYWN0aXZlID09IHRoaXMuYWN0aXZlICYmIG9wZW4gPT0gdGhpcy5vcGVuID8gdGhpcyA6IG5ldyBDb21wbGV0aW9uU3RhdGUoYWN0aXZlLCB0aGlzLmlkLCBvcGVuKTtcbiAgICB9XG4gICAgZ2V0IHRvb2x0aXAoKSB7IHJldHVybiB0aGlzLm9wZW4gPyB0aGlzLm9wZW4udG9vbHRpcCA6IG51bGw7IH1cbiAgICBnZXQgYXR0cnMoKSB7IHJldHVybiB0aGlzLm9wZW4gPyB0aGlzLm9wZW4uYXR0cnMgOiB0aGlzLmFjdGl2ZS5sZW5ndGggPyBiYXNlQXR0cnMgOiBub0F0dHJzOyB9XG59XG5mdW5jdGlvbiBzYW1lUmVzdWx0cyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICB3aGlsZSAoaUEgPCBhLmxlbmd0aCAmJiAhYVtpQV0uaGFzUmVzdWx0KCkpXG4gICAgICAgICAgICBpQSsrO1xuICAgICAgICB3aGlsZSAoaUIgPCBiLmxlbmd0aCAmJiAhYltpQl0uaGFzUmVzdWx0KCkpXG4gICAgICAgICAgICBpQisrO1xuICAgICAgICBsZXQgZW5kQSA9IGlBID09IGEubGVuZ3RoLCBlbmRCID0gaUIgPT0gYi5sZW5ndGg7XG4gICAgICAgIGlmIChlbmRBIHx8IGVuZEIpXG4gICAgICAgICAgICByZXR1cm4gZW5kQSA9PSBlbmRCO1xuICAgICAgICBpZiAoYVtpQSsrXS5yZXN1bHQgIT0gYltpQisrXS5yZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgYmFzZUF0dHJzID0ge1xuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCJcbn07XG5jb25zdCBub0F0dHJzID0ge307XG5mdW5jdGlvbiBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSB7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIixcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwibGlzdGJveFwiLFxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogaWRcbiAgICB9O1xuICAgIGlmIChzZWxlY3RlZCA+IC0xKVxuICAgICAgICByZXN1bHRbXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIl0gPSBpZCArIFwiLVwiICsgc2VsZWN0ZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmZ1bmN0aW9uIGdldFVwZGF0ZVR5cGUodHIsIGNvbmYpIHtcbiAgICBpZiAodHIuaXNVc2VyRXZlbnQoXCJpbnB1dC5jb21wbGV0ZVwiKSkge1xuICAgICAgICBsZXQgY29tcGxldGlvbiA9IHRyLmFubm90YXRpb24ocGlja2VkQ29tcGxldGlvbik7XG4gICAgICAgIGlmIChjb21wbGV0aW9uICYmIGNvbmYuYWN0aXZhdGVPbkNvbXBsZXRpb24oY29tcGxldGlvbikpXG4gICAgICAgICAgICByZXR1cm4gNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovIHwgOCAvKiBVcGRhdGVUeXBlLlJlc2V0ICovO1xuICAgIH1cbiAgICBsZXQgdHlwaW5nID0gdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpO1xuICAgIHJldHVybiB0eXBpbmcgJiYgY29uZi5hY3RpdmF0ZU9uVHlwaW5nID8gNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovIHwgMSAvKiBVcGRhdGVUeXBlLlR5cGluZyAqL1xuICAgICAgICA6IHR5cGluZyA/IDEgLyogVXBkYXRlVHlwZS5UeXBpbmcgKi9cbiAgICAgICAgICAgIDogdHIuaXNVc2VyRXZlbnQoXCJkZWxldGUuYmFja3dhcmRcIikgPyAyIC8qIFVwZGF0ZVR5cGUuQmFja3NwYWNpbmcgKi9cbiAgICAgICAgICAgICAgICA6IHRyLnNlbGVjdGlvbiA/IDggLyogVXBkYXRlVHlwZS5SZXNldCAqL1xuICAgICAgICAgICAgICAgICAgICA6IHRyLmRvY0NoYW5nZWQgPyAxNiAvKiBVcGRhdGVUeXBlLlJlc2V0SWZUb3VjaGluZyAqLyA6IDAgLyogVXBkYXRlVHlwZS5Ob25lICovO1xufVxuY2xhc3MgQWN0aXZlU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHN0YXRlLCBleHBsaWNpdCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICB9XG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNQZW5kaW5nKCkgeyByZXR1cm4gdGhpcy5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi87IH1cbiAgICB1cGRhdGUodHIsIGNvbmYpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBnZXRVcGRhdGVUeXBlKHRyLCBjb25mKSwgdmFsdWUgPSB0aGlzO1xuICAgICAgICBpZiAoKHR5cGUgJiA4IC8qIFVwZGF0ZVR5cGUuUmVzZXQgKi8pIHx8ICh0eXBlICYgMTYgLyogVXBkYXRlVHlwZS5SZXNldElmVG91Y2hpbmcgKi8pICYmIHRoaXMudG91Y2hlcyh0cikpXG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBBY3RpdmVTb3VyY2UodmFsdWUuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgaWYgKCh0eXBlICYgNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovKSAmJiB2YWx1ZS5zdGF0ZSA9PSAwIC8qIFN0YXRlLkluYWN0aXZlICovKVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZUZvcih0ciwgdHlwZSk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKGNsb3NlQ29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoc2V0QWN0aXZlRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgZWZmZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLnNvdXJjZSA9PSB2YWx1ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFjdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHVwZGF0ZUZvcih0ciwgdHlwZSkgeyByZXR1cm4gdGhpcy5tYXAodHIuY2hhbmdlcyk7IH1cbiAgICBtYXAoY2hhbmdlcykgeyByZXR1cm4gdGhpczsgfVxuICAgIHRvdWNoZXModHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGN1cih0ci5zdGF0ZSkpO1xuICAgIH1cbn1cbmNsYXNzIEFjdGl2ZVJlc3VsdCBleHRlbmRzIEFjdGl2ZVNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBleHBsaWNpdCwgbGltaXQsIHJlc3VsdCwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoc291cmNlLCAzIC8qIFN0YXRlLlJlc3VsdCAqLywgZXhwbGljaXQpO1xuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIGhhc1Jlc3VsdCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICB1cGRhdGVGb3IodHIsIHR5cGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoISh0eXBlICYgMyAvKiBVcGRhdGVUeXBlLlNpbXBsZUludGVyYWN0aW9uICovKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVzdWx0O1xuICAgICAgICBpZiAocmVzdWx0Lm1hcCAmJiAhdHIuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAocmVzdWx0LCB0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IGZyb20gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20pLCB0byA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEpO1xuICAgICAgICBsZXQgcG9zID0gY3VyKHRyLnN0YXRlKTtcbiAgICAgICAgaWYgKHBvcyA+IHRvIHx8ICFyZXN1bHQgfHxcbiAgICAgICAgICAgICh0eXBlICYgMiAvKiBVcGRhdGVUeXBlLkJhY2tzcGFjaW5nICovKSAmJiAoY3VyKHRyLnN0YXJ0U3RhdGUpID09IHRoaXMuZnJvbSB8fCBwb3MgPCB0aGlzLmxpbWl0KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCB0eXBlICYgNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovID8gMSAvKiBTdGF0ZS5QZW5kaW5nICovIDogMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIGxldCBsaW1pdCA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMubGltaXQpO1xuICAgICAgICBpZiAoY2hlY2tWYWxpZChyZXN1bHQudmFsaWRGb3IsIHRyLnN0YXRlLCBmcm9tLCB0bykpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgdGhpcy5leHBsaWNpdCwgbGltaXQsIHJlc3VsdCwgZnJvbSwgdG8pO1xuICAgICAgICBpZiAocmVzdWx0LnVwZGF0ZSAmJlxuICAgICAgICAgICAgKHJlc3VsdCA9IHJlc3VsdC51cGRhdGUocmVzdWx0LCBmcm9tLCB0bywgbmV3IENvbXBsZXRpb25Db250ZXh0KHRyLnN0YXRlLCBwb3MsIGZhbHNlKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIHRoaXMuZXhwbGljaXQsIGxpbWl0LCByZXN1bHQsIHJlc3VsdC5mcm9tLCAoX2EgPSByZXN1bHQudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cih0ci5zdGF0ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCB0aGlzLmV4cGxpY2l0KTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVzdWx0Lm1hcCA/IHRoaXMucmVzdWx0Lm1hcCh0aGlzLnJlc3VsdCwgbWFwcGluZykgOiB0aGlzLnJlc3VsdDtcbiAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmxpbWl0KSwgdGhpcy5yZXN1bHQsIG1hcHBpbmcubWFwUG9zKHRoaXMuZnJvbSksIG1hcHBpbmcubWFwUG9zKHRoaXMudG8sIDEpKTtcbiAgICB9XG4gICAgdG91Y2hlcyh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkKHZhbGlkRm9yLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIXZhbGlkRm9yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHRleHQgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWxpZEZvciA9PSBcImZ1bmN0aW9uXCIgPyB2YWxpZEZvcih0ZXh0LCBmcm9tLCB0bywgc3RhdGUpIDogZW5zdXJlQW5jaG9yKHZhbGlkRm9yLCB0cnVlKS50ZXN0KHRleHQpO1xufVxuY29uc3Qgc2V0QWN0aXZlRWZmZWN0ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAoc291cmNlcywgbWFwcGluZykgeyByZXR1cm4gc291cmNlcy5tYXAocyA9PiBzLm1hcChtYXBwaW5nKSk7IH1cbn0pO1xuY29uc3Qgc2V0U2VsZWN0ZWRFZmZlY3QgPSBzdGF0ZS5TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNvbXBsZXRpb25TdGF0ZSA9IHN0YXRlLlN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBDb21wbGV0aW9uU3RhdGUuc3RhcnQoKTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7IHJldHVybiB2YWx1ZS51cGRhdGUodHIpOyB9LFxuICAgIHByb3ZpZGU6IGYgPT4gW1xuICAgICAgICB2aWV3LnNob3dUb29sdGlwLmZyb20oZiwgdmFsID0+IHZhbC50b29sdGlwKSxcbiAgICAgICAgdmlldy5FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmZyb20oZiwgc3RhdGUgPT4gc3RhdGUuYXR0cnMpXG4gICAgXVxufSk7XG5mdW5jdGlvbiBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uKSB7XG4gICAgY29uc3QgYXBwbHkgPSBvcHRpb24uY29tcGxldGlvbi5hcHBseSB8fCBvcHRpb24uY29tcGxldGlvbi5sYWJlbDtcbiAgICBsZXQgcmVzdWx0ID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gb3B0aW9uLnNvdXJjZSk7XG4gICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgQWN0aXZlUmVzdWx0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgYXBwbHkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgdmlldy5kaXNwYXRjaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc2VydENvbXBsZXRpb25UZXh0KHZpZXcuc3RhdGUsIGFwcGx5LCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKSksIHsgYW5ub3RhdGlvbnM6IHBpY2tlZENvbXBsZXRpb24ub2Yob3B0aW9uLmNvbXBsZXRpb24pIH0pKTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGx5KHZpZXcsIG9wdGlvbi5jb21wbGV0aW9uLCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IGNyZWF0ZVRvb2x0aXAgPSBjb21wbGV0aW9uVG9vbHRpcChjb21wbGV0aW9uU3RhdGUsIGFwcGx5Q29tcGxldGlvbik7XG5cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgdGhhdCBtb3ZlcyB0aGUgY29tcGxldGlvbiBzZWxlY3Rpb24gZm9yd2FyZCBvclxuYmFja3dhcmQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiovXG5mdW5jdGlvbiBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmb3J3YXJkLCBieSA9IFwib3B0aW9uXCIpIHtcbiAgICByZXR1cm4gKHZpZXckMSkgPT4ge1xuICAgICAgICBsZXQgY1N0YXRlID0gdmlldyQxLnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWNTdGF0ZSB8fCAhY1N0YXRlLm9wZW4gfHwgY1N0YXRlLm9wZW4uZGlzYWJsZWQgfHxcbiAgICAgICAgICAgIERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCB2aWV3JDEuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuaW50ZXJhY3Rpb25EZWxheSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0ZXAgPSAxLCB0b29sdGlwO1xuICAgICAgICBpZiAoYnkgPT0gXCJwYWdlXCIgJiYgKHRvb2x0aXAgPSB2aWV3LmdldFRvb2x0aXAodmlldyQxLCBjU3RhdGUub3Blbi50b29sdGlwKSkpXG4gICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcih0b29sdGlwLmRvbS5vZmZzZXRIZWlnaHQgL1xuICAgICAgICAgICAgICAgIHRvb2x0aXAuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKS5vZmZzZXRIZWlnaHQpIC0gMSk7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gY1N0YXRlLm9wZW4ub3B0aW9ucztcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gY1N0YXRlLm9wZW4uc2VsZWN0ZWQgPiAtMSA/IGNTdGF0ZS5vcGVuLnNlbGVjdGVkICsgc3RlcCAqIChmb3J3YXJkID8gMSA6IC0xKSA6IGZvcndhcmQgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHNlbGVjdGVkIDwgMClcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWQgPj0gbGVuZ3RoKVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBieSA9PSBcInBhZ2VcIiA/IGxlbmd0aCAtIDEgOiAwO1xuICAgICAgICB2aWV3JDEuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWxlY3RlZEVmZmVjdC5vZihzZWxlY3RlZCkgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkFjY2VwdCB0aGUgY3VycmVudCBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IGFjY2VwdENvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5IHx8ICFjU3RhdGUgfHwgIWNTdGF0ZS5vcGVuIHx8IGNTdGF0ZS5vcGVuLnNlbGVjdGVkIDwgMCB8fCBjU3RhdGUub3Blbi5kaXNhYmxlZCB8fFxuICAgICAgICBEYXRlLm5vdygpIC0gY1N0YXRlLm9wZW4udGltZXN0YW1wIDwgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5pbnRlcmFjdGlvbkRlbGF5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGFwcGx5Q29tcGxldGlvbih2aWV3LCBjU3RhdGUub3Blbi5vcHRpb25zW2NTdGF0ZS5vcGVuLnNlbGVjdGVkXSk7XG59O1xuLyoqXG5FeHBsaWNpdGx5IHN0YXJ0IGF1dG9jb21wbGV0aW9uLlxuKi9cbmNvbnN0IHN0YXJ0Q29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFjU3RhdGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc3RhcnRDb21wbGV0aW9uRWZmZWN0Lm9mKHRydWUpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ2xvc2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgY29tcGxldGlvbi5cbiovXG5jb25zdCBjbG9zZUNvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghY1N0YXRlIHx8ICFjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jbGFzcyBSdW5uaW5nUXVlcnkge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2ZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy51cGRhdGVzID0gW107XG4gICAgICAgIC8vIE5vdGUgdGhhdCAndW5kZWZpbmVkJyBtZWFucyAnbm90IGRvbmUgeWV0Jywgd2hlcmVhcyAnbnVsbCcgbWVhbnNcbiAgICAgICAgLy8gJ3F1ZXJ5IHJldHVybmVkIG51bGwnLlxuICAgICAgICB0aGlzLmRvbmUgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuY29uc3QgTWF4VXBkYXRlQ291bnQgPSA1MCwgTWluQWJvcnRUaW1lID0gMTAwMDtcbmNvbnN0IGNvbXBsZXRpb25QbHVnaW4gPSB2aWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gW107XG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLztcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUpXG4gICAgICAgICAgICBpZiAoYWN0aXZlLmlzUGVuZGluZylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xuICAgICAgICBpZiAoIXVwZGF0ZS5zZWxlY3Rpb25TZXQgJiYgIXVwZGF0ZS5kb2NDaGFuZ2VkICYmIHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkgPT0gY1N0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9lc1Jlc2V0ID0gdXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gZ2V0VXBkYXRlVHlwZSh0ciwgY29uZik7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUgJiA4IC8qIFVwZGF0ZVR5cGUuUmVzZXQgKi8pIHx8ICh0ci5zZWxlY3Rpb24gfHwgdHIuZG9jQ2hhbmdlZCkgJiYgISh0eXBlICYgMyAvKiBVcGRhdGVUeXBlLlNpbXBsZUludGVyYWN0aW9uICovKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAoZG9lc1Jlc2V0IHx8XG4gICAgICAgICAgICAgICAgcXVlcnkuY29udGV4dC5hYm9ydE9uRG9jQ2hhbmdlICYmIHVwZGF0ZS5kb2NDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgICAgcXVlcnkudXBkYXRlcy5sZW5ndGggKyB1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aCA+IE1heFVwZGF0ZUNvdW50ICYmIERhdGUubm93KCkgLSBxdWVyeS50aW1lID4gTWluQWJvcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcubG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXVlcnkuY29udGV4dC5hYm9ydExpc3RlbmVycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnkudXBkYXRlcy5wdXNoKC4uLnVwZGF0ZS50cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlYm91bmNlVXBkYXRlID4gLTEpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVVwZGF0ZSk7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuZWZmZWN0cy5zb21lKGUgPT4gZS5pcyhzdGFydENvbXBsZXRpb25FZmZlY3QpKSkpXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTdGFydCA9IHRydWU7XG4gICAgICAgIGxldCBkZWxheSA9IHRoaXMucGVuZGluZ1N0YXJ0ID8gNTAgOiBjb25mLmFjdGl2YXRlT25UeXBpbmdEZWxheTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuaXNQZW5kaW5nICYmICF0aGlzLnJ1bm5pbmcuc29tZShxID0+IHEuYWN0aXZlLnNvdXJjZSA9PSBhLnNvdXJjZSkpXG4gICAgICAgICAgICA/IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydFVwZGF0ZSgpLCBkZWxheSkgOiAtMTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nICE9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovKVxuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMiAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWQgKi87XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb21wb3NpbmcgPT0gMiAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWQgKi8gJiYgdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDMgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkQW5kTW92ZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VXBkYXRlKCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiBjU3RhdGUuYWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlLmlzUGVuZGluZyAmJiAhdGhpcy5ydW5uaW5nLnNvbWUociA9PiByLmFjdGl2ZS5zb3VyY2UgPT0gYWN0aXZlLnNvdXJjZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVubmluZy5sZW5ndGggJiYgY1N0YXRlLm9wZW4gJiYgY1N0YXRlLm9wZW4uZGlzYWJsZWQpXG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjY2VwdCgpLCB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykudXBkYXRlU3luY1RpbWUpO1xuICAgIH1cbiAgICBzdGFydFF1ZXJ5KGFjdGl2ZSkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBwb3MgPSBjdXIoc3RhdGUpO1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBDb21wbGV0aW9uQ29udGV4dChzdGF0ZSwgcG9zLCBhY3RpdmUuZXhwbGljaXQsIHRoaXMudmlldyk7XG4gICAgICAgIGxldCBwZW5kaW5nID0gbmV3IFJ1bm5pbmdRdWVyeShhY3RpdmUsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcucHVzaChwZW5kaW5nKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGFjdGl2ZS5zb3VyY2UoY29udGV4dCkpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmICghcGVuZGluZy5jb250ZXh0LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLmRvbmUgPSByZXN1bHQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQWNjZXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgICAgICAgICB2aWV3LmxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlZHVsZUFjY2VwdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZy5ldmVyeShxID0+IHEuZG9uZSAhPT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY2NlcHQoKSwgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLnVwZGF0ZVN5bmNUaW1lKTtcbiAgICB9XG4gICAgLy8gRm9yIGVhY2ggZmluaXNoZWQgcXVlcnkgaW4gdGhpcy5ydW5uaW5nLCB0cnkgdG8gY3JlYXRlIGEgcmVzdWx0XG4gICAgLy8gb3IsIGlmIGFwcHJvcHJpYXRlLCByZXN0YXJ0IHRoZSBxdWVyeS5cbiAgICBhY2NlcHQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlQWNjZXB0KTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKSwgY1N0YXRlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gY3VyKHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoID8gcXVlcnkudXBkYXRlc1swXS5zdGFydFN0YXRlIDogdGhpcy52aWV3LnN0YXRlKTtcbiAgICAgICAgICAgICAgICBsZXQgbGltaXQgPSBNYXRoLm1pbihwb3MsIHF1ZXJ5LmRvbmUuZnJvbSArIChxdWVyeS5hY3RpdmUuZXhwbGljaXQgPyAwIDogMSkpO1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlUmVzdWx0KHF1ZXJ5LmFjdGl2ZS5zb3VyY2UsIHF1ZXJ5LmFjdGl2ZS5leHBsaWNpdCwgbGltaXQsIHF1ZXJ5LmRvbmUsIHF1ZXJ5LmRvbmUuZnJvbSwgKF9hID0gcXVlcnkuZG9uZS50bykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcG9zKTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYXkgdGhlIHRyYW5zYWN0aW9ucyB0aGF0IGhhcHBlbmVkIHNpbmNlIHRoZSBzdGFydCBvZlxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IGFuZCBzZWUgaWYgdGhhdCBwcmVzZXJ2ZXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUuaGFzUmVzdWx0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gY1N0YXRlLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gcXVlcnkuYWN0aXZlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmlzUGVuZGluZykge1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBmYWlsZWQuIFNob3VsZCBjbGVhciB0aGUgcGVuZGluZyBzdGF0dXMgaWYgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzbid0IGJlZW4gcmUtc2V0IGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTb3VyY2UocXVlcnkuYWN0aXZlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhY3RpdmUuaXNQZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhcmVkIGJ5IHN1YnNlcXVlbnQgdHJhbnNhY3Rpb25zLiBSZXN0YXJ0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkLmxlbmd0aCB8fCBjU3RhdGUub3BlbiAmJiBjU3RhdGUub3Blbi5kaXNhYmxlZClcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldEFjdGl2ZUVmZmVjdC5vZih1cGRhdGVkKSB9KTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICBibHVyKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9vbHRpcCAmJiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuY2xvc2VPbkJsdXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlhbG9nID0gc3RhdGUub3BlbiAmJiB2aWV3LmdldFRvb2x0aXAodGhpcy52aWV3LCBzdGF0ZS5vcGVuLnRvb2x0aXApO1xuICAgICAgICAgICAgICAgIGlmICghZGlhbG9nIHx8ICFkaWFsb2cuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wb3NpdGlvbnN0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAxIC8qIENvbXBvc2l0aW9uU3RhdGUuU3RhcnRlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25lbmQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPT0gMyAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWRBbmRNb3ZlZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBjb21wb3NpdGlvbmVuZCBldmVudHMgc3luY2hyb25vdXNseSwgcG9zc2libHlcbiAgICAgICAgICAgICAgICAvLyBmcm9tIGluc2lkZSBhbiB1cGRhdGUsIHNvIGRpc3BhdGNoIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJlZW50cmFuY3lcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHN0YXJ0Q29tcGxldGlvbkVmZmVjdC5vZihmYWxzZSkgfSksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi87XG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IHdpbmRvd3MgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwib2JqZWN0XCIgJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgY29tbWl0Q2hhcmFjdGVycyA9IHN0YXRlLlByZWMuaGlnaGVzdCh2aWV3LkVkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAga2V5ZG93bihldmVudCwgdmlldykge1xuICAgICAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5vcGVuIHx8IGZpZWxkLm9wZW4uZGlzYWJsZWQgfHwgZmllbGQub3Blbi5zZWxlY3RlZCA8IDAgfHxcbiAgICAgICAgICAgIGV2ZW50LmtleS5sZW5ndGggPiAxIHx8IGV2ZW50LmN0cmxLZXkgJiYgISh3aW5kb3dzICYmIGV2ZW50LmFsdEtleSkgfHwgZXZlbnQubWV0YUtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG9wdGlvbiA9IGZpZWxkLm9wZW4ub3B0aW9uc1tmaWVsZC5vcGVuLnNlbGVjdGVkXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZpZWxkLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gb3B0aW9uLnNvdXJjZSk7XG4gICAgICAgIGxldCBjb21taXRDaGFycyA9IG9wdGlvbi5jb21wbGV0aW9uLmNvbW1pdENoYXJhY3RlcnMgfHwgcmVzdWx0LnJlc3VsdC5jb21taXRDaGFyYWN0ZXJzO1xuICAgICAgICBpZiAoY29tbWl0Q2hhcnMgJiYgY29tbWl0Q2hhcnMuaW5kZXhPZihldmVudC5rZXkpID4gLTEpXG4gICAgICAgICAgICBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pKTtcblxuY29uc3QgYmFzZVRoZW1lID0gdmlldy5FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tdG9vbHRpcC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiOiB7XG4gICAgICAgIFwiJiA+IHVsXCI6IHtcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwibW9ub3NwYWNlXCIsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuIGF1dG9cIixcbiAgICAgICAgICAgIG1heFdpZHRoX2ZhbGxiYWNrOiBcIjcwMHB4XCIsXG4gICAgICAgICAgICBtYXhXaWR0aDogXCJtaW4oNzAwcHgsIDk1dncpXCIsXG4gICAgICAgICAgICBtaW5XaWR0aDogXCIyNTBweFwiLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBcIjEwZW1cIixcbiAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICBsaXN0U3R5bGU6IFwibm9uZVwiLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIFwiJiA+IGxpLCAmID4gY29tcGxldGlvbi1zZWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjFweCAzcHhcIixcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxLjJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgPiBsaVwiOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgPiBjb21wbGV0aW9uLXNlY3Rpb25cIjoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwibGlzdC1pdGVtXCIsXG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogXCIwLjVlbVwiLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuN1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMxN2NcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZCB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzc3N1wiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMzNDdcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNDQ0XCIsXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVUb3A6YmVmb3JlLCAuY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tOmFmdGVyXCI6IHtcbiAgICAgICAgY29udGVudDogJ1wiwrfCt8K3XCInLFxuICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLmNtLWNvbXBsZXRpb25JbmZvXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgcGFkZGluZzogXCIzcHggOXB4XCIsXG4gICAgICAgIHdpZHRoOiBcIm1heC1jb250ZW50XCIsXG4gICAgICAgIG1heFdpZHRoOiBgJHs0MDAgLyogSW5mby5XaWR0aCAqL31weGAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlLWxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdFwiOiB7IHJpZ2h0OiBcIjEwMCVcIiB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLXJpZ2h0XCI6IHsgbGVmdDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1sZWZ0LW5hcnJvd1wiOiB7IHJpZ2h0OiBgJHszMCAvKiBJbmZvLk1hcmdpbiAqL31weGAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodC1uYXJyb3dcIjogeyBsZWZ0OiBgJHszMCAvKiBJbmZvLk1hcmdpbiAqL31weGAgfSxcbiAgICBcIiZsaWdodCAuY20tc25pcHBldEZpZWxkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMwMDAwMDAyMlwiIH0sXG4gICAgXCImZGFyayAuY20tc25pcHBldEZpZWxkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmZmYyMlwiIH0sXG4gICAgXCIuY20tc25pcHBldEZpZWxkUG9zaXRpb25cIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRleHQtdG9wXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IFwiMS4xNWVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIG1hcmdpbjogXCIwIC0wLjdweCAtLjdlbVwiLFxuICAgICAgICBib3JkZXJMZWZ0OiBcIjEuNHB4IGRvdHRlZCAjODg4XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25NYXRjaGVkVGV4dFwiOiB7XG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uRGV0YWlsXCI6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogXCIwLjVlbVwiLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uXCI6IHtcbiAgICAgICAgZm9udFNpemU6IFwiOTAlXCIsXG4gICAgICAgIHdpZHRoOiBcIi44ZW1cIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IFwiLjZlbVwiLFxuICAgICAgICBvcGFjaXR5OiBcIjAuNlwiLFxuICAgICAgICBib3hTaXppbmc6IFwiY29udGVudC1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZnVuY3Rpb24sIC5jbS1jb21wbGV0aW9uSWNvbi1tZXRob2RcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifGkidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jbGFzc1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KXiydcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1pbnRlcmZhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifil4wnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdmFyaWFibGVcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZGlJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNvbnN0YW50XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2QtidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10eXBlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2RoSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1lbnVtXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4oiqJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXByb3BlcnR5XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4pahJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWtleXdvcmRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwn5SRXFx1RkUwRSdcIiB9IC8vIERpc2FibGUgZW1vamkgcmVuZGVyaW5nXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1uYW1lc3BhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifilqInXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdGV4dFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ2FiYydcIiwgZm9udFNpemU6IFwiNTAlXCIsIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIgfVxuICAgIH1cbn0pO1xuXG5jbGFzcyBGaWVsZFBvcyB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIGxpbmUsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmNsYXNzIEZpZWxkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20sIC0xLCBzdGF0ZS5NYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgbGV0IHRvID0gY2hhbmdlcy5tYXBQb3ModGhpcy50bywgMSwgc3RhdGUuTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgIHJldHVybiBmcm9tID09IG51bGwgfHwgdG8gPT0gbnVsbCA/IG51bGwgOiBuZXcgRmllbGRSYW5nZSh0aGlzLmZpZWxkLCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgU25pcHBldCB7XG4gICAgY29uc3RydWN0b3IobGluZXMsIGZpZWxkUG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5maWVsZFBvc2l0aW9ucyA9IGZpZWxkUG9zaXRpb25zO1xuICAgIH1cbiAgICBpbnN0YW50aWF0ZShzdGF0ZSwgcG9zKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gW10sIGxpbmVTdGFydCA9IFtwb3NdO1xuICAgICAgICBsZXQgbGluZU9iaiA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgYmFzZUluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lT2JqLnRleHQpWzBdO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMubGluZXMpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSBiYXNlSW5kZW50LCB0YWJzID0gL15cXHQqLy5leGVjKGxpbmUpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnM7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IHN0YXRlLmZhY2V0KGxhbmd1YWdlLmluZGVudFVuaXQpO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydC5wdXNoKHBvcyArIGluZGVudC5sZW5ndGggLSB0YWJzKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gaW5kZW50ICsgbGluZS5zbGljZSh0YWJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIHBvcyArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMuZmllbGRQb3NpdGlvbnMubWFwKHBvcyA9PiBuZXcgRmllbGRSYW5nZShwb3MuZmllbGQsIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MuZnJvbSwgbGluZVN0YXJ0W3Bvcy5saW5lXSArIHBvcy50bykpO1xuICAgICAgICByZXR1cm4geyB0ZXh0LCByYW5nZXMgfTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHRlbXBsYXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGxpbmVzID0gW10sIHBvc2l0aW9ucyA9IFtdLCBtO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRlbXBsYXRlLnNwbGl0KC9cXHJcXG4/fFxcbi8pKSB7XG4gICAgICAgICAgICB3aGlsZSAobSA9IC9bIyRdXFx7KD86KFxcZCspKD86OihbXn1dKikpP3woKD86XFxcXFt7fV18W159XSkqKSlcXH0vLmV4ZWMobGluZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VxID0gbVsxXSA/ICttWzFdIDogbnVsbCwgcmF3TmFtZSA9IG1bMl0gfHwgbVszXSB8fCBcIlwiLCBmb3VuZCA9IC0xO1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gcmF3TmFtZS5yZXBsYWNlKC9cXFxcW3t9XS9nLCBtID0+IG1bMV0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXEgIT0gbnVsbCA/IGZpZWxkc1tpXS5zZXEgPT0gc2VxIDogbmFtZSA/IGZpZWxkc1tpXS5uYW1lID09IG5hbWUgOiBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgZmllbGRzLmxlbmd0aCAmJiAoc2VxID09IG51bGwgfHwgKGZpZWxkc1tpXS5zZXEgIT0gbnVsbCAmJiBmaWVsZHNbaV0uc2VxIDwgc2VxKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5zcGxpY2UoaSwgMCwgeyBzZXEsIG5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MuZmllbGQgPj0gZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZpZWxkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBGaWVsZFBvcyhmb3VuZCwgbGluZXMubGVuZ3RoLCBtLmluZGV4LCBtLmluZGV4ICsgbmFtZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBtLmluZGV4KSArIHJhd05hbWUgKyBsaW5lLnNsaWNlKG0uaW5kZXggKyBtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9cXFxcKFt7fV0pL2csIChfLCBicmFjZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zLmxpbmUgPT0gbGluZXMubGVuZ3RoICYmIHBvcy5mcm9tID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5mcm9tLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MudG8tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBicmFjZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNuaXBwZXQobGluZXMsIHBvc2l0aW9ucyk7XG4gICAgfVxufVxubGV0IGZpZWxkTWFya2VyID0gdmlldy5EZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogbmV3IGNsYXNzIGV4dGVuZHMgdmlldy5XaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00oKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI7XG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfSB9KTtcbmxldCBmaWVsZFJhbmdlID0gdmlldy5EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zbmlwcGV0RmllbGRcIiB9KTtcbmNsYXNzIEFjdGl2ZVNuaXBwZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlcywgYWN0aXZlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5kZWNvID0gdmlldy5EZWNvcmF0aW9uLnNldChyYW5nZXMubWFwKHIgPT4gKHIuZnJvbSA9PSByLnRvID8gZmllbGRNYXJrZXIgOiBmaWVsZFJhbmdlKS5yYW5nZShyLmZyb20sIHIudG8pKSk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHIubWFwKGNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKCFtYXBwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldChyYW5nZXMsIHRoaXMuYWN0aXZlKTtcbiAgICB9XG4gICAgc2VsZWN0aW9uSW5zaWRlRmllbGQoc2VsKSB7XG4gICAgICAgIHJldHVybiBzZWwucmFuZ2VzLmV2ZXJ5KHJhbmdlID0+IHRoaXMucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IHRoaXMuYWN0aXZlICYmIHIuZnJvbSA8PSByYW5nZS5mcm9tICYmIHIudG8gPj0gcmFuZ2UudG8pKTtcbiAgICB9XG59XG5jb25zdCBzZXRBY3RpdmUgPSBzdGF0ZS5TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcCh2YWx1ZSwgY2hhbmdlcykgeyByZXR1cm4gdmFsdWUgJiYgdmFsdWUubWFwKGNoYW5nZXMpOyB9XG59KTtcbmNvbnN0IG1vdmVUb0ZpZWxkID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzbmlwcGV0U3RhdGUgPSBzdGF0ZS5TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMobW92ZVRvRmllbGQpICYmIHZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldCh2YWx1ZS5yYW5nZXMsIGVmZmVjdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLnNlbGVjdGlvbiAmJiAhdmFsdWUuc2VsZWN0aW9uSW5zaWRlRmllbGQodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiB2aWV3LkVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmLCB2YWwgPT4gdmFsID8gdmFsLmRlY28gOiB2aWV3LkRlY29yYXRpb24ubm9uZSlcbn0pO1xuZnVuY3Rpb24gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCBmaWVsZCkge1xuICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5maWx0ZXIociA9PiByLmZpZWxkID09IGZpZWxkKS5tYXAociA9PiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5mcm9tLCByLnRvKSkpO1xufVxuLyoqXG5Db252ZXJ0IGEgc25pcHBldCB0ZW1wbGF0ZSB0byBhIGZ1bmN0aW9uIHRoYXQgY2FuXG5bYXBwbHldKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb24uYXBwbHkpIGl0LiBTbmlwcGV0cyBhcmUgd3JpdHRlblxudXNpbmcgc3ludGF4IGxpa2UgdGhpczpcblxuICAgIFwiZm9yIChsZXQgJHtpbmRleH0gPSAwOyAke2luZGV4fSA8ICR7ZW5kfTsgJHtpbmRleH0rKykge1xcblxcdCR7fVxcbn1cIlxuXG5FYWNoIGAke31gIHBsYWNlaG9sZGVyICh5b3UgbWF5IGFsc28gdXNlIGAje31gKSBpbmRpY2F0ZXMgYSBmaWVsZFxudGhhdCB0aGUgdXNlciBjYW4gZmlsbCBpbi4gSXRzIG5hbWUsIGlmIGFueSwgd2lsbCBiZSB0aGUgZGVmYXVsdFxuY29udGVudCBmb3IgdGhlIGZpZWxkLlxuXG5XaGVuIHRoZSBzbmlwcGV0IGlzIGFjdGl2YXRlZCBieSBjYWxsaW5nIHRoZSByZXR1cm5lZCBmdW5jdGlvbixcbnRoZSBjb2RlIGlzIGluc2VydGVkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gTmV3bGluZXMgaW4gdGhlXG50ZW1wbGF0ZSBhcmUgaW5kZW50ZWQgYnkgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBzdGFydCBsaW5lLCBwbHVzXG5vbmUgW2luZGVudCB1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIHBlciB0YWIgY2hhcmFjdGVyIGFmdGVyXG50aGUgbmV3bGluZS5cblxuT24gYWN0aXZhdGlvbiwgKGFsbCBpbnN0YW5jZXMgb2YpIHRoZSBmaXJzdCBmaWVsZCBhcmUgc2VsZWN0ZWQuXG5UaGUgdXNlciBjYW4gbW92ZSBiZXR3ZWVuIGZpZWxkcyB3aXRoIFRhYiBhbmQgU2hpZnQtVGFiIGFzIGxvbmcgYXNcbnRoZSBmaWVsZHMgYXJlIGFjdGl2ZS4gTW92aW5nIHRvIHRoZSBsYXN0IGZpZWxkIG9yIG1vdmluZyB0aGVcbmN1cnNvciBvdXQgb2YgdGhlIGN1cnJlbnQgZmllbGQgZGVhY3RpdmF0ZXMgdGhlIGZpZWxkcy5cblxuVGhlIG9yZGVyIG9mIGZpZWxkcyBkZWZhdWx0cyB0byB0ZXh0dWFsIG9yZGVyLCBidXQgeW91IGNhbiBhZGRcbm51bWJlcnMgdG8gcGxhY2Vob2xkZXJzIChgJHsxfWAgb3IgYCR7MTpkZWZhdWx0VGV4dH1gKSB0byBwcm92aWRlXG5hIGN1c3RvbSBvcmRlci5cblxuVG8gaW5jbHVkZSBhIGxpdGVyYWwgYHtgIG9yIGB9YCBpbiB5b3VyIHRlbXBsYXRlLCBwdXQgYSBiYWNrc2xhc2hcbmluIGZyb250IG9mIGl0LiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBhbmQgdGhlIGJyYWNlIHdpbGwgbm90IGJlXG5pbnRlcnByZXRlZCBhcyBpbmRpY2F0aW5nIGEgcGxhY2Vob2xkZXIuXG4qL1xuZnVuY3Rpb24gc25pcHBldCh0ZW1wbGF0ZSkge1xuICAgIGxldCBzbmlwcGV0ID0gU25pcHBldC5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIChlZGl0b3IsIGNvbXBsZXRpb24sIGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGxldCB7IHRleHQsIHJhbmdlcyB9ID0gc25pcHBldC5pbnN0YW50aWF0ZShlZGl0b3Iuc3RhdGUsIGZyb20pO1xuICAgICAgICBsZXQgc3BlYyA9IHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogc3RhdGUuVGV4dC5vZih0ZXh0KSB9LFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICBhbm5vdGF0aW9uczogY29tcGxldGlvbiA/IFtwaWNrZWRDb21wbGV0aW9uLm9mKGNvbXBsZXRpb24pLCBzdGF0ZS5UcmFuc2FjdGlvbi51c2VyRXZlbnQub2YoXCJpbnB1dC5jb21wbGV0ZVwiKV0gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICBzcGVjLnNlbGVjdGlvbiA9IGZpZWxkU2VsZWN0aW9uKHJhbmdlcywgMCk7XG4gICAgICAgIGlmIChyYW5nZXMuc29tZShyID0+IHIuZmllbGQgPiAwKSkge1xuICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTbmlwcGV0KHJhbmdlcywgMCk7XG4gICAgICAgICAgICBsZXQgZWZmZWN0cyA9IHNwZWMuZWZmZWN0cyA9IFtzZXRBY3RpdmUub2YoYWN0aXZlKV07XG4gICAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHN0YXRlLlN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbc25pcHBldFN0YXRlLCBhZGRTbmlwcGV0S2V5bWFwLCBzbmlwcGV0UG9pbnRlckhhbmRsZXIsIGJhc2VUaGVtZV0pKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goZWRpdG9yLnN0YXRlLnVwZGF0ZShzcGVjKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVGaWVsZChkaXIpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCBkaXIgPCAwICYmIGFjdGl2ZS5hY3RpdmUgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG5leHQgPSBhY3RpdmUuYWN0aXZlICsgZGlyLCBsYXN0ID0gZGlyID4gMCAmJiAhYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSBuZXh0ICsgZGlyKTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogZmllbGRTZWxlY3Rpb24oYWN0aXZlLnJhbmdlcywgbmV4dCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YobGFzdCA/IG51bGwgOiBuZXcgQWN0aXZlU25pcHBldChhY3RpdmUucmFuZ2VzLCBuZXh0KSksXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkEgY29tbWFuZCB0aGF0IGNsZWFycyB0aGUgYWN0aXZlIHNuaXBwZXQsIGlmIGFueS5cbiovXG5jb25zdCBjbGVhclNuaXBwZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHM6IHNldEFjdGl2ZS5vZihudWxsKSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRvIHRoZSBuZXh0IHNuaXBwZXQgZmllbGQsIGlmIGF2YWlsYWJsZS5cbiovXG5jb25zdCBuZXh0U25pcHBldEZpZWxkID0gbW92ZUZpZWxkKDEpO1xuLyoqXG5Nb3ZlIHRvIHRoZSBwcmV2aW91cyBzbmlwcGV0IGZpZWxkLCBpZiBhdmFpbGFibGUuXG4qL1xuY29uc3QgcHJldlNuaXBwZXRGaWVsZCA9IG1vdmVGaWVsZCgtMSk7XG4vKipcbkNoZWNrIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBzbmlwcGV0IHdpdGggYSBuZXh0IGZpZWxkIGZvclxuYG5leHRTbmlwcGV0RmllbGRgIHRvIG1vdmUgdG8uXG4qL1xuZnVuY3Rpb24gaGFzTmV4dFNuaXBwZXRGaWVsZChzdGF0ZSkge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gISEoYWN0aXZlICYmIGFjdGl2ZS5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPT0gYWN0aXZlLmFjdGl2ZSArIDEpKTtcbn1cbi8qKlxuUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBzbmlwcGV0IGFuZCBhIHByZXZpb3VzIGZpZWxkXG5mb3IgYHByZXZTbmlwcGV0RmllbGRgIHRvIG1vdmUgdG8uXG4qL1xuZnVuY3Rpb24gaGFzUHJldlNuaXBwZXRGaWVsZChzdGF0ZSkge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gISEoYWN0aXZlICYmIGFjdGl2ZS5hY3RpdmUgPiAwKTtcbn1cbmNvbnN0IGRlZmF1bHRTbmlwcGV0S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIlRhYlwiLCBydW46IG5leHRTbmlwcGV0RmllbGQsIHNoaWZ0OiBwcmV2U25pcHBldEZpZWxkIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xlYXJTbmlwcGV0IH1cbl07XG4vKipcbkEgZmFjZXQgdGhhdCBjYW4gYmUgdXNlZCB0byBjb25maWd1cmUgdGhlIGtleSBiaW5kaW5ncyB1c2VkIGJ5XG5zbmlwcGV0cy4gVGhlIGRlZmF1bHQgYmluZHMgVGFiIHRvXG5bYG5leHRTbmlwcGV0RmllbGRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5uZXh0U25pcHBldEZpZWxkKSwgU2hpZnQtVGFiIHRvXG5bYHByZXZTbmlwcGV0RmllbGRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5wcmV2U25pcHBldEZpZWxkKSwgYW5kIEVzY2FwZVxudG8gW2BjbGVhclNuaXBwZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbGVhclNuaXBwZXQpLlxuKi9cbmNvbnN0IHNuaXBwZXRLZXltYXAgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobWFwcykgeyByZXR1cm4gbWFwcy5sZW5ndGggPyBtYXBzWzBdIDogZGVmYXVsdFNuaXBwZXRLZXltYXA7IH1cbn0pO1xuY29uc3QgYWRkU25pcHBldEtleW1hcCA9IHN0YXRlLlByZWMuaGlnaGVzdCh2aWV3LmtleW1hcC5jb21wdXRlKFtzbmlwcGV0S2V5bWFwXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoc25pcHBldEtleW1hcCkpKTtcbi8qKlxuQ3JlYXRlIGEgY29tcGxldGlvbiBmcm9tIGEgc25pcHBldC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGVcbnByb3BlcnRpZXMgZnJvbSBgY29tcGxldGlvbmAsIHBsdXMgYW4gYGFwcGx5YCBmdW5jdGlvbiB0aGF0XG5hcHBsaWVzIHRoZSBzbmlwcGV0LlxuKi9cbmZ1bmN0aW9uIHNuaXBwZXRDb21wbGV0aW9uKHRlbXBsYXRlLCBjb21wbGV0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tcGxldGlvbiksIHsgYXBwbHk6IHNuaXBwZXQodGVtcGxhdGUpIH0pO1xufVxuY29uc3Qgc25pcHBldFBvaW50ZXJIYW5kbGVyID0gdmlldy5FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIG1vdXNlZG93bihldmVudCwgdmlldykge1xuICAgICAgICBsZXQgYWN0aXZlID0gdmlldy5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSwgcG9zO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCAocG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBtYXRjaCA9IGFjdGl2ZS5yYW5nZXMuZmluZChyID0+IHIuZnJvbSA8PSBwb3MgJiYgci50byA+PSBwb3MpO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmZpZWxkID09IGFjdGl2ZS5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YoYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA+IG1hdGNoLmZpZWxkKVxuICAgICAgICAgICAgICAgID8gbmV3IEFjdGl2ZVNuaXBwZXQoYWN0aXZlLnJhbmdlcywgbWF0Y2guZmllbGQpIDogbnVsbCksXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHdvcmRSRSh3b3JkQ2hhcnMpIHtcbiAgICBsZXQgZXNjYXBlZCA9IHdvcmRDaGFycy5yZXBsYWNlKC9bXFxdXFwtXFxcXF0vZywgXCJcXFxcJCZcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fJHtlc2NhcGVkfV0rYCwgXCJ1Z1wiKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBbXFx3JHtlc2NhcGVkfV1gLCBcImdcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwUkUocmUsIGYpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChmKHJlLnNvdXJjZSksIHJlLnVuaWNvZGUgPyBcInVcIiA6IFwiXCIpO1xufVxuY29uc3Qgd29yZENhY2hlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiB3b3JkQ2FjaGUod29yZENoYXJzKSB7XG4gICAgcmV0dXJuIHdvcmRDYWNoZXNbd29yZENoYXJzXSB8fCAod29yZENhY2hlc1t3b3JkQ2hhcnNdID0gbmV3IFdlYWtNYXApO1xufVxuZnVuY3Rpb24gc3RvcmVXb3Jkcyhkb2MsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCkge1xuICAgIGZvciAobGV0IGxpbmVzID0gZG9jLml0ZXJMaW5lcygpLCBwb3MgPSAwOyAhbGluZXMubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSBsaW5lcywgbTtcbiAgICAgICAgd29yZFJFLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChtID0gd29yZFJFLmV4ZWModmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXNlZW5bbVswXV0gJiYgcG9zICsgbS5pbmRleCAhPSBpZ25vcmVBdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIGxhYmVsOiBtWzBdIH0pO1xuICAgICAgICAgICAgICAgIHNlZW5bbVswXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID49IDIwMDAgLyogQy5NYXhMaXN0ICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IHZhbHVlLmxlbmd0aCArIDE7XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdFdvcmRzKGRvYywgY2FjaGUsIHdvcmRSRSwgdG8sIGlnbm9yZUF0KSB7XG4gICAgbGV0IGJpZyA9IGRvYy5sZW5ndGggPj0gMTAwMCAvKiBDLk1pbkNhY2hlTGVuICovO1xuICAgIGxldCBjYWNoZWQgPSBiaWcgJiYgY2FjaGUuZ2V0KGRvYyk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChkb2MuY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGRvYy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoLmxlbmd0aCA+PSAxMDAwIC8qIEMuTWluQ2FjaGVMZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNvbGxlY3RXb3JkcyhjaCwgY2FjaGUsIHdvcmRSRSwgdG8gLSBwb3MsIGlnbm9yZUF0IC0gcG9zKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW5bYy5sYWJlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5bYy5sYWJlbF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yZVdvcmRzKGNoLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQgLSBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGNoLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0b3JlV29yZHMoZG9jLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQpO1xuICAgIH1cbiAgICBpZiAoYmlnICYmIHJlc3VsdC5sZW5ndGggPCAyMDAwIC8qIEMuTWF4TGlzdCAqLylcbiAgICAgICAgY2FjaGUuc2V0KGRvYywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5BIGNvbXBsZXRpb24gc291cmNlIHRoYXQgd2lsbCBzY2FuIHRoZSBkb2N1bWVudCBmb3Igd29yZHMgKHVzaW5nIGFcbltjaGFyYWN0ZXIgY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSksIGFuZFxucmV0dXJuIHRob3NlIGFzIGNvbXBsZXRpb25zLlxuKi9cbmNvbnN0IGNvbXBsZXRlQW55V29yZCA9IGNvbnRleHQgPT4ge1xuICAgIGxldCB3b3JkQ2hhcnMgPSBjb250ZXh0LnN0YXRlLmxhbmd1YWdlRGF0YUF0KFwid29yZENoYXJzXCIsIGNvbnRleHQucG9zKS5qb2luKFwiXCIpO1xuICAgIGxldCByZSA9IHdvcmRSRSh3b3JkQ2hhcnMpO1xuICAgIGxldCB0b2tlbiA9IGNvbnRleHQubWF0Y2hCZWZvcmUobWFwUkUocmUsIHMgPT4gcyArIFwiJFwiKSk7XG4gICAgaWYgKCF0b2tlbiAmJiAhY29udGV4dC5leHBsaWNpdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZyb20gPSB0b2tlbiA/IHRva2VuLmZyb20gOiBjb250ZXh0LnBvcztcbiAgICBsZXQgb3B0aW9ucyA9IGNvbGxlY3RXb3Jkcyhjb250ZXh0LnN0YXRlLmRvYywgd29yZENhY2hlKHdvcmRDaGFycyksIHJlLCA1MDAwMCAvKiBDLlJhbmdlICovLCBmcm9tKTtcbiAgICByZXR1cm4geyBmcm9tLCBvcHRpb25zLCB2YWxpZEZvcjogbWFwUkUocmUsIHMgPT4gXCJeXCIgKyBzKSB9O1xufTtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgYnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJ10sXG4gICAgYmVmb3JlOiBcIildfTo7PlwiLFxuICAgIHN0cmluZ1ByZWZpeGVzOiBbXVxufTtcbmNvbnN0IGNsb3NlQnJhY2tldEVmZmVjdCA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHZhbHVlLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSBtYXBwaW5nLm1hcFBvcyh2YWx1ZSwgLTEsIHN0YXRlLk1hcE1vZGUuVHJhY2tBZnRlcik7XG4gICAgICAgIHJldHVybiBtYXBwZWQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG1hcHBlZDtcbiAgICB9XG59KTtcbmNvbnN0IGNsb3NlZEJyYWNrZXQgPSBuZXcgY2xhc3MgZXh0ZW5kcyBzdGF0ZS5SYW5nZVZhbHVlIHtcbn07XG5jbG9zZWRCcmFja2V0LnN0YXJ0U2lkZSA9IDE7XG5jbG9zZWRCcmFja2V0LmVuZFNpZGUgPSAtMTtcbmNvbnN0IGJyYWNrZXRTdGF0ZSA9IHN0YXRlLlN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBzdGF0ZS5SYW5nZVNldC5lbXB0eTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBpZiAodHIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRyLnN0YXRlLmRvYy5saW5lQXQodHIuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZSh7IGZpbHRlcjogZnJvbSA9PiBmcm9tID49IGxpbmUuZnJvbSAmJiBmcm9tIDw9IGxpbmUudG8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlQnJhY2tldEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGUoeyBhZGQ6IFtjbG9zZWRCcmFja2V0LnJhbmdlKGVmZmVjdC52YWx1ZSwgZWZmZWN0LnZhbHVlICsgMSldIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufSk7XG4vKipcbkV4dGVuc2lvbiB0byBlbmFibGUgYnJhY2tldC1jbG9zaW5nIGJlaGF2aW9yLiBXaGVuIGEgY2xvc2VhYmxlXG5icmFja2V0IGlzIHR5cGVkLCBpdHMgY2xvc2luZyBicmFja2V0IGlzIGltbWVkaWF0ZWx5IGluc2VydGVkXG5hZnRlciB0aGUgY3Vyc29yLiBXaGVuIGNsb3NpbmcgYSBicmFja2V0IGRpcmVjdGx5IGluIGZyb250IG9mIGFcbmNsb3NpbmcgYnJhY2tldCBpbnNlcnRlZCBieSB0aGUgZXh0ZW5zaW9uLCB0aGUgY3Vyc29yIG1vdmVzIG92ZXJcbnRoYXQgYnJhY2tldC5cbiovXG5mdW5jdGlvbiBjbG9zZUJyYWNrZXRzKCkge1xuICAgIHJldHVybiBbaW5wdXRIYW5kbGVyLCBicmFja2V0U3RhdGVdO1xufVxuY29uc3QgZGVmaW5lZENsb3NpbmcgPSBcIigpW117fTw+XCI7XG5mdW5jdGlvbiBjbG9zaW5nKGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWZpbmVkQ2xvc2luZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgaWYgKGRlZmluZWRDbG9zaW5nLmNoYXJDb2RlQXQoaSkgPT0gY2gpXG4gICAgICAgICAgICByZXR1cm4gZGVmaW5lZENsb3NpbmcuY2hhckF0KGkgKyAxKTtcbiAgICByZXR1cm4gc3RhdGUuZnJvbUNvZGVQb2ludChjaCA8IDEyOCA/IGNoIDogY2ggKyAxKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZyhzdGF0ZSwgcG9zKSB7XG4gICAgcmV0dXJuIHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiY2xvc2VCcmFja2V0c1wiLCBwb3MpWzBdIHx8IGRlZmF1bHRzO1xufVxuY29uc3QgYW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJvYmplY3RcIiAmJiAvQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IGlucHV0SGFuZGxlciA9IHZpZXcuRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIub2YoKHZpZXcsIGZyb20sIHRvLCBpbnNlcnQpID0+IHtcbiAgICBpZiAoKGFuZHJvaWQgPyB2aWV3LmNvbXBvc2luZyA6IHZpZXcuY29tcG9zaXRpb25TdGFydGVkKSB8fCB2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGluc2VydC5sZW5ndGggPiAyIHx8IGluc2VydC5sZW5ndGggPT0gMiAmJiBzdGF0ZS5jb2RlUG9pbnRTaXplKHN0YXRlLmNvZGVQb2ludEF0KGluc2VydCwgMCkpID09IDEgfHxcbiAgICAgICAgZnJvbSAhPSBzZWwuZnJvbSB8fCB0byAhPSBzZWwudG8pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHIgPSBpbnNlcnRCcmFja2V0KHZpZXcuc3RhdGUsIGluc2VydCk7XG4gICAgaWYgKCF0cilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbkNvbW1hbmQgdGhhdCBpbXBsZW1lbnRzIGRlbGV0aW5nIGEgcGFpciBvZiBtYXRjaGluZyBicmFja2V0cyB3aGVuXG50aGUgY3Vyc29yIGlzIGJldHdlZW4gdGhlbS5cbiovXG5jb25zdCBkZWxldGVCcmFja2V0UGFpciA9ICh7IHN0YXRlOiBzdGF0ZSQxLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlJDEucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY29uZiA9IGNvbmZpZyhzdGF0ZSQxLCBzdGF0ZSQxLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlJDEuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHByZXZDaGFyKHN0YXRlJDEuZG9jLCByYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PSBiZWZvcmUgJiYgbmV4dENoYXIoc3RhdGUkMS5kb2MsIHJhbmdlLmhlYWQpID09IGNsb3Npbmcoc3RhdGUuY29kZVBvaW50QXQodG9rZW4sIDApKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoLCB0bzogcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCAtIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKCFkb250KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZSQxLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmJhY2t3YXJkXCIgfSkpO1xuICAgIHJldHVybiAhZG9udDtcbn07XG4vKipcbkNsb3NlLWJyYWNrZXRzIHJlbGF0ZWQga2V5IGJpbmRpbmdzLiBCaW5kcyBCYWNrc3BhY2UgdG9cbltgZGVsZXRlQnJhY2tldFBhaXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5kZWxldGVCcmFja2V0UGFpcikuXG4qL1xuY29uc3QgY2xvc2VCcmFja2V0c0tleW1hcCA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVCcmFja2V0UGFpciB9XG5dO1xuLyoqXG5JbXBsZW1lbnRzIHRoZSBleHRlbnNpb24ncyBiZWhhdmlvciBvbiB0ZXh0IGluc2VydGlvbi4gSWYgdGhlXG5naXZlbiBzdHJpbmcgY291bnRzIGFzIGEgYnJhY2tldCBpbiB0aGUgbGFuZ3VhZ2UgYXJvdW5kIHRoZVxuc2VsZWN0aW9uLCBhbmQgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBpdCByZXF1aXJlcyBjdXN0b21cbmJlaGF2aW9yIChpbnNlcnRpbmcgYSBjbG9zaW5nIHZlcnNpb24gb3Igc2tpcHBpbmcgcGFzdCBhXG5wcmV2aW91c2x5LWNsb3NlZCBicmFja2V0KSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudGluZyB0aGF0IGN1c3RvbSBiZWhhdmlvci4gKFlvdSBvbmx5IG5lZWQgdGhpcyBpZiB5b3Ugd2FudFxudG8gcHJvZ3JhbW1hdGljYWxseSBpbnNlcnQgYnJhY2tldHPigJR0aGVcbltgY2xvc2VCcmFja2V0c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQnJhY2tldHMpIGV4dGVuc2lvbiB3aWxsXG50YWtlIGNhcmUgb2YgcnVubmluZyB0aGlzIGZvciB1c2VyIGlucHV0LilcbiovXG5mdW5jdGlvbiBpbnNlcnRCcmFja2V0KHN0YXRlJDEsIGJyYWNrZXQpIHtcbiAgICBsZXQgY29uZiA9IGNvbmZpZyhzdGF0ZSQxLCBzdGF0ZSQxLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGZvciAobGV0IHRvayBvZiB0b2tlbnMpIHtcbiAgICAgICAgbGV0IGNsb3NlZCA9IGNsb3Npbmcoc3RhdGUuY29kZVBvaW50QXQodG9rLCAwKSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IHRvaylcbiAgICAgICAgICAgIHJldHVybiBjbG9zZWQgPT0gdG9rID8gaGFuZGxlU2FtZShzdGF0ZSQxLCB0b2ssIHRva2Vucy5pbmRleE9mKHRvayArIHRvayArIHRvaykgPiAtMSwgY29uZilcbiAgICAgICAgICAgICAgICA6IGhhbmRsZU9wZW4oc3RhdGUkMSwgdG9rLCBjbG9zZWQsIGNvbmYuYmVmb3JlIHx8IGRlZmF1bHRzLmJlZm9yZSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IGNsb3NlZCAmJiBjbG9zZWRCcmFja2V0QXQoc3RhdGUkMSwgc3RhdGUkMS5zZWxlY3Rpb24ubWFpbi5mcm9tKSlcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDbG9zZShzdGF0ZSQxLCB0b2ssIGNsb3NlZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBzdGF0ZS5maWVsZChicmFja2V0U3RhdGUpLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgZnJvbSA9PiB7XG4gICAgICAgIGlmIChmcm9tID09IHBvcylcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBuZXh0Q2hhcihkb2MsIHBvcykge1xuICAgIGxldCBuZXh0ID0gZG9jLnNsaWNlU3RyaW5nKHBvcywgcG9zICsgMik7XG4gICAgcmV0dXJuIG5leHQuc2xpY2UoMCwgc3RhdGUuY29kZVBvaW50U2l6ZShzdGF0ZS5jb2RlUG9pbnRBdChuZXh0LCAwKSkpO1xufVxuZnVuY3Rpb24gcHJldkNoYXIoZG9jLCBwb3MpIHtcbiAgICBsZXQgcHJldiA9IGRvYy5zbGljZVN0cmluZyhwb3MgLSAyLCBwb3MpO1xuICAgIHJldHVybiBzdGF0ZS5jb2RlUG9pbnRTaXplKHN0YXRlLmNvZGVQb2ludEF0KHByZXYsIDApKSA9PSBwcmV2Lmxlbmd0aCA/IHByZXYgOiBwcmV2LnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gaGFuZGxlT3BlbihzdGF0ZSQxLCBvcGVuLCBjbG9zZSwgY2xvc2VCZWZvcmUpIHtcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZSQxLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW3sgaW5zZXJ0OiBvcGVuLCBmcm9tOiByYW5nZS5mcm9tIH0sIHsgaW5zZXJ0OiBjbG9zZSwgZnJvbTogcmFuZ2UudG8gfV0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHJhbmdlLnRvICsgb3Blbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yICsgb3Blbi5sZW5ndGgsIHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCkgfTtcbiAgICAgICAgbGV0IG5leHQgPSBuZXh0Q2hhcihzdGF0ZSQxLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgIGlmICghbmV4dCB8fCAvXFxzLy50ZXN0KG5leHQpIHx8IGNsb3NlQmVmb3JlLmluZGV4T2YobmV4dCkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiBvcGVuICsgY2xvc2UsIGZyb206IHJhbmdlLmhlYWQgfSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZSQxLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVDbG9zZShzdGF0ZSQxLCBfb3BlbiwgY2xvc2UpIHtcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZSQxLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgbmV4dENoYXIoc3RhdGUkMS5kb2MsIHJhbmdlLmhlYWQpID09IGNsb3NlKVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkLCB0bzogcmFuZ2UuaGVhZCArIGNsb3NlLmxlbmd0aCwgaW5zZXJ0OiBjbG9zZSB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBjbG9zZS5sZW5ndGgpIH07XG4gICAgICAgIHJldHVybiBkb250ID0geyByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlJDEudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC50eXBlXCJcbiAgICB9KTtcbn1cbi8vIEhhbmRsZXMgY2FzZXMgd2hlcmUgdGhlIG9wZW4gYW5kIGNsb3NlIHRva2VuIGFyZSB0aGUgc2FtZSwgYW5kXG4vLyBwb3NzaWJseSB0cmlwbGUgcXVvdGVzIChhcyBpbiBgXCJcIlwiYWJjXCJcIlwiYC1zdHlsZSBxdW90aW5nKS5cbmZ1bmN0aW9uIGhhbmRsZVNhbWUoc3RhdGUkMSwgdG9rZW4sIGFsbG93VHJpcGxlLCBjb25maWcpIHtcbiAgICBsZXQgc3RyaW5nUHJlZml4ZXMgPSBjb25maWcuc3RyaW5nUHJlZml4ZXMgfHwgZGVmYXVsdHMuc3RyaW5nUHJlZml4ZXM7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUkMS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogdG9rZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS50byB9XSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UudG8gKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yICsgdG9rZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgbmV4dCA9IG5leHRDaGFyKHN0YXRlJDEuZG9jLCBwb3MpLCBzdGFydDtcbiAgICAgICAgaWYgKG5leHQgPT0gdG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChub2RlU3RhcnQoc3RhdGUkMSwgcG9zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlZEJyYWNrZXRBdChzdGF0ZSQxLCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzVHJpcGxlID0gYWxsb3dUcmlwbGUgJiYgc3RhdGUkMS5zbGljZURvYyhwb3MsIHBvcyArIHRva2VuLmxlbmd0aCAqIDMpID09IHRva2VuICsgdG9rZW4gKyB0b2tlbjtcbiAgICAgICAgICAgICAgICBsZXQgY29udGVudCA9IGlzVHJpcGxlID8gdG9rZW4gKyB0b2tlbiArIHRva2VuIDogdG9rZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiBwb3MsIHRvOiBwb3MgKyBjb250ZW50Lmxlbmd0aCwgaW5zZXJ0OiBjb250ZW50IH0sXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIGNvbnRlbnQubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG93VHJpcGxlICYmIHN0YXRlJDEuc2xpY2VEb2MocG9zIC0gMiAqIHRva2VuLmxlbmd0aCwgcG9zKSA9PSB0b2tlbiArIHRva2VuICYmXG4gICAgICAgICAgICAoc3RhcnQgPSBjYW5TdGFydFN0cmluZ0F0KHN0YXRlJDEsIHBvcyAtIDIgKiB0b2tlbi5sZW5ndGgsIHN0cmluZ1ByZWZpeGVzKSkgPiAtMSAmJlxuICAgICAgICAgICAgbm9kZVN0YXJ0KHN0YXRlJDEsIHN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4gKyB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUkMS5jaGFyQ2F0ZWdvcml6ZXIocG9zKShuZXh0KSAhPSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUkMSwgcG9zLCBzdHJpbmdQcmVmaXhlcykgPiAtMSAmJiAhcHJvYmFibHlJblN0cmluZyhzdGF0ZSQxLCBwb3MsIHRva2VuLCBzdHJpbmdQcmVmaXhlcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZSQxLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBub2RlU3RhcnQoc3RhdGUsIHBvcykge1xuICAgIGxldCB0cmVlID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyArIDEpO1xuICAgIHJldHVybiB0cmVlLnBhcmVudCAmJiB0cmVlLmZyb20gPT0gcG9zO1xufVxuZnVuY3Rpb24gcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCBxdW90ZVRva2VuLCBwcmVmaXhlcykge1xuICAgIGxldCBub2RlID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcywgLTEpO1xuICAgIGxldCBtYXhQcmVmaXggPSBwcmVmaXhlcy5yZWR1Y2UoKG0sIHApID0+IE1hdGgubWF4KG0sIHAubGVuZ3RoKSwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhdGUuc2xpY2VEb2Mobm9kZS5mcm9tLCBNYXRoLm1pbihub2RlLnRvLCBub2RlLmZyb20gKyBxdW90ZVRva2VuLmxlbmd0aCArIG1heFByZWZpeCkpO1xuICAgICAgICBsZXQgcXVvdGVQb3MgPSBzdGFydC5pbmRleE9mKHF1b3RlVG9rZW4pO1xuICAgICAgICBpZiAoIXF1b3RlUG9zIHx8IHF1b3RlUG9zID4gLTEgJiYgcHJlZml4ZXMuaW5kZXhPZihzdGFydC5zbGljZSgwLCBxdW90ZVBvcykpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdCAmJiBmaXJzdC5mcm9tID09IG5vZGUuZnJvbSAmJiBmaXJzdC50byAtIGZpcnN0LmZyb20gPiBxdW90ZVRva2VuLmxlbmd0aCArIHF1b3RlUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKGZpcnN0LnRvIC0gcXVvdGVUb2tlbi5sZW5ndGgsIGZpcnN0LnRvKSA9PSBxdW90ZVRva2VuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmaXJzdC5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUudG8gPT0gcG9zICYmIG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYW5TdGFydFN0cmluZ0F0KHN0YXRlJDEsIHBvcywgcHJlZml4ZXMpIHtcbiAgICBsZXQgY2hhckNhdCA9IHN0YXRlJDEuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgaWYgKGNoYXJDYXQoc3RhdGUkMS5zbGljZURvYyhwb3MgLSAxLCBwb3MpKSAhPSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBmb3IgKGxldCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXRlJDEuc2xpY2VEb2Moc3RhcnQsIHBvcykgPT0gcHJlZml4ICYmIGNoYXJDYXQoc3RhdGUkMS5zbGljZURvYyhzdGFydCAtIDEsIHN0YXJ0KSkgIT0gc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYXV0b2NvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gYXV0b2NvbXBsZXRpb24oY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBjb21taXRDaGFyYWN0ZXJzLFxuICAgICAgICBjb21wbGV0aW9uU3RhdGUsXG4gICAgICAgIGNvbXBsZXRpb25Db25maWcub2YoY29uZmlnKSxcbiAgICAgICAgY29tcGxldGlvblBsdWdpbixcbiAgICAgICAgY29tcGxldGlvbktleW1hcEV4dCxcbiAgICAgICAgYmFzZVRoZW1lXG4gICAgXTtcbn1cbi8qKlxuQmFzaWMga2V5YmluZGluZ3MgZm9yIGF1dG9jb21wbGV0aW9uLlxuXG4gLSBDdHJsLVNwYWNlIChhbmQgQWx0LVxcYCBvbiBtYWNPUyk6IFtgc3RhcnRDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuc3RhcnRDb21wbGV0aW9uKVxuIC0gRXNjYXBlOiBbYGNsb3NlQ29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQ29tcGxldGlvbilcbiAtIEFycm93RG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSlgXG4gLSBBcnJvd1VwOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYChmYWxzZSlgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gUGFnZURvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUsIFwicGFnZVwiKWBcbiAtIEVudGVyOiBbYGFjY2VwdENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hY2NlcHRDb21wbGV0aW9uKVxuKi9cbmNvbnN0IGNvbXBsZXRpb25LZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TcGFjZVwiLCBydW46IHN0YXJ0Q29tcGxldGlvbiB9LFxuICAgIHsgbWFjOiBcIkFsdC1gXCIsIHJ1bjogc3RhcnRDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24odHJ1ZSkgfSxcbiAgICB7IGtleTogXCJBcnJvd1VwXCIsIHJ1bjogbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UpIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmYWxzZSwgXCJwYWdlXCIpIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBhY2NlcHRDb21wbGV0aW9uIH1cbl07XG5jb25zdCBjb21wbGV0aW9uS2V5bWFwRXh0ID0gc3RhdGUuUHJlYy5oaWdoZXN0KHZpZXcua2V5bWFwLmNvbXB1dGVOKFtjb21wbGV0aW9uQ29uZmlnXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuZGVmYXVsdEtleW1hcCA/IFtjb21wbGV0aW9uS2V5bWFwXSA6IFtdKSk7XG4vKipcbkdldCB0aGUgY3VycmVudCBjb21wbGV0aW9uIHN0YXR1cy4gV2hlbiBjb21wbGV0aW9ucyBhcmUgYXZhaWxhYmxlLFxudGhpcyB3aWxsIHJldHVybiBgXCJhY3RpdmVcImAuIFdoZW4gY29tcGxldGlvbnMgYXJlIHBlbmRpbmcgKGluIHRoZVxucHJvY2VzcyBvZiBiZWluZyBxdWVyaWVkKSwgdGhpcyByZXR1cm5zIGBcInBlbmRpbmdcImAuIE90aGVyd2lzZSwgaXRcbnJldHVybnMgYG51bGxgLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRpb25TdGF0dXMoc3RhdGUpIHtcbiAgICBsZXQgY1N0YXRlID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGNTdGF0ZSAmJiBjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLmlzUGVuZGluZykgPyBcInBlbmRpbmdcIlxuICAgICAgICA6IGNTdGF0ZSAmJiBjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pID8gXCJhY3RpdmVcIiA6IG51bGw7XG59XG5jb25zdCBjb21wbGV0aW9uQXJyYXlDYWNoZSA9IG5ldyBXZWFrTWFwO1xuLyoqXG5SZXR1cm5zIHRoZSBhdmFpbGFibGUgY29tcGxldGlvbnMgYXMgYW4gYXJyYXkuXG4qL1xuZnVuY3Rpb24gY3VycmVudENvbXBsZXRpb25zKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIGlmICghb3BlbiB8fCBvcGVuLmRpc2FibGVkKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGNvbXBsZXRpb25zID0gY29tcGxldGlvbkFycmF5Q2FjaGUuZ2V0KG9wZW4ub3B0aW9ucyk7XG4gICAgaWYgKCFjb21wbGV0aW9ucylcbiAgICAgICAgY29tcGxldGlvbkFycmF5Q2FjaGUuc2V0KG9wZW4ub3B0aW9ucywgY29tcGxldGlvbnMgPSBvcGVuLm9wdGlvbnMubWFwKG8gPT4gby5jb21wbGV0aW9uKSk7XG4gICAgcmV0dXJuIGNvbXBsZXRpb25zO1xufVxuLyoqXG5SZXR1cm4gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uLCBpZiBhbnkuXG4qL1xuZnVuY3Rpb24gc2VsZWN0ZWRDb21wbGV0aW9uKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4ub3B0aW9uc1tvcGVuLnNlbGVjdGVkXS5jb21wbGV0aW9uIDogbnVsbDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBvc2l0aW9uIGluIHRoZSBhY3RpdmUgY29tcGxldGlvblxubGlzdCwgb3IgbnVsbCBpZiBubyBjb21wbGV0aW9ucyBhcmUgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIHNlbGVjdGVkQ29tcGxldGlvbkluZGV4KHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4uc2VsZWN0ZWQgOiBudWxsO1xufVxuLyoqXG5DcmVhdGUgYW4gZWZmZWN0IHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdHJhbnNhY3Rpb24gdG8gY2hhbmdlXG50aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWRDb21wbGV0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHNldFNlbGVjdGVkRWZmZWN0Lm9mKGluZGV4KTtcbn1cblxuZXhwb3J0cy5Db21wbGV0aW9uQ29udGV4dCA9IENvbXBsZXRpb25Db250ZXh0O1xuZXhwb3J0cy5hY2NlcHRDb21wbGV0aW9uID0gYWNjZXB0Q29tcGxldGlvbjtcbmV4cG9ydHMuYXV0b2NvbXBsZXRpb24gPSBhdXRvY29tcGxldGlvbjtcbmV4cG9ydHMuY2xlYXJTbmlwcGV0ID0gY2xlYXJTbmlwcGV0O1xuZXhwb3J0cy5jbG9zZUJyYWNrZXRzID0gY2xvc2VCcmFja2V0cztcbmV4cG9ydHMuY2xvc2VCcmFja2V0c0tleW1hcCA9IGNsb3NlQnJhY2tldHNLZXltYXA7XG5leHBvcnRzLmNsb3NlQ29tcGxldGlvbiA9IGNsb3NlQ29tcGxldGlvbjtcbmV4cG9ydHMuY29tcGxldGVBbnlXb3JkID0gY29tcGxldGVBbnlXb3JkO1xuZXhwb3J0cy5jb21wbGV0ZUZyb21MaXN0ID0gY29tcGxldGVGcm9tTGlzdDtcbmV4cG9ydHMuY29tcGxldGlvbktleW1hcCA9IGNvbXBsZXRpb25LZXltYXA7XG5leHBvcnRzLmNvbXBsZXRpb25TdGF0dXMgPSBjb21wbGV0aW9uU3RhdHVzO1xuZXhwb3J0cy5jdXJyZW50Q29tcGxldGlvbnMgPSBjdXJyZW50Q29tcGxldGlvbnM7XG5leHBvcnRzLmRlbGV0ZUJyYWNrZXRQYWlyID0gZGVsZXRlQnJhY2tldFBhaXI7XG5leHBvcnRzLmhhc05leHRTbmlwcGV0RmllbGQgPSBoYXNOZXh0U25pcHBldEZpZWxkO1xuZXhwb3J0cy5oYXNQcmV2U25pcHBldEZpZWxkID0gaGFzUHJldlNuaXBwZXRGaWVsZDtcbmV4cG9ydHMuaWZJbiA9IGlmSW47XG5leHBvcnRzLmlmTm90SW4gPSBpZk5vdEluO1xuZXhwb3J0cy5pbnNlcnRCcmFja2V0ID0gaW5zZXJ0QnJhY2tldDtcbmV4cG9ydHMuaW5zZXJ0Q29tcGxldGlvblRleHQgPSBpbnNlcnRDb21wbGV0aW9uVGV4dDtcbmV4cG9ydHMubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24gPSBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbjtcbmV4cG9ydHMubmV4dFNuaXBwZXRGaWVsZCA9IG5leHRTbmlwcGV0RmllbGQ7XG5leHBvcnRzLnBpY2tlZENvbXBsZXRpb24gPSBwaWNrZWRDb21wbGV0aW9uO1xuZXhwb3J0cy5wcmV2U25pcHBldEZpZWxkID0gcHJldlNuaXBwZXRGaWVsZDtcbmV4cG9ydHMuc2VsZWN0ZWRDb21wbGV0aW9uID0gc2VsZWN0ZWRDb21wbGV0aW9uO1xuZXhwb3J0cy5zZWxlY3RlZENvbXBsZXRpb25JbmRleCA9IHNlbGVjdGVkQ29tcGxldGlvbkluZGV4O1xuZXhwb3J0cy5zZXRTZWxlY3RlZENvbXBsZXRpb24gPSBzZXRTZWxlY3RlZENvbXBsZXRpb247XG5leHBvcnRzLnNuaXBwZXQgPSBzbmlwcGV0O1xuZXhwb3J0cy5zbmlwcGV0Q29tcGxldGlvbiA9IHNuaXBwZXRDb21wbGV0aW9uO1xuZXhwb3J0cy5zbmlwcGV0S2V5bWFwID0gc25pcHBldEtleW1hcDtcbmV4cG9ydHMuc3RhcnRDb21wbGV0aW9uID0gc3RhcnRDb21wbGV0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RhdGUgPSByZXF1aXJlKCdAY29kZW1pcnJvci9zdGF0ZScpO1xudmFyIHZpZXcgPSByZXF1aXJlKCdAY29kZW1pcnJvci92aWV3Jyk7XG52YXIgbGFuZ3VhZ2UgPSByZXF1aXJlKCdAY29kZW1pcnJvci9sYW5ndWFnZScpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJ0BsZXplci9jb21tb24nKTtcblxuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgdXNlIGxpbmUgY29tbWVudHNcbmlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGxpbmcgYmFjayB0byBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCB0b2dnbGVDb21tZW50ID0gdGFyZ2V0ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChzdGF0ZS5zZWxlY3Rpb24ubWFpbi5mcm9tKSwgY29uZmlnID0gZ2V0Q29uZmlnKHRhcmdldC5zdGF0ZSwgbGluZS5mcm9tKTtcbiAgICByZXR1cm4gY29uZmlnLmxpbmUgPyB0b2dnbGVMaW5lQ29tbWVudCh0YXJnZXQpIDogY29uZmlnLmJsb2NrID8gdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lKHRhcmdldCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBjb21tYW5kKGYsIG9wdGlvbikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGYob3B0aW9uLCBzdGF0ZSk7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh0cikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cblRoZSBsaW5lIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlTGluZUNvbW1lbnQgPSBjb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbi8qKlxuQ29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cbiovXG5jb25zdCBsaW5lQ29tbWVudCA9IGNvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovKTtcbi8qKlxuVW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGxpbmVVbmNvbW1lbnQgPSBjb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovKTtcbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuVGhlIGJsb2NrIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50ID0gY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuLyoqXG5Db21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCBibG9ja0NvbW1lbnQgPSBjb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8pO1xuLyoqXG5VbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGJsb2NrVW5jb21tZW50ID0gY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8pO1xuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgbGluZXMgYXJvdW5kIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZ1xuYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lID0gY29tbWFuZCgobywgcykgPT4gY2hhbmdlQmxvY2tDb21tZW50KG8sIHMsIHNlbGVjdGVkTGluZVJhbmdlcyhzKSksIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuZnVuY3Rpb24gZ2V0Q29uZmlnKHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgZGF0YSA9IHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiY29tbWVudFRva2Vuc1wiLCBwb3MpO1xuICAgIHJldHVybiBkYXRhLmxlbmd0aCA/IGRhdGFbMF0gOiB7fTtcbn1cbmNvbnN0IFNlYXJjaE1hcmdpbiA9IDUwO1xuLyoqXG5EZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiByYW5nZSBpcyBibG9jay1jb21tZW50ZWQgaW4gdGhlIGdpdmVuXG5zdGF0ZS5cbiovXG5mdW5jdGlvbiBmaW5kQmxvY2tDb21tZW50KHN0YXRlLCB7IG9wZW4sIGNsb3NlIH0sIGZyb20sIHRvKSB7XG4gICAgbGV0IHRleHRCZWZvcmUgPSBzdGF0ZS5zbGljZURvYyhmcm9tIC0gU2VhcmNoTWFyZ2luLCBmcm9tKTtcbiAgICBsZXQgdGV4dEFmdGVyID0gc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgU2VhcmNoTWFyZ2luKTtcbiAgICBsZXQgc3BhY2VCZWZvcmUgPSAvXFxzKiQvLmV4ZWModGV4dEJlZm9yZSlbMF0ubGVuZ3RoLCBzcGFjZUFmdGVyID0gL15cXHMqLy5leGVjKHRleHRBZnRlcilbMF0ubGVuZ3RoO1xuICAgIGxldCBiZWZvcmVPZmYgPSB0ZXh0QmVmb3JlLmxlbmd0aCAtIHNwYWNlQmVmb3JlO1xuICAgIGlmICh0ZXh0QmVmb3JlLnNsaWNlKGJlZm9yZU9mZiAtIG9wZW4ubGVuZ3RoLCBiZWZvcmVPZmYpID09IG9wZW4gJiZcbiAgICAgICAgdGV4dEFmdGVyLnNsaWNlKHNwYWNlQWZ0ZXIsIHNwYWNlQWZ0ZXIgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tIC0gc3BhY2VCZWZvcmUsIG1hcmdpbjogc3BhY2VCZWZvcmUgJiYgMSB9LFxuICAgICAgICAgICAgY2xvc2U6IHsgcG9zOiB0byArIHNwYWNlQWZ0ZXIsIG1hcmdpbjogc3BhY2VBZnRlciAmJiAxIH0gfTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0VGV4dCwgZW5kVGV4dDtcbiAgICBpZiAodG8gLSBmcm9tIDw9IDIgKiBTZWFyY2hNYXJnaW4pIHtcbiAgICAgICAgc3RhcnRUZXh0ID0gZW5kVGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0VGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIGZyb20gKyBTZWFyY2hNYXJnaW4pO1xuICAgICAgICBlbmRUZXh0ID0gc3RhdGUuc2xpY2VEb2ModG8gLSBTZWFyY2hNYXJnaW4sIHRvKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0U3BhY2UgPSAvXlxccyovLmV4ZWMoc3RhcnRUZXh0KVswXS5sZW5ndGgsIGVuZFNwYWNlID0gL1xccyokLy5leGVjKGVuZFRleHQpWzBdLmxlbmd0aDtcbiAgICBsZXQgZW5kT2ZmID0gZW5kVGV4dC5sZW5ndGggLSBlbmRTcGFjZSAtIGNsb3NlLmxlbmd0aDtcbiAgICBpZiAoc3RhcnRUZXh0LnNsaWNlKHN0YXJ0U3BhY2UsIHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCkgPT0gb3BlbiAmJlxuICAgICAgICBlbmRUZXh0LnNsaWNlKGVuZE9mZiwgZW5kT2ZmICsgY2xvc2UubGVuZ3RoKSA9PSBjbG9zZSkge1xuICAgICAgICByZXR1cm4geyBvcGVuOiB7IHBvczogZnJvbSArIHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3Qoc3RhcnRUZXh0LmNoYXJBdChzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgpKSA/IDEgOiAwIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvIC0gZW5kU3BhY2UgLSBjbG9zZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAvXFxzLy50ZXN0KGVuZFRleHQuY2hhckF0KGVuZE9mZiAtIDEpKSA/IDEgOiAwIH0gfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVSYW5nZXMoc3RhdGUpIHtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgciBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tTGluZSA9IHN0YXRlLmRvYy5saW5lQXQoci5mcm9tKTtcbiAgICAgICAgbGV0IHRvTGluZSA9IHIudG8gPD0gZnJvbUxpbmUudG8gPyBmcm9tTGluZSA6IHN0YXRlLmRvYy5saW5lQXQoci50byk7XG4gICAgICAgIGlmICh0b0xpbmUuZnJvbSA+IGZyb21MaW5lLmZyb20gJiYgdG9MaW5lLmZyb20gPT0gci50bylcbiAgICAgICAgICAgIHRvTGluZSA9IHIudG8gPT0gZnJvbUxpbmUudG8gKyAxID8gZnJvbUxpbmUgOiBzdGF0ZS5kb2MubGluZUF0KHIudG8gLSAxKTtcbiAgICAgICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPj0gMCAmJiByYW5nZXNbbGFzdF0udG8gPiBmcm9tTGluZS5mcm9tKVxuICAgICAgICAgICAgcmFuZ2VzW2xhc3RdLnRvID0gdG9MaW5lLnRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IGZyb21MaW5lLmZyb20gKyAvXlxccyovLmV4ZWMoZnJvbUxpbmUudGV4dClbMF0ubGVuZ3RoLCB0bzogdG9MaW5lLnRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgYmxvY2sgY29tbWVudHMgaW5cbi8vIGxhbmd1YWdlcyB0aGF0IHN1cHBvcnQgdGhlbS5cbmZ1bmN0aW9uIGNoYW5nZUJsb2NrQ29tbWVudChvcHRpb24sIHN0YXRlLCByYW5nZXMgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgbGV0IHRva2VucyA9IHJhbmdlcy5tYXAociA9PiBnZXRDb25maWcoc3RhdGUsIHIuZnJvbSkuYmxvY2spO1xuICAgIGlmICghdG9rZW5zLmV2ZXJ5KGMgPT4gYykpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBjb21tZW50cyA9IHJhbmdlcy5tYXAoKHIsIGkpID0+IGZpbmRCbG9ja0NvbW1lbnQoc3RhdGUsIHRva2Vuc1tpXSwgci5mcm9tLCByLnRvKSk7XG4gICAgaWYgKG9wdGlvbiAhPSAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovICYmICFjb21tZW50cy5ldmVyeShjID0+IGMpKSB7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHN0YXRlLmNoYW5nZXMocmFuZ2VzLm1hcCgocmFuZ2UsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogcmFuZ2UuZnJvbSwgaW5zZXJ0OiB0b2tlbnNbaV0ub3BlbiArIFwiIFwiIH0sIHsgZnJvbTogcmFuZ2UudG8sIGluc2VydDogXCIgXCIgKyB0b2tlbnNbaV0uY2xvc2UgfV07XG4gICAgICAgICAgICB9KSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9uICE9IDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovICYmIGNvbW1lbnRzLnNvbWUoYyA9PiBjKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgY29tbWVudDsgaSA8IGNvbW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPSBjb21tZW50c1tpXSkge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHRva2Vuc1tpXSwgeyBvcGVuLCBjbG9zZSB9ID0gY29tbWVudDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBvcGVuLnBvcyAtIHRva2VuLm9wZW4ubGVuZ3RoLCB0bzogb3Blbi5wb3MgKyBvcGVuLm1hcmdpbiB9LCB7IGZyb206IGNsb3NlLnBvcyAtIGNsb3NlLm1hcmdpbiwgdG86IGNsb3NlLnBvcyArIHRva2VuLmNsb3NlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIFBlcmZvcm1zIHRvZ2dsZSwgY29tbWVudCBhbmQgdW5jb21tZW50IG9mIGxpbmUgY29tbWVudHMuXG5mdW5jdGlvbiBjaGFuZ2VMaW5lQ29tbWVudChvcHRpb24sIHN0YXRlLCByYW5nZXMgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGV0IHByZXZMaW5lID0gLTE7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHJhbmdlcykge1xuICAgICAgICBsZXQgc3RhcnRJID0gbGluZXMubGVuZ3RoLCBtaW5JbmRlbnQgPSAxZTk7XG4gICAgICAgIGxldCB0b2tlbiA9IGdldENvbmZpZyhzdGF0ZSwgZnJvbSkubGluZTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPiBwcmV2TGluZSAmJiAoZnJvbSA9PSB0byB8fCB0byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBwcmV2TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBlbXB0eSA9IGluZGVudCA9PSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWVudCA9IGxpbmUudGV4dC5zbGljZShpbmRlbnQsIGluZGVudCArIHRva2VuLmxlbmd0aCkgPT0gdG9rZW4gPyBpbmRlbnQgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50IDwgbGluZS50ZXh0Lmxlbmd0aCAmJiBpbmRlbnQgPCBtaW5JbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIG1pbkluZGVudCA9IGluZGVudDtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHsgbGluZSwgY29tbWVudCwgdG9rZW4sIGluZGVudCwgZW1wdHksIHNpbmdsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWluSW5kZW50IDwgMWU5KVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0STsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChsaW5lc1tpXS5pbmRlbnQgPCBsaW5lc1tpXS5saW5lLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBsaW5lc1tpXS5pbmRlbnQgPSBtaW5JbmRlbnQ7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT0gc3RhcnRJICsgMSlcbiAgICAgICAgICAgIGxpbmVzW3N0YXJ0SV0uc2luZ2xlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbiAhPSAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovICYmIGxpbmVzLnNvbWUobCA9PiBsLmNvbW1lbnQgPCAwICYmICghbC5lbXB0eSB8fCBsLnNpbmdsZSkpKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgbGluZSwgdG9rZW4sIGluZGVudCwgZW1wdHksIHNpbmdsZSB9IG9mIGxpbmVzKVxuICAgICAgICAgICAgaWYgKHNpbmdsZSB8fCAhZW1wdHkpXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsgaW5kZW50LCBpbnNlcnQ6IHRva2VuICsgXCIgXCIgfSk7XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBjaGFuZ2VTZXQsIHNlbGVjdGlvbjogc3RhdGUuc2VsZWN0aW9uLm1hcChjaGFuZ2VTZXQsIDEpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50ID49IDApKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgbGluZSwgY29tbWVudCwgdG9rZW4gfSBvZiBsaW5lcylcbiAgICAgICAgICAgIGlmIChjb21tZW50ID49IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGxpbmUuZnJvbSArIGNvbW1lbnQsIHRvID0gZnJvbSArIHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGluZS50ZXh0W3RvIC0gbGluZS5mcm9tXSA9PSBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgZnJvbUhpc3RvcnkgPSBzdGF0ZS5Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBhbm5vdGF0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IHRoYXQgdHJhbnNhY3Rpb24gZnJvbVxuYmVpbmcgY29tYmluZWQgd2l0aCBvdGhlciB0cmFuc2FjdGlvbnMgaW4gdGhlIHVuZG8gaGlzdG9yeS4gR2l2ZW5cbmBcImJlZm9yZVwiYCwgaXQnbGwgcHJldmVudCBtZXJnaW5nIHdpdGggcHJldmlvdXMgdHJhbnNhY3Rpb25zLiBXaXRoXG5gXCJhZnRlclwiYCwgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMgd29uJ3QgYmUgY29tYmluZWQgd2l0aCB0aGlzXG5vbmUuIFdpdGggYFwiZnVsbFwiYCwgdGhlIHRyYW5zYWN0aW9uIGlzIGlzb2xhdGVkIG9uIGJvdGggc2lkZXMuXG4qL1xuY29uc3QgaXNvbGF0ZUhpc3RvcnkgPSBzdGF0ZS5Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UaGlzIGZhY2V0IHByb3ZpZGVzIGEgd2F5IHRvIHJlZ2lzdGVyIGZ1bmN0aW9ucyB0aGF0LCBnaXZlbiBhXG50cmFuc2FjdGlvbiwgcHJvdmlkZSBhIHNldCBvZiBlZmZlY3RzIHRoYXQgdGhlIGhpc3Rvcnkgc2hvdWxkXG5zdG9yZSB3aGVuIGludmVydGluZyB0aGUgdHJhbnNhY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQgdG9cbmludGVncmF0ZSBzb21lIGtpbmRzIG9mIGVmZmVjdHMgaW4gdGhlIGhpc3RvcnksIHNvIHRoYXQgdGhleSBjYW5cbmJlIHVuZG9uZSAoYW5kIHJlZG9uZSBhZ2FpbikuXG4qL1xuY29uc3QgaW52ZXJ0ZWRFZmZlY3RzID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBoaXN0b3J5Q29uZmlnID0gc3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgbWluRGVwdGg6IDEwMCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMCxcbiAgICAgICAgICAgIGpvaW5Ub0V2ZW50OiAoX3QsIGlzQWRqYWNlbnQpID0+IGlzQWRqYWNlbnQsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1pbkRlcHRoOiBNYXRoLm1heCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IE1hdGgubWluLFxuICAgICAgICAgICAgam9pblRvRXZlbnQ6IChhLCBiKSA9PiAodHIsIGFkaikgPT4gYSh0ciwgYWRqKSB8fCBiKHRyLCBhZGopXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3QgaGlzdG9yeUZpZWxkXyA9IHN0YXRlLlN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBIaXN0b3J5U3RhdGUuZW1wdHk7XG4gICAgfSxcbiAgICB1cGRhdGUoc3RhdGUkMSwgdHIpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGhpc3RvcnlDb25maWcpO1xuICAgICAgICBsZXQgZnJvbUhpc3QgPSB0ci5hbm5vdGF0aW9uKGZyb21IaXN0b3J5KTtcbiAgICAgICAgaWYgKGZyb21IaXN0KSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IEhpc3RFdmVudC5mcm9tVHJhbnNhY3Rpb24odHIsIGZyb21IaXN0LnNlbGVjdGlvbiksIGZyb20gPSBmcm9tSGlzdC5zaWRlO1xuICAgICAgICAgICAgbGV0IG90aGVyID0gZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHN0YXRlJDEudW5kb25lIDogc3RhdGUkMS5kb25lO1xuICAgICAgICAgICAgaWYgKGl0ZW0pXG4gICAgICAgICAgICAgICAgb3RoZXIgPSB1cGRhdGVCcmFuY2gob3RoZXIsIG90aGVyLmxlbmd0aCwgY29uZmlnLm1pbkRlcHRoLCBpdGVtKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvdGhlciA9IGFkZFNlbGVjdGlvbihvdGhlciwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGZyb21IaXN0LnJlc3QgOiBvdGhlciwgZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IG90aGVyIDogZnJvbUhpc3QucmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzb2xhdGUgPSB0ci5hbm5vdGF0aW9uKGlzb2xhdGVIaXN0b3J5KTtcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImJlZm9yZVwiKVxuICAgICAgICAgICAgc3RhdGUkMSA9IHN0YXRlJDEuaXNvbGF0ZSgpO1xuICAgICAgICBpZiAodHIuYW5ub3RhdGlvbihzdGF0ZS5UcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiAhdHIuY2hhbmdlcy5lbXB0eSA/IHN0YXRlJDEuYWRkTWFwcGluZyh0ci5jaGFuZ2VzLmRlc2MpIDogc3RhdGUkMTtcbiAgICAgICAgbGV0IGV2ZW50ID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0cik7XG4gICAgICAgIGxldCB0aW1lID0gdHIuYW5ub3RhdGlvbihzdGF0ZS5UcmFuc2FjdGlvbi50aW1lKSwgdXNlckV2ZW50ID0gdHIuYW5ub3RhdGlvbihzdGF0ZS5UcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQpXG4gICAgICAgICAgICBzdGF0ZSQxID0gc3RhdGUkMS5hZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZywgdHIpO1xuICAgICAgICBlbHNlIGlmICh0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICBzdGF0ZSQxID0gc3RhdGUkMS5hZGRTZWxlY3Rpb24odHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLm5ld0dyb3VwRGVsYXkpO1xuICAgICAgICBpZiAoaXNvbGF0ZSA9PSBcImZ1bGxcIiB8fCBpc29sYXRlID09IFwiYWZ0ZXJcIilcbiAgICAgICAgICAgIHN0YXRlJDEgPSBzdGF0ZSQxLmlzb2xhdGUoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlJDE7XG4gICAgfSxcbiAgICB0b0pTT04odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdmFsdWUuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSwgdW5kb25lOiB2YWx1ZS51bmRvbmUubWFwKGUgPT4gZS50b0pTT04oKSkgfTtcbiAgICB9LFxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoanNvbi5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pLCBqc29uLnVuZG9uZS5tYXAoSGlzdEV2ZW50LmZyb21KU09OKSk7XG4gICAgfVxufSk7XG4vKipcbkNyZWF0ZSBhIGhpc3RvcnkgZXh0ZW5zaW9uIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4qL1xuZnVuY3Rpb24gaGlzdG9yeShjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGhpc3RvcnlGaWVsZF8sXG4gICAgICAgIGhpc3RvcnlDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgdmlldy5FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgICAgICAgICAgYmVmb3JlaW5wdXQoZSwgdmlldykge1xuICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVJlZG9cIiA/IHJlZG8gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICBdO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdXNlZCB0byBzdG9yZSB0aGUgaGlzdG9yeSBkYXRhLiBTaG91bGQgcHJvYmFibHlcbm9ubHkgYmUgdXNlZCB3aGVuIHlvdSB3YW50IHRvXG5bc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgb3JcbltkZXNlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgc3RhdGUgb2JqZWN0cyBpbiBhIHdheVxudGhhdCBwcmVzZXJ2ZXMgaGlzdG9yeS5cbiovXG5jb25zdCBoaXN0b3J5RmllbGQgPSBoaXN0b3J5RmllbGRfO1xuZnVuY3Rpb24gY21kKHNpZGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkge1xuICAgICAgICBpZiAoIXNlbGVjdGlvbiAmJiBzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGhpc3RvcnlTdGF0ZSA9IHN0YXRlLmZpZWxkKGhpc3RvcnlGaWVsZF8sIGZhbHNlKTtcbiAgICAgICAgaWYgKCFoaXN0b3J5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGhpc3RvcnlTdGF0ZS5wb3Aoc2lkZSwgc3RhdGUsIHNlbGVjdGlvbik7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuVW5kbyBhIHNpbmdsZSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cFxud2FzIGF2YWlsYWJsZS5cbiovXG5jb25zdCB1bmRvID0gY21kKDAgLyogQnJhbmNoTmFtZS5Eb25lICovLCBmYWxzZSk7XG4vKipcblJlZG8gYSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cCB3YXNcbmF2YWlsYWJsZS5cbiovXG5jb25zdCByZWRvID0gY21kKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8sIGZhbHNlKTtcbi8qKlxuVW5kbyBhIGNoYW5nZSBvciBzZWxlY3Rpb24gY2hhbmdlLlxuKi9cbmNvbnN0IHVuZG9TZWxlY3Rpb24gPSBjbWQoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8sIHRydWUpO1xuLyoqXG5SZWRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgcmVkb1NlbGVjdGlvbiA9IGNtZCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovLCB0cnVlKTtcbmZ1bmN0aW9uIGRlcHRoKHNpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGxldCBoaXN0U3RhdGUgPSBzdGF0ZS5maWVsZChoaXN0b3J5RmllbGRfLCBmYWxzZSk7XG4gICAgICAgIGlmICghaGlzdFN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBicmFuY2ggPSBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gaGlzdFN0YXRlLmRvbmUgOiBoaXN0U3RhdGUudW5kb25lO1xuICAgICAgICByZXR1cm4gYnJhbmNoLmxlbmd0aCAtIChicmFuY2gubGVuZ3RoICYmICFicmFuY2hbMF0uY2hhbmdlcyA/IDEgOiAwKTtcbiAgICB9O1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHVuZG9hYmxlIGNoYW5nZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuY29uc3QgdW5kb0RlcHRoID0gZGVwdGgoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8pO1xuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGNoYW5nZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuY29uc3QgcmVkb0RlcHRoID0gZGVwdGgoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLyk7XG4vLyBIaXN0b3J5IGV2ZW50cyBzdG9yZSBncm91cHMgb2YgY2hhbmdlcyBvciBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZVxuLy8gdW5kb25lL3JlZG9uZSB0b2dldGhlci5cbmNsYXNzIEhpc3RFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGNoYW5nZXMgaW4gdGhpcyBldmVudC4gTm9ybWFsIGV2ZW50cyBob2xkIGF0IGxlYXN0IG9uZVxuICAgIC8vIGNoYW5nZSBvciBlZmZlY3QuIEJ1dCBpdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHN0b3JlIHNlbGVjdGlvblxuICAgIC8vIGV2ZW50cyBiZWZvcmUgdGhlIGZpcnN0IGNoYW5nZSwgaW4gd2hpY2ggY2FzZSBhIHNwZWNpYWwgdHlwZSBvZlxuICAgIC8vIGluc3RhbmNlIGlzIGNyZWF0ZWQgd2hpY2ggZG9lc24ndCBob2xkIGFueSBjaGFuZ2VzLCB3aXRoXG4gICAgLy8gY2hhbmdlcyA9PSBzdGFydFNlbGVjdGlvbiA9PSB1bmRlZmluZWRcbiAgICBjaGFuZ2VzLCBcbiAgICAvLyBUaGUgZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudFxuICAgIGVmZmVjdHMsIFxuICAgIC8vIEFjY3VtdWxhdGVkIG1hcHBpbmcgKGZyb20gYWRkVG9IaXN0b3J5PT1mYWxzZSkgdGhhdCBzaG91bGQgYmVcbiAgICAvLyBhcHBsaWVkIHRvIGV2ZW50cyBiZWxvdyB0aGlzIG9uZS5cbiAgICBtYXBwZWQsIFxuICAgIC8vIFRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoaXMgZXZlbnRcbiAgICBzdGFydFNlbGVjdGlvbiwgXG4gICAgLy8gU3RvcmVzIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIHRoaXMgZXZlbnQsIHRvIGJlIHVzZWQgZm9yXG4gICAgLy8gc2VsZWN0aW9uIHVuZG8vcmVkby5cbiAgICBzZWxlY3Rpb25zQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5tYXBwZWQgPSBtYXBwZWQ7XG4gICAgICAgIHRoaXMuc3RhcnRTZWxlY3Rpb24gPSBzdGFydFNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zQWZ0ZXIgPSBzZWxlY3Rpb25zQWZ0ZXI7XG4gICAgfVxuICAgIHNldFNlbEFmdGVyKGFmdGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRoaXMuY2hhbmdlcywgdGhpcy5lZmZlY3RzLCB0aGlzLm1hcHBlZCwgdGhpcy5zdGFydFNlbGVjdGlvbiwgYWZ0ZXIpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogKF9hID0gdGhpcy5jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKCksXG4gICAgICAgICAgICBtYXBwZWQ6IChfYiA9IHRoaXMubWFwcGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9KU09OKCksXG4gICAgICAgICAgICBzdGFydFNlbGVjdGlvbjogKF9jID0gdGhpcy5zdGFydFNlbGVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvSlNPTigpLFxuICAgICAgICAgICAgc2VsZWN0aW9uc0FmdGVyOiB0aGlzLnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLnRvSlNPTigpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudChqc29uLmNoYW5nZXMgJiYgc3RhdGUuQ2hhbmdlU2V0LmZyb21KU09OKGpzb24uY2hhbmdlcyksIFtdLCBqc29uLm1hcHBlZCAmJiBzdGF0ZS5DaGFuZ2VEZXNjLmZyb21KU09OKGpzb24ubWFwcGVkKSwganNvbi5zdGFydFNlbGVjdGlvbiAmJiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zdGFydFNlbGVjdGlvbiksIGpzb24uc2VsZWN0aW9uc0FmdGVyLm1hcChzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04pKTtcbiAgICB9XG4gICAgLy8gVGhpcyBkb2VzIG5vdCBjaGVjayBgYWRkVG9IaXN0b3J5YCBhbmQgc3VjaCwgaXQgYXNzdW1lcyB0aGVcbiAgICAvLyB0cmFuc2FjdGlvbiBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYW4gaXRlbS4gUmV0dXJucyBudWxsIHdoZW5cbiAgICAvLyB0aGVyZSBhcmUgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICBzdGF0aWMgZnJvbVRyYW5zYWN0aW9uKHRyLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBub25lO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnQgb2YgdHIuc3RhcnRTdGF0ZS5mYWNldChpbnZlcnRlZEVmZmVjdHMpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gaW52ZXJ0KHRyKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMgPSBlZmZlY3RzLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGggJiYgdHIuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh0ci5jaGFuZ2VzLmludmVydCh0ci5zdGFydFN0YXRlLmRvYyksIGVmZmVjdHMsIHVuZGVmaW5lZCwgc2VsZWN0aW9uIHx8IHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLCBub25lKTtcbiAgICB9XG4gICAgc3RhdGljIHNlbGVjdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHVuZGVmaW5lZCwgbm9uZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHNlbGVjdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUJyYW5jaChicmFuY2gsIHRvLCBtYXhMZW4sIG5ld0V2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gdG8gKyAxID4gbWF4TGVuICsgMjAgPyB0byAtIG1heExlbiAtIDEgOiAwO1xuICAgIGxldCBuZXdCcmFuY2ggPSBicmFuY2guc2xpY2Uoc3RhcnQsIHRvKTtcbiAgICBuZXdCcmFuY2gucHVzaChuZXdFdmVudCk7XG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcbn1cbmZ1bmN0aW9uIGlzQWRqYWNlbnQoYSwgYikge1xuICAgIGxldCByYW5nZXMgPSBbXSwgaXNBZGphY2VudCA9IGZhbHNlO1xuICAgIGEuaXRlckNoYW5nZWRSYW5nZXMoKGYsIHQpID0+IHJhbmdlcy5wdXNoKGYsIHQpKTtcbiAgICBiLml0ZXJDaGFuZ2VkUmFuZ2VzKChfZiwgX3QsIGYsIHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaSsrXSwgdG8gPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIGlmICh0ID49IGZyb20gJiYgZiA8PSB0bylcbiAgICAgICAgICAgICAgICBpc0FkamFjZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc0FkamFjZW50O1xufVxuZnVuY3Rpb24gZXFTZWxlY3Rpb25TaGFwZShhLCBiKSB7XG4gICAgcmV0dXJuIGEucmFuZ2VzLmxlbmd0aCA9PSBiLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgICAgYS5yYW5nZXMuZmlsdGVyKChyLCBpKSA9PiByLmVtcHR5ICE9IGIucmFuZ2VzW2ldLmVtcHR5KS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiBjb25jKGEsIGIpIHtcbiAgICByZXR1cm4gIWEubGVuZ3RoID8gYiA6ICFiLmxlbmd0aCA/IGEgOiBhLmNvbmNhdChiKTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmNvbnN0IE1heFNlbGVjdGlvbnNQZXJFdmVudCA9IDIwMDtcbmZ1bmN0aW9uIGFkZFNlbGVjdGlvbihicmFuY2gsIHNlbGVjdGlvbikge1xuICAgIGlmICghYnJhbmNoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW0hpc3RFdmVudC5zZWxlY3Rpb24oW3NlbGVjdGlvbl0pXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsYXN0RXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgICAgICBsZXQgc2VscyA9IGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoTWF0aC5tYXgoMCwgbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSBNYXhTZWxlY3Rpb25zUGVyRXZlbnQpKTtcbiAgICAgICAgaWYgKHNlbHMubGVuZ3RoICYmIHNlbHNbc2Vscy5sZW5ndGggLSAxXS5lcShzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgc2Vscy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB1cGRhdGVCcmFuY2goYnJhbmNoLCBicmFuY2gubGVuZ3RoIC0gMSwgMWU5LCBsYXN0RXZlbnQuc2V0U2VsQWZ0ZXIoc2VscykpO1xuICAgIH1cbn1cbi8vIEFzc3VtZXMgdGhlIHRvcCBpdGVtIGhhcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb25BZnRlciB2YWx1ZXNcbmZ1bmN0aW9uIHBvcFNlbGVjdGlvbihicmFuY2gpIHtcbiAgICBsZXQgbGFzdCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZSgpO1xuICAgIG5ld0JyYW5jaFticmFuY2gubGVuZ3RoIC0gMV0gPSBsYXN0LnNldFNlbEFmdGVyKGxhc3Quc2VsZWN0aW9uc0FmdGVyLnNsaWNlKDAsIGxhc3Quc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuLy8gQWRkIGEgbWFwcGluZyB0byB0aGUgdG9wIGV2ZW50IGluIHRoZSBnaXZlbiBicmFuY2guIElmIHRoaXMgbWFwc1xuLy8gYXdheSBhbGwgdGhlIGNoYW5nZXMgYW5kIGVmZmVjdHMgaW4gdGhhdCBpdGVtLCBkcm9wIGl0IGFuZFxuLy8gcHJvcGFnYXRlIHRoZSBtYXBwaW5nIHRvIHRoZSBuZXh0IGl0ZW0uXG5mdW5jdGlvbiBhZGRNYXBwaW5nVG9CcmFuY2goYnJhbmNoLCBtYXBwaW5nKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKVxuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIGxldCBsZW5ndGggPSBicmFuY2gubGVuZ3RoLCBzZWxlY3Rpb25zID0gbm9uZTtcbiAgICB3aGlsZSAobGVuZ3RoKSB7XG4gICAgICAgIGxldCBldmVudCA9IG1hcEV2ZW50KGJyYW5jaFtsZW5ndGggLSAxXSwgbWFwcGluZywgc2VsZWN0aW9ucyk7XG4gICAgICAgIGlmIChldmVudC5jaGFuZ2VzICYmICFldmVudC5jaGFuZ2VzLmVtcHR5IHx8IGV2ZW50LmVmZmVjdHMubGVuZ3RoKSB7IC8vIEV2ZW50IHN1cnZpdmVkIG1hcHBpbmdcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBicmFuY2guc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGggLSAxXSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gRHJvcCB0aGlzIGV2ZW50LCBzaW5jZSB0aGVyZSdzIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBsZWZ0XG4gICAgICAgICAgICBtYXBwaW5nID0gZXZlbnQubWFwcGVkO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gZXZlbnQuc2VsZWN0aW9uc0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb25zLmxlbmd0aCA/IFtIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpXSA6IG5vbmU7XG59XG5mdW5jdGlvbiBtYXBFdmVudChldmVudCwgbWFwcGluZywgZXh0cmFTZWxlY3Rpb25zKSB7XG4gICAgbGV0IHNlbGVjdGlvbnMgPSBjb25jKGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggPyBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy5tYXAobWFwcGluZykpIDogbm9uZSwgZXh0cmFTZWxlY3Rpb25zKTtcbiAgICAvLyBDaGFuZ2UtbGVzcyBldmVudHMgZG9uJ3Qgc3RvcmUgbWFwcGluZ3MgKHRoZXkgYXJlIGFsd2F5cyB0aGUgbGFzdCBldmVudCBpbiBhIGJyYW5jaClcbiAgICBpZiAoIWV2ZW50LmNoYW5nZXMpXG4gICAgICAgIHJldHVybiBIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpO1xuICAgIGxldCBtYXBwZWRDaGFuZ2VzID0gZXZlbnQuY2hhbmdlcy5tYXAobWFwcGluZyksIGJlZm9yZSA9IG1hcHBpbmcubWFwRGVzYyhldmVudC5jaGFuZ2VzLCB0cnVlKTtcbiAgICBsZXQgZnVsbE1hcHBpbmcgPSBldmVudC5tYXBwZWQgPyBldmVudC5tYXBwZWQuY29tcG9zZURlc2MoYmVmb3JlKSA6IGJlZm9yZTtcbiAgICByZXR1cm4gbmV3IEhpc3RFdmVudChtYXBwZWRDaGFuZ2VzLCBzdGF0ZS5TdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGV2ZW50LmVmZmVjdHMsIG1hcHBpbmcpLCBmdWxsTWFwcGluZywgZXZlbnQuc3RhcnRTZWxlY3Rpb24ubWFwKGJlZm9yZSksIHNlbGVjdGlvbnMpO1xufVxuY29uc3Qgam9pbmFibGVVc2VyRXZlbnQgPSAvXihpbnB1dFxcLnR5cGV8ZGVsZXRlKSgkfFxcLikvO1xuY2xhc3MgSGlzdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb25lLCB1bmRvbmUsIHByZXZUaW1lID0gMCwgcHJldlVzZXJFdmVudCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRvbmUgPSBkb25lO1xuICAgICAgICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgICAgICAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xuICAgICAgICB0aGlzLnByZXZVc2VyRXZlbnQgPSBwcmV2VXNlckV2ZW50O1xuICAgIH1cbiAgICBpc29sYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2VGltZSA/IG5ldyBIaXN0b3J5U3RhdGUodGhpcy5kb25lLCB0aGlzLnVuZG9uZSkgOiB0aGlzO1xuICAgIH1cbiAgICBhZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZywgdHIpIHtcbiAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmRvbmUsIGxhc3RFdmVudCA9IGRvbmVbZG9uZS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RFdmVudCAmJiBsYXN0RXZlbnQuY2hhbmdlcyAmJiAhbGFzdEV2ZW50LmNoYW5nZXMuZW1wdHkgJiYgZXZlbnQuY2hhbmdlcyAmJlxuICAgICAgICAgICAgKCF1c2VyRXZlbnQgfHwgam9pbmFibGVVc2VyRXZlbnQudGVzdCh1c2VyRXZlbnQpKSAmJlxuICAgICAgICAgICAgKCghbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICB0aW1lIC0gdGhpcy5wcmV2VGltZSA8IGNvbmZpZy5uZXdHcm91cERlbGF5ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLmpvaW5Ub0V2ZW50KHRyLCBpc0FkamFjZW50KGxhc3RFdmVudC5jaGFuZ2VzLCBldmVudC5jaGFuZ2VzKSkpIHx8XG4gICAgICAgICAgICAgICAgLy8gRm9yIGNvbXBvc2UgKGJ1dCBub3QgY29tcG9zZS5zdGFydCkgZXZlbnRzLCBhbHdheXMgam9pbiB3aXRoIHByZXZpb3VzIGV2ZW50XG4gICAgICAgICAgICAgICAgdXNlckV2ZW50ID09IFwiaW5wdXQudHlwZS5jb21wb3NlXCIpKSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoIC0gMSwgY29uZmlnLm1pbkRlcHRoLCBuZXcgSGlzdEV2ZW50KGV2ZW50LmNoYW5nZXMuY29tcG9zZShsYXN0RXZlbnQuY2hhbmdlcyksIGNvbmMoc3RhdGUuU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhldmVudC5lZmZlY3RzLCBsYXN0RXZlbnQuY2hhbmdlcyksIGxhc3RFdmVudC5lZmZlY3RzKSwgbGFzdEV2ZW50Lm1hcHBlZCwgbGFzdEV2ZW50LnN0YXJ0U2VsZWN0aW9uLCBub25lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoLCBjb25maWcubWluRGVwdGgsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShkb25lLCBub25lLCB0aW1lLCB1c2VyRXZlbnQpO1xuICAgIH1cbiAgICBhZGRTZWxlY3Rpb24oc2VsZWN0aW9uLCB0aW1lLCB1c2VyRXZlbnQsIG5ld0dyb3VwRGVsYXkpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbmUubGVuZ3RoID8gdGhpcy5kb25lW3RoaXMuZG9uZS5sZW5ndGggLSAxXS5zZWxlY3Rpb25zQWZ0ZXIgOiBub25lO1xuICAgICAgICBpZiAobGFzdC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aW1lIC0gdGhpcy5wcmV2VGltZSA8IG5ld0dyb3VwRGVsYXkgJiZcbiAgICAgICAgICAgIHVzZXJFdmVudCA9PSB0aGlzLnByZXZVc2VyRXZlbnQgJiYgdXNlckV2ZW50ICYmIC9ec2VsZWN0KCR8XFwuKS8udGVzdCh1c2VyRXZlbnQpICYmXG4gICAgICAgICAgICBlcVNlbGVjdGlvblNoYXBlKGxhc3RbbGFzdC5sZW5ndGggLSAxXSwgc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShhZGRTZWxlY3Rpb24odGhpcy5kb25lLCBzZWxlY3Rpb24pLCB0aGlzLnVuZG9uZSwgdGltZSwgdXNlckV2ZW50KTtcbiAgICB9XG4gICAgYWRkTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLmRvbmUsIG1hcHBpbmcpLCBhZGRNYXBwaW5nVG9CcmFuY2godGhpcy51bmRvbmUsIG1hcHBpbmcpLCB0aGlzLnByZXZUaW1lLCB0aGlzLnByZXZVc2VyRXZlbnQpO1xuICAgIH1cbiAgICBwb3Aoc2lkZSwgc3RhdGUsIG9ubHlTZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGJyYW5jaCA9IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyB0aGlzLmRvbmUgOiB0aGlzLnVuZG9uZTtcbiAgICAgICAgaWYgKGJyYW5jaC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdLCBzZWxlY3Rpb24gPSBldmVudC5zZWxlY3Rpb25zQWZ0ZXJbMF0gfHwgc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAob25seVNlbGVjdGlvbiAmJiBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnNlbGVjdGlvbnNBZnRlcltldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdDogcG9wU2VsZWN0aW9uKGJyYW5jaCksIHNlbGVjdGlvbiB9KSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBcInNlbGVjdC51bmRvXCIgOiBcInNlbGVjdC5yZWRvXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFldmVudC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXN0ID0gYnJhbmNoLmxlbmd0aCA9PSAxID8gbm9uZSA6IGJyYW5jaC5zbGljZSgwLCBicmFuY2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAoZXZlbnQubWFwcGVkKVxuICAgICAgICAgICAgICAgIHJlc3QgPSBhZGRNYXBwaW5nVG9CcmFuY2gocmVzdCwgZXZlbnQubWFwcGVkKTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIGNoYW5nZXM6IGV2ZW50LmNoYW5nZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zdGFydFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBldmVudC5lZmZlY3RzLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3QsIHNlbGVjdGlvbiB9KSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IFwidW5kb1wiIDogXCJyZWRvXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuSGlzdG9yeVN0YXRlLmVtcHR5ID0gbmV3IEhpc3RvcnlTdGF0ZShub25lLCBub25lKTtcbi8qKlxuRGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoZSB1bmRvIGhpc3RvcnkuXG5cbi0gTW9kLXo6IFtgdW5kb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudW5kbykuXG4tIE1vZC15IChNb2QtU2hpZnQteiBvbiBtYWNPUykgKyBDdHJsLVNoaWZ0LXogb24gTGludXg6IFtgcmVkb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMucmVkbykuXG4tIE1vZC11OiBbYHVuZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnVuZG9TZWxlY3Rpb24pLlxuLSBBbHQtdSAoTW9kLVNoaWZ0LXUgb24gbWFjT1MpOiBbYHJlZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnJlZG9TZWxlY3Rpb24pLlxuKi9cbmNvbnN0IGhpc3RvcnlLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLXpcIiwgcnVuOiB1bmRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC15XCIsIG1hYzogXCJNb2QtU2hpZnQtelwiLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBsaW51eDogXCJDdHJsLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC11XCIsIHJ1bjogdW5kb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBbHQtdVwiLCBtYWM6IFwiTW9kLVNoaWZ0LXVcIiwgcnVuOiByZWRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9XG5dO1xuXG5mdW5jdGlvbiB1cGRhdGVTZWwoc2VsLCBieSkge1xuICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMubWFwKGJ5KSwgc2VsLm1haW5JbmRleCk7XG59XG5mdW5jdGlvbiBzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSk7XG59XG5mdW5jdGlvbiBtb3ZlU2VsKHsgc3RhdGUsIGRpc3BhdGNoIH0sIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCBob3cpO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uLCB0cnVlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkge1xuICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyByYW5nZS50byA6IHJhbmdlLmZyb20pO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuZnVuY3Rpb24gbHRyQXRDdXJzb3IodmlldyQxKSB7XG4gICAgcmV0dXJuIHZpZXckMS50ZXh0RGlyZWN0aW9uQXQodmlldyQxLnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpID09IHZpZXcuRGlyZWN0aW9uLkxUUjtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQgKHdoaWNoIGlzIGJhY2t3YXJkIGluXG5sZWZ0LXRvLXJpZ2h0IHRleHQsIGZvcndhcmQgaW4gcmlnaHQtdG8tbGVmdCB0ZXh0KS5cbiovXG5jb25zdCBjdXJzb3JDaGFyTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JDaGFyUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gYnlDaGFyTG9naWNhbChzdGF0ZSQxLCByYW5nZSwgZm9yd2FyZCkge1xuICAgIGxldCBwb3MgPSByYW5nZS5oZWFkLCBsaW5lID0gc3RhdGUkMS5kb2MubGluZUF0KHBvcyk7XG4gICAgaWYgKHBvcyA9PSAoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20pKVxuICAgICAgICBwb3MgPSBmb3J3YXJkID8gTWF0aC5taW4oc3RhdGUkMS5kb2MubGVuZ3RoLCBsaW5lLnRvICsgMSkgOiBNYXRoLm1heCgwLCBsaW5lLmZyb20gLSAxKTtcbiAgICBlbHNlXG4gICAgICAgIHBvcyA9IGxpbmUuZnJvbSArIHN0YXRlLmZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQpO1xuICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgZm9yd2FyZCA/IC0xIDogMSk7XG59XG5mdW5jdGlvbiBtb3ZlQnlDaGFyTG9naWNhbCh0YXJnZXQsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh0YXJnZXQsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gYnlDaGFyTG9naWNhbCh0YXJnZXQuc3RhdGUsIHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGZvcndhcmQsIGluIGxvZ2ljYWxcbihub24tdGV4dC1kaXJlY3Rpb24tYXdhcmUpIHN0cmluZyBpbmRleCBvcmRlci5cbiovXG5jb25zdCBjdXJzb3JDaGFyRm9yd2FyZExvZ2ljYWwgPSB0YXJnZXQgPT4gbW92ZUJ5Q2hhckxvZ2ljYWwodGFyZ2V0LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQsIGluIGxvZ2ljYWwgc3RyaW5nIGluZGV4XG5vcmRlci5cbiovXG5jb25zdCBjdXJzb3JDaGFyQmFja3dhcmRMb2dpY2FsID0gdGFyZ2V0ID0+IG1vdmVCeUNoYXJMb2dpY2FsKHRhcmdldCwgZmFsc2UpO1xuZnVuY3Rpb24gY3Vyc29yQnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbGVmdCBhY3Jvc3Mgb25lIGdyb3VwIG9mIHdvcmQgb3Jcbm5vbi13b3JkIChidXQgYWxzbyBub24tc3BhY2UpIGNoYXJhY3RlcnMuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBMZWZ0ID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgZmFsc2UpO1xuY29uc3Qgc2VnbWVudGVyID0gdHlwZW9mIEludGwgIT0gXCJ1bmRlZmluZWRcIiAmJiBJbnRsLlNlZ21lbnRlciA/XG4gICAgbmV3IChJbnRsLlNlZ21lbnRlcikodW5kZWZpbmVkLCB7IGdyYW51bGFyaXR5OiBcIndvcmRcIiB9KSA6IG51bGw7XG5mdW5jdGlvbiBtb3ZlQnlTdWJ3b3JkKHZpZXcsIHJhbmdlLCBmb3J3YXJkKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5mcm9tKTtcbiAgICBsZXQgY2F0ID0gc3RhdGUuQ2hhckNhdGVnb3J5LlNwYWNlLCBwb3MgPSByYW5nZS5mcm9tLCBzdGVwcyA9IDA7XG4gICAgbGV0IGRvbmUgPSBmYWxzZSwgc2F3VXBwZXIgPSBmYWxzZSwgc2F3TG93ZXIgPSBmYWxzZTtcbiAgICBsZXQgc3RlcCA9IChuZXh0KSA9PiB7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb3MgKz0gZm9yd2FyZCA/IG5leHQubGVuZ3RoIDogLW5leHQubGVuZ3RoO1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dCksIGFoZWFkO1xuICAgICAgICBpZiAobmV4dENhdCA9PSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCAmJiBuZXh0LmNoYXJDb2RlQXQoMCkgPCAxMjggJiYgL1tcXFdfXS8udGVzdChuZXh0KSlcbiAgICAgICAgICAgIG5leHRDYXQgPSAtMTsgLy8gVHJlYXQgd29yZCBwdW5jdHVhdGlvbiBzcGVjaWFsbHlcbiAgICAgICAgaWYgKGNhdCA9PSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICBpZiAoY2F0ICE9IG5leHRDYXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjYXQgPT0gc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpIHtcbiAgICAgICAgICAgIGlmIChuZXh0LnRvTG93ZXJDYXNlKCkgPT0gbmV4dCkge1xuICAgICAgICAgICAgICAgIGlmICghZm9yd2FyZCAmJiBzYXdVcHBlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHNhd0xvd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhd0xvd2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzYXdVcHBlciAmJiBmb3J3YXJkICYmIGNhdGVnb3JpemUoYWhlYWQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSkpID09IHN0YXRlLkNoYXJDYXRlZ29yeS5Xb3JkICYmXG4gICAgICAgICAgICAgICAgICAgIGFoZWFkLnRvTG93ZXJDYXNlKCkgPT0gYWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBzYXdVcHBlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RlcHMrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBsZXQgZW5kID0gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkLCBzdGFydCA9PiB7XG4gICAgICAgIHN0ZXAoc3RhcnQpO1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICB9KTtcbiAgICBpZiAoc2VnbWVudGVyICYmIGNhdCA9PSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCAmJiBlbmQuZnJvbSA9PSByYW5nZS5mcm9tICsgc3RlcHMgKiAoZm9yd2FyZCA/IDEgOiAtMSkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihyYW5nZS5oZWFkLCBlbmQuaGVhZCksIHRvID0gTWF0aC5tYXgocmFuZ2UuaGVhZCwgZW5kLmhlYWQpO1xuICAgICAgICBsZXQgc2tpcHBlZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAxICYmIC9bXFx1NEUwMC1cXHVmZmZmXS8udGVzdChza2lwcGVkKSkge1xuICAgICAgICAgICAgbGV0IHNlZ21lbnRzID0gQXJyYXkuZnJvbShzZWdtZW50ZXIuc2VnbWVudChza2lwcGVkKSk7XG4gICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgc2VnbWVudHNbMV0uaW5kZXgsIC0xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihlbmQuaGVhZCArIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLmluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBvciBjYW1lbC1jYXNlIHN1YndvcmQgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JTdWJ3b3JkRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5U3Vid29yZCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5vZGUsIGJyYWNrZXRQcm9wKSB7XG4gICAgaWYgKG5vZGUudHlwZS5wcm9wKGJyYWNrZXRQcm9wKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGxlbiA9IG5vZGUudG8gLSBub2RlLmZyb207XG4gICAgcmV0dXJuIGxlbiAmJiAobGVuID4gMiB8fCAvW15cXHMsLjs6XS8udGVzdChzdGF0ZS5zbGljZURvYyhub2RlLmZyb20sIG5vZGUudG8pKSkgfHwgbm9kZS5maXJzdENoaWxkO1xufVxuZnVuY3Rpb24gbW92ZUJ5U3ludGF4KHN0YXRlJDEsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBvcyA9IGxhbmd1YWdlLnN5bnRheFRyZWUoc3RhdGUkMSkucmVzb2x2ZUlubmVyKHN0YXJ0LmhlYWQpO1xuICAgIGxldCBicmFja2V0UHJvcCA9IGZvcndhcmQgPyBjb21tb24uTm9kZVByb3AuY2xvc2VkQnkgOiBjb21tb24uTm9kZVByb3Aub3BlbmVkQnk7XG4gICAgLy8gU2NhbiBmb3J3YXJkIHRocm91Z2ggY2hpbGQgbm9kZXMgdG8gc2VlIGlmIHRoZXJlJ3MgYW4gaW50ZXJlc3RpbmdcbiAgICAvLyBub2RlIGFoZWFkLlxuICAgIGZvciAobGV0IGF0ID0gc3RhcnQuaGVhZDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gZm9yd2FyZCA/IHBvcy5jaGlsZEFmdGVyKGF0KSA6IHBvcy5jaGlsZEJlZm9yZShhdCk7XG4gICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoaW50ZXJlc3RpbmdOb2RlKHN0YXRlJDEsIG5leHQsIGJyYWNrZXRQcm9wKSlcbiAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF0ID0gZm9yd2FyZCA/IG5leHQudG8gOiBuZXh0LmZyb207XG4gICAgfVxuICAgIGxldCBicmFja2V0ID0gcG9zLnR5cGUucHJvcChicmFja2V0UHJvcCksIG1hdGNoLCBuZXdQb3M7XG4gICAgaWYgKGJyYWNrZXQgJiYgKG1hdGNoID0gZm9yd2FyZCA/IGxhbmd1YWdlLm1hdGNoQnJhY2tldHMoc3RhdGUkMSwgcG9zLmZyb20sIDEpIDogbGFuZ3VhZ2UubWF0Y2hCcmFja2V0cyhzdGF0ZSQxLCBwb3MudG8sIC0xKSkgJiYgbWF0Y2gubWF0Y2hlZClcbiAgICAgICAgbmV3UG9zID0gZm9yd2FyZCA/IG1hdGNoLmVuZC50byA6IG1hdGNoLmVuZC5mcm9tO1xuICAgIGVsc2VcbiAgICAgICAgbmV3UG9zID0gZm9yd2FyZCA/IHBvcy50byA6IHBvcy5mcm9tO1xuICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5ld1BvcywgZm9yd2FyZCA/IC0xIDogMSk7XG59XG4vKipcbk1vdmUgdGhlIGN1cnNvciBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvclN5bnRheExlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvclN5bnRheFJpZ2h0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbmZ1bmN0aW9uIGN1cnNvckJ5TGluZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgbGV0IG1vdmVkID0gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCk7XG4gICAgICAgIHJldHVybiBtb3ZlZC5oZWFkICE9IHJhbmdlLmhlYWQgPyBtb3ZlZCA6IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICB9KTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHVwLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVVcCA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yTGluZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5TGluZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIHBhZ2VJbmZvKHZpZXckMSkge1xuICAgIGxldCBzZWxmU2Nyb2xsID0gdmlldyQxLnNjcm9sbERPTS5jbGllbnRIZWlnaHQgPCB2aWV3JDEuc2Nyb2xsRE9NLnNjcm9sbEhlaWdodCAtIDI7XG4gICAgbGV0IG1hcmdpblRvcCA9IDAsIG1hcmdpbkJvdHRvbSA9IDAsIGhlaWdodDtcbiAgICBpZiAoc2VsZlNjcm9sbCkge1xuICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgdmlldyQxLnN0YXRlLmZhY2V0KHZpZXcuRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zKSkge1xuICAgICAgICAgICAgbGV0IG1hcmdpbnMgPSBzb3VyY2UodmlldyQxKTtcbiAgICAgICAgICAgIGlmIChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMudG9wKVxuICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IE1hdGgubWF4KG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy50b3AsIG1hcmdpblRvcCk7XG4gICAgICAgICAgICBpZiAobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLmJvdHRvbSlcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBNYXRoLm1heChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMuYm90dG9tLCBtYXJnaW5Cb3R0b20pO1xuICAgICAgICB9XG4gICAgICAgIGhlaWdodCA9IHZpZXckMS5zY3JvbGxET00uY2xpZW50SGVpZ2h0IC0gbWFyZ2luVG9wIC0gbWFyZ2luQm90dG9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gKHZpZXckMS5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmlubmVySGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4geyBtYXJnaW5Ub3AsIG1hcmdpbkJvdHRvbSwgc2VsZlNjcm9sbCxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCh2aWV3JDEuZGVmYXVsdExpbmVIZWlnaHQsIGhlaWdodCAtIDUpIH07XG59XG5mdW5jdGlvbiBjdXJzb3JCeVBhZ2UodmlldyQxLCBmb3J3YXJkKSB7XG4gICAgbGV0IHBhZ2UgPSBwYWdlSW5mbyh2aWV3JDEpO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3JDEsIHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLmVtcHR5ID8gdmlldyQxLm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlLmhlaWdodClcbiAgICAgICAgICAgIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3Q7XG4gICAgaWYgKHBhZ2Uuc2VsZlNjcm9sbCkge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSB2aWV3JDEuY29vcmRzQXRQb3Moc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIGxldCBzY3JvbGxSZWN0ID0gdmlldyQxLnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHNjcm9sbFJlY3QudG9wICsgcGFnZS5tYXJnaW5Ub3AsIHNjcm9sbEJvdHRvbSA9IHNjcm9sbFJlY3QuYm90dG9tIC0gcGFnZS5tYXJnaW5Cb3R0b207XG4gICAgICAgIGlmIChzdGFydFBvcyAmJiBzdGFydFBvcy50b3AgPiBzY3JvbGxUb3AgJiYgc3RhcnRQb3MuYm90dG9tIDwgc2Nyb2xsQm90dG9tKVxuICAgICAgICAgICAgZWZmZWN0ID0gdmlldy5FZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5tYWluLmhlYWQsIHsgeTogXCJzdGFydFwiLCB5TWFyZ2luOiBzdGFydFBvcy50b3AgLSBzY3JvbGxUb3AgfSk7XG4gICAgfVxuICAgIHZpZXckMS5kaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbiksIHsgZWZmZWN0czogZWZmZWN0IH0pO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIHBhZ2UgdXAuXG4qL1xuY29uc3QgY3Vyc29yUGFnZVVwID0gdmlldyA9PiBjdXJzb3JCeVBhZ2UodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIHBhZ2UgZG93bi5cbiovXG5jb25zdCBjdXJzb3JQYWdlRG93biA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHN0YXJ0LmhlYWQpLCBtb3ZlZCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHN0YXJ0LCBmb3J3YXJkKTtcbiAgICBpZiAobW92ZWQuaGVhZCA9PSBzdGFydC5oZWFkICYmIG1vdmVkLmhlYWQgIT0gKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKSlcbiAgICAgICAgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgZmFsc2UpO1xuICAgIGlmICghZm9yd2FyZCAmJiBtb3ZlZC5oZWFkID09IGxpbmUuZnJvbSAmJiBsaW5lLmxlbmd0aCkge1xuICAgICAgICBsZXQgc3BhY2UgPSAvXlxccyovLmV4ZWModmlldy5zdGF0ZS5zbGljZURvYyhsaW5lLmZyb20sIE1hdGgubWluKGxpbmUuZnJvbSArIDEwMCwgbGluZS50bykpKVswXS5sZW5ndGg7XG4gICAgICAgIGlmIChzcGFjZSAmJiBzdGFydC5oZWFkICE9IGxpbmUuZnJvbSArIHNwYWNlKVxuICAgICAgICAgICAgbW92ZWQgPSBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGxpbmUuZnJvbSArIHNwYWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdmVkO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgbGluZSB3cmFwIHBvaW50LCBvciB0byB0aGUgZW5kIG9mXG50aGUgbGluZSBpZiB0aGVyZSBpc24ndCBvbmUgbGVmdCBvbiB0aGlzIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIHRydWUpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHByZXZpb3VzIGxpbmUgd3JhcCBwb2ludCwgb3IgZmFpbGluZyB0aGF0IHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBsaW5lIGlzIGluZGVudGVkLCBhbmQgdGhlIGN1cnNvclxuaXNuJ3QgYWxyZWFkeSBhdCB0aGUgZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiwgdGhpcyB3aWxsIG1vdmUgdG8gdGhlXG5lbmQgb2YgdGhlIGluZGVudGF0aW9uIGluc3RlYWQgb2YgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgZmFsc2UpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgd3JhcCBwb2ludCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVTdGFydCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkuZnJvbSwgMSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lRW5kID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bywgLTEpKTtcbmZ1bmN0aW9uIHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlJDEsIGRpc3BhdGNoLCBleHRlbmQpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZSwgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlJDEuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBtYXRjaGluZyA9IGxhbmd1YWdlLm1hdGNoQnJhY2tldHMoc3RhdGUkMSwgcmFuZ2UuaGVhZCwgLTEpXG4gICAgICAgICAgICB8fCBsYW5ndWFnZS5tYXRjaEJyYWNrZXRzKHN0YXRlJDEsIHJhbmdlLmhlYWQsIDEpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA+IDAgJiYgbGFuZ3VhZ2UubWF0Y2hCcmFja2V0cyhzdGF0ZSQxLCByYW5nZS5oZWFkIC0gMSwgMSkpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA8IHN0YXRlJDEuZG9jLmxlbmd0aCAmJiBsYW5ndWFnZS5tYXRjaEJyYWNrZXRzKHN0YXRlJDEsIHJhbmdlLmhlYWQgKyAxLCAtMSkpO1xuICAgICAgICBpZiAoIW1hdGNoaW5nIHx8ICFtYXRjaGluZy5lbmQpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYXRjaGluZy5zdGFydC5mcm9tID09IHJhbmdlLmhlYWQgPyBtYXRjaGluZy5lbmQudG8gOiBtYXRjaGluZy5lbmQuZnJvbTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCA/IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IsIGhlYWQpIDogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkKTtcbiAgICB9KTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlJDEsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSBpdCBpcyBjdXJyZW50bHlcbm9uLCBpZiBhbnkuXG4qL1xuY29uc3QgY3Vyc29yTWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5FeHRlbmQgdGhlIHNlbGVjdGlvbiB0byB0aGUgYnJhY2tldCBtYXRjaGluZyB0aGUgb25lIHRoZSBzZWxlY3Rpb25cbmhlYWQgaXMgY3VycmVudGx5IG9uLCBpZiBhbnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBleHRlbmRTZWwodGFyZ2V0LCBob3cpIHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHRhcmdldC5zdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGhlYWQgPSBob3cocmFuZ2UpO1xuICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZC5oZWFkLCBoZWFkLmdvYWxDb2x1bW4sIGhlYWQuYmlkaUxldmVsIHx8IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcSh0YXJnZXQuc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaChzZXRTZWwodGFyZ2V0LnN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEJ5Q2hhcih2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgbGVmdCwgd2hpbGUgbGVhdmluZ1xudGhlIGFuY2hvciBpbiBwbGFjZS5cbiovXG5jb25zdCBzZWxlY3RDaGFyTGVmdCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdENoYXJSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGZvcndhcmQgYnkgbG9naWNhbFxuKG5vbi1kaXJlY3Rpb24gYXdhcmUpIHN0cmluZyBpbmRleCBvcmRlci5cbiovXG5jb25zdCBzZWxlY3RDaGFyRm9yd2FyZExvZ2ljYWwgPSB0YXJnZXQgPT4gZXh0ZW5kU2VsKHRhcmdldCwgcmFuZ2UgPT4gYnlDaGFyTG9naWNhbCh0YXJnZXQuc3RhdGUsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQgYnkgbG9naWNhbCBzdHJpbmdcbmluZGV4IG9yZGVyLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJCYWNrd2FyZExvZ2ljYWwgPSB0YXJnZXQgPT4gZXh0ZW5kU2VsKHRhcmdldCwgcmFuZ2UgPT4gYnlDaGFyTG9naWNhbCh0YXJnZXQuc3RhdGUsIHJhbmdlLCBmYWxzZSkpO1xuZnVuY3Rpb24gc2VsZWN0QnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBbZ3JvdXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSB0b1xudGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBvciBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhMZWZ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0U3ludGF4UmlnaHQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG5mdW5jdGlvbiBzZWxlY3RCeUxpbmUodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSB1cC5cbiovXG5jb25zdCBzZWxlY3RMaW5lVXAgPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGRvd24uXG4qL1xuY29uc3Qgc2VsZWN0TGluZURvd24gPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlSW5mbyh2aWV3KS5oZWlnaHQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgdXAuXG4qL1xuY29uc3Qgc2VsZWN0UGFnZVVwID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSBkb3duLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VEb3duID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBuZXh0IGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgcHJldmlvdXMgbGluZSBib3VuZGFyeS5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgZmFsc2UpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGJvdW5kYXJ5IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVTdGFydCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUVuZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIGVudGlyZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogeyBhbmNob3I6IDAsIGhlYWQ6IHN0YXRlLmRvYy5sZW5ndGggfSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkV4cGFuZCB0aGUgc2VsZWN0aW9uIHRvIGNvdmVyIGVudGlyZSBsaW5lcy5cbiovXG5jb25zdCBzZWxlY3RMaW5lID0gKHsgc3RhdGU6IHN0YXRlJDEsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlJDEpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgTWF0aC5taW4odG8gKyAxLCBzdGF0ZSQxLmRvYy5sZW5ndGgpKSk7XG4gICAgZGlzcGF0Y2goc3RhdGUkMS51cGRhdGUoeyBzZWxlY3Rpb246IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgbmV4dCBzeW50YWN0aWMgY29uc3RydWN0IHRoYXQgaXMgbGFyZ2VyIHRoYW4gdGhlXG5zZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrIGluc29mYXIgYXMgdGhlIGxhbmd1YWdlXG5bcHJvdmlkZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2UpIHlvdSB1c2UgYnVpbGRzIHVwIGEgZnVsbFxuc3ludGF4IHRyZWUuXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50U3ludGF4ID0gKHsgc3RhdGU6IHN0YXRlJDEsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlJDEuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCB0cmVlID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShzdGF0ZSQxKSwgc3RhY2sgPSB0cmVlLnJlc29sdmVTdGFjayhyYW5nZS5mcm9tLCAxKTtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgc3RhY2tCZWZvcmUgPSB0cmVlLnJlc29sdmVTdGFjayhyYW5nZS5mcm9tLCAtMSk7XG4gICAgICAgICAgICBpZiAoc3RhY2tCZWZvcmUubm9kZS5mcm9tID49IHN0YWNrLm5vZGUuZnJvbSAmJiBzdGFja0JlZm9yZS5ub2RlLnRvIDw9IHN0YWNrLm5vZGUudG8pXG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFja0JlZm9yZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjdXIgPSBzdGFjazsgY3VyOyBjdXIgPSBjdXIubmV4dCkge1xuICAgICAgICAgICAgbGV0IHsgbm9kZSB9ID0gY3VyO1xuICAgICAgICAgICAgaWYgKCgobm9kZS5mcm9tIDwgcmFuZ2UuZnJvbSAmJiBub2RlLnRvID49IHJhbmdlLnRvKSB8fFxuICAgICAgICAgICAgICAgIChub2RlLnRvID4gcmFuZ2UudG8gJiYgbm9kZS5mcm9tIDw9IHJhbmdlLmZyb20pKSAmJlxuICAgICAgICAgICAgICAgIGN1ci5uZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2Uobm9kZS50bywgbm9kZS5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZSQxLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUkMSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TaW1wbGlmeSB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdoZW4gbXVsdGlwbGUgcmFuZ2VzIGFyZSBzZWxlY3RlZCxcbnJlZHVjZSBpdCB0byBpdHMgbWFpbiByYW5nZS4gT3RoZXJ3aXNlLCBpZiB0aGUgc2VsZWN0aW9uIGlzXG5ub24tZW1wdHksIGNvbnZlcnQgaXQgdG8gYSBjdXJzb3Igc2VsZWN0aW9uLlxuKi9cbmNvbnN0IHNpbXBsaWZ5U2VsZWN0aW9uID0gKHsgc3RhdGU6IHN0YXRlJDEsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgY3VyID0gc3RhdGUkMS5zZWxlY3Rpb24sIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgaWYgKGN1ci5yYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgc2VsZWN0aW9uID0gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbY3VyLm1haW5dKTtcbiAgICBlbHNlIGlmICghY3VyLm1haW4uZW1wdHkpXG4gICAgICAgIHNlbGVjdGlvbiA9IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3N0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IoY3VyLm1haW4uaGVhZCldKTtcbiAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSQxLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWxldGVCeSh0YXJnZXQsIGJ5KSB7XG4gICAgaWYgKHRhcmdldC5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBldmVudCA9IFwiZGVsZXRlLnNlbGVjdGlvblwiLCB7IHN0YXRlOiBzdGF0ZSQxIH0gPSB0YXJnZXQ7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZSQxLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChmcm9tID09IHRvKSB7XG4gICAgICAgICAgICBsZXQgdG93YXJkcyA9IGJ5KHJhbmdlKTtcbiAgICAgICAgICAgIGlmICh0b3dhcmRzIDwgZnJvbSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJkZWxldGUuYmFja3dhcmRcIjtcbiAgICAgICAgICAgICAgICB0b3dhcmRzID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvd2FyZHMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvd2FyZHMgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5mb3J3YXJkXCI7XG4gICAgICAgICAgICAgICAgdG93YXJkcyA9IHNraXBBdG9taWModGFyZ2V0LCB0b3dhcmRzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb20gPSBNYXRoLm1pbihmcm9tLCB0b3dhcmRzKTtcbiAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIHRvd2FyZHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHNraXBBdG9taWModGFyZ2V0LCBmcm9tLCBmYWxzZSk7XG4gICAgICAgICAgICB0byA9IHNraXBBdG9taWModGFyZ2V0LCB0bywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdG8gPyB7IHJhbmdlIH0gOiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8gfSwgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSwgZnJvbSA8IHJhbmdlLmhlYWQgPyAtMSA6IDEpIH07XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaChzdGF0ZSQxLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IGV2ZW50LFxuICAgICAgICBlZmZlY3RzOiBldmVudCA9PSBcImRlbGV0ZS5zZWxlY3Rpb25cIiA/IHZpZXcuRWRpdG9yVmlldy5hbm5vdW5jZS5vZihzdGF0ZSQxLnBocmFzZShcIlNlbGVjdGlvbiBkZWxldGVkXCIpKSA6IHVuZGVmaW5lZFxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNraXBBdG9taWModGFyZ2V0LCBwb3MsIGZvcndhcmQpIHtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2Ygdmlldy5FZGl0b3JWaWV3KVxuICAgICAgICBmb3IgKGxldCByYW5nZXMgb2YgdGFyZ2V0LnN0YXRlLmZhY2V0KHZpZXcuRWRpdG9yVmlldy5hdG9taWNSYW5nZXMpLm1hcChmID0+IGYodGFyZ2V0KSkpXG4gICAgICAgICAgICByYW5nZXMuYmV0d2Vlbihwb3MsIHBvcywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGZvcndhcmQgPyB0byA6IGZyb207XG4gICAgICAgICAgICB9KTtcbiAgICByZXR1cm4gcG9zO1xufVxuY29uc3QgZGVsZXRlQnlDaGFyID0gKHRhcmdldCwgZm9yd2FyZCwgYnlJbmRlbnRVbml0KSA9PiBkZWxldGVCeSh0YXJnZXQsIHJhbmdlID0+IHtcbiAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgeyBzdGF0ZTogc3RhdGUkMSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUkMS5kb2MubGluZUF0KHBvcyksIGJlZm9yZSwgdGFyZ2V0UG9zO1xuICAgIGlmIChieUluZGVudFVuaXQgJiYgIWZvcndhcmQgJiYgcG9zID4gbGluZS5mcm9tICYmIHBvcyA8IGxpbmUuZnJvbSArIDIwMCAmJlxuICAgICAgICAhL1teIFxcdF0vLnRlc3QoYmVmb3JlID0gbGluZS50ZXh0LnNsaWNlKDAsIHBvcyAtIGxpbmUuZnJvbSkpKSB7XG4gICAgICAgIGlmIChiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDFdID09IFwiXFx0XCIpXG4gICAgICAgICAgICByZXR1cm4gcG9zIC0gMTtcbiAgICAgICAgbGV0IGNvbCA9IHN0YXRlLmNvdW50Q29sdW1uKGJlZm9yZSwgc3RhdGUkMS50YWJTaXplKSwgZHJvcCA9IGNvbCAlIGxhbmd1YWdlLmdldEluZGVudFVuaXQoc3RhdGUkMSkgfHwgbGFuZ3VhZ2UuZ2V0SW5kZW50VW5pdChzdGF0ZSQxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcm9wICYmIGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMSAtIGldID09IFwiIFwiOyBpKyspXG4gICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgdGFyZ2V0UG9zID0gcG9zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0UG9zID0gc3RhdGUuZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZm9yd2FyZCwgZm9yd2FyZCkgKyBsaW5lLmZyb207XG4gICAgICAgIGlmICh0YXJnZXRQb3MgPT0gcG9zICYmIGxpbmUubnVtYmVyICE9IChmb3J3YXJkID8gc3RhdGUkMS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgIHRhcmdldFBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICBlbHNlIGlmICghZm9yd2FyZCAmJiAvW1xcdWZlMDAtXFx1ZmUwZl0vLnRlc3QobGluZS50ZXh0LnNsaWNlKHRhcmdldFBvcyAtIGxpbmUuZnJvbSwgcG9zIC0gbGluZS5mcm9tKSkpXG4gICAgICAgICAgICB0YXJnZXRQb3MgPSBzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgdGFyZ2V0UG9zIC0gbGluZS5mcm9tLCBmYWxzZSwgZmFsc2UpICsgbGluZS5mcm9tO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0UG9zO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgZm9yIGN1cnNvciBzZWxlY3Rpb25zLCB0aGUgY2hhcmFjdGVyIG9yXG5pbmRlbnRhdGlvbiB1bml0IGJlZm9yZSB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIGZhbHNlLCB0cnVlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgdGhlIGNoYXJhY3RlciBiZWZvcmUgdGhlIGN1cnNvci4gRG9lcyBub3RcbmltcGxlbWVudCBhbnkgZXh0ZW5kZWQgYmVoYXZpb3IgbGlrZSBkZWxldGluZyB3aG9sZSBpbmRlbnRhdGlvblxudW5pdHMgaW4gb25lIGdvLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJCYWNrd2FyZFN0cmljdCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIGZhbHNlLCBmYWxzZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyRm9yd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIHRydWUsIGZhbHNlKTtcbmNvbnN0IGRlbGV0ZUJ5R3JvdXAgPSAodGFyZ2V0LCBmb3J3YXJkKSA9PiBkZWxldGVCeSh0YXJnZXQsIHJhbmdlID0+IHtcbiAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgeyBzdGF0ZTogc3RhdGUkMSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUkMS5kb2MubGluZUF0KHBvcyk7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZSQxLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGZvciAobGV0IGNhdCA9IG51bGw7Oykge1xuICAgICAgICBpZiAocG9zID09IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gcmFuZ2UuaGVhZCAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlJDEuZG9jLmxpbmVzIDogMSkpXG4gICAgICAgICAgICAgICAgcG9zICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IHN0YXRlLmZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQpICsgbGluZS5mcm9tO1xuICAgICAgICBsZXQgbmV4dENoYXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4ocG9zLCBuZXh0KSAtIGxpbmUuZnJvbSwgTWF0aC5tYXgocG9zLCBuZXh0KSAtIGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0Q2hhcik7XG4gICAgICAgIGlmIChjYXQgIT0gbnVsbCAmJiBuZXh0Q2F0ICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dENoYXIgIT0gXCIgXCIgfHwgcG9zICE9IHJhbmdlLmhlYWQpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIGJhY2t3YXJkIHVudGlsIHRoZSBlbmQgb2YgdGhlIG5leHRcbltncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5R3JvdXApLCBvbmx5IHNraXBwaW5nIGdyb3VwcyBvZlxud2hpdGVzcGFjZSB3aGVuIHRoZXkgY29uc2lzdCBvZiBhIHNpbmdsZSBzcGFjZS5cbiovXG5jb25zdCBkZWxldGVHcm91cEJhY2t3YXJkID0gdGFyZ2V0ID0+IGRlbGV0ZUJ5R3JvdXAodGFyZ2V0LCBmYWxzZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIGZvcndhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dCBncm91cC5cbiovXG5jb25zdCBkZWxldGVHcm91cEZvcndhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIHRydWUpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgZW5kIG9mIHRoZSBsaW5lLiBJZiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IGF0IHRoZSBlbmQgb2YgdGhlXG5saW5lLCBkZWxldGUgdGhlIGxpbmUgYnJlYWsgYWZ0ZXIgaXQuXG4qL1xuY29uc3QgZGVsZXRlVG9MaW5lRW5kID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVFbmQgPSB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLnRvO1xuICAgIHJldHVybiByYW5nZS5oZWFkIDwgbGluZUVuZCA/IGxpbmVFbmQgOiBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIHJhbmdlLmhlYWQgKyAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGJlZm9yZSBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVTdGFydCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lU3RhcnQgPSB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb207XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPiBsaW5lU3RhcnQgPyBsaW5lU3RhcnQgOiBNYXRoLm1heCgwLCByYW5nZS5oZWFkIC0gMSk7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lIG9yIHRoZSBuZXh0IGxpbmUgd3JhcCBiZWZvcmUgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lU3RhcnQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZmFsc2UpLmhlYWQ7XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPiBsaW5lU3RhcnQgPyBsaW5lU3RhcnQgOiBNYXRoLm1heCgwLCByYW5nZS5oZWFkIC0gMSk7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIGVuZCBvZiB0aGUgbGluZSBvciB0aGUgbmV4dCBsaW5lIHdyYXAgYWZ0ZXIgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVTdGFydCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCB0cnVlKS5oZWFkO1xuICAgIHJldHVybiByYW5nZS5oZWFkIDwgbGluZVN0YXJ0ID8gbGluZVN0YXJ0IDogTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGVuZ3RoLCByYW5nZS5oZWFkICsgMSk7XG59KTtcbi8qKlxuRGVsZXRlIGFsbCB3aGl0ZXNwYWNlIGRpcmVjdGx5IGJlZm9yZSBhIGxpbmUgZW5kIGZyb20gdGhlXG5kb2N1bWVudC5cbiovXG5jb25zdCBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gMCwgcHJldiA9IFwiXCIsIGl0ZXIgPSBzdGF0ZS5kb2MuaXRlcigpOzspIHtcbiAgICAgICAgaXRlci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyLmxpbmVCcmVhayB8fCBpdGVyLmRvbmUpIHtcbiAgICAgICAgICAgIGxldCB0cmFpbGluZyA9IHByZXYuc2VhcmNoKC9cXHMrJC8pO1xuICAgICAgICAgICAgaWYgKHRyYWlsaW5nID4gLTEpXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogcG9zIC0gKHByZXYubGVuZ3RoIC0gdHJhaWxpbmcpLCB0bzogcG9zIH0pO1xuICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHByZXYgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldiA9IGl0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGl0ZXIudmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgY2hhbmdlcywgdXNlckV2ZW50OiBcImRlbGV0ZVwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgZWFjaCBzZWxlY3Rpb24gcmFuZ2Ugd2l0aCBhIGxpbmUgYnJlYWssIGxlYXZpbmcgdGhlIGN1cnNvclxub24gdGhlIGxpbmUgYmVmb3JlIHRoZSBicmVhay5cbiovXG5jb25zdCBzcGxpdExpbmUgPSAoeyBzdGF0ZTogc3RhdGUkMSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZSQxLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZSQxLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBzdGF0ZS5UZXh0Lm9mKFtcIlwiLCBcIlwiXSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20pIH07XG4gICAgfSk7XG4gICAgZGlzcGF0Y2goc3RhdGUkMS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRmxpcCB0aGUgY2hhcmFjdGVycyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjdXJzb3IocykuXG4qL1xuY29uc3QgdHJhbnNwb3NlQ2hhcnMgPSAoeyBzdGF0ZTogc3RhdGUkMSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZSQxLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZSQxLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5IHx8IHJhbmdlLmZyb20gPT0gMCB8fCByYW5nZS5mcm9tID09IHN0YXRlJDEuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgIGxldCBwb3MgPSByYW5nZS5mcm9tLCBsaW5lID0gc3RhdGUkMS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gcG9zID09IGxpbmUuZnJvbSA/IHBvcyAtIDEgOiBzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmYWxzZSkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCB0byA9IHBvcyA9PSBsaW5lLnRvID8gcG9zICsgMSA6IHN0YXRlLmZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIHRydWUpICsgbGluZS5mcm9tO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IHN0YXRlJDEuZG9jLnNsaWNlKHBvcywgdG8pLmFwcGVuZChzdGF0ZSQxLmRvYy5zbGljZShmcm9tLCBwb3MpKSB9LFxuICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pIH07XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlJDEudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJtb3ZlLmNoYXJhY3RlclwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpIHtcbiAgICBsZXQgYmxvY2tzID0gW10sIHVwdG8gPSAtMTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLCBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byk7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgJiYgcmFuZ2UudG8gPT0gZW5kTGluZS5mcm9tKVxuICAgICAgICAgICAgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8gLSAxKTtcbiAgICAgICAgaWYgKHVwdG8gPj0gc3RhcnRMaW5lLm51bWJlcikge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcHJldi50byA9IGVuZExpbmUudG87XG4gICAgICAgICAgICBwcmV2LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHsgZnJvbTogc3RhcnRMaW5lLmZyb20sIHRvOiBlbmRMaW5lLnRvLCByYW5nZXM6IFtyYW5nZV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXB0byA9IGVuZExpbmUubnVtYmVyICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2Nrcztcbn1cbmZ1bmN0aW9uIG1vdmVMaW5lKHN0YXRlJDEsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlJDEucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdLCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUkMSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQgPyBibG9jay50byA9PSBzdGF0ZSQxLmRvYy5sZW5ndGggOiBibG9jay5mcm9tID09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IG5leHRMaW5lID0gc3RhdGUkMS5kb2MubGluZUF0KGZvcndhcmQgPyBibG9jay50byArIDEgOiBibG9jay5mcm9tIC0gMSk7XG4gICAgICAgIGxldCBzaXplID0gbmV4dExpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLnRvLCB0bzogbmV4dExpbmUudG8gfSwgeyBmcm9tOiBibG9jay5mcm9tLCBpbnNlcnQ6IG5leHRMaW5lLnRleHQgKyBzdGF0ZSQxLmxpbmVCcmVhayB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgYmxvY2sucmFuZ2VzKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHN0YXRlLkVkaXRvclNlbGVjdGlvbi5yYW5nZShNYXRoLm1pbihzdGF0ZSQxLmRvYy5sZW5ndGgsIHIuYW5jaG9yICsgc2l6ZSksIE1hdGgubWluKHN0YXRlJDEuZG9jLmxlbmd0aCwgci5oZWFkICsgc2l6ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG5leHRMaW5lLmZyb20sIHRvOiBibG9jay5mcm9tIH0sIHsgZnJvbTogYmxvY2sudG8sIGluc2VydDogc3RhdGUkMS5saW5lQnJlYWsgKyBuZXh0TGluZS50ZXh0IH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuYW5jaG9yIC0gc2l6ZSwgci5oZWFkIC0gc2l6ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZSQxLnVwZGF0ZSh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBzZWxlY3Rpb246IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzdGF0ZSQxLnNlbGVjdGlvbi5tYWluSW5kZXgpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwibW92ZS5saW5lXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGVkIGxpbmVzIHVwIG9uZSBsaW5lLlxuKi9cbmNvbnN0IG1vdmVMaW5lVXAgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGVkIGxpbmVzIGRvd24gb25lIGxpbmUuXG4qL1xuY29uc3QgbW92ZUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZvcndhcmQpIHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGJsb2NrIG9mIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay5mcm9tLCBpbnNlcnQ6IHN0YXRlLmRvYy5zbGljZShibG9jay5mcm9tLCBibG9jay50bykgKyBzdGF0ZS5saW5lQnJlYWsgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIHN0YXRlLmRvYy5zbGljZShibG9jay5mcm9tLCBibG9jay50bykgfSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGNoYW5nZXMsIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXQuY29weWxpbmVcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkNyZWF0ZSBhIGNvcHkgb2YgdGhlIHNlbGVjdGVkIGxpbmVzLiBLZWVwIHRoZSBzZWxlY3Rpb24gaW4gdGhlIHRvcCBjb3B5LlxuKi9cbmNvbnN0IGNvcHlMaW5lVXAgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4vKipcbkNyZWF0ZSBhIGNvcHkgb2YgdGhlIHNlbGVjdGVkIGxpbmVzLiBLZWVwIHRoZSBzZWxlY3Rpb24gaW4gdGhlIGJvdHRvbSBjb3B5LlxuKi9cbmNvbnN0IGNvcHlMaW5lRG93biA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuLyoqXG5EZWxldGUgc2VsZWN0ZWQgbGluZXMuXG4qL1xuY29uc3QgZGVsZXRlTGluZSA9IHZpZXcgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VzKHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkubWFwKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICBlbHNlIGlmICh0byA8IHN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICB0bysrO1xuICAgICAgICByZXR1cm4geyBmcm9tLCB0byB9O1xuICAgIH0pKTtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgZGlzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHZpZXcubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLCBwb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHJhbmdlLmhlYWQsIHJhbmdlLmFzc29jIHx8IDEpO1xuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICBkaXN0ID0gKGJsb2NrLmJvdHRvbSArIHZpZXcuZG9jdW1lbnRUb3ApIC0gcG9zLmJvdHRvbSArIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCB0cnVlLCBkaXN0KTtcbiAgICB9KS5tYXAoY2hhbmdlcyk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGNoYW5nZXMsIHNlbGVjdGlvbiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJkZWxldGUubGluZVwiIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHN0YXRlLmxpbmVCcmVhayksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBhbmQgdGhlIHNhbWUgYW1vdW50IG9mXG5pbmRlbnRhdGlvbiBhcyB0aGUgbGluZSBhYm92ZS5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lS2VlcEluZGVudCA9ICh7IHN0YXRlOiBzdGF0ZSQxLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc3RhdGUkMS51cGRhdGUoc3RhdGUkMS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IC9eXFxzKi8uZXhlYyhzdGF0ZSQxLmRvYy5saW5lQXQocmFuZ2UuZnJvbSkudGV4dClbMF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBzdGF0ZSQxLmxpbmVCcmVhayArIGluZGVudCB9LFxuICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGluZGVudC5sZW5ndGggKyAxKVxuICAgICAgICB9O1xuICAgIH0pLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIHBvcykge1xuICAgIGlmICgvXFwoXFwpfFxcW1xcXXxcXHtcXH0vLnRlc3Qoc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zICsgMSkpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MgfTtcbiAgICBsZXQgY29udGV4dCA9IGxhbmd1YWdlLnN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MpO1xuICAgIGxldCBiZWZvcmUgPSBjb250ZXh0LmNoaWxkQmVmb3JlKHBvcyksIGFmdGVyID0gY29udGV4dC5jaGlsZEFmdGVyKHBvcyksIGNsb3NlZEJ5O1xuICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIgJiYgYmVmb3JlLnRvIDw9IHBvcyAmJiBhZnRlci5mcm9tID49IHBvcyAmJlxuICAgICAgICAoY2xvc2VkQnkgPSBiZWZvcmUudHlwZS5wcm9wKGNvbW1vbi5Ob2RlUHJvcC5jbG9zZWRCeSkpICYmIGNsb3NlZEJ5LmluZGV4T2YoYWZ0ZXIubmFtZSkgPiAtMSAmJlxuICAgICAgICBzdGF0ZS5kb2MubGluZUF0KGJlZm9yZS50bykuZnJvbSA9PSBzdGF0ZS5kb2MubGluZUF0KGFmdGVyLmZyb20pLmZyb20gJiZcbiAgICAgICAgIS9cXFMvLnRlc3Qoc3RhdGUuc2xpY2VEb2MoYmVmb3JlLnRvLCBhZnRlci5mcm9tKSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IGJlZm9yZS50bywgdG86IGFmdGVyLmZyb20gfTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGFuZCBpbmRlbnQgdGhlIG5ld2x5IGNyZWF0ZWRcbmxpbmUocykuIElmIHRoZSBjdXJyZW50IGxpbmUgY29uc2lzdHMgb25seSBvZiB3aGl0ZXNwYWNlLCB0aGlzXG53aWxsIGFsc28gZGVsZXRlIHRoYXQgd2hpdGVzcGFjZS4gV2hlbiB0aGUgY3Vyc29yIGlzIGJldHdlZW5cbm1hdGNoaW5nIGJyYWNrZXRzLCBhbiBhZGRpdGlvbmFsIG5ld2xpbmUgd2lsbCBiZSBpbnNlcnRlZCBhZnRlclxudGhlIGN1cnNvci5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lQW5kSW5kZW50ID0gbmV3bGluZUFuZEluZGVudChmYWxzZSk7XG4vKipcbkNyZWF0ZSBhIGJsYW5rLCBpbmRlbnRlZCBsaW5lIGJlbG93IHRoZSBjdXJyZW50IGxpbmUuXG4qL1xuY29uc3QgaW5zZXJ0QmxhbmtMaW5lID0gbmV3bGluZUFuZEluZGVudCh0cnVlKTtcbmZ1bmN0aW9uIG5ld2xpbmVBbmRJbmRlbnQoYXRFb2YpIHtcbiAgICByZXR1cm4gKHsgc3RhdGU6IHN0YXRlJDEsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlJDEucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gc3RhdGUkMS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZSwgbGluZSA9IHN0YXRlJDEuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGxldCBleHBsb2RlID0gIWF0RW9mICYmIGZyb20gPT0gdG8gJiYgaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUkMSwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoYXRFb2YpXG4gICAgICAgICAgICAgICAgZnJvbSA9IHRvID0gKHRvIDw9IGxpbmUudG8gPyBsaW5lIDogc3RhdGUkMS5kb2MubGluZUF0KHRvKSkudG87XG4gICAgICAgICAgICBsZXQgY3ggPSBuZXcgbGFuZ3VhZ2UuSW5kZW50Q29udGV4dChzdGF0ZSQxLCB7IHNpbXVsYXRlQnJlYWs6IGZyb20sIHNpbXVsYXRlRG91YmxlQnJlYWs6ICEhZXhwbG9kZSB9KTtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSBsYW5ndWFnZS5nZXRJbmRlbnRhdGlvbihjeCwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gc3RhdGUuY291bnRDb2x1bW4oL15cXHMqLy5leGVjKHN0YXRlJDEuZG9jLmxpbmVBdChmcm9tKS50ZXh0KVswXSwgc3RhdGUkMS50YWJTaXplKTtcbiAgICAgICAgICAgIHdoaWxlICh0byA8IGxpbmUudG8gJiYgL1xccy8udGVzdChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dKSlcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgKHsgZnJvbSwgdG8gfSA9IGV4cGxvZGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA+IGxpbmUuZnJvbSAmJiBmcm9tIDwgbGluZS5mcm9tICsgMTAwICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dC5zbGljZSgwLCBmcm9tKSkpXG4gICAgICAgICAgICAgICAgZnJvbSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBbXCJcIiwgbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKHN0YXRlJDEsIGluZGVudCldO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2gobGFuZ3VhZ2UuaW5kZW50U3RyaW5nKHN0YXRlJDEsIGN4LmxpbmVJbmRlbnQobGluZS5mcm9tLCAtMSkpKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogc3RhdGUuVGV4dC5vZihpbnNlcnQpIH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSArIDEgKyBpbnNlcnRbMV0ubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUkMS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUkMSwgZikge1xuICAgIGxldCBhdExpbmUgPSAtMTtcbiAgICByZXR1cm4gc3RhdGUkMS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gcmFuZ2UuZnJvbTsgcG9zIDw9IHJhbmdlLnRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZSQxLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA+IGF0TGluZSAmJiAocmFuZ2UuZW1wdHkgfHwgcmFuZ2UudG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgZihsaW5lLCBjaGFuZ2VzLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgYXRMaW5lID0gbGluZS5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUkMS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzLFxuICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5yYW5nZShjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmFuY2hvciwgMSksIGNoYW5nZVNldC5tYXBQb3MocmFuZ2UuaGVhZCwgMSkpIH07XG4gICAgfSk7XG59XG4vKipcbkF1dG8taW5kZW50IHRoZSBzZWxlY3RlZCBsaW5lcy4gVGhpcyB1c2VzIHRoZSBbaW5kZW50YXRpb24gc2VydmljZVxuZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkgYXMgc291cmNlIGZvciBhdXRvLWluZGVudFxuaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgaW5kZW50U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgbGFuZ3VhZ2UuSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB1cGRhdGVkW3N0YXJ0XTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCA9PSBudWxsID8gLTEgOiBmb3VuZDtcbiAgICAgICAgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcywgcmFuZ2UpID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IGxhbmd1YWdlLmdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXG4gICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGxldCBub3JtID0gbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICBpZiAoY3VyICE9IG5vcm0gfHwgcmFuZ2UuZnJvbSA8IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyB1c2VyRXZlbnQ6IFwiaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQWRkIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gdG8gYWxsIHNlbGVjdGVkXG5saW5lcy5cbiovXG5jb25zdCBpbmRlbnRNb3JlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0OiBzdGF0ZS5mYWNldChsYW5ndWFnZS5pbmRlbnRVbml0KSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVtb3ZlIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gZnJvbSBhbGxcbnNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGluZGVudExlc3MgPSAoeyBzdGF0ZTogc3RhdGUkMSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZSQxLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUkMS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUkMSwgKGxpbmUsIGNoYW5nZXMpID0+IHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGlmICghc3BhY2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb2wgPSBzdGF0ZS5jb3VudENvbHVtbihzcGFjZSwgc3RhdGUkMS50YWJTaXplKSwga2VlcCA9IDA7XG4gICAgICAgIGxldCBpbnNlcnQgPSBsYW5ndWFnZS5pbmRlbnRTdHJpbmcoc3RhdGUkMSwgTWF0aC5tYXgoMCwgY29sIC0gbGFuZ3VhZ2UuZ2V0SW5kZW50VW5pdChzdGF0ZSQxKSkpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IHNwYWNlLmxlbmd0aCAmJiBrZWVwIDwgaW5zZXJ0Lmxlbmd0aCAmJiBzcGFjZS5jaGFyQ29kZUF0KGtlZXApID09IGluc2VydC5jaGFyQ29kZUF0KGtlZXApKVxuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBrZWVwLCB0bzogbGluZS5mcm9tICsgc3BhY2UubGVuZ3RoLCBpbnNlcnQ6IGluc2VydC5zbGljZShrZWVwKSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiZGVsZXRlLmRlZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkVuYWJsZXMgb3IgZGlzYWJsZXNcblt0YWItZm9jdXMgbW9kZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuc2V0VGFiRm9jdXNNb2RlKS4gV2hpbGUgb24sIHRoaXNcbnByZXZlbnRzIHRoZSBlZGl0b3IncyBrZXkgYmluZGluZ3MgZnJvbSBjYXB0dXJpbmcgVGFiIG9yXG5TaGlmdC1UYWIsIG1ha2luZyBpdCBwb3NzaWJsZSBmb3IgdGhlIHVzZXIgdG8gbW92ZSBmb2N1cyBvdXQgb2ZcbnRoZSBlZGl0b3Igd2l0aCB0aGUga2V5Ym9hcmQuXG4qL1xuY29uc3QgdG9nZ2xlVGFiRm9jdXNNb2RlID0gdmlldyA9PiB7XG4gICAgdmlldy5zZXRUYWJGb2N1c01vZGUoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblRlbXBvcmFyaWx5IGVuYWJsZXMgW3RhYi1mb2N1c1xubW9kZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuc2V0VGFiRm9jdXNNb2RlKSBmb3IgdHdvIHNlY29uZHMgb3IgdW50aWxcbmFub3RoZXIga2V5IGlzIHByZXNzZWQuXG4qL1xuY29uc3QgdGVtcG9yYXJpbHlTZXRUYWJGb2N1c01vZGUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LnNldFRhYkZvY3VzTW9kZSgyMDAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkluc2VydCBhIHRhYiBjaGFyYWN0ZXIgYXQgdGhlIGN1cnNvciBvciwgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkLFxudXNlIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgdG8gaW5kZW50IHRoZSBlbnRpcmVcbnNlbGVjdGlvbi5cbiovXG5jb25zdCBpbnNlcnRUYWIgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiAhci5lbXB0eSkpXG4gICAgICAgIHJldHVybiBpbmRlbnRNb3JlKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKFwiXFx0XCIpLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BcnJheSBvZiBrZXkgYmluZGluZ3MgY29udGFpbmluZyB0aGUgRW1hY3Mtc3R5bGUgYmluZGluZ3MgdGhhdCBhcmVcbmF2YWlsYWJsZSBvbiBtYWNPUyBieSBkZWZhdWx0LlxuXG4gLSBDdHJsLWI6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWY6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1wOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtbjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIEN0cmwtYTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWU6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZDogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLWg6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBDdHJsLWs6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpXG4gLSBDdHJsLUFsdC1oOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLW86IFtgc3BsaXRMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdExpbmUpXG4gLSBDdHJsLXQ6IFtgdHJhbnNwb3NlQ2hhcnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRyYW5zcG9zZUNoYXJzKVxuIC0gQ3RybC12OiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bilcbiAtIEFsdC12OiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKVxuKi9cbmNvbnN0IGVtYWNzU3R5bGVLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1iXCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJDdHJsLWZcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQgfSxcbiAgICB7IGtleTogXCJDdHJsLXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAgfSxcbiAgICB7IGtleTogXCJDdHJsLW5cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1hXCIsIHJ1bjogY3Vyc29yTGluZVN0YXJ0LCBzaGlmdDogc2VsZWN0TGluZVN0YXJ0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1lXCIsIHJ1bjogY3Vyc29yTGluZUVuZCwgc2hpZnQ6IHNlbGVjdExpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWRcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtaFwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwta1wiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LWhcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1vXCIsIHJ1bjogc3BsaXRMaW5lIH0sXG4gICAgeyBrZXk6IFwiQ3RybC10XCIsIHJ1bjogdHJhbnNwb3NlQ2hhcnMgfSxcbiAgICB7IGtleTogXCJDdHJsLXZcIiwgcnVuOiBjdXJzb3JQYWdlRG93biB9LFxuXTtcbi8qKlxuQW4gYXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNsb3NlbHkgc3RpY2tpbmcgdG8gcGxhdGZvcm0tc3RhbmRhcmQgb3JcbndpZGVseSB1c2VkIGJpbmRpbmdzLiAoVGhpcyBpbmNsdWRlcyB0aGUgYmluZGluZ3MgZnJvbVxuW2BlbWFjc1N0eWxlS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5lbWFjc1N0eWxlS2V5bWFwKSwgd2l0aCB0aGVpciBga2V5YFxucHJvcGVydHkgY2hhbmdlZCB0byBgbWFjYC4pXG5cbiAtIEFycm93TGVmdDogW2BjdXJzb3JDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhckxlZnQpIChbYHNlbGVjdENoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyTGVmdCkgd2l0aCBTaGlmdClcbiAtIEFycm93UmlnaHQ6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd0xlZnQgKEFsdC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSAoW2BzZWxlY3RHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwTGVmdCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dSaWdodCAoQWx0LUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwUmlnaHQpIChbYHNlbGVjdEdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dMZWZ0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93UmlnaHQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRW5kKSAoW2BzZWxlY3RMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dVcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBBcnJvd0Rvd246IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dEb3duIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBQYWdlVXA6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZURvd246IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBIb21lOiBbYGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCkgKFtgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gRW5kOiBbYGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUhvbWUgKENtZC1Ib21lIG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtRW5kIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpIChbYHNlbGVjdERvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jRW5kKSB3aXRoIFNoaWZ0KVxuIC0gRW50ZXIgYW5kIFNoaWZ0LUVudGVyOiBbYGluc2VydE5ld2xpbmVBbmRJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydE5ld2xpbmVBbmRJbmRlbnQpXG4gLSBDdHJsLWEgKENtZC1hIG9uIG1hY09TKTogW2BzZWxlY3RBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEFsbClcbiAtIEJhY2tzcGFjZTogW2BkZWxldGVDaGFyQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJCYWNrd2FyZClcbiAtIERlbGV0ZTogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLUJhY2tzcGFjZSAoQWx0LUJhY2tzcGFjZSBvbiBtYWNPUyk6IFtgZGVsZXRlR3JvdXBCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBCYWNrd2FyZClcbiAtIEN0cmwtRGVsZXRlIChBbHQtRGVsZXRlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwRm9yd2FyZClcbiAtIENtZC1CYWNrc3BhY2UgKG1hY09TKTogW2BkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQpLlxuIC0gQ21kLURlbGV0ZSAobWFjT1MpOiBbYGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQpLlxuKi9cbmNvbnN0IHN0YW5kYXJkS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkFycm93TGVmdFwiLCBydW46IGN1cnNvckNoYXJMZWZ0LCBzaGlmdDogc2VsZWN0Q2hhckxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFycm93TGVmdFwiLCBtYWM6IFwiQWx0LUFycm93TGVmdFwiLCBydW46IGN1cnNvckdyb3VwTGVmdCwgc2hpZnQ6IHNlbGVjdEdyb3VwTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckNoYXJSaWdodCwgc2hpZnQ6IHNlbGVjdENoYXJSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtQXJyb3dSaWdodFwiLCBtYWM6IFwiQWx0LUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JHcm91cFJpZ2h0LCBzaGlmdDogc2VsZWN0R3JvdXBSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0LCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dVcFwiLCBydW46IGN1cnNvckxpbmVVcCwgc2hpZnQ6IHNlbGVjdExpbmVVcCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dVcFwiLCBydW46IGN1cnNvckRvY1N0YXJ0LCBzaGlmdDogc2VsZWN0RG9jU3RhcnQgfSxcbiAgICB7IG1hYzogXCJDdHJsLUFycm93VXBcIiwgcnVuOiBjdXJzb3JQYWdlVXAsIHNoaWZ0OiBzZWxlY3RQYWdlVXAgfSxcbiAgICB7IGtleTogXCJBcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JEb2NFbmQsIHNoaWZ0OiBzZWxlY3REb2NFbmQgfSxcbiAgICB7IG1hYzogXCJDdHJsLUFycm93RG93blwiLCBydW46IGN1cnNvclBhZ2VEb3duLCBzaGlmdDogc2VsZWN0UGFnZURvd24gfSxcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiBjdXJzb3JQYWdlVXAsIHNoaWZ0OiBzZWxlY3RQYWdlVXAgfSxcbiAgICB7IGtleTogXCJQYWdlRG93blwiLCBydW46IGN1cnNvclBhZ2VEb3duLCBzaGlmdDogc2VsZWN0UGFnZURvd24gfSxcbiAgICB7IGtleTogXCJIb21lXCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtSG9tZVwiLCBydW46IGN1cnNvckRvY1N0YXJ0LCBzaGlmdDogc2VsZWN0RG9jU3RhcnQgfSxcbiAgICB7IGtleTogXCJFbmRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtRW5kXCIsIHJ1bjogY3Vyc29yRG9jRW5kLCBzaGlmdDogc2VsZWN0RG9jRW5kIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBpbnNlcnROZXdsaW5lQW5kSW5kZW50LCBzaGlmdDogaW5zZXJ0TmV3bGluZUFuZEluZGVudCB9LFxuICAgIHsga2V5OiBcIk1vZC1hXCIsIHJ1bjogc2VsZWN0QWxsIH0sXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQ2hhckJhY2t3YXJkLCBzaGlmdDogZGVsZXRlQ2hhckJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiRGVsZXRlXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJNb2QtQmFja3NwYWNlXCIsIG1hYzogXCJBbHQtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1EZWxldGVcIiwgbWFjOiBcIkFsdC1EZWxldGVcIiwgcnVuOiBkZWxldGVHcm91cEZvcndhcmQgfSxcbiAgICB7IG1hYzogXCJNb2QtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQgfSxcbiAgICB7IG1hYzogXCJNb2QtRGVsZXRlXCIsIHJ1bjogZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCB9XG5dLmNvbmNhdChlbWFjc1N0eWxlS2V5bWFwLm1hcChiID0+ICh7IG1hYzogYi5rZXksIHJ1bjogYi5ydW4sIHNoaWZ0OiBiLnNoaWZ0IH0pKSk7XG4vKipcblRoZSBkZWZhdWx0IGtleW1hcC4gSW5jbHVkZXMgYWxsIGJpbmRpbmdzIGZyb21cbltgc3RhbmRhcmRLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnN0YW5kYXJkS2V5bWFwKSBwbHVzIHRoZSBmb2xsb3dpbmc6XG5cbi0gQWx0LUFycm93TGVmdCAoQ3RybC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheExlZnQpIChbYHNlbGVjdFN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheExlZnQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1JpZ2h0IChDdHJsLUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhSaWdodCkgKFtgc2VsZWN0U3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheFJpZ2h0KSB3aXRoIFNoaWZ0KVxuLSBBbHQtQXJyb3dVcDogW2Btb3ZlTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZVVwKVxuLSBBbHQtQXJyb3dEb3duOiBbYG1vdmVMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMubW92ZUxpbmVEb3duKVxuLSBTaGlmdC1BbHQtQXJyb3dVcDogW2Bjb3B5TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZVVwKVxuLSBTaGlmdC1BbHQtQXJyb3dEb3duOiBbYGNvcHlMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY29weUxpbmVEb3duKVxuLSBFc2NhcGU6IFtgc2ltcGxpZnlTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNpbXBsaWZ5U2VsZWN0aW9uKVxuLSBDdHJsLUVudGVyIChDbWQtRW50ZXIgb24gbWFjT1MpOiBbYGluc2VydEJsYW5rTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5zZXJ0QmxhbmtMaW5lKVxuLSBBbHQtbCAoQ3RybC1sIG9uIG1hY09TKTogW2BzZWxlY3RMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lKVxuLSBDdHJsLWkgKENtZC1pIG9uIG1hY09TKTogW2BzZWxlY3RQYXJlbnRTeW50YXhgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhcmVudFN5bnRheClcbi0gQ3RybC1bIChDbWQtWyBvbiBtYWNPUyk6IFtgaW5kZW50TGVzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TGVzcylcbi0gQ3RybC1dIChDbWQtXSBvbiBtYWNPUyk6IFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSlcbi0gQ3RybC1BbHQtXFxcXCAoQ21kLUFsdC1cXFxcIG9uIG1hY09TKTogW2BpbmRlbnRTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudFNlbGVjdGlvbilcbi0gU2hpZnQtQ3RybC1rIChTaGlmdC1DbWQtayBvbiBtYWNPUyk6IFtgZGVsZXRlTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlTGluZSlcbi0gU2hpZnQtQ3RybC1cXFxcIChTaGlmdC1DbWQtXFxcXCBvbiBtYWNPUyk6IFtgY3Vyc29yTWF0Y2hpbmdCcmFja2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JNYXRjaGluZ0JyYWNrZXQpXG4tIEN0cmwtLyAoQ21kLS8gb24gbWFjT1MpOiBbYHRvZ2dsZUNvbW1lbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRvZ2dsZUNvbW1lbnQpLlxuLSBTaGlmdC1BbHQtYTogW2B0b2dnbGVCbG9ja0NvbW1lbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRvZ2dsZUJsb2NrQ29tbWVudCkuXG4tIEN0cmwtbSAoQWx0LVNoaWZ0LW0gb24gbWFjT1MpOiBbYHRvZ2dsZVRhYkZvY3VzTW9kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudG9nZ2xlVGFiRm9jdXNNb2RlKS5cbiovXG5jb25zdCBkZWZhdWx0S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkFsdC1BcnJvd0xlZnRcIiwgbWFjOiBcIkN0cmwtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yU3ludGF4TGVmdCwgc2hpZnQ6IHNlbGVjdFN5bnRheExlZnQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dSaWdodFwiLCBtYWM6IFwiQ3RybC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yU3ludGF4UmlnaHQsIHNoaWZ0OiBzZWxlY3RTeW50YXhSaWdodCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1VwXCIsIHJ1bjogbW92ZUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd1VwXCIsIHJ1bjogY29weUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd0Rvd25cIiwgcnVuOiBtb3ZlTGluZURvd24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dEb3duXCIsIHJ1bjogY29weUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogc2ltcGxpZnlTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJNb2QtRW50ZXJcIiwgcnVuOiBpbnNlcnRCbGFua0xpbmUgfSxcbiAgICB7IGtleTogXCJBbHQtbFwiLCBtYWM6IFwiQ3RybC1sXCIsIHJ1bjogc2VsZWN0TGluZSB9LFxuICAgIHsga2V5OiBcIk1vZC1pXCIsIHJ1bjogc2VsZWN0UGFyZW50U3ludGF4LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1bXCIsIHJ1bjogaW5kZW50TGVzcyB9LFxuICAgIHsga2V5OiBcIk1vZC1dXCIsIHJ1bjogaW5kZW50TW9yZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BbHQtXFxcXFwiLCBydW46IGluZGVudFNlbGVjdGlvbiB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1rXCIsIHJ1bjogZGVsZXRlTGluZSB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1cXFxcXCIsIHJ1bjogY3Vyc29yTWF0Y2hpbmdCcmFja2V0IH0sXG4gICAgeyBrZXk6IFwiTW9kLS9cIiwgcnVuOiB0b2dnbGVDb21tZW50IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFcIiwgcnVuOiB0b2dnbGVCbG9ja0NvbW1lbnQgfSxcbiAgICB7IGtleTogXCJDdHJsLW1cIiwgbWFjOiBcIlNoaWZ0LUFsdC1tXCIsIHJ1bjogdG9nZ2xlVGFiRm9jdXNNb2RlIH0sXG5dLmNvbmNhdChzdGFuZGFyZEtleW1hcCk7XG4vKipcbkEgYmluZGluZyB0aGF0IGJpbmRzIFRhYiB0byBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIGFuZFxuU2hpZnQtVGFiIHRvIFtgaW5kZW50TGVzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TGVzcykuXG5QbGVhc2Ugc2VlIHRoZSBbVGFiIGV4YW1wbGVdKC4uLy4uL2V4YW1wbGVzL3RhYi8pIGJlZm9yZSB1c2luZ1xudGhpcy5cbiovXG5jb25zdCBpbmRlbnRXaXRoVGFiID0geyBrZXk6IFwiVGFiXCIsIHJ1bjogaW5kZW50TW9yZSwgc2hpZnQ6IGluZGVudExlc3MgfTtcblxuZXhwb3J0cy5ibG9ja0NvbW1lbnQgPSBibG9ja0NvbW1lbnQ7XG5leHBvcnRzLmJsb2NrVW5jb21tZW50ID0gYmxvY2tVbmNvbW1lbnQ7XG5leHBvcnRzLmNvcHlMaW5lRG93biA9IGNvcHlMaW5lRG93bjtcbmV4cG9ydHMuY29weUxpbmVVcCA9IGNvcHlMaW5lVXA7XG5leHBvcnRzLmN1cnNvckNoYXJCYWNrd2FyZCA9IGN1cnNvckNoYXJCYWNrd2FyZDtcbmV4cG9ydHMuY3Vyc29yQ2hhckJhY2t3YXJkTG9naWNhbCA9IGN1cnNvckNoYXJCYWNrd2FyZExvZ2ljYWw7XG5leHBvcnRzLmN1cnNvckNoYXJGb3J3YXJkID0gY3Vyc29yQ2hhckZvcndhcmQ7XG5leHBvcnRzLmN1cnNvckNoYXJGb3J3YXJkTG9naWNhbCA9IGN1cnNvckNoYXJGb3J3YXJkTG9naWNhbDtcbmV4cG9ydHMuY3Vyc29yQ2hhckxlZnQgPSBjdXJzb3JDaGFyTGVmdDtcbmV4cG9ydHMuY3Vyc29yQ2hhclJpZ2h0ID0gY3Vyc29yQ2hhclJpZ2h0O1xuZXhwb3J0cy5jdXJzb3JEb2NFbmQgPSBjdXJzb3JEb2NFbmQ7XG5leHBvcnRzLmN1cnNvckRvY1N0YXJ0ID0gY3Vyc29yRG9jU3RhcnQ7XG5leHBvcnRzLmN1cnNvckdyb3VwQmFja3dhcmQgPSBjdXJzb3JHcm91cEJhY2t3YXJkO1xuZXhwb3J0cy5jdXJzb3JHcm91cEZvcndhcmQgPSBjdXJzb3JHcm91cEZvcndhcmQ7XG5leHBvcnRzLmN1cnNvckdyb3VwTGVmdCA9IGN1cnNvckdyb3VwTGVmdDtcbmV4cG9ydHMuY3Vyc29yR3JvdXBSaWdodCA9IGN1cnNvckdyb3VwUmlnaHQ7XG5leHBvcnRzLmN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkID0gY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQ7XG5leHBvcnRzLmN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQgPSBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkO1xuZXhwb3J0cy5jdXJzb3JMaW5lQm91bmRhcnlMZWZ0ID0gY3Vyc29yTGluZUJvdW5kYXJ5TGVmdDtcbmV4cG9ydHMuY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQgPSBjdXJzb3JMaW5lQm91bmRhcnlSaWdodDtcbmV4cG9ydHMuY3Vyc29yTGluZURvd24gPSBjdXJzb3JMaW5lRG93bjtcbmV4cG9ydHMuY3Vyc29yTGluZUVuZCA9IGN1cnNvckxpbmVFbmQ7XG5leHBvcnRzLmN1cnNvckxpbmVTdGFydCA9IGN1cnNvckxpbmVTdGFydDtcbmV4cG9ydHMuY3Vyc29yTGluZVVwID0gY3Vyc29yTGluZVVwO1xuZXhwb3J0cy5jdXJzb3JNYXRjaGluZ0JyYWNrZXQgPSBjdXJzb3JNYXRjaGluZ0JyYWNrZXQ7XG5leHBvcnRzLmN1cnNvclBhZ2VEb3duID0gY3Vyc29yUGFnZURvd247XG5leHBvcnRzLmN1cnNvclBhZ2VVcCA9IGN1cnNvclBhZ2VVcDtcbmV4cG9ydHMuY3Vyc29yU3Vid29yZEJhY2t3YXJkID0gY3Vyc29yU3Vid29yZEJhY2t3YXJkO1xuZXhwb3J0cy5jdXJzb3JTdWJ3b3JkRm9yd2FyZCA9IGN1cnNvclN1YndvcmRGb3J3YXJkO1xuZXhwb3J0cy5jdXJzb3JTeW50YXhMZWZ0ID0gY3Vyc29yU3ludGF4TGVmdDtcbmV4cG9ydHMuY3Vyc29yU3ludGF4UmlnaHQgPSBjdXJzb3JTeW50YXhSaWdodDtcbmV4cG9ydHMuZGVmYXVsdEtleW1hcCA9IGRlZmF1bHRLZXltYXA7XG5leHBvcnRzLmRlbGV0ZUNoYXJCYWNrd2FyZCA9IGRlbGV0ZUNoYXJCYWNrd2FyZDtcbmV4cG9ydHMuZGVsZXRlQ2hhckJhY2t3YXJkU3RyaWN0ID0gZGVsZXRlQ2hhckJhY2t3YXJkU3RyaWN0O1xuZXhwb3J0cy5kZWxldGVDaGFyRm9yd2FyZCA9IGRlbGV0ZUNoYXJGb3J3YXJkO1xuZXhwb3J0cy5kZWxldGVHcm91cEJhY2t3YXJkID0gZGVsZXRlR3JvdXBCYWNrd2FyZDtcbmV4cG9ydHMuZGVsZXRlR3JvdXBGb3J3YXJkID0gZGVsZXRlR3JvdXBGb3J3YXJkO1xuZXhwb3J0cy5kZWxldGVMaW5lID0gZGVsZXRlTGluZTtcbmV4cG9ydHMuZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQgPSBkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZDtcbmV4cG9ydHMuZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCA9IGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQ7XG5leHBvcnRzLmRlbGV0ZVRvTGluZUVuZCA9IGRlbGV0ZVRvTGluZUVuZDtcbmV4cG9ydHMuZGVsZXRlVG9MaW5lU3RhcnQgPSBkZWxldGVUb0xpbmVTdGFydDtcbmV4cG9ydHMuZGVsZXRlVHJhaWxpbmdXaGl0ZXNwYWNlID0gZGVsZXRlVHJhaWxpbmdXaGl0ZXNwYWNlO1xuZXhwb3J0cy5lbWFjc1N0eWxlS2V5bWFwID0gZW1hY3NTdHlsZUtleW1hcDtcbmV4cG9ydHMuaGlzdG9yeSA9IGhpc3Rvcnk7XG5leHBvcnRzLmhpc3RvcnlGaWVsZCA9IGhpc3RvcnlGaWVsZDtcbmV4cG9ydHMuaGlzdG9yeUtleW1hcCA9IGhpc3RvcnlLZXltYXA7XG5leHBvcnRzLmluZGVudExlc3MgPSBpbmRlbnRMZXNzO1xuZXhwb3J0cy5pbmRlbnRNb3JlID0gaW5kZW50TW9yZTtcbmV4cG9ydHMuaW5kZW50U2VsZWN0aW9uID0gaW5kZW50U2VsZWN0aW9uO1xuZXhwb3J0cy5pbmRlbnRXaXRoVGFiID0gaW5kZW50V2l0aFRhYjtcbmV4cG9ydHMuaW5zZXJ0QmxhbmtMaW5lID0gaW5zZXJ0QmxhbmtMaW5lO1xuZXhwb3J0cy5pbnNlcnROZXdsaW5lID0gaW5zZXJ0TmV3bGluZTtcbmV4cG9ydHMuaW5zZXJ0TmV3bGluZUFuZEluZGVudCA9IGluc2VydE5ld2xpbmVBbmRJbmRlbnQ7XG5leHBvcnRzLmluc2VydE5ld2xpbmVLZWVwSW5kZW50ID0gaW5zZXJ0TmV3bGluZUtlZXBJbmRlbnQ7XG5leHBvcnRzLmluc2VydFRhYiA9IGluc2VydFRhYjtcbmV4cG9ydHMuaW52ZXJ0ZWRFZmZlY3RzID0gaW52ZXJ0ZWRFZmZlY3RzO1xuZXhwb3J0cy5pc29sYXRlSGlzdG9yeSA9IGlzb2xhdGVIaXN0b3J5O1xuZXhwb3J0cy5saW5lQ29tbWVudCA9IGxpbmVDb21tZW50O1xuZXhwb3J0cy5saW5lVW5jb21tZW50ID0gbGluZVVuY29tbWVudDtcbmV4cG9ydHMubW92ZUxpbmVEb3duID0gbW92ZUxpbmVEb3duO1xuZXhwb3J0cy5tb3ZlTGluZVVwID0gbW92ZUxpbmVVcDtcbmV4cG9ydHMucmVkbyA9IHJlZG87XG5leHBvcnRzLnJlZG9EZXB0aCA9IHJlZG9EZXB0aDtcbmV4cG9ydHMucmVkb1NlbGVjdGlvbiA9IHJlZG9TZWxlY3Rpb247XG5leHBvcnRzLnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbmV4cG9ydHMuc2VsZWN0Q2hhckJhY2t3YXJkID0gc2VsZWN0Q2hhckJhY2t3YXJkO1xuZXhwb3J0cy5zZWxlY3RDaGFyQmFja3dhcmRMb2dpY2FsID0gc2VsZWN0Q2hhckJhY2t3YXJkTG9naWNhbDtcbmV4cG9ydHMuc2VsZWN0Q2hhckZvcndhcmQgPSBzZWxlY3RDaGFyRm9yd2FyZDtcbmV4cG9ydHMuc2VsZWN0Q2hhckZvcndhcmRMb2dpY2FsID0gc2VsZWN0Q2hhckZvcndhcmRMb2dpY2FsO1xuZXhwb3J0cy5zZWxlY3RDaGFyTGVmdCA9IHNlbGVjdENoYXJMZWZ0O1xuZXhwb3J0cy5zZWxlY3RDaGFyUmlnaHQgPSBzZWxlY3RDaGFyUmlnaHQ7XG5leHBvcnRzLnNlbGVjdERvY0VuZCA9IHNlbGVjdERvY0VuZDtcbmV4cG9ydHMuc2VsZWN0RG9jU3RhcnQgPSBzZWxlY3REb2NTdGFydDtcbmV4cG9ydHMuc2VsZWN0R3JvdXBCYWNrd2FyZCA9IHNlbGVjdEdyb3VwQmFja3dhcmQ7XG5leHBvcnRzLnNlbGVjdEdyb3VwRm9yd2FyZCA9IHNlbGVjdEdyb3VwRm9yd2FyZDtcbmV4cG9ydHMuc2VsZWN0R3JvdXBMZWZ0ID0gc2VsZWN0R3JvdXBMZWZ0O1xuZXhwb3J0cy5zZWxlY3RHcm91cFJpZ2h0ID0gc2VsZWN0R3JvdXBSaWdodDtcbmV4cG9ydHMuc2VsZWN0TGluZSA9IHNlbGVjdExpbmU7XG5leHBvcnRzLnNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkID0gc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQ7XG5leHBvcnRzLnNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQgPSBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkO1xuZXhwb3J0cy5zZWxlY3RMaW5lQm91bmRhcnlMZWZ0ID0gc2VsZWN0TGluZUJvdW5kYXJ5TGVmdDtcbmV4cG9ydHMuc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQgPSBzZWxlY3RMaW5lQm91bmRhcnlSaWdodDtcbmV4cG9ydHMuc2VsZWN0TGluZURvd24gPSBzZWxlY3RMaW5lRG93bjtcbmV4cG9ydHMuc2VsZWN0TGluZUVuZCA9IHNlbGVjdExpbmVFbmQ7XG5leHBvcnRzLnNlbGVjdExpbmVTdGFydCA9IHNlbGVjdExpbmVTdGFydDtcbmV4cG9ydHMuc2VsZWN0TGluZVVwID0gc2VsZWN0TGluZVVwO1xuZXhwb3J0cy5zZWxlY3RNYXRjaGluZ0JyYWNrZXQgPSBzZWxlY3RNYXRjaGluZ0JyYWNrZXQ7XG5leHBvcnRzLnNlbGVjdFBhZ2VEb3duID0gc2VsZWN0UGFnZURvd247XG5leHBvcnRzLnNlbGVjdFBhZ2VVcCA9IHNlbGVjdFBhZ2VVcDtcbmV4cG9ydHMuc2VsZWN0UGFyZW50U3ludGF4ID0gc2VsZWN0UGFyZW50U3ludGF4O1xuZXhwb3J0cy5zZWxlY3RTdWJ3b3JkQmFja3dhcmQgPSBzZWxlY3RTdWJ3b3JkQmFja3dhcmQ7XG5leHBvcnRzLnNlbGVjdFN1YndvcmRGb3J3YXJkID0gc2VsZWN0U3Vid29yZEZvcndhcmQ7XG5leHBvcnRzLnNlbGVjdFN5bnRheExlZnQgPSBzZWxlY3RTeW50YXhMZWZ0O1xuZXhwb3J0cy5zZWxlY3RTeW50YXhSaWdodCA9IHNlbGVjdFN5bnRheFJpZ2h0O1xuZXhwb3J0cy5zaW1wbGlmeVNlbGVjdGlvbiA9IHNpbXBsaWZ5U2VsZWN0aW9uO1xuZXhwb3J0cy5zcGxpdExpbmUgPSBzcGxpdExpbmU7XG5leHBvcnRzLnN0YW5kYXJkS2V5bWFwID0gc3RhbmRhcmRLZXltYXA7XG5leHBvcnRzLnRlbXBvcmFyaWx5U2V0VGFiRm9jdXNNb2RlID0gdGVtcG9yYXJpbHlTZXRUYWJGb2N1c01vZGU7XG5leHBvcnRzLnRvZ2dsZUJsb2NrQ29tbWVudCA9IHRvZ2dsZUJsb2NrQ29tbWVudDtcbmV4cG9ydHMudG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lID0gdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lO1xuZXhwb3J0cy50b2dnbGVDb21tZW50ID0gdG9nZ2xlQ29tbWVudDtcbmV4cG9ydHMudG9nZ2xlTGluZUNvbW1lbnQgPSB0b2dnbGVMaW5lQ29tbWVudDtcbmV4cG9ydHMudG9nZ2xlVGFiRm9jdXNNb2RlID0gdG9nZ2xlVGFiRm9jdXNNb2RlO1xuZXhwb3J0cy50cmFuc3Bvc2VDaGFycyA9IHRyYW5zcG9zZUNoYXJzO1xuZXhwb3J0cy51bmRvID0gdW5kbztcbmV4cG9ydHMudW5kb0RlcHRoID0gdW5kb0RlcHRoO1xuZXhwb3J0cy51bmRvU2VsZWN0aW9uID0gdW5kb1NlbGVjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNzcyQxID0gcmVxdWlyZSgnQGxlemVyL2NzcycpO1xudmFyIGxhbmd1YWdlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCdAbGV6ZXIvY29tbW9uJyk7XG5cbmxldCBfcHJvcGVydGllcyA9IG51bGw7XG5mdW5jdGlvbiBwcm9wZXJ0aWVzKCkge1xuICAgIGlmICghX3Byb3BlcnRpZXMgJiYgdHlwZW9mIGRvY3VtZW50ID09IFwib2JqZWN0XCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBsZXQgeyBzdHlsZSB9ID0gZG9jdW1lbnQuYm9keSwgbmFtZXMgPSBbXSwgc2VlbiA9IG5ldyBTZXQ7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gc3R5bGUpXG4gICAgICAgICAgICBpZiAocHJvcCAhPSBcImNzc1RleHRcIiAmJiBwcm9wICE9IFwiY3NzRmxvYXRcIikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGVbcHJvcF0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoL1tBLVpdLy50ZXN0KHByb3ApKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3AucmVwbGFjZSgvW0EtWl0vZywgY2ggPT4gXCItXCIgKyBjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW4uYWRkKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBfcHJvcGVydGllcyA9IG5hbWVzLnNvcnQoKS5tYXAobmFtZSA9PiAoeyB0eXBlOiBcInByb3BlcnR5XCIsIGxhYmVsOiBuYW1lLCBhcHBseTogbmFtZSArIFwiOiBcIiB9KSk7XG4gICAgfVxuICAgIHJldHVybiBfcHJvcGVydGllcyB8fCBbXTtcbn1cbmNvbnN0IHBzZXVkb0NsYXNzZXMgPSBbXG4gICAgXCJhY3RpdmVcIiwgXCJhZnRlclwiLCBcImFueS1saW5rXCIsIFwiYXV0b2ZpbGxcIiwgXCJiYWNrZHJvcFwiLCBcImJlZm9yZVwiLFxuICAgIFwiY2hlY2tlZFwiLCBcImN1ZVwiLCBcImRlZmF1bHRcIiwgXCJkZWZpbmVkXCIsIFwiZGlzYWJsZWRcIiwgXCJlbXB0eVwiLFxuICAgIFwiZW5hYmxlZFwiLCBcImZpbGUtc2VsZWN0b3ItYnV0dG9uXCIsIFwiZmlyc3RcIiwgXCJmaXJzdC1jaGlsZFwiLFxuICAgIFwiZmlyc3QtbGV0dGVyXCIsIFwiZmlyc3QtbGluZVwiLCBcImZpcnN0LW9mLXR5cGVcIiwgXCJmb2N1c1wiLFxuICAgIFwiZm9jdXMtdmlzaWJsZVwiLCBcImZvY3VzLXdpdGhpblwiLCBcImZ1bGxzY3JlZW5cIiwgXCJoYXNcIiwgXCJob3N0XCIsXG4gICAgXCJob3N0LWNvbnRleHRcIiwgXCJob3ZlclwiLCBcImluLXJhbmdlXCIsIFwiaW5kZXRlcm1pbmF0ZVwiLCBcImludmFsaWRcIixcbiAgICBcImlzXCIsIFwibGFuZ1wiLCBcImxhc3QtY2hpbGRcIiwgXCJsYXN0LW9mLXR5cGVcIiwgXCJsZWZ0XCIsIFwibGlua1wiLCBcIm1hcmtlclwiLFxuICAgIFwibW9kYWxcIiwgXCJub3RcIiwgXCJudGgtY2hpbGRcIiwgXCJudGgtbGFzdC1jaGlsZFwiLCBcIm50aC1sYXN0LW9mLXR5cGVcIixcbiAgICBcIm50aC1vZi10eXBlXCIsIFwib25seS1jaGlsZFwiLCBcIm9ubHktb2YtdHlwZVwiLCBcIm9wdGlvbmFsXCIsIFwib3V0LW9mLXJhbmdlXCIsXG4gICAgXCJwYXJ0XCIsIFwicGxhY2Vob2xkZXJcIiwgXCJwbGFjZWhvbGRlci1zaG93blwiLCBcInJlYWQtb25seVwiLCBcInJlYWQtd3JpdGVcIixcbiAgICBcInJlcXVpcmVkXCIsIFwicmlnaHRcIiwgXCJyb290XCIsIFwic2NvcGVcIiwgXCJzZWxlY3Rpb25cIiwgXCJzbG90dGVkXCIsIFwidGFyZ2V0XCIsXG4gICAgXCJ0YXJnZXQtdGV4dFwiLCBcInZhbGlkXCIsIFwidmlzaXRlZFwiLCBcIndoZXJlXCJcbl0ubWFwKG5hbWUgPT4gKHsgdHlwZTogXCJjbGFzc1wiLCBsYWJlbDogbmFtZSB9KSk7XG5jb25zdCB2YWx1ZXMgPSBbXG4gICAgXCJhYm92ZVwiLCBcImFic29sdXRlXCIsIFwiYWN0aXZlYm9yZGVyXCIsIFwiYWRkaXRpdmVcIiwgXCJhY3RpdmVjYXB0aW9uXCIsIFwiYWZ0ZXItd2hpdGUtc3BhY2VcIixcbiAgICBcImFoZWFkXCIsIFwiYWxpYXNcIiwgXCJhbGxcIiwgXCJhbGwtc2Nyb2xsXCIsIFwiYWxwaGFiZXRpY1wiLCBcImFsdGVybmF0ZVwiLCBcImFsd2F5c1wiLFxuICAgIFwiYW50aWFsaWFzZWRcIiwgXCJhcHB3b3Jrc3BhY2VcIiwgXCJhc3Rlcmlza3NcIiwgXCJhdHRyXCIsIFwiYXV0b1wiLCBcImF1dG8tZmxvd1wiLCBcImF2b2lkXCIsIFwiYXZvaWQtY29sdW1uXCIsXG4gICAgXCJhdm9pZC1wYWdlXCIsIFwiYXZvaWQtcmVnaW9uXCIsIFwiYXhpcy1wYW5cIiwgXCJiYWNrZ3JvdW5kXCIsIFwiYmFja3dhcmRzXCIsIFwiYmFzZWxpbmVcIiwgXCJiZWxvd1wiLFxuICAgIFwiYmlkaS1vdmVycmlkZVwiLCBcImJsaW5rXCIsIFwiYmxvY2tcIiwgXCJibG9jay1heGlzXCIsIFwiYm9sZFwiLCBcImJvbGRlclwiLCBcImJvcmRlclwiLCBcImJvcmRlci1ib3hcIixcbiAgICBcImJvdGhcIiwgXCJib3R0b21cIiwgXCJicmVha1wiLCBcImJyZWFrLWFsbFwiLCBcImJyZWFrLXdvcmRcIiwgXCJidWxsZXRzXCIsIFwiYnV0dG9uXCIsIFwiYnV0dG9uLWJldmVsXCIsXG4gICAgXCJidXR0b25mYWNlXCIsIFwiYnV0dG9uaGlnaGxpZ2h0XCIsIFwiYnV0dG9uc2hhZG93XCIsIFwiYnV0dG9udGV4dFwiLCBcImNhbGNcIiwgXCJjYXBpdGFsaXplXCIsXG4gICAgXCJjYXBzLWxvY2staW5kaWNhdG9yXCIsIFwiY2FwdGlvblwiLCBcImNhcHRpb250ZXh0XCIsIFwiY2FyZXRcIiwgXCJjZWxsXCIsIFwiY2VudGVyXCIsIFwiY2hlY2tib3hcIiwgXCJjaXJjbGVcIixcbiAgICBcImNqay1kZWNpbWFsXCIsIFwiY2xlYXJcIiwgXCJjbGlwXCIsIFwiY2xvc2UtcXVvdGVcIiwgXCJjb2wtcmVzaXplXCIsIFwiY29sbGFwc2VcIiwgXCJjb2xvclwiLCBcImNvbG9yLWJ1cm5cIixcbiAgICBcImNvbG9yLWRvZGdlXCIsIFwiY29sdW1uXCIsIFwiY29sdW1uLXJldmVyc2VcIiwgXCJjb21wYWN0XCIsIFwiY29uZGVuc2VkXCIsIFwiY29udGFpblwiLCBcImNvbnRlbnRcIixcbiAgICBcImNvbnRlbnRzXCIsIFwiY29udGVudC1ib3hcIiwgXCJjb250ZXh0LW1lbnVcIiwgXCJjb250aW51b3VzXCIsIFwiY29weVwiLCBcImNvdW50ZXJcIiwgXCJjb3VudGVyc1wiLCBcImNvdmVyXCIsXG4gICAgXCJjcm9wXCIsIFwiY3Jvc3NcIiwgXCJjcm9zc2hhaXJcIiwgXCJjdXJyZW50Y29sb3JcIiwgXCJjdXJzaXZlXCIsIFwiY3ljbGljXCIsIFwiZGFya2VuXCIsIFwiZGFzaGVkXCIsIFwiZGVjaW1hbFwiLFxuICAgIFwiZGVjaW1hbC1sZWFkaW5nLXplcm9cIiwgXCJkZWZhdWx0XCIsIFwiZGVmYXVsdC1idXR0b25cIiwgXCJkZW5zZVwiLCBcImRlc3RpbmF0aW9uLWF0b3BcIiwgXCJkZXN0aW5hdGlvbi1pblwiLFxuICAgIFwiZGVzdGluYXRpb24tb3V0XCIsIFwiZGVzdGluYXRpb24tb3ZlclwiLCBcImRpZmZlcmVuY2VcIiwgXCJkaXNjXCIsIFwiZGlzY2FyZFwiLCBcImRpc2Nsb3N1cmUtY2xvc2VkXCIsXG4gICAgXCJkaXNjbG9zdXJlLW9wZW5cIiwgXCJkb2N1bWVudFwiLCBcImRvdC1kYXNoXCIsIFwiZG90LWRvdC1kYXNoXCIsIFwiZG90dGVkXCIsIFwiZG91YmxlXCIsIFwiZG93blwiLCBcImUtcmVzaXplXCIsXG4gICAgXCJlYXNlXCIsIFwiZWFzZS1pblwiLCBcImVhc2UtaW4tb3V0XCIsIFwiZWFzZS1vdXRcIiwgXCJlbGVtZW50XCIsIFwiZWxsaXBzZVwiLCBcImVsbGlwc2lzXCIsIFwiZW1iZWRcIiwgXCJlbmRcIixcbiAgICBcImV0aGlvcGljLWFiZWdlZGUtZ2V6XCIsIFwiZXRoaW9waWMtaGFsZWhhbWUtYWEtZXJcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS1nZXpcIiwgXCJldy1yZXNpemVcIiwgXCJleGNsdXNpb25cIixcbiAgICBcImV4cGFuZGVkXCIsIFwiZXh0ZW5kc1wiLCBcImV4dHJhLWNvbmRlbnNlZFwiLCBcImV4dHJhLWV4cGFuZGVkXCIsIFwiZmFudGFzeVwiLCBcImZhc3RcIiwgXCJmaWxsXCIsIFwiZmlsbC1ib3hcIixcbiAgICBcImZpeGVkXCIsIFwiZmxhdFwiLCBcImZsZXhcIiwgXCJmbGV4LWVuZFwiLCBcImZsZXgtc3RhcnRcIiwgXCJmb290bm90ZXNcIiwgXCJmb3J3YXJkc1wiLCBcImZyb21cIixcbiAgICBcImdlb21ldHJpY1ByZWNpc2lvblwiLCBcImdyYXl0ZXh0XCIsIFwiZ3JpZFwiLCBcImdyb292ZVwiLCBcImhhbmRcIiwgXCJoYXJkLWxpZ2h0XCIsIFwiaGVscFwiLCBcImhpZGRlblwiLCBcImhpZGVcIixcbiAgICBcImhpZ2hlclwiLCBcImhpZ2hsaWdodFwiLCBcImhpZ2hsaWdodHRleHRcIiwgXCJob3Jpem9udGFsXCIsIFwiaHNsXCIsIFwiaHNsYVwiLCBcImh1ZVwiLCBcImljb25cIiwgXCJpZ25vcmVcIixcbiAgICBcImluYWN0aXZlYm9yZGVyXCIsIFwiaW5hY3RpdmVjYXB0aW9uXCIsIFwiaW5hY3RpdmVjYXB0aW9udGV4dFwiLCBcImluZmluaXRlXCIsIFwiaW5mb2JhY2tncm91bmRcIiwgXCJpbmZvdGV4dFwiLFxuICAgIFwiaW5oZXJpdFwiLCBcImluaXRpYWxcIiwgXCJpbmxpbmVcIiwgXCJpbmxpbmUtYXhpc1wiLCBcImlubGluZS1ibG9ja1wiLCBcImlubGluZS1mbGV4XCIsIFwiaW5saW5lLWdyaWRcIixcbiAgICBcImlubGluZS10YWJsZVwiLCBcImluc2V0XCIsIFwiaW5zaWRlXCIsIFwiaW50cmluc2ljXCIsIFwiaW52ZXJ0XCIsIFwiaXRhbGljXCIsIFwianVzdGlmeVwiLCBcImtlZXAtYWxsXCIsXG4gICAgXCJsYW5kc2NhcGVcIiwgXCJsYXJnZVwiLCBcImxhcmdlclwiLCBcImxlZnRcIiwgXCJsZXZlbFwiLCBcImxpZ2h0ZXJcIiwgXCJsaWdodGVuXCIsIFwibGluZS10aHJvdWdoXCIsIFwibGluZWFyXCIsXG4gICAgXCJsaW5lYXItZ3JhZGllbnRcIiwgXCJsaW5lc1wiLCBcImxpc3QtaXRlbVwiLCBcImxpc3Rib3hcIiwgXCJsaXN0aXRlbVwiLCBcImxvY2FsXCIsIFwibG9naWNhbFwiLCBcImxvdWRcIiwgXCJsb3dlclwiLFxuICAgIFwibG93ZXItaGV4YWRlY2ltYWxcIiwgXCJsb3dlci1sYXRpblwiLCBcImxvd2VyLW5vcndlZ2lhblwiLCBcImxvd2VyY2FzZVwiLCBcImx0clwiLCBcImx1bWlub3NpdHlcIiwgXCJtYW5pcHVsYXRpb25cIixcbiAgICBcIm1hdGNoXCIsIFwibWF0cml4XCIsIFwibWF0cml4M2RcIiwgXCJtZWRpdW1cIiwgXCJtZW51XCIsIFwibWVudXRleHRcIiwgXCJtZXNzYWdlLWJveFwiLCBcIm1pZGRsZVwiLCBcIm1pbi1pbnRyaW5zaWNcIixcbiAgICBcIm1peFwiLCBcIm1vbm9zcGFjZVwiLCBcIm1vdmVcIiwgXCJtdWx0aXBsZVwiLCBcIm11bHRpcGxlX21hc2tfaW1hZ2VzXCIsIFwibXVsdGlwbHlcIiwgXCJuLXJlc2l6ZVwiLCBcIm5hcnJvd2VyXCIsXG4gICAgXCJuZS1yZXNpemVcIiwgXCJuZXN3LXJlc2l6ZVwiLCBcIm5vLWNsb3NlLXF1b3RlXCIsIFwibm8tZHJvcFwiLCBcIm5vLW9wZW4tcXVvdGVcIiwgXCJuby1yZXBlYXRcIiwgXCJub25lXCIsXG4gICAgXCJub3JtYWxcIiwgXCJub3QtYWxsb3dlZFwiLCBcIm5vd3JhcFwiLCBcIm5zLXJlc2l6ZVwiLCBcIm51bWJlcnNcIiwgXCJudW1lcmljXCIsIFwibnctcmVzaXplXCIsIFwibndzZS1yZXNpemVcIixcbiAgICBcIm9ibGlxdWVcIiwgXCJvcGFjaXR5XCIsIFwib3Blbi1xdW90ZVwiLCBcIm9wdGltaXplTGVnaWJpbGl0eVwiLCBcIm9wdGltaXplU3BlZWRcIiwgXCJvdXRzZXRcIiwgXCJvdXRzaWRlXCIsXG4gICAgXCJvdXRzaWRlLXNoYXBlXCIsIFwib3ZlcmxheVwiLCBcIm92ZXJsaW5lXCIsIFwicGFkZGluZ1wiLCBcInBhZGRpbmctYm94XCIsIFwicGFpbnRlZFwiLCBcInBhZ2VcIiwgXCJwYXVzZWRcIixcbiAgICBcInBlcnNwZWN0aXZlXCIsIFwicGluY2gtem9vbVwiLCBcInBsdXMtZGFya2VyXCIsIFwicGx1cy1saWdodGVyXCIsIFwicG9pbnRlclwiLCBcInBvbHlnb25cIiwgXCJwb3J0cmFpdFwiLFxuICAgIFwicHJlXCIsIFwicHJlLWxpbmVcIiwgXCJwcmUtd3JhcFwiLCBcInByZXNlcnZlLTNkXCIsIFwicHJvZ3Jlc3NcIiwgXCJwdXNoLWJ1dHRvblwiLCBcInJhZGlhbC1ncmFkaWVudFwiLCBcInJhZGlvXCIsXG4gICAgXCJyZWFkLW9ubHlcIiwgXCJyZWFkLXdyaXRlXCIsIFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLCBcInJlY3RhbmdsZVwiLCBcInJlZ2lvblwiLCBcInJlbGF0aXZlXCIsIFwicmVwZWF0XCIsXG4gICAgXCJyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50XCIsIFwicmVwZWF0aW5nLXJhZGlhbC1ncmFkaWVudFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgXCJyZXNldFwiLCBcInJldmVyc2VcIixcbiAgICBcInJnYlwiLCBcInJnYmFcIiwgXCJyaWRnZVwiLCBcInJpZ2h0XCIsIFwicm90YXRlXCIsIFwicm90YXRlM2RcIiwgXCJyb3RhdGVYXCIsIFwicm90YXRlWVwiLCBcInJvdGF0ZVpcIiwgXCJyb3VuZFwiLFxuICAgIFwicm93XCIsIFwicm93LXJlc2l6ZVwiLCBcInJvdy1yZXZlcnNlXCIsIFwicnRsXCIsIFwicnVuLWluXCIsIFwicnVubmluZ1wiLCBcInMtcmVzaXplXCIsIFwic2Fucy1zZXJpZlwiLCBcInNhdHVyYXRpb25cIixcbiAgICBcInNjYWxlXCIsIFwic2NhbGUzZFwiLCBcInNjYWxlWFwiLCBcInNjYWxlWVwiLCBcInNjYWxlWlwiLCBcInNjcmVlblwiLCBcInNjcm9sbFwiLCBcInNjcm9sbGJhclwiLCBcInNjcm9sbC1wb3NpdGlvblwiLFxuICAgIFwic2UtcmVzaXplXCIsIFwic2VsZi1zdGFydFwiLCBcInNlbGYtZW5kXCIsIFwic2VtaS1jb25kZW5zZWRcIiwgXCJzZW1pLWV4cGFuZGVkXCIsIFwic2VwYXJhdGVcIiwgXCJzZXJpZlwiLCBcInNob3dcIixcbiAgICBcInNpbmdsZVwiLCBcInNrZXdcIiwgXCJza2V3WFwiLCBcInNrZXdZXCIsIFwic2tpcC13aGl0ZS1zcGFjZVwiLCBcInNsaWRlXCIsIFwic2xpZGVyLWhvcml6b250YWxcIixcbiAgICBcInNsaWRlci12ZXJ0aWNhbFwiLCBcInNsaWRlcnRodW1iLWhvcml6b250YWxcIiwgXCJzbGlkZXJ0aHVtYi12ZXJ0aWNhbFwiLCBcInNsb3dcIiwgXCJzbWFsbFwiLCBcInNtYWxsLWNhcHNcIixcbiAgICBcInNtYWxsLWNhcHRpb25cIiwgXCJzbWFsbGVyXCIsIFwic29mdC1saWdodFwiLCBcInNvbGlkXCIsIFwic291cmNlLWF0b3BcIiwgXCJzb3VyY2UtaW5cIiwgXCJzb3VyY2Utb3V0XCIsXG4gICAgXCJzb3VyY2Utb3ZlclwiLCBcInNwYWNlXCIsIFwic3BhY2UtYXJvdW5kXCIsIFwic3BhY2UtYmV0d2VlblwiLCBcInNwYWNlLWV2ZW5seVwiLCBcInNwZWxsLW91dFwiLCBcInNxdWFyZVwiLCBcInN0YXJ0XCIsXG4gICAgXCJzdGF0aWNcIiwgXCJzdGF0dXMtYmFyXCIsIFwic3RyZXRjaFwiLCBcInN0cm9rZVwiLCBcInN0cm9rZS1ib3hcIiwgXCJzdWJcIiwgXCJzdWJwaXhlbC1hbnRpYWxpYXNlZFwiLCBcInN2Z19tYXNrc1wiLFxuICAgIFwic3VwZXJcIiwgXCJzdy1yZXNpemVcIiwgXCJzeW1ib2xpY1wiLCBcInN5bWJvbHNcIiwgXCJzeXN0ZW0tdWlcIiwgXCJ0YWJsZVwiLCBcInRhYmxlLWNhcHRpb25cIiwgXCJ0YWJsZS1jZWxsXCIsXG4gICAgXCJ0YWJsZS1jb2x1bW5cIiwgXCJ0YWJsZS1jb2x1bW4tZ3JvdXBcIiwgXCJ0YWJsZS1mb290ZXItZ3JvdXBcIiwgXCJ0YWJsZS1oZWFkZXItZ3JvdXBcIiwgXCJ0YWJsZS1yb3dcIixcbiAgICBcInRhYmxlLXJvdy1ncm91cFwiLCBcInRleHRcIiwgXCJ0ZXh0LWJvdHRvbVwiLCBcInRleHQtdG9wXCIsIFwidGV4dGFyZWFcIiwgXCJ0ZXh0ZmllbGRcIiwgXCJ0aGlja1wiLCBcInRoaW5cIixcbiAgICBcInRocmVlZGRhcmtzaGFkb3dcIiwgXCJ0aHJlZWRmYWNlXCIsIFwidGhyZWVkaGlnaGxpZ2h0XCIsIFwidGhyZWVkbGlnaHRzaGFkb3dcIiwgXCJ0aHJlZWRzaGFkb3dcIiwgXCJ0b1wiLCBcInRvcFwiLFxuICAgIFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlXCIsIFwidHJhbnNsYXRlM2RcIiwgXCJ0cmFuc2xhdGVYXCIsIFwidHJhbnNsYXRlWVwiLCBcInRyYW5zbGF0ZVpcIiwgXCJ0cmFuc3BhcmVudFwiLFxuICAgIFwidWx0cmEtY29uZGVuc2VkXCIsIFwidWx0cmEtZXhwYW5kZWRcIiwgXCJ1bmRlcmxpbmVcIiwgXCJ1bmlkaXJlY3Rpb25hbC1wYW5cIiwgXCJ1bnNldFwiLCBcInVwXCIsIFwidXBwZXItbGF0aW5cIixcbiAgICBcInVwcGVyY2FzZVwiLCBcInVybFwiLCBcInZhclwiLCBcInZlcnRpY2FsXCIsIFwidmVydGljYWwtdGV4dFwiLCBcInZpZXctYm94XCIsIFwidmlzaWJsZVwiLCBcInZpc2libGVGaWxsXCIsXG4gICAgXCJ2aXNpYmxlUGFpbnRlZFwiLCBcInZpc2libGVTdHJva2VcIiwgXCJ2aXN1YWxcIiwgXCJ3LXJlc2l6ZVwiLCBcIndhaXRcIiwgXCJ3YXZlXCIsIFwid2lkZXJcIiwgXCJ3aW5kb3dcIiwgXCJ3aW5kb3dmcmFtZVwiLFxuICAgIFwid2luZG93dGV4dFwiLCBcIndvcmRzXCIsIFwid3JhcFwiLCBcIndyYXAtcmV2ZXJzZVwiLCBcIngtbGFyZ2VcIiwgXCJ4LXNtYWxsXCIsIFwieG9yXCIsIFwieHgtbGFyZ2VcIiwgXCJ4eC1zbWFsbFwiXG5dLm1hcChuYW1lID0+ICh7IHR5cGU6IFwia2V5d29yZFwiLCBsYWJlbDogbmFtZSB9KSkuY29uY2F0KFtcbiAgICBcImFsaWNlYmx1ZVwiLCBcImFudGlxdWV3aGl0ZVwiLCBcImFxdWFcIiwgXCJhcXVhbWFyaW5lXCIsIFwiYXp1cmVcIiwgXCJiZWlnZVwiLFxuICAgIFwiYmlzcXVlXCIsIFwiYmxhY2tcIiwgXCJibGFuY2hlZGFsbW9uZFwiLCBcImJsdWVcIiwgXCJibHVldmlvbGV0XCIsIFwiYnJvd25cIixcbiAgICBcImJ1cmx5d29vZFwiLCBcImNhZGV0Ymx1ZVwiLCBcImNoYXJ0cmV1c2VcIiwgXCJjaG9jb2xhdGVcIiwgXCJjb3JhbFwiLCBcImNvcm5mbG93ZXJibHVlXCIsXG4gICAgXCJjb3Juc2lsa1wiLCBcImNyaW1zb25cIiwgXCJjeWFuXCIsIFwiZGFya2JsdWVcIiwgXCJkYXJrY3lhblwiLCBcImRhcmtnb2xkZW5yb2RcIixcbiAgICBcImRhcmtncmF5XCIsIFwiZGFya2dyZWVuXCIsIFwiZGFya2toYWtpXCIsIFwiZGFya21hZ2VudGFcIiwgXCJkYXJrb2xpdmVncmVlblwiLFxuICAgIFwiZGFya29yYW5nZVwiLCBcImRhcmtvcmNoaWRcIiwgXCJkYXJrcmVkXCIsIFwiZGFya3NhbG1vblwiLCBcImRhcmtzZWFncmVlblwiLFxuICAgIFwiZGFya3NsYXRlYmx1ZVwiLCBcImRhcmtzbGF0ZWdyYXlcIiwgXCJkYXJrdHVycXVvaXNlXCIsIFwiZGFya3Zpb2xldFwiLFxuICAgIFwiZGVlcHBpbmtcIiwgXCJkZWVwc2t5Ymx1ZVwiLCBcImRpbWdyYXlcIiwgXCJkb2RnZXJibHVlXCIsIFwiZmlyZWJyaWNrXCIsXG4gICAgXCJmbG9yYWx3aGl0ZVwiLCBcImZvcmVzdGdyZWVuXCIsIFwiZnVjaHNpYVwiLCBcImdhaW5zYm9yb1wiLCBcImdob3N0d2hpdGVcIixcbiAgICBcImdvbGRcIiwgXCJnb2xkZW5yb2RcIiwgXCJncmF5XCIsIFwiZ3JleVwiLCBcImdyZWVuXCIsIFwiZ3JlZW55ZWxsb3dcIiwgXCJob25leWRld1wiLFxuICAgIFwiaG90cGlua1wiLCBcImluZGlhbnJlZFwiLCBcImluZGlnb1wiLCBcIml2b3J5XCIsIFwia2hha2lcIiwgXCJsYXZlbmRlclwiLFxuICAgIFwibGF2ZW5kZXJibHVzaFwiLCBcImxhd25ncmVlblwiLCBcImxlbW9uY2hpZmZvblwiLCBcImxpZ2h0Ymx1ZVwiLCBcImxpZ2h0Y29yYWxcIixcbiAgICBcImxpZ2h0Y3lhblwiLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCIsIFwibGlnaHRncmF5XCIsIFwibGlnaHRncmVlblwiLCBcImxpZ2h0cGlua1wiLFxuICAgIFwibGlnaHRzYWxtb25cIiwgXCJsaWdodHNlYWdyZWVuXCIsIFwibGlnaHRza3libHVlXCIsIFwibGlnaHRzbGF0ZWdyYXlcIixcbiAgICBcImxpZ2h0c3RlZWxibHVlXCIsIFwibGlnaHR5ZWxsb3dcIiwgXCJsaW1lXCIsIFwibGltZWdyZWVuXCIsIFwibGluZW5cIiwgXCJtYWdlbnRhXCIsXG4gICAgXCJtYXJvb25cIiwgXCJtZWRpdW1hcXVhbWFyaW5lXCIsIFwibWVkaXVtYmx1ZVwiLCBcIm1lZGl1bW9yY2hpZFwiLCBcIm1lZGl1bXB1cnBsZVwiLFxuICAgIFwibWVkaXVtc2VhZ3JlZW5cIiwgXCJtZWRpdW1zbGF0ZWJsdWVcIiwgXCJtZWRpdW1zcHJpbmdncmVlblwiLCBcIm1lZGl1bXR1cnF1b2lzZVwiLFxuICAgIFwibWVkaXVtdmlvbGV0cmVkXCIsIFwibWlkbmlnaHRibHVlXCIsIFwibWludGNyZWFtXCIsIFwibWlzdHlyb3NlXCIsIFwibW9jY2FzaW5cIixcbiAgICBcIm5hdmFqb3doaXRlXCIsIFwibmF2eVwiLCBcIm9sZGxhY2VcIiwgXCJvbGl2ZVwiLCBcIm9saXZlZHJhYlwiLCBcIm9yYW5nZVwiLCBcIm9yYW5nZXJlZFwiLFxuICAgIFwib3JjaGlkXCIsIFwicGFsZWdvbGRlbnJvZFwiLCBcInBhbGVncmVlblwiLCBcInBhbGV0dXJxdW9pc2VcIiwgXCJwYWxldmlvbGV0cmVkXCIsXG4gICAgXCJwYXBheWF3aGlwXCIsIFwicGVhY2hwdWZmXCIsIFwicGVydVwiLCBcInBpbmtcIiwgXCJwbHVtXCIsIFwicG93ZGVyYmx1ZVwiLFxuICAgIFwicHVycGxlXCIsIFwicmViZWNjYXB1cnBsZVwiLCBcInJlZFwiLCBcInJvc3licm93blwiLCBcInJveWFsYmx1ZVwiLCBcInNhZGRsZWJyb3duXCIsXG4gICAgXCJzYWxtb25cIiwgXCJzYW5keWJyb3duXCIsIFwic2VhZ3JlZW5cIiwgXCJzZWFzaGVsbFwiLCBcInNpZW5uYVwiLCBcInNpbHZlclwiLCBcInNreWJsdWVcIixcbiAgICBcInNsYXRlYmx1ZVwiLCBcInNsYXRlZ3JheVwiLCBcInNub3dcIiwgXCJzcHJpbmdncmVlblwiLCBcInN0ZWVsYmx1ZVwiLCBcInRhblwiLFxuICAgIFwidGVhbFwiLCBcInRoaXN0bGVcIiwgXCJ0b21hdG9cIiwgXCJ0dXJxdW9pc2VcIiwgXCJ2aW9sZXRcIiwgXCJ3aGVhdFwiLCBcIndoaXRlXCIsXG4gICAgXCJ3aGl0ZXNtb2tlXCIsIFwieWVsbG93XCIsIFwieWVsbG93Z3JlZW5cIlxuXS5tYXAobmFtZSA9PiAoeyB0eXBlOiBcImNvbnN0YW50XCIsIGxhYmVsOiBuYW1lIH0pKSk7XG5jb25zdCB0YWdzID0gW1xuICAgIFwiYVwiLCBcImFiYnJcIiwgXCJhZGRyZXNzXCIsIFwiYXJ0aWNsZVwiLCBcImFzaWRlXCIsIFwiYlwiLCBcImJkaVwiLCBcImJkb1wiLCBcImJsb2NrcXVvdGVcIiwgXCJib2R5XCIsXG4gICAgXCJiclwiLCBcImJ1dHRvblwiLCBcImNhbnZhc1wiLCBcImNhcHRpb25cIiwgXCJjaXRlXCIsIFwiY29kZVwiLCBcImNvbFwiLCBcImNvbGdyb3VwXCIsIFwiZGRcIiwgXCJkZWxcIixcbiAgICBcImRldGFpbHNcIiwgXCJkZm5cIiwgXCJkaWFsb2dcIiwgXCJkaXZcIiwgXCJkbFwiLCBcImR0XCIsIFwiZW1cIiwgXCJmaWdjYXB0aW9uXCIsIFwiZmlndXJlXCIsIFwiZm9vdGVyXCIsXG4gICAgXCJmb3JtXCIsIFwiaGVhZGVyXCIsIFwiaGdyb3VwXCIsIFwiaDFcIiwgXCJoMlwiLCBcImgzXCIsIFwiaDRcIiwgXCJoNVwiLCBcImg2XCIsIFwiaHJcIiwgXCJodG1sXCIsIFwiaVwiLCBcImlmcmFtZVwiLFxuICAgIFwiaW1nXCIsIFwiaW5wdXRcIiwgXCJpbnNcIiwgXCJrYmRcIiwgXCJsYWJlbFwiLCBcImxlZ2VuZFwiLCBcImxpXCIsIFwibWFpblwiLCBcIm1ldGVyXCIsIFwibmF2XCIsIFwib2xcIiwgXCJvdXRwdXRcIixcbiAgICBcInBcIiwgXCJwcmVcIiwgXCJydWJ5XCIsIFwic2VjdGlvblwiLCBcInNlbGVjdFwiLCBcInNtYWxsXCIsIFwic291cmNlXCIsIFwic3BhblwiLCBcInN0cm9uZ1wiLCBcInN1YlwiLCBcInN1bW1hcnlcIixcbiAgICBcInN1cFwiLCBcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0ZFwiLCBcInRlbXBsYXRlXCIsIFwidGV4dGFyZWFcIiwgXCJ0Zm9vdFwiLCBcInRoXCIsIFwidGhlYWRcIiwgXCJ0clwiLCBcInVcIiwgXCJ1bFwiXG5dLm1hcChuYW1lID0+ICh7IHR5cGU6IFwidHlwZVwiLCBsYWJlbDogbmFtZSB9KSk7XG5jb25zdCBhdFJ1bGVzID0gW1xuICAgIFwiQGNoYXJzZXRcIiwgXCJAY29sb3ItcHJvZmlsZVwiLCBcIkBjb250YWluZXJcIiwgXCJAY291bnRlci1zdHlsZVwiLCBcIkBmb250LWZhY2VcIiwgXCJAZm9udC1mZWF0dXJlLXZhbHVlc1wiLFxuICAgIFwiQGZvbnQtcGFsZXR0ZS12YWx1ZXNcIiwgXCJAaW1wb3J0XCIsIFwiQGtleWZyYW1lc1wiLCBcIkBsYXllclwiLCBcIkBtZWRpYVwiLCBcIkBuYW1lc3BhY2VcIiwgXCJAcGFnZVwiLFxuICAgIFwiQHBvc2l0aW9uLXRyeVwiLCBcIkBwcm9wZXJ0eVwiLCBcIkBzY29wZVwiLCBcIkBzdGFydGluZy1zdHlsZVwiLCBcIkBzdXBwb3J0c1wiLCBcIkB2aWV3LXRyYW5zaXRpb25cIlxuXS5tYXAobGFiZWwgPT4gKHsgdHlwZTogXCJrZXl3b3JkXCIsIGxhYmVsIH0pKTtcbmNvbnN0IGlkZW50aWZpZXIgPSAvXihcXHdbXFx3LV0qfC1cXHdbXFx3LV0qfCkkLywgdmFyaWFibGUgPSAvXi0oLVtcXHctXSopPyQvO1xuZnVuY3Rpb24gaXNWYXJBcmcobm9kZSwgZG9jKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChub2RlLm5hbWUgPT0gXCIoXCIgfHwgbm9kZS50eXBlLmlzRXJyb3IpXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudCB8fCBub2RlO1xuICAgIGlmIChub2RlLm5hbWUgIT0gXCJBcmdMaXN0XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2FsbGVlID0gKF9hID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJzdENoaWxkO1xuICAgIGlmICgoY2FsbGVlID09PSBudWxsIHx8IGNhbGxlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGVlLm5hbWUpICE9IFwiQ2FsbGVlXCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZG9jLnNsaWNlU3RyaW5nKGNhbGxlZS5mcm9tLCBjYWxsZWUudG8pID09IFwidmFyXCI7XG59XG5jb25zdCBWYXJpYWJsZXNCeU5vZGUgPSBuZXcgY29tbW9uLk5vZGVXZWFrTWFwKCk7XG5jb25zdCBkZWNsU2VsZWN0b3IgPSBbXCJEZWNsYXJhdGlvblwiXTtcbmZ1bmN0aW9uIGFzdFRvcChub2RlKSB7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTs7KSB7XG4gICAgICAgIGlmIChjdXIudHlwZS5pc1RvcClcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIGlmICghKGN1ciA9IGN1ci5wYXJlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFyaWFibGVOYW1lcyhkb2MsIG5vZGUsIGlzVmFyaWFibGUpIHtcbiAgICBpZiAobm9kZS50byAtIG5vZGUuZnJvbSA+IDQwOTYpIHtcbiAgICAgICAgbGV0IGtub3duID0gVmFyaWFibGVzQnlOb2RlLmdldChub2RlKTtcbiAgICAgICAgaWYgKGtub3duKVxuICAgICAgICAgICAgcmV0dXJuIGtub3duO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBuZXcgU2V0LCBjdXJzb3IgPSBub2RlLmN1cnNvcihjb21tb24uSXRlck1vZGUuSW5jbHVkZUFub255bW91cyk7XG4gICAgICAgIGlmIChjdXJzb3IuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiB2YXJpYWJsZU5hbWVzKGRvYywgY3Vyc29yLm5vZGUsIGlzVmFyaWFibGUpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW4uaGFzKG9wdGlvbi5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW4uYWRkKG9wdGlvbi5sYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgICAgIFZhcmlhYmxlc0J5Tm9kZS5zZXQobm9kZSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgc2VlbiA9IG5ldyBTZXQ7XG4gICAgICAgIG5vZGUuY3Vyc29yKCkuaXRlcmF0ZShub2RlID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKG5vZGUpICYmIG5vZGUubWF0Y2hDb250ZXh0KGRlY2xTZWxlY3RvcikgJiYgKChfYSA9IG5vZGUubm9kZS5uZXh0U2libGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBkb2Muc2xpY2VTdHJpbmcobm9kZS5mcm9tLCBub2RlLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlZW4uaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW4uYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGxhYmVsOiBuYW1lLCB0eXBlOiBcInZhcmlhYmxlXCIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkNyZWF0ZSBhIGNvbXBsZXRpb24gc291cmNlIGZvciBhIENTUyBkaWFsZWN0LCBwcm92aWRpbmcgYVxucHJlZGljYXRlIGZvciBkZXRlcm1pbmluZyB3aGF0IGtpbmQgb2Ygc3ludGF4IG5vZGUgY2FuIGFjdCBhcyBhXG5jb21wbGV0YWJsZSB2YXJpYWJsZS4gVGhpcyBpcyB1c2VkIGJ5IGxhbmd1YWdlIG1vZGVzIGxpa2UgU2FzcyBhbmRcbkxlc3MgdG8gcmV1c2UgdGhpcyBwYWNrYWdlJ3MgY29tcGxldGlvbiBsb2dpYy5cbiovXG5jb25zdCBkZWZpbmVDU1NDb21wbGV0aW9uU291cmNlID0gKGlzVmFyaWFibGUpID0+IGNvbnRleHQgPT4ge1xuICAgIGxldCB7IHN0YXRlLCBwb3MgfSA9IGNvbnRleHQsIG5vZGUgPSBsYW5ndWFnZS5zeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zLCAtMSk7XG4gICAgbGV0IGlzRGFzaCA9IG5vZGUudHlwZS5pc0Vycm9yICYmIG5vZGUuZnJvbSA9PSBub2RlLnRvIC0gMSAmJiBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcobm9kZS5mcm9tLCBub2RlLnRvKSA9PSBcIi1cIjtcbiAgICBpZiAobm9kZS5uYW1lID09IFwiUHJvcGVydHlOYW1lXCIgfHxcbiAgICAgICAgKGlzRGFzaCB8fCBub2RlLm5hbWUgPT0gXCJUYWdOYW1lXCIpICYmIC9eKEJsb2NrfFN0eWxlcykkLy50ZXN0KG5vZGUucmVzb2x2ZShub2RlLnRvKS5uYW1lKSlcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogbm9kZS5mcm9tLCBvcHRpb25zOiBwcm9wZXJ0aWVzKCksIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG4gICAgaWYgKG5vZGUubmFtZSA9PSBcIlZhbHVlTmFtZVwiKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBub2RlLmZyb20sIG9wdGlvbnM6IHZhbHVlcywgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbiAgICBpZiAobm9kZS5uYW1lID09IFwiUHNldWRvQ2xhc3NOYW1lXCIpXG4gICAgICAgIHJldHVybiB7IGZyb206IG5vZGUuZnJvbSwgb3B0aW9uczogcHNldWRvQ2xhc3NlcywgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbiAgICBpZiAoaXNWYXJpYWJsZShub2RlKSB8fCAoY29udGV4dC5leHBsaWNpdCB8fCBpc0Rhc2gpICYmIGlzVmFyQXJnKG5vZGUsIHN0YXRlLmRvYykpXG4gICAgICAgIHJldHVybiB7IGZyb206IGlzVmFyaWFibGUobm9kZSkgfHwgaXNEYXNoID8gbm9kZS5mcm9tIDogcG9zLFxuICAgICAgICAgICAgb3B0aW9uczogdmFyaWFibGVOYW1lcyhzdGF0ZS5kb2MsIGFzdFRvcChub2RlKSwgaXNWYXJpYWJsZSksXG4gICAgICAgICAgICB2YWxpZEZvcjogdmFyaWFibGUgfTtcbiAgICBpZiAobm9kZS5uYW1lID09IFwiVGFnTmFtZVwiKSB7XG4gICAgICAgIGZvciAobGV0IHsgcGFyZW50IH0gPSBub2RlOyBwYXJlbnQ7IHBhcmVudCA9IHBhcmVudC5wYXJlbnQpXG4gICAgICAgICAgICBpZiAocGFyZW50Lm5hbWUgPT0gXCJCbG9ja1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb206IG5vZGUuZnJvbSwgb3B0aW9uczogcHJvcGVydGllcygpLCB2YWxpZEZvcjogaWRlbnRpZmllciB9O1xuICAgICAgICByZXR1cm4geyBmcm9tOiBub2RlLmZyb20sIG9wdGlvbnM6IHRhZ3MsIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG4gICAgfVxuICAgIGlmIChub2RlLm5hbWUgPT0gXCJBdEtleXdvcmRcIilcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogbm9kZS5mcm9tLCBvcHRpb25zOiBhdFJ1bGVzLCB2YWxpZEZvcjogaWRlbnRpZmllciB9O1xuICAgIGlmICghY29udGV4dC5leHBsaWNpdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFib3ZlID0gbm9kZS5yZXNvbHZlKHBvcyksIGJlZm9yZSA9IGFib3ZlLmNoaWxkQmVmb3JlKHBvcyk7XG4gICAgaWYgKGJlZm9yZSAmJiBiZWZvcmUubmFtZSA9PSBcIjpcIiAmJiBhYm92ZS5uYW1lID09IFwiUHNldWRvQ2xhc3NTZWxlY3RvclwiKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIG9wdGlvbnM6IHBzZXVkb0NsYXNzZXMsIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG4gICAgaWYgKGJlZm9yZSAmJiBiZWZvcmUubmFtZSA9PSBcIjpcIiAmJiBhYm92ZS5uYW1lID09IFwiRGVjbGFyYXRpb25cIiB8fCBhYm92ZS5uYW1lID09IFwiQXJnTGlzdFwiKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIG9wdGlvbnM6IHZhbHVlcywgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbiAgICBpZiAoYWJvdmUubmFtZSA9PSBcIkJsb2NrXCIgfHwgYWJvdmUubmFtZSA9PSBcIlN0eWxlc1wiKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIG9wdGlvbnM6IHByb3BlcnRpZXMoKSwgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbiAgICByZXR1cm4gbnVsbDtcbn07XG4vKipcbkNTUyBwcm9wZXJ0eSwgdmFyaWFibGUsIGFuZCB2YWx1ZSBrZXl3b3JkIGNvbXBsZXRpb24gc291cmNlLlxuKi9cbmNvbnN0IGNzc0NvbXBsZXRpb25Tb3VyY2UgPSBkZWZpbmVDU1NDb21wbGV0aW9uU291cmNlKG4gPT4gbi5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIpO1xuXG4vKipcbkEgbGFuZ3VhZ2UgcHJvdmlkZXIgYmFzZWQgb24gdGhlIFtMZXplciBDU1NcbnBhcnNlcl0oaHR0cHM6Ly9naXRodWIuY29tL2xlemVyLXBhcnNlci9jc3MpLCBleHRlbmRlZCB3aXRoXG5oaWdobGlnaHRpbmcgYW5kIGluZGVudGF0aW9uIGluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IGNzc0xhbmd1YWdlID0gbGFuZ3VhZ2UuTFJMYW5ndWFnZS5kZWZpbmUoe1xuICAgIG5hbWU6IFwiY3NzXCIsXG4gICAgcGFyc2VyOiBjc3MkMS5wYXJzZXIuY29uZmlndXJlKHtcbiAgICAgICAgcHJvcHM6IFtcbiAgICAgICAgICAgIGxhbmd1YWdlLmluZGVudE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgRGVjbGFyYXRpb246IGxhbmd1YWdlLmNvbnRpbnVlZEluZGVudCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGxhbmd1YWdlLmZvbGROb2RlUHJvcC5hZGQoe1xuICAgICAgICAgICAgICAgIFwiQmxvY2sgS2V5ZnJhbWVMaXN0XCI6IGxhbmd1YWdlLmZvbGRJbnNpZGVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICB9KSxcbiAgICBsYW5ndWFnZURhdGE6IHtcbiAgICAgICAgY29tbWVudFRva2VuczogeyBibG9jazogeyBvcGVuOiBcIi8qXCIsIGNsb3NlOiBcIiovXCIgfSB9LFxuICAgICAgICBpbmRlbnRPbklucHV0OiAvXlxccypcXH0kLyxcbiAgICAgICAgd29yZENoYXJzOiBcIi1cIlxuICAgIH1cbn0pO1xuLyoqXG5MYW5ndWFnZSBzdXBwb3J0IGZvciBDU1MuXG4qL1xuZnVuY3Rpb24gY3NzKCkge1xuICAgIHJldHVybiBuZXcgbGFuZ3VhZ2UuTGFuZ3VhZ2VTdXBwb3J0KGNzc0xhbmd1YWdlLCBjc3NMYW5ndWFnZS5kYXRhLm9mKHsgYXV0b2NvbXBsZXRlOiBjc3NDb21wbGV0aW9uU291cmNlIH0pKTtcbn1cblxuZXhwb3J0cy5jc3MgPSBjc3M7XG5leHBvcnRzLmNzc0NvbXBsZXRpb25Tb3VyY2UgPSBjc3NDb21wbGV0aW9uU291cmNlO1xuZXhwb3J0cy5jc3NMYW5ndWFnZSA9IGNzc0xhbmd1YWdlO1xuZXhwb3J0cy5kZWZpbmVDU1NDb21wbGV0aW9uU291cmNlID0gZGVmaW5lQ1NTQ29tcGxldGlvblNvdXJjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGh0bWwkMSA9IHJlcXVpcmUoJ0BsZXplci9odG1sJyk7XG52YXIgbGFuZ0NzcyA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL2xhbmctY3NzJyk7XG52YXIgbGFuZ0phdmFzY3JpcHQgPSByZXF1aXJlKCdAY29kZW1pcnJvci9sYW5nLWphdmFzY3JpcHQnKTtcbnZhciB2aWV3ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvdmlldycpO1xudmFyIHN0YXRlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3Ivc3RhdGUnKTtcbnZhciBsYW5ndWFnZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJyk7XG5cbmNvbnN0IFRhcmdldHMgPSBbXCJfYmxhbmtcIiwgXCJfc2VsZlwiLCBcIl90b3BcIiwgXCJfcGFyZW50XCJdO1xuY29uc3QgQ2hhcnNldHMgPSBbXCJhc2NpaVwiLCBcInV0Zi04XCIsIFwidXRmLTE2XCIsIFwibGF0aW4xXCIsIFwibGF0aW4xXCJdO1xuY29uc3QgTWV0aG9kcyA9IFtcImdldFwiLCBcInBvc3RcIiwgXCJwdXRcIiwgXCJkZWxldGVcIl07XG5jb25zdCBFbmNzID0gW1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBcInRleHQvcGxhaW5cIl07XG5jb25zdCBCb29sID0gW1widHJ1ZVwiLCBcImZhbHNlXCJdO1xuY29uc3QgUyA9IHt9OyAvLyBFbXB0eSB0YWcgc3BlY1xuY29uc3QgVGFncyA9IHtcbiAgICBhOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBocmVmOiBudWxsLCBwaW5nOiBudWxsLCB0eXBlOiBudWxsLFxuICAgICAgICAgICAgbWVkaWE6IG51bGwsXG4gICAgICAgICAgICB0YXJnZXQ6IFRhcmdldHMsXG4gICAgICAgICAgICBocmVmbGFuZzogbnVsbFxuICAgICAgICB9XG4gICAgfSxcbiAgICBhYmJyOiBTLFxuICAgIGFkZHJlc3M6IFMsXG4gICAgYXJlYToge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgYWx0OiBudWxsLCBjb29yZHM6IG51bGwsIGhyZWY6IG51bGwsIHRhcmdldDogbnVsbCwgcGluZzogbnVsbCxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLCBocmVmbGFuZzogbnVsbCwgdHlwZTogbnVsbCxcbiAgICAgICAgICAgIHNoYXBlOiBbXCJkZWZhdWx0XCIsIFwicmVjdFwiLCBcImNpcmNsZVwiLCBcInBvbHlcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYXJ0aWNsZTogUyxcbiAgICBhc2lkZTogUyxcbiAgICBhdWRpbzoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgc3JjOiBudWxsLCBtZWRpYWdyb3VwOiBudWxsLFxuICAgICAgICAgICAgY3Jvc3NvcmlnaW46IFtcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiXSxcbiAgICAgICAgICAgIHByZWxvYWQ6IFtcIm5vbmVcIiwgXCJtZXRhZGF0YVwiLCBcImF1dG9cIl0sXG4gICAgICAgICAgICBhdXRvcGxheTogW1wiYXV0b3BsYXlcIl0sXG4gICAgICAgICAgICBsb29wOiBbXCJsb29wXCJdLFxuICAgICAgICAgICAgY29udHJvbHM6IFtcImNvbnRyb2xzXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGI6IFMsXG4gICAgYmFzZTogeyBhdHRyczogeyBocmVmOiBudWxsLCB0YXJnZXQ6IFRhcmdldHMgfSB9LFxuICAgIGJkaTogUyxcbiAgICBiZG86IFMsXG4gICAgYmxvY2txdW90ZTogeyBhdHRyczogeyBjaXRlOiBudWxsIH0gfSxcbiAgICBib2R5OiBTLFxuICAgIGJyOiBTLFxuICAgIGJ1dHRvbjoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZm9ybTogbnVsbCwgZm9ybWFjdGlvbjogbnVsbCwgbmFtZTogbnVsbCwgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICAgICAgICBmb3JtZW5jdHlwZTogRW5jcyxcbiAgICAgICAgICAgIGZvcm1tZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBmb3Jtbm92YWxpZGF0ZTogW1wibm92YWxpZGF0ZVwiXSxcbiAgICAgICAgICAgIGZvcm10YXJnZXQ6IFRhcmdldHMsXG4gICAgICAgICAgICB0eXBlOiBbXCJzdWJtaXRcIiwgXCJyZXNldFwiLCBcImJ1dHRvblwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjYW52YXM6IHsgYXR0cnM6IHsgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9IH0sXG4gICAgY2FwdGlvbjogUyxcbiAgICBjZW50ZXI6IFMsXG4gICAgY2l0ZTogUyxcbiAgICBjb2RlOiBTLFxuICAgIGNvbDogeyBhdHRyczogeyBzcGFuOiBudWxsIH0gfSxcbiAgICBjb2xncm91cDogeyBhdHRyczogeyBzcGFuOiBudWxsIH0gfSxcbiAgICBjb21tYW5kOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiBbXCJjb21tYW5kXCIsIFwiY2hlY2tib3hcIiwgXCJyYWRpb1wiXSxcbiAgICAgICAgICAgIGxhYmVsOiBudWxsLCBpY29uOiBudWxsLCByYWRpb2dyb3VwOiBudWxsLCBjb21tYW5kOiBudWxsLCB0aXRsZTogbnVsbCxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgICAgICAgIGNoZWNrZWQ6IFtcImNoZWNrZWRcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogeyBhdHRyczogeyB2YWx1ZTogbnVsbCB9IH0sXG4gICAgZGF0YWdyaWQ6IHsgYXR0cnM6IHsgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLCBtdWx0aXBsZTogW1wibXVsdGlwbGVcIl0gfSB9LFxuICAgIGRhdGFsaXN0OiB7IGF0dHJzOiB7IGRhdGE6IG51bGwgfSB9LFxuICAgIGRkOiBTLFxuICAgIGRlbDogeyBhdHRyczogeyBjaXRlOiBudWxsLCBkYXRldGltZTogbnVsbCB9IH0sXG4gICAgZGV0YWlsczogeyBhdHRyczogeyBvcGVuOiBbXCJvcGVuXCJdIH0gfSxcbiAgICBkZm46IFMsXG4gICAgZGl2OiBTLFxuICAgIGRsOiBTLFxuICAgIGR0OiBTLFxuICAgIGVtOiBTLFxuICAgIGVtYmVkOiB7IGF0dHJzOiB7IHNyYzogbnVsbCwgdHlwZTogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9IH0sXG4gICAgZXZlbnRzb3VyY2U6IHsgYXR0cnM6IHsgc3JjOiBudWxsIH0gfSxcbiAgICBmaWVsZHNldDogeyBhdHRyczogeyBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sIGZvcm06IG51bGwsIG5hbWU6IG51bGwgfSB9LFxuICAgIGZpZ2NhcHRpb246IFMsXG4gICAgZmlndXJlOiBTLFxuICAgIGZvb3RlcjogUyxcbiAgICBmb3JtOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBhY3Rpb246IG51bGwsIG5hbWU6IG51bGwsXG4gICAgICAgICAgICBcImFjY2VwdC1jaGFyc2V0XCI6IENoYXJzZXRzLFxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBbXCJvblwiLCBcIm9mZlwiXSxcbiAgICAgICAgICAgIGVuY3R5cGU6IEVuY3MsXG4gICAgICAgICAgICBtZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBub3ZhbGlkYXRlOiBbXCJub3ZhbGlkYXRlXCJdLFxuICAgICAgICAgICAgdGFyZ2V0OiBUYXJnZXRzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGgxOiBTLCBoMjogUywgaDM6IFMsIGg0OiBTLCBoNTogUywgaDY6IFMsXG4gICAgaGVhZDoge1xuICAgICAgICBjaGlsZHJlbjogW1widGl0bGVcIiwgXCJiYXNlXCIsIFwibGlua1wiLCBcInN0eWxlXCIsIFwibWV0YVwiLCBcInNjcmlwdFwiLCBcIm5vc2NyaXB0XCIsIFwiY29tbWFuZFwiXVxuICAgIH0sXG4gICAgaGVhZGVyOiBTLFxuICAgIGhncm91cDogUyxcbiAgICBocjogUyxcbiAgICBodG1sOiB7XG4gICAgICAgIGF0dHJzOiB7IG1hbmlmZXN0OiBudWxsIH1cbiAgICB9LFxuICAgIGk6IFMsXG4gICAgaWZyYW1lOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBzcmM6IG51bGwsIHNyY2RvYzogbnVsbCwgbmFtZTogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHNhbmRib3g6IFtcImFsbG93LXRvcC1uYXZpZ2F0aW9uXCIsIFwiYWxsb3ctc2FtZS1vcmlnaW5cIiwgXCJhbGxvdy1mb3Jtc1wiLCBcImFsbG93LXNjcmlwdHNcIl0sXG4gICAgICAgICAgICBzZWFtbGVzczogW1wic2VhbWxlc3NcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW1nOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBhbHQ6IG51bGwsIHNyYzogbnVsbCwgaXNtYXA6IG51bGwsIHVzZW1hcDogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luOiBbXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW5wdXQ6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGFsdDogbnVsbCwgZGlybmFtZTogbnVsbCwgZm9ybTogbnVsbCwgZm9ybWFjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIGhlaWdodDogbnVsbCwgbGlzdDogbnVsbCwgbWF4OiBudWxsLCBtYXhsZW5ndGg6IG51bGwsIG1pbjogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6IG51bGwsIHBhdHRlcm46IG51bGwsIHBsYWNlaG9sZGVyOiBudWxsLCBzaXplOiBudWxsLCBzcmM6IG51bGwsXG4gICAgICAgICAgICBzdGVwOiBudWxsLCB2YWx1ZTogbnVsbCwgd2lkdGg6IG51bGwsXG4gICAgICAgICAgICBhY2NlcHQ6IFtcImF1ZGlvLypcIiwgXCJ2aWRlby8qXCIsIFwiaW1hZ2UvKlwiXSxcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogW1wib25cIiwgXCJvZmZcIl0sXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGNoZWNrZWQ6IFtcImNoZWNrZWRcIl0sXG4gICAgICAgICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICAgICAgICBmb3JtZW5jdHlwZTogRW5jcyxcbiAgICAgICAgICAgIGZvcm1tZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBmb3Jtbm92YWxpZGF0ZTogW1wibm92YWxpZGF0ZVwiXSxcbiAgICAgICAgICAgIGZvcm10YXJnZXQ6IFRhcmdldHMsXG4gICAgICAgICAgICBtdWx0aXBsZTogW1wibXVsdGlwbGVcIl0sXG4gICAgICAgICAgICByZWFkb25seTogW1wicmVhZG9ubHlcIl0sXG4gICAgICAgICAgICByZXF1aXJlZDogW1wicmVxdWlyZWRcIl0sXG4gICAgICAgICAgICB0eXBlOiBbXCJoaWRkZW5cIiwgXCJ0ZXh0XCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCIsIFwiZW1haWxcIiwgXCJwYXNzd29yZFwiLCBcImRhdGV0aW1lXCIsIFwiZGF0ZVwiLCBcIm1vbnRoXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWVrXCIsIFwidGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsIFwibnVtYmVyXCIsIFwicmFuZ2VcIiwgXCJjb2xvclwiLCBcImNoZWNrYm94XCIsIFwicmFkaW9cIixcbiAgICAgICAgICAgICAgICBcImZpbGVcIiwgXCJzdWJtaXRcIiwgXCJpbWFnZVwiLCBcInJlc2V0XCIsIFwiYnV0dG9uXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGluczogeyBhdHRyczogeyBjaXRlOiBudWxsLCBkYXRldGltZTogbnVsbCB9IH0sXG4gICAga2JkOiBTLFxuICAgIGtleWdlbjoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgY2hhbGxlbmdlOiBudWxsLCBmb3JtOiBudWxsLCBuYW1lOiBudWxsLFxuICAgICAgICAgICAgYXV0b2ZvY3VzOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICAgICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICAgICAgICBrZXl0eXBlOiBbXCJSU0FcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbGFiZWw6IHsgYXR0cnM6IHsgZm9yOiBudWxsLCBmb3JtOiBudWxsIH0gfSxcbiAgICBsZWdlbmQ6IFMsXG4gICAgbGk6IHsgYXR0cnM6IHsgdmFsdWU6IG51bGwgfSB9LFxuICAgIGxpbms6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGhyZWY6IG51bGwsIHR5cGU6IG51bGwsXG4gICAgICAgICAgICBocmVmbGFuZzogbnVsbCxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLFxuICAgICAgICAgICAgc2l6ZXM6IFtcImFsbFwiLCBcIjE2eDE2XCIsIFwiMTZ4MTYgMzJ4MzJcIiwgXCIxNngxNiAzMngzMiA2NHg2NFwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXA6IHsgYXR0cnM6IHsgbmFtZTogbnVsbCB9IH0sXG4gICAgbWFyazogUyxcbiAgICBtZW51OiB7IGF0dHJzOiB7IGxhYmVsOiBudWxsLCB0eXBlOiBbXCJsaXN0XCIsIFwiY29udGV4dFwiLCBcInRvb2xiYXJcIl0gfSB9LFxuICAgIG1ldGE6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgICAgICAgICBjaGFyc2V0OiBDaGFyc2V0cyxcbiAgICAgICAgICAgIG5hbWU6IFtcInZpZXdwb3J0XCIsIFwiYXBwbGljYXRpb24tbmFtZVwiLCBcImF1dGhvclwiLCBcImRlc2NyaXB0aW9uXCIsIFwiZ2VuZXJhdG9yXCIsIFwia2V5d29yZHNcIl0sXG4gICAgICAgICAgICBcImh0dHAtZXF1aXZcIjogW1wiY29udGVudC1sYW5ndWFnZVwiLCBcImNvbnRlbnQtdHlwZVwiLCBcImRlZmF1bHQtc3R5bGVcIiwgXCJyZWZyZXNoXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGVyOiB7IGF0dHJzOiB7IHZhbHVlOiBudWxsLCBtaW46IG51bGwsIGxvdzogbnVsbCwgaGlnaDogbnVsbCwgbWF4OiBudWxsLCBvcHRpbXVtOiBudWxsIH0gfSxcbiAgICBuYXY6IFMsXG4gICAgbm9zY3JpcHQ6IFMsXG4gICAgb2JqZWN0OiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLCB0eXBlOiBudWxsLCBuYW1lOiBudWxsLCB1c2VtYXA6IG51bGwsIGZvcm06IG51bGwsIHdpZHRoOiBudWxsLCBoZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICB0eXBlbXVzdG1hdGNoOiBbXCJ0eXBlbXVzdG1hdGNoXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9sOiB7IGF0dHJzOiB7IHJldmVyc2VkOiBbXCJyZXZlcnNlZFwiXSwgc3RhcnQ6IG51bGwsIHR5cGU6IFtcIjFcIiwgXCJhXCIsIFwiQVwiLCBcImlcIiwgXCJJXCJdIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbXCJsaVwiLCBcInNjcmlwdFwiLCBcInRlbXBsYXRlXCIsIFwidWxcIiwgXCJvbFwiXSB9LFxuICAgIG9wdGdyb3VwOiB7IGF0dHJzOiB7IGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSwgbGFiZWw6IG51bGwgfSB9LFxuICAgIG9wdGlvbjogeyBhdHRyczogeyBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sIGxhYmVsOiBudWxsLCBzZWxlY3RlZDogW1wic2VsZWN0ZWRcIl0sIHZhbHVlOiBudWxsIH0gfSxcbiAgICBvdXRwdXQ6IHsgYXR0cnM6IHsgZm9yOiBudWxsLCBmb3JtOiBudWxsLCBuYW1lOiBudWxsIH0gfSxcbiAgICBwOiBTLFxuICAgIHBhcmFtOiB7IGF0dHJzOiB7IG5hbWU6IG51bGwsIHZhbHVlOiBudWxsIH0gfSxcbiAgICBwcmU6IFMsXG4gICAgcHJvZ3Jlc3M6IHsgYXR0cnM6IHsgdmFsdWU6IG51bGwsIG1heDogbnVsbCB9IH0sXG4gICAgcTogeyBhdHRyczogeyBjaXRlOiBudWxsIH0gfSxcbiAgICBycDogUyxcbiAgICBydDogUyxcbiAgICBydWJ5OiBTLFxuICAgIHNhbXA6IFMsXG4gICAgc2NyaXB0OiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiBbXCJ0ZXh0L2phdmFzY3JpcHRcIl0sXG4gICAgICAgICAgICBzcmM6IG51bGwsXG4gICAgICAgICAgICBhc3luYzogW1wiYXN5bmNcIl0sXG4gICAgICAgICAgICBkZWZlcjogW1wiZGVmZXJcIl0sXG4gICAgICAgICAgICBjaGFyc2V0OiBDaGFyc2V0c1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZWN0aW9uOiBTLFxuICAgIHNlbGVjdDoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZm9ybTogbnVsbCwgbmFtZTogbnVsbCwgc2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGF1dG9mb2N1czogW1wiYXV0b2ZvY3VzXCJdLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLFxuICAgICAgICAgICAgbXVsdGlwbGU6IFtcIm11bHRpcGxlXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNsb3Q6IHsgYXR0cnM6IHsgbmFtZTogbnVsbCB9IH0sXG4gICAgc21hbGw6IFMsXG4gICAgc291cmNlOiB7IGF0dHJzOiB7IHNyYzogbnVsbCwgdHlwZTogbnVsbCwgbWVkaWE6IG51bGwgfSB9LFxuICAgIHNwYW46IFMsXG4gICAgc3Ryb25nOiBTLFxuICAgIHN0eWxlOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiBbXCJ0ZXh0L2Nzc1wiXSxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLFxuICAgICAgICAgICAgc2NvcGVkOiBudWxsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN1YjogUyxcbiAgICBzdW1tYXJ5OiBTLFxuICAgIHN1cDogUyxcbiAgICB0YWJsZTogUyxcbiAgICB0Ym9keTogUyxcbiAgICB0ZDogeyBhdHRyczogeyBjb2xzcGFuOiBudWxsLCByb3dzcGFuOiBudWxsLCBoZWFkZXJzOiBudWxsIH0gfSxcbiAgICB0ZW1wbGF0ZTogUyxcbiAgICB0ZXh0YXJlYToge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZGlybmFtZTogbnVsbCwgZm9ybTogbnVsbCwgbWF4bGVuZ3RoOiBudWxsLCBuYW1lOiBudWxsLCBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgICAgIHJvd3M6IG51bGwsIGNvbHM6IG51bGwsXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgICAgICAgIHJlYWRvbmx5OiBbXCJyZWFkb25seVwiXSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJyZXF1aXJlZFwiXSxcbiAgICAgICAgICAgIHdyYXA6IFtcInNvZnRcIiwgXCJoYXJkXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRmb290OiBTLFxuICAgIHRoOiB7IGF0dHJzOiB7IGNvbHNwYW46IG51bGwsIHJvd3NwYW46IG51bGwsIGhlYWRlcnM6IG51bGwsIHNjb3BlOiBbXCJyb3dcIiwgXCJjb2xcIiwgXCJyb3dncm91cFwiLCBcImNvbGdyb3VwXCJdIH0gfSxcbiAgICB0aGVhZDogUyxcbiAgICB0aW1lOiB7IGF0dHJzOiB7IGRhdGV0aW1lOiBudWxsIH0gfSxcbiAgICB0aXRsZTogUyxcbiAgICB0cjogUyxcbiAgICB0cmFjazoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgc3JjOiBudWxsLCBsYWJlbDogbnVsbCwgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIGtpbmQ6IFtcInN1YnRpdGxlc1wiLCBcImNhcHRpb25zXCIsIFwiZGVzY3JpcHRpb25zXCIsIFwiY2hhcHRlcnNcIiwgXCJtZXRhZGF0YVwiXSxcbiAgICAgICAgICAgIHNyY2xhbmc6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdWw6IHsgY2hpbGRyZW46IFtcImxpXCIsIFwic2NyaXB0XCIsIFwidGVtcGxhdGVcIiwgXCJ1bFwiLCBcIm9sXCJdIH0sXG4gICAgdmFyOiBTLFxuICAgIHZpZGVvOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBzcmM6IG51bGwsIHBvc3RlcjogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luOiBbXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIl0sXG4gICAgICAgICAgICBwcmVsb2FkOiBbXCJhdXRvXCIsIFwibWV0YWRhdGFcIiwgXCJub25lXCJdLFxuICAgICAgICAgICAgYXV0b3BsYXk6IFtcImF1dG9wbGF5XCJdLFxuICAgICAgICAgICAgbWVkaWFncm91cDogW1wibW92aWVcIl0sXG4gICAgICAgICAgICBtdXRlZDogW1wibXV0ZWRcIl0sXG4gICAgICAgICAgICBjb250cm9sczogW1wiY29udHJvbHNcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2JyOiBTXG59O1xuY29uc3QgR2xvYmFsQXR0cnMgPSB7XG4gICAgYWNjZXNza2V5OiBudWxsLFxuICAgIGNsYXNzOiBudWxsLFxuICAgIGNvbnRlbnRlZGl0YWJsZTogQm9vbCxcbiAgICBjb250ZXh0bWVudTogbnVsbCxcbiAgICBkaXI6IFtcImx0clwiLCBcInJ0bFwiLCBcImF1dG9cIl0sXG4gICAgZHJhZ2dhYmxlOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJhdXRvXCJdLFxuICAgIGRyb3B6b25lOiBbXCJjb3B5XCIsIFwibW92ZVwiLCBcImxpbmtcIiwgXCJzdHJpbmc6XCIsIFwiZmlsZTpcIl0sXG4gICAgaGlkZGVuOiBbXCJoaWRkZW5cIl0sXG4gICAgaWQ6IG51bGwsXG4gICAgaW5lcnQ6IFtcImluZXJ0XCJdLFxuICAgIGl0ZW1pZDogbnVsbCxcbiAgICBpdGVtcHJvcDogbnVsbCxcbiAgICBpdGVtcmVmOiBudWxsLFxuICAgIGl0ZW1zY29wZTogW1wiaXRlbXNjb3BlXCJdLFxuICAgIGl0ZW10eXBlOiBudWxsLFxuICAgIGxhbmc6IFtcImFyXCIsIFwiYm5cIiwgXCJkZVwiLCBcImVuLUdCXCIsIFwiZW4tVVNcIiwgXCJlc1wiLCBcImZyXCIsIFwiaGlcIiwgXCJpZFwiLCBcImphXCIsIFwicGFcIiwgXCJwdFwiLCBcInJ1XCIsIFwidHJcIiwgXCJ6aFwiXSxcbiAgICBzcGVsbGNoZWNrOiBCb29sLFxuICAgIGF1dG9jb3JyZWN0OiBCb29sLFxuICAgIGF1dG9jYXBpdGFsaXplOiBCb29sLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIHRhYmluZGV4OiBudWxsLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHRyYW5zbGF0ZTogW1wieWVzXCIsIFwibm9cIl0sXG4gICAgcmVsOiBbXCJzdHlsZXNoZWV0XCIsIFwiYWx0ZXJuYXRlXCIsIFwiYXV0aG9yXCIsIFwiYm9va21hcmtcIiwgXCJoZWxwXCIsIFwibGljZW5zZVwiLCBcIm5leHRcIiwgXCJub2ZvbGxvd1wiLCBcIm5vcmVmZXJyZXJcIiwgXCJwcmVmZXRjaFwiLCBcInByZXZcIiwgXCJzZWFyY2hcIiwgXCJ0YWdcIl0sXG4gICAgcm9sZTogXCJhbGVydCBhcHBsaWNhdGlvbiBhcnRpY2xlIGJhbm5lciBidXR0b24gY2VsbCBjaGVja2JveCBjb21wbGVtZW50YXJ5IGNvbnRlbnRpbmZvIGRpYWxvZyBkb2N1bWVudCBmZWVkIGZpZ3VyZSBmb3JtIGdyaWQgZ3JpZGNlbGwgaGVhZGluZyBpbWcgbGlzdCBsaXN0Ym94IGxpc3RpdGVtIG1haW4gbmF2aWdhdGlvbiByZWdpb24gcm93IHJvd2dyb3VwIHNlYXJjaCBzd2l0Y2ggdGFiIHRhYmxlIHRhYnBhbmVsIHRleHRib3ggdGltZXJcIi5zcGxpdChcIiBcIiksXG4gICAgXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjogbnVsbCxcbiAgICBcImFyaWEtYXRvbWljXCI6IEJvb2wsXG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBbXCJpbmxpbmVcIiwgXCJsaXN0XCIsIFwiYm90aFwiLCBcIm5vbmVcIl0sXG4gICAgXCJhcmlhLWJ1c3lcIjogQm9vbCxcbiAgICBcImFyaWEtY2hlY2tlZFwiOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJtaXhlZFwiLCBcInVuZGVmaW5lZFwiXSxcbiAgICBcImFyaWEtY29udHJvbHNcIjogbnVsbCxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogbnVsbCxcbiAgICBcImFyaWEtZGlzYWJsZWRcIjogQm9vbCxcbiAgICBcImFyaWEtZHJvcGVmZmVjdFwiOiBudWxsLFxuICAgIFwiYXJpYS1leHBhbmRlZFwiOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgXCJhcmlhLWZsb3d0b1wiOiBudWxsLFxuICAgIFwiYXJpYS1ncmFiYmVkXCI6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcInVuZGVmaW5lZFwiXSxcbiAgICBcImFyaWEtaGFzcG9wdXBcIjogQm9vbCxcbiAgICBcImFyaWEtaGlkZGVuXCI6IEJvb2wsXG4gICAgXCJhcmlhLWludmFsaWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwiZ3JhbW1hclwiLCBcInNwZWxsaW5nXCJdLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBudWxsLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IG51bGwsXG4gICAgXCJhcmlhLWxldmVsXCI6IG51bGwsXG4gICAgXCJhcmlhLWxpdmVcIjogW1wib2ZmXCIsIFwicG9saXRlXCIsIFwiYXNzZXJ0aXZlXCJdLFxuICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogQm9vbCxcbiAgICBcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCI6IEJvb2wsXG4gICAgXCJhcmlhLW93bnNcIjogbnVsbCxcbiAgICBcImFyaWEtcG9zaW5zZXRcIjogbnVsbCxcbiAgICBcImFyaWEtcHJlc3NlZFwiOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJtaXhlZFwiLCBcInVuZGVmaW5lZFwiXSxcbiAgICBcImFyaWEtcmVhZG9ubHlcIjogQm9vbCxcbiAgICBcImFyaWEtcmVsZXZhbnRcIjogbnVsbCxcbiAgICBcImFyaWEtcmVxdWlyZWRcIjogQm9vbCxcbiAgICBcImFyaWEtc2VsZWN0ZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwidW5kZWZpbmVkXCJdLFxuICAgIFwiYXJpYS1zZXRzaXplXCI6IG51bGwsXG4gICAgXCJhcmlhLXNvcnRcIjogW1wiYXNjZW5kaW5nXCIsIFwiZGVzY2VuZGluZ1wiLCBcIm5vbmVcIiwgXCJvdGhlclwiXSxcbiAgICBcImFyaWEtdmFsdWVtYXhcIjogbnVsbCxcbiAgICBcImFyaWEtdmFsdWVtaW5cIjogbnVsbCxcbiAgICBcImFyaWEtdmFsdWVub3dcIjogbnVsbCxcbiAgICBcImFyaWEtdmFsdWV0ZXh0XCI6IG51bGxcbn07XG5jb25zdCBldmVudEF0dHJpYnV0ZXMgPSAoXCJiZWZvcmV1bmxvYWQgY29weSBjdXQgZHJhZ3N0YXJ0IGRyYWdvdmVyIGRyYWdsZWF2ZSBkcmFnZW50ZXIgZHJhZ2VuZCBcIiArXG4gICAgXCJkcmFnIHBhc3RlIGZvY3VzIGJsdXIgY2hhbmdlIGNsaWNrIGxvYWQgbW91c2Vkb3duIG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG4gICAgXCJtb3VzZXVwIGtleWRvd24ga2V5dXAgcmVzaXplIHNjcm9sbCB1bmxvYWRcIikuc3BsaXQoXCIgXCIpLm1hcChuID0+IFwib25cIiArIG4pO1xuZm9yIChsZXQgYSBvZiBldmVudEF0dHJpYnV0ZXMpXG4gICAgR2xvYmFsQXR0cnNbYV0gPSBudWxsO1xuY2xhc3MgU2NoZW1hIHtcbiAgICBjb25zdHJ1Y3RvcihleHRyYVRhZ3MsIGV4dHJhQXR0cnMpIHtcbiAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBUYWdzKSwgZXh0cmFUYWdzKTtcbiAgICAgICAgdGhpcy5nbG9iYWxBdHRycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgR2xvYmFsQXR0cnMpLCBleHRyYUF0dHJzKTtcbiAgICAgICAgdGhpcy5hbGxUYWdzID0gT2JqZWN0LmtleXModGhpcy50YWdzKTtcbiAgICAgICAgdGhpcy5nbG9iYWxBdHRyTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmdsb2JhbEF0dHJzKTtcbiAgICB9XG59XG5TY2hlbWEuZGVmYXVsdCA9IG5ldyBTY2hlbWE7XG5mdW5jdGlvbiBlbGVtZW50TmFtZShkb2MsIHRyZWUsIG1heCA9IGRvYy5sZW5ndGgpIHtcbiAgICBpZiAoIXRyZWUpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIGxldCB0YWcgPSB0cmVlLmZpcnN0Q2hpbGQ7XG4gICAgbGV0IG5hbWUgPSB0YWcgJiYgdGFnLmdldENoaWxkKFwiVGFnTmFtZVwiKTtcbiAgICByZXR1cm4gbmFtZSA/IGRvYy5zbGljZVN0cmluZyhuYW1lLmZyb20sIE1hdGgubWluKG5hbWUudG8sIG1heCkpIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGZpbmRQYXJlbnRFbGVtZW50KHRyZWUsIHNraXAgPSBmYWxzZSkge1xuICAgIGZvciAoOyB0cmVlOyB0cmVlID0gdHJlZS5wYXJlbnQpXG4gICAgICAgIGlmICh0cmVlLm5hbWUgPT0gXCJFbGVtZW50XCIpIHtcbiAgICAgICAgICAgIGlmIChza2lwKVxuICAgICAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYWxsb3dlZENoaWxkcmVuKGRvYywgdHJlZSwgc2NoZW1hKSB7XG4gICAgbGV0IHBhcmVudEluZm8gPSBzY2hlbWEudGFnc1tlbGVtZW50TmFtZShkb2MsIGZpbmRQYXJlbnRFbGVtZW50KHRyZWUpKV07XG4gICAgcmV0dXJuIChwYXJlbnRJbmZvID09PSBudWxsIHx8IHBhcmVudEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudEluZm8uY2hpbGRyZW4pIHx8IHNjaGVtYS5hbGxUYWdzO1xufVxuZnVuY3Rpb24gb3BlblRhZ3MoZG9jLCB0cmVlKSB7XG4gICAgbGV0IG9wZW4gPSBbXTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBmaW5kUGFyZW50RWxlbWVudCh0cmVlKTsgcGFyZW50ICYmICFwYXJlbnQudHlwZS5pc1RvcDsgcGFyZW50ID0gZmluZFBhcmVudEVsZW1lbnQocGFyZW50LnBhcmVudCkpIHtcbiAgICAgICAgbGV0IHRhZ05hbWUgPSBlbGVtZW50TmFtZShkb2MsIHBhcmVudCk7XG4gICAgICAgIGlmICh0YWdOYW1lICYmIHBhcmVudC5sYXN0Q2hpbGQubmFtZSA9PSBcIkNsb3NlVGFnXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHRhZ05hbWUgJiYgb3Blbi5pbmRleE9mKHRhZ05hbWUpIDwgMCAmJiAodHJlZS5uYW1lID09IFwiRW5kVGFnXCIgfHwgdHJlZS5mcm9tID49IHBhcmVudC5maXJzdENoaWxkLnRvKSlcbiAgICAgICAgICAgIG9wZW4ucHVzaCh0YWdOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wZW47XG59XG5jb25zdCBpZGVudGlmaWVyID0gL15bOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC87XG5mdW5jdGlvbiBjb21wbGV0ZVRhZyhzdGF0ZSwgc2NoZW1hLCB0cmVlLCBmcm9tLCB0bykge1xuICAgIGxldCBlbmQgPSAvXFxzKj4vLnRlc3Qoc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgNSkpID8gXCJcIiA6IFwiPlwiO1xuICAgIGxldCBwYXJlbnQgPSBmaW5kUGFyZW50RWxlbWVudCh0cmVlLCB0cnVlKTtcbiAgICByZXR1cm4geyBmcm9tLCB0byxcbiAgICAgICAgb3B0aW9uczogYWxsb3dlZENoaWxkcmVuKHN0YXRlLmRvYywgcGFyZW50LCBzY2hlbWEpLm1hcCh0YWdOYW1lID0+ICh7IGxhYmVsOiB0YWdOYW1lLCB0eXBlOiBcInR5cGVcIiB9KSkuY29uY2F0KG9wZW5UYWdzKHN0YXRlLmRvYywgdHJlZSkubWFwKCh0YWcsIGkpID0+ICh7IGxhYmVsOiBcIi9cIiArIHRhZywgYXBwbHk6IFwiL1wiICsgdGFnICsgZW5kLFxuICAgICAgICAgICAgdHlwZTogXCJ0eXBlXCIsIGJvb3N0OiA5OSAtIGkgfSkpKSxcbiAgICAgICAgdmFsaWRGb3I6IC9eXFwvP1s6XFwtXFwuXFx3XFx1MDBiNy1cXHVmZmZmXSokLyB9O1xufVxuZnVuY3Rpb24gY29tcGxldGVDbG9zZVRhZyhzdGF0ZSwgdHJlZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgZW5kID0gL1xccyo+Ly50ZXN0KHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIDUpKSA/IFwiXCIgOiBcIj5cIjtcbiAgICByZXR1cm4geyBmcm9tLCB0byxcbiAgICAgICAgb3B0aW9uczogb3BlblRhZ3Moc3RhdGUuZG9jLCB0cmVlKS5tYXAoKHRhZywgaSkgPT4gKHsgbGFiZWw6IHRhZywgYXBwbHk6IHRhZyArIGVuZCwgdHlwZTogXCJ0eXBlXCIsIGJvb3N0OiA5OSAtIGkgfSkpLFxuICAgICAgICB2YWxpZEZvcjogaWRlbnRpZmllciB9O1xufVxuZnVuY3Rpb24gY29tcGxldGVTdGFydFRhZyhzdGF0ZSwgc2NoZW1hLCB0cmVlLCBwb3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IFtdLCBsZXZlbCA9IDA7XG4gICAgZm9yIChsZXQgdGFnTmFtZSBvZiBhbGxvd2VkQ2hpbGRyZW4oc3RhdGUuZG9jLCB0cmVlLCBzY2hlbWEpKVxuICAgICAgICBvcHRpb25zLnB1c2goeyBsYWJlbDogXCI8XCIgKyB0YWdOYW1lLCB0eXBlOiBcInR5cGVcIiB9KTtcbiAgICBmb3IgKGxldCBvcGVuIG9mIG9wZW5UYWdzKHN0YXRlLmRvYywgdHJlZSkpXG4gICAgICAgIG9wdGlvbnMucHVzaCh7IGxhYmVsOiBcIjwvXCIgKyBvcGVuICsgXCI+XCIsIHR5cGU6IFwidHlwZVwiLCBib29zdDogOTkgLSBsZXZlbCsrIH0pO1xuICAgIHJldHVybiB7IGZyb206IHBvcywgdG86IHBvcywgb3B0aW9ucywgdmFsaWRGb3I6IC9ePFxcLz9bOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC8gfTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlQXR0ck5hbWUoc3RhdGUsIHNjaGVtYSwgdHJlZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgZWx0ID0gZmluZFBhcmVudEVsZW1lbnQodHJlZSksIGluZm8gPSBlbHQgPyBzY2hlbWEudGFnc1tlbGVtZW50TmFtZShzdGF0ZS5kb2MsIGVsdCldIDogbnVsbDtcbiAgICBsZXQgbG9jYWxBdHRycyA9IGluZm8gJiYgaW5mby5hdHRycyA/IE9iamVjdC5rZXlzKGluZm8uYXR0cnMpIDogW107XG4gICAgbGV0IG5hbWVzID0gaW5mbyAmJiBpbmZvLmdsb2JhbEF0dHJzID09PSBmYWxzZSA/IGxvY2FsQXR0cnNcbiAgICAgICAgOiBsb2NhbEF0dHJzLmxlbmd0aCA/IGxvY2FsQXR0cnMuY29uY2F0KHNjaGVtYS5nbG9iYWxBdHRyTmFtZXMpIDogc2NoZW1hLmdsb2JhbEF0dHJOYW1lcztcbiAgICByZXR1cm4geyBmcm9tLCB0byxcbiAgICAgICAgb3B0aW9uczogbmFtZXMubWFwKGF0dHJOYW1lID0+ICh7IGxhYmVsOiBhdHRyTmFtZSwgdHlwZTogXCJwcm9wZXJ0eVwiIH0pKSxcbiAgICAgICAgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlQXR0clZhbHVlKHN0YXRlLCBzY2hlbWEsIHRyZWUsIGZyb20sIHRvKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBuYW1lTm9kZSA9IChfYSA9IHRyZWUucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q2hpbGQoXCJBdHRyaWJ1dGVOYW1lXCIpO1xuICAgIGxldCBvcHRpb25zID0gW10sIHRva2VuID0gdW5kZWZpbmVkO1xuICAgIGlmIChuYW1lTm9kZSkge1xuICAgICAgICBsZXQgYXR0ck5hbWUgPSBzdGF0ZS5zbGljZURvYyhuYW1lTm9kZS5mcm9tLCBuYW1lTm9kZS50byk7XG4gICAgICAgIGxldCBhdHRycyA9IHNjaGVtYS5nbG9iYWxBdHRyc1thdHRyTmFtZV07XG4gICAgICAgIGlmICghYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCBlbHQgPSBmaW5kUGFyZW50RWxlbWVudCh0cmVlKSwgaW5mbyA9IGVsdCA/IHNjaGVtYS50YWdzW2VsZW1lbnROYW1lKHN0YXRlLmRvYywgZWx0KV0gOiBudWxsO1xuICAgICAgICAgICAgYXR0cnMgPSAoaW5mbyA9PT0gbnVsbCB8fCBpbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvLmF0dHJzKSAmJiBpbmZvLmF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCBiYXNlID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pLnRvTG93ZXJDYXNlKCksIHF1b3RlU3RhcnQgPSAnXCInLCBxdW90ZUVuZCA9ICdcIic7XG4gICAgICAgICAgICBpZiAoL15bJ1wiXS8udGVzdChiYXNlKSkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gYmFzZVswXSA9PSAnXCInID8gL15bXlwiXSokLyA6IC9eW14nXSokLztcbiAgICAgICAgICAgICAgICBxdW90ZVN0YXJ0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBxdW90ZUVuZCA9IHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIDEpID09IGJhc2VbMF0gPyBcIlwiIDogYmFzZVswXTtcbiAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBmcm9tKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IC9eW15cXHM8Pj0nXCJdKiQvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgYXR0cnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHsgbGFiZWw6IHZhbHVlLCBhcHBseTogcXVvdGVTdGFydCArIHZhbHVlICsgcXVvdGVFbmQsIHR5cGU6IFwiY29uc3RhbnRcIiB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBmcm9tLCB0bywgb3B0aW9ucywgdmFsaWRGb3I6IHRva2VuIH07XG59XG5mdW5jdGlvbiBodG1sQ29tcGxldGlvbkZvcihzY2hlbWEsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBzdGF0ZSwgcG9zIH0gPSBjb250ZXh0LCB0cmVlID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcywgLTEpLCBhcm91bmQgPSB0cmVlLnJlc29sdmUocG9zKTtcbiAgICBmb3IgKGxldCBzY2FuID0gcG9zLCBiZWZvcmU7IGFyb3VuZCA9PSB0cmVlICYmIChiZWZvcmUgPSB0cmVlLmNoaWxkQmVmb3JlKHNjYW4pKTspIHtcbiAgICAgICAgbGV0IGxhc3QgPSBiZWZvcmUubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgIWxhc3QudHlwZS5pc0Vycm9yIHx8IGxhc3QuZnJvbSA8IGxhc3QudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgYXJvdW5kID0gdHJlZSA9IGJlZm9yZTtcbiAgICAgICAgc2NhbiA9IGxhc3QuZnJvbTtcbiAgICB9XG4gICAgaWYgKHRyZWUubmFtZSA9PSBcIlRhZ05hbWVcIikge1xuICAgICAgICByZXR1cm4gdHJlZS5wYXJlbnQgJiYgL0Nsb3NlVGFnJC8udGVzdCh0cmVlLnBhcmVudC5uYW1lKSA/IGNvbXBsZXRlQ2xvc2VUYWcoc3RhdGUsIHRyZWUsIHRyZWUuZnJvbSwgcG9zKVxuICAgICAgICAgICAgOiBjb21wbGV0ZVRhZyhzdGF0ZSwgc2NoZW1hLCB0cmVlLCB0cmVlLmZyb20sIHBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyZWUubmFtZSA9PSBcIlN0YXJ0VGFnXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlVGFnKHN0YXRlLCBzY2hlbWEsIHRyZWUsIHBvcywgcG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJlZS5uYW1lID09IFwiU3RhcnRDbG9zZVRhZ1wiIHx8IHRyZWUubmFtZSA9PSBcIkluY29tcGxldGVDbG9zZVRhZ1wiKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZUNsb3NlVGFnKHN0YXRlLCB0cmVlLCBwb3MsIHBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyZWUubmFtZSA9PSBcIk9wZW5UYWdcIiB8fCB0cmVlLm5hbWUgPT0gXCJTZWxmQ2xvc2luZ1RhZ1wiIHx8IHRyZWUubmFtZSA9PSBcIkF0dHJpYnV0ZU5hbWVcIikge1xuICAgICAgICByZXR1cm4gY29tcGxldGVBdHRyTmFtZShzdGF0ZSwgc2NoZW1hLCB0cmVlLCB0cmVlLm5hbWUgPT0gXCJBdHRyaWJ1dGVOYW1lXCIgPyB0cmVlLmZyb20gOiBwb3MsIHBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyZWUubmFtZSA9PSBcIklzXCIgfHwgdHJlZS5uYW1lID09IFwiQXR0cmlidXRlVmFsdWVcIiB8fCB0cmVlLm5hbWUgPT0gXCJVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlQXR0clZhbHVlKHN0YXRlLCBzY2hlbWEsIHRyZWUsIHRyZWUubmFtZSA9PSBcIklzXCIgPyBwb3MgOiB0cmVlLmZyb20sIHBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQuZXhwbGljaXQgJiYgKGFyb3VuZC5uYW1lID09IFwiRWxlbWVudFwiIHx8IGFyb3VuZC5uYW1lID09IFwiVGV4dFwiIHx8IGFyb3VuZC5uYW1lID09IFwiRG9jdW1lbnRcIikpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlU3RhcnRUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgcG9zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuSFRNTCB0YWcgY29tcGxldGlvbi4gT3BlbnMgYW5kIGNsb3NlcyB0YWdzIGFuZCBhdHRyaWJ1dGVzIGluIGFcbmNvbnRleHQtYXdhcmUgd2F5LlxuKi9cbmZ1bmN0aW9uIGh0bWxDb21wbGV0aW9uU291cmNlKGNvbnRleHQpIHtcbiAgICByZXR1cm4gaHRtbENvbXBsZXRpb25Gb3IoU2NoZW1hLmRlZmF1bHQsIGNvbnRleHQpO1xufVxuLyoqXG5DcmVhdGUgYSBjb21wbGV0aW9uIHNvdXJjZSBmb3IgSFRNTCBleHRlbmRlZCB3aXRoIGFkZGl0aW9uYWwgdGFnc1xub3IgYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiBodG1sQ29tcGxldGlvblNvdXJjZVdpdGgoY29uZmlnKSB7XG4gICAgbGV0IHsgZXh0cmFUYWdzLCBleHRyYUdsb2JhbEF0dHJpYnV0ZXM6IGV4dHJhQXR0cnMgfSA9IGNvbmZpZztcbiAgICBsZXQgc2NoZW1hID0gZXh0cmFBdHRycyB8fCBleHRyYVRhZ3MgPyBuZXcgU2NoZW1hKGV4dHJhVGFncywgZXh0cmFBdHRycykgOiBTY2hlbWEuZGVmYXVsdDtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IGh0bWxDb21wbGV0aW9uRm9yKHNjaGVtYSwgY29udGV4dCk7XG59XG5cbmNvbnN0IGpzb25QYXJzZXIgPSBsYW5nSmF2YXNjcmlwdC5qYXZhc2NyaXB0TGFuZ3VhZ2UucGFyc2VyLmNvbmZpZ3VyZSh7IHRvcDogXCJTaW5nbGVFeHByZXNzaW9uXCIgfSk7XG5jb25zdCBkZWZhdWx0TmVzdGluZyA9IFtcbiAgICB7IHRhZzogXCJzY3JpcHRcIixcbiAgICAgICAgYXR0cnM6IGF0dHJzID0+IGF0dHJzLnR5cGUgPT0gXCJ0ZXh0L3R5cGVzY3JpcHRcIiB8fCBhdHRycy5sYW5nID09IFwidHNcIixcbiAgICAgICAgcGFyc2VyOiBsYW5nSmF2YXNjcmlwdC50eXBlc2NyaXB0TGFuZ3VhZ2UucGFyc2VyIH0sXG4gICAgeyB0YWc6IFwic2NyaXB0XCIsXG4gICAgICAgIGF0dHJzOiBhdHRycyA9PiBhdHRycy50eXBlID09IFwidGV4dC9iYWJlbFwiIHx8IGF0dHJzLnR5cGUgPT0gXCJ0ZXh0L2pzeFwiLFxuICAgICAgICBwYXJzZXI6IGxhbmdKYXZhc2NyaXB0LmpzeExhbmd1YWdlLnBhcnNlciB9LFxuICAgIHsgdGFnOiBcInNjcmlwdFwiLFxuICAgICAgICBhdHRyczogYXR0cnMgPT4gYXR0cnMudHlwZSA9PSBcInRleHQvdHlwZXNjcmlwdC1qc3hcIixcbiAgICAgICAgcGFyc2VyOiBsYW5nSmF2YXNjcmlwdC50c3hMYW5ndWFnZS5wYXJzZXIgfSxcbiAgICB7IHRhZzogXCJzY3JpcHRcIixcbiAgICAgICAgYXR0cnMoYXR0cnMpIHtcbiAgICAgICAgICAgIHJldHVybiAvXihpbXBvcnRtYXB8c3BlY3VsYXRpb25ydWxlc3xhcHBsaWNhdGlvblxcLyguK1xcKyk/anNvbikkL2kudGVzdChhdHRycy50eXBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2VyOiBqc29uUGFyc2VyIH0sXG4gICAgeyB0YWc6IFwic2NyaXB0XCIsXG4gICAgICAgIGF0dHJzKGF0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gIWF0dHJzLnR5cGUgfHwgL14oPzp0ZXh0fGFwcGxpY2F0aW9uKVxcLyg/OngtKT8oPzpqYXZhfGVjbWEpc2NyaXB0JHxebW9kdWxlJHxeJC9pLnRlc3QoYXR0cnMudHlwZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlcjogbGFuZ0phdmFzY3JpcHQuamF2YXNjcmlwdExhbmd1YWdlLnBhcnNlciB9LFxuICAgIHsgdGFnOiBcInN0eWxlXCIsXG4gICAgICAgIGF0dHJzKGF0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gKCFhdHRycy5sYW5nIHx8IGF0dHJzLmxhbmcgPT0gXCJjc3NcIikgJiYgKCFhdHRycy50eXBlIHx8IC9eKHRleHRcXC8pPyh4LSk/KHN0eWxlc2hlZXR8Y3NzKSQvaS50ZXN0KGF0dHJzLnR5cGUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2VyOiBsYW5nQ3NzLmNzc0xhbmd1YWdlLnBhcnNlciB9XG5dO1xuY29uc3QgZGVmYXVsdEF0dHJzID0gW1xuICAgIHsgbmFtZTogXCJzdHlsZVwiLFxuICAgICAgICBwYXJzZXI6IGxhbmdDc3MuY3NzTGFuZ3VhZ2UucGFyc2VyLmNvbmZpZ3VyZSh7IHRvcDogXCJTdHlsZXNcIiB9KSB9XG5dLmNvbmNhdChldmVudEF0dHJpYnV0ZXMubWFwKG5hbWUgPT4gKHsgbmFtZSwgcGFyc2VyOiBsYW5nSmF2YXNjcmlwdC5qYXZhc2NyaXB0TGFuZ3VhZ2UucGFyc2VyIH0pKSk7XG4vKipcbkEgbGFuZ3VhZ2UgcHJvdmlkZXIgYmFzZWQgb24gdGhlIFtMZXplciBIVE1MXG5wYXJzZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZXplci1wYXJzZXIvaHRtbCksIGV4dGVuZGVkIHdpdGggdGhlXG5KYXZhU2NyaXB0IGFuZCBDU1MgcGFyc2VycyB0byBwYXJzZSB0aGUgY29udGVudCBvZiBgPHNjcmlwdD5gIGFuZFxuYDxzdHlsZT5gIHRhZ3MuXG4qL1xuY29uc3QgaHRtbFBsYWluID0gbGFuZ3VhZ2UuTFJMYW5ndWFnZS5kZWZpbmUoe1xuICAgIG5hbWU6IFwiaHRtbFwiLFxuICAgIHBhcnNlcjogaHRtbCQxLnBhcnNlci5jb25maWd1cmUoe1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgICAgbGFuZ3VhZ2UuaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBFbGVtZW50KGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gL14oXFxzKikoPFxcLyk/Ly5leGVjKGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQubm9kZS50byA8PSBjb250ZXh0LnBvcyArIGFmdGVyWzBdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmxpbmVJbmRlbnQoY29udGV4dC5ub2RlLmZyb20pICsgKGFmdGVyWzJdID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIk9wZW5UYWcgQ2xvc2VUYWcgU2VsZkNsb3NpbmdUYWdcIihjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbHVtbihjb250ZXh0Lm5vZGUuZnJvbSkgKyBjb250ZXh0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBEb2N1bWVudChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnBvcyArIC9cXHMqLy5leGVjKGNvbnRleHQudGV4dEFmdGVyKVswXS5sZW5ndGggPCBjb250ZXh0Lm5vZGUudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kRWx0ID0gbnVsbCwgY2xvc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IGNvbnRleHQubm9kZTs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGN1ci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC5uYW1lICE9IFwiRWxlbWVudFwiIHx8IGxhc3QudG8gIT0gY3VyLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kRWx0ID0gY3VyID0gbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kRWx0ICYmICEoKGNsb3NlID0gZW5kRWx0Lmxhc3RDaGlsZCkgJiYgKGNsb3NlLm5hbWUgPT0gXCJDbG9zZVRhZ1wiIHx8IGNsb3NlLm5hbWUgPT0gXCJTZWxmQ2xvc2luZ1RhZ1wiKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5saW5lSW5kZW50KGVuZEVsdC5mcm9tKSArIGNvbnRleHQudW5pdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBsYW5ndWFnZS5mb2xkTm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBFbGVtZW50KG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkLCBsYXN0ID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlyc3QgfHwgZmlyc3QubmFtZSAhPSBcIk9wZW5UYWdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmcm9tOiBmaXJzdC50bywgdG86IGxhc3QubmFtZSA9PSBcIkNsb3NlVGFnXCIgPyBsYXN0LmZyb20gOiBub2RlLnRvIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBsYW5ndWFnZS5icmFja2V0TWF0Y2hpbmdIYW5kbGUuYWRkKHtcbiAgICAgICAgICAgICAgICBcIk9wZW5UYWcgQ2xvc2VUYWdcIjogbm9kZSA9PiBub2RlLmdldENoaWxkKFwiVGFnTmFtZVwiKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgIH0pLFxuICAgIGxhbmd1YWdlRGF0YToge1xuICAgICAgICBjb21tZW50VG9rZW5zOiB7IGJsb2NrOiB7IG9wZW46IFwiPCEtLVwiLCBjbG9zZTogXCItLT5cIiB9IH0sXG4gICAgICAgIGluZGVudE9uSW5wdXQ6IC9eXFxzKjxcXC9cXHcrXFxXJC8sXG4gICAgICAgIHdvcmRDaGFyczogXCItLl9cIlxuICAgIH1cbn0pO1xuLyoqXG5BIGxhbmd1YWdlIHByb3ZpZGVyIGJhc2VkIG9uIHRoZSBbTGV6ZXIgSFRNTFxucGFyc2VyXShodHRwczovL2dpdGh1Yi5jb20vbGV6ZXItcGFyc2VyL2h0bWwpLCBleHRlbmRlZCB3aXRoIHRoZVxuSmF2YVNjcmlwdCBhbmQgQ1NTIHBhcnNlcnMgdG8gcGFyc2UgdGhlIGNvbnRlbnQgb2YgYDxzY3JpcHQ+YCBhbmRcbmA8c3R5bGU+YCB0YWdzLlxuKi9cbmNvbnN0IGh0bWxMYW5ndWFnZSA9IGh0bWxQbGFpbi5jb25maWd1cmUoe1xuICAgIHdyYXA6IGh0bWwkMS5jb25maWd1cmVOZXN0aW5nKGRlZmF1bHROZXN0aW5nLCBkZWZhdWx0QXR0cnMpXG59KTtcbi8qKlxuTGFuZ3VhZ2Ugc3VwcG9ydCBmb3IgSFRNTCwgaW5jbHVkaW5nXG5bYGh0bWxDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5nLWh0bWwuaHRtbENvbXBsZXRpb24pIGFuZCBKYXZhU2NyaXB0IGFuZFxuQ1NTIHN1cHBvcnQgZXh0ZW5zaW9ucy5cbiovXG5mdW5jdGlvbiBodG1sKGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IGRpYWxlY3QgPSBcIlwiLCB3cmFwO1xuICAgIGlmIChjb25maWcubWF0Y2hDbG9zaW5nVGFncyA9PT0gZmFsc2UpXG4gICAgICAgIGRpYWxlY3QgPSBcIm5vTWF0Y2hcIjtcbiAgICBpZiAoY29uZmlnLnNlbGZDbG9zaW5nVGFncyA9PT0gdHJ1ZSlcbiAgICAgICAgZGlhbGVjdCA9IChkaWFsZWN0ID8gZGlhbGVjdCArIFwiIFwiIDogXCJcIikgKyBcInNlbGZDbG9zaW5nXCI7XG4gICAgaWYgKGNvbmZpZy5uZXN0ZWRMYW5ndWFnZXMgJiYgY29uZmlnLm5lc3RlZExhbmd1YWdlcy5sZW5ndGggfHxcbiAgICAgICAgY29uZmlnLm5lc3RlZEF0dHJpYnV0ZXMgJiYgY29uZmlnLm5lc3RlZEF0dHJpYnV0ZXMubGVuZ3RoKVxuICAgICAgICB3cmFwID0gaHRtbCQxLmNvbmZpZ3VyZU5lc3RpbmcoKGNvbmZpZy5uZXN0ZWRMYW5ndWFnZXMgfHwgW10pLmNvbmNhdChkZWZhdWx0TmVzdGluZyksIChjb25maWcubmVzdGVkQXR0cmlidXRlcyB8fCBbXSkuY29uY2F0KGRlZmF1bHRBdHRycykpO1xuICAgIGxldCBsYW5nID0gd3JhcCA/IGh0bWxQbGFpbi5jb25maWd1cmUoeyB3cmFwLCBkaWFsZWN0IH0pIDogZGlhbGVjdCA/IGh0bWxMYW5ndWFnZS5jb25maWd1cmUoeyBkaWFsZWN0IH0pIDogaHRtbExhbmd1YWdlO1xuICAgIHJldHVybiBuZXcgbGFuZ3VhZ2UuTGFuZ3VhZ2VTdXBwb3J0KGxhbmcsIFtcbiAgICAgICAgaHRtbExhbmd1YWdlLmRhdGEub2YoeyBhdXRvY29tcGxldGU6IGh0bWxDb21wbGV0aW9uU291cmNlV2l0aChjb25maWcpIH0pLFxuICAgICAgICBjb25maWcuYXV0b0Nsb3NlVGFncyAhPT0gZmFsc2UgPyBhdXRvQ2xvc2VUYWdzIDogW10sXG4gICAgICAgIGxhbmdKYXZhc2NyaXB0LmphdmFzY3JpcHQoKS5zdXBwb3J0LFxuICAgICAgICBsYW5nQ3NzLmNzcygpLnN1cHBvcnRcbiAgICBdKTtcbn1cbmNvbnN0IHNlbGZDbG9zZXJzID0gbmV3IFNldChcImFyZWEgYmFzZSBiciBjb2wgY29tbWFuZCBlbWJlZCBmcmFtZSBociBpbWcgaW5wdXQga2V5Z2VuIGxpbmsgbWV0YSBwYXJhbSBzb3VyY2UgdHJhY2sgd2JyIG1lbnVpdGVtXCIuc3BsaXQoXCIgXCIpKTtcbi8qKlxuRXh0ZW5zaW9uIHRoYXQgd2lsbCBhdXRvbWF0aWNhbGx5IGluc2VydCBjbG9zZSB0YWdzIHdoZW4gYSBgPmAgb3JcbmAvYCBpcyB0eXBlZC5cbiovXG5jb25zdCBhdXRvQ2xvc2VUYWdzID0gdmlldy5FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIHRleHQsIGluc2VydFRyYW5zYWN0aW9uKSA9PiB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkgfHwgZnJvbSAhPSB0byB8fCAodGV4dCAhPSBcIj5cIiAmJiB0ZXh0ICE9IFwiL1wiKSB8fFxuICAgICAgICAhaHRtbExhbmd1YWdlLmlzQWN0aXZlQXQodmlldy5zdGF0ZSwgZnJvbSwgLTEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGJhc2UgPSBpbnNlcnRUcmFuc2FjdGlvbigpLCB7IHN0YXRlOiBzdGF0ZSQxIH0gPSBiYXNlO1xuICAgIGxldCBjbG9zZVRhZ3MgPSBzdGF0ZSQxLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgbGV0IGRpZFR5cGUgPSBzdGF0ZSQxLmRvYy5zbGljZVN0cmluZyhyYW5nZS5mcm9tIC0gMSwgcmFuZ2UudG8pID09IHRleHQ7XG4gICAgICAgIGxldCB7IGhlYWQgfSA9IHJhbmdlLCBhZnRlciA9IGxhbmd1YWdlLnN5bnRheFRyZWUoc3RhdGUkMSkucmVzb2x2ZUlubmVyKGhlYWQsIC0xKSwgbmFtZTtcbiAgICAgICAgaWYgKGRpZFR5cGUgJiYgdGV4dCA9PSBcIj5cIiAmJiBhZnRlci5uYW1lID09IFwiRW5kVGFnXCIpIHtcbiAgICAgICAgICAgIGxldCB0YWcgPSBhZnRlci5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoKChfYiA9IChfYSA9IHRhZy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0Q2hpbGQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSAhPSBcIkNsb3NlVGFnXCIgJiZcbiAgICAgICAgICAgICAgICAobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlJDEuZG9jLCB0YWcucGFyZW50LCBoZWFkKSkgJiZcbiAgICAgICAgICAgICAgICAhc2VsZkNsb3NlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvID0gaGVhZCArIChzdGF0ZSQxLmRvYy5zbGljZVN0cmluZyhoZWFkLCBoZWFkICsgMSkgPT09IFwiPlwiID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGxldCBpbnNlcnQgPSBgPC8ke25hbWV9PmA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIGNoYW5nZXM6IHsgZnJvbTogaGVhZCwgdG8sIGluc2VydCB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlkVHlwZSAmJiB0ZXh0ID09IFwiL1wiICYmIGFmdGVyLm5hbWUgPT0gXCJJbmNvbXBsZXRlQ2xvc2VUYWdcIikge1xuICAgICAgICAgICAgbGV0IHRhZyA9IGFmdGVyLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChhZnRlci5mcm9tID09IGhlYWQgLSAyICYmICgoX2MgPSB0YWcubGFzdENoaWxkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubmFtZSkgIT0gXCJDbG9zZVRhZ1wiICYmXG4gICAgICAgICAgICAgICAgKG5hbWUgPSBlbGVtZW50TmFtZShzdGF0ZSQxLmRvYywgdGFnLCBoZWFkKSkgJiYgIXNlbGZDbG9zZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGxldCB0byA9IGhlYWQgKyAoc3RhdGUkMS5kb2Muc2xpY2VTdHJpbmcoaGVhZCwgaGVhZCArIDEpID09PSBcIj5cIiA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0ID0gYCR7bmFtZX0+YDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByYW5nZTogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkICsgaW5zZXJ0Lmxlbmd0aCwgLTEpLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IGhlYWQsIHRvLCBpbnNlcnQgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICB9KTtcbiAgICBpZiAoY2xvc2VUYWdzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKFtcbiAgICAgICAgYmFzZSxcbiAgICAgICAgc3RhdGUkMS51cGRhdGUoY2xvc2VUYWdzLCB7XG4gICAgICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIixcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgIH0pXG4gICAgXSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZXhwb3J0cy5hdXRvQ2xvc2VUYWdzID0gYXV0b0Nsb3NlVGFncztcbmV4cG9ydHMuaHRtbCA9IGh0bWw7XG5leHBvcnRzLmh0bWxDb21wbGV0aW9uU291cmNlID0gaHRtbENvbXBsZXRpb25Tb3VyY2U7XG5leHBvcnRzLmh0bWxDb21wbGV0aW9uU291cmNlV2l0aCA9IGh0bWxDb21wbGV0aW9uU291cmNlV2l0aDtcbmV4cG9ydHMuaHRtbExhbmd1YWdlID0gaHRtbExhbmd1YWdlO1xuZXhwb3J0cy5odG1sUGxhaW4gPSBodG1sUGxhaW47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBqYXZhc2NyaXB0JDEgPSByZXF1aXJlKCdAbGV6ZXIvamF2YXNjcmlwdCcpO1xudmFyIGxhbmd1YWdlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnKTtcbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG52YXIgdmlldyA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3ZpZXcnKTtcbnZhciBhdXRvY29tcGxldGUgPSByZXF1aXJlKCdAY29kZW1pcnJvci9hdXRvY29tcGxldGUnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCdAbGV6ZXIvY29tbW9uJyk7XG5cbi8qKlxuQSBjb2xsZWN0aW9uIG9mIEphdmFTY3JpcHQtcmVsYXRlZFxuW3NuaXBwZXRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5zbmlwcGV0KS5cbiovXG5jb25zdCBzbmlwcGV0cyA9IFtcbiAgICBhdXRvY29tcGxldGUuc25pcHBldENvbXBsZXRpb24oXCJmdW5jdGlvbiAke25hbWV9KCR7cGFyYW1zfSkge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJmdW5jdGlvblwiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIGF1dG9jb21wbGV0ZS5zbmlwcGV0Q29tcGxldGlvbihcImZvciAobGV0ICR7aW5kZXh9ID0gMDsgJHtpbmRleH0gPCAke2JvdW5kfTsgJHtpbmRleH0rKykge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJmb3JcIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICBhdXRvY29tcGxldGUuc25pcHBldENvbXBsZXRpb24oXCJmb3IgKGxldCAke25hbWV9IG9mICR7Y29sbGVjdGlvbn0pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZm9yXCIsXG4gICAgICAgIGRldGFpbDogXCJvZiBsb29wXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgYXV0b2NvbXBsZXRlLnNuaXBwZXRDb21wbGV0aW9uKFwiZG8ge1xcblxcdCR7fVxcbn0gd2hpbGUgKCR7fSlcIiwge1xuICAgICAgICBsYWJlbDogXCJkb1wiLFxuICAgICAgICBkZXRhaWw6IFwibG9vcFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIGF1dG9jb21wbGV0ZS5zbmlwcGV0Q29tcGxldGlvbihcIndoaWxlICgke30pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwid2hpbGVcIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICBhdXRvY29tcGxldGUuc25pcHBldENvbXBsZXRpb24oXCJ0cnkge1xcblxcdCR7fVxcbn0gY2F0Y2ggKCR7ZXJyb3J9KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcInRyeVwiLFxuICAgICAgICBkZXRhaWw6IFwiLyBjYXRjaCBibG9ja1wiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIGF1dG9jb21wbGV0ZS5zbmlwcGV0Q29tcGxldGlvbihcImlmICgke30pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaWZcIixcbiAgICAgICAgZGV0YWlsOiBcImJsb2NrXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgYXV0b2NvbXBsZXRlLnNuaXBwZXRDb21wbGV0aW9uKFwiaWYgKCR7fSkge1xcblxcdCR7fVxcbn0gZWxzZSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImlmXCIsXG4gICAgICAgIGRldGFpbDogXCIvIGVsc2UgYmxvY2tcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICBhdXRvY29tcGxldGUuc25pcHBldENvbXBsZXRpb24oXCJjbGFzcyAke25hbWV9IHtcXG5cXHRjb25zdHJ1Y3Rvcigke3BhcmFtc30pIHtcXG5cXHRcXHQke31cXG5cXHR9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImNsYXNzXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgYXV0b2NvbXBsZXRlLnNuaXBwZXRDb21wbGV0aW9uKFwiaW1wb3J0IHske25hbWVzfX0gZnJvbSBcXFwiJHttb2R1bGV9XFxcIlxcbiR7fVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImltcG9ydFwiLFxuICAgICAgICBkZXRhaWw6IFwibmFtZWRcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICBhdXRvY29tcGxldGUuc25pcHBldENvbXBsZXRpb24oXCJpbXBvcnQgJHtuYW1lfSBmcm9tIFxcXCIke21vZHVsZX1cXFwiXFxuJHt9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaW1wb3J0XCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZhdWx0XCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSlcbl07XG4vKipcbkEgY29sbGVjdGlvbiBvZiBzbmlwcGV0IGNvbXBsZXRpb25zIGZvciBUeXBlU2NyaXB0LiBJbmNsdWRlcyB0aGVcbkphdmFTY3JpcHQgW3NuaXBwZXRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmctamF2YXNjcmlwdC5zbmlwcGV0cykuXG4qL1xuY29uc3QgdHlwZXNjcmlwdFNuaXBwZXRzID0gc25pcHBldHMuY29uY2F0KFtcbiAgICBhdXRvY29tcGxldGUuc25pcHBldENvbXBsZXRpb24oXCJpbnRlcmZhY2UgJHtuYW1lfSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImludGVyZmFjZVwiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIGF1dG9jb21wbGV0ZS5zbmlwcGV0Q29tcGxldGlvbihcInR5cGUgJHtuYW1lfSA9ICR7dHlwZX1cIiwge1xuICAgICAgICBsYWJlbDogXCJ0eXBlXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgYXV0b2NvbXBsZXRlLnNuaXBwZXRDb21wbGV0aW9uKFwiZW51bSAke25hbWV9IHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZW51bVwiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pXG5dKTtcblxuY29uc3QgY2FjaGUgPSBuZXcgY29tbW9uLk5vZGVXZWFrTWFwKCk7XG5jb25zdCBTY29wZU5vZGVzID0gbmV3IFNldChbXG4gICAgXCJTY3JpcHRcIiwgXCJCbG9ja1wiLFxuICAgIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBcIkFycm93RnVuY3Rpb25cIiwgXCJNZXRob2REZWNsYXJhdGlvblwiLFxuICAgIFwiRm9yU3RhdGVtZW50XCJcbl0pO1xuZnVuY3Rpb24gZGVmSUQodHlwZSkge1xuICAgIHJldHVybiAobm9kZSwgZGVmKSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG5vZGUubm9kZS5nZXRDaGlsZChcIlZhcmlhYmxlRGVmaW5pdGlvblwiKTtcbiAgICAgICAgaWYgKGlkKVxuICAgICAgICAgICAgZGVmKGlkLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmNvbnN0IGZ1bmN0aW9uQ29udGV4dCA9IFtcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIl07XG5jb25zdCBnYXRoZXJDb21wbGV0aW9ucyA9IHtcbiAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBkZWZJRChcImZ1bmN0aW9uXCIpLFxuICAgIENsYXNzRGVjbGFyYXRpb246IGRlZklEKFwiY2xhc3NcIiksXG4gICAgQ2xhc3NFeHByZXNzaW9uOiAoKSA9PiB0cnVlLFxuICAgIEVudW1EZWNsYXJhdGlvbjogZGVmSUQoXCJjb25zdGFudFwiKSxcbiAgICBUeXBlQWxpYXNEZWNsYXJhdGlvbjogZGVmSUQoXCJ0eXBlXCIpLFxuICAgIE5hbWVzcGFjZURlY2xhcmF0aW9uOiBkZWZJRChcIm5hbWVzcGFjZVwiKSxcbiAgICBWYXJpYWJsZURlZmluaXRpb24obm9kZSwgZGVmKSB7IGlmICghbm9kZS5tYXRjaENvbnRleHQoZnVuY3Rpb25Db250ZXh0KSlcbiAgICAgICAgZGVmKG5vZGUsIFwidmFyaWFibGVcIik7IH0sXG4gICAgVHlwZURlZmluaXRpb24obm9kZSwgZGVmKSB7IGRlZihub2RlLCBcInR5cGVcIik7IH0sXG4gICAgX19wcm90b19fOiBudWxsXG59O1xuZnVuY3Rpb24gZ2V0U2NvcGUoZG9jLCBub2RlKSB7XG4gICAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoY2FjaGVkKVxuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIGxldCBjb21wbGV0aW9ucyA9IFtdLCB0b3AgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGRlZihub2RlLCB0eXBlKSB7XG4gICAgICAgIGxldCBuYW1lID0gZG9jLnNsaWNlU3RyaW5nKG5vZGUuZnJvbSwgbm9kZS50byk7XG4gICAgICAgIGNvbXBsZXRpb25zLnB1c2goeyBsYWJlbDogbmFtZSwgdHlwZSB9KTtcbiAgICB9XG4gICAgbm9kZS5jdXJzb3IoY29tbW9uLkl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpLml0ZXJhdGUobm9kZSA9PiB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgIHRvcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubmFtZSkge1xuICAgICAgICAgICAgbGV0IGdhdGhlciA9IGdhdGhlckNvbXBsZXRpb25zW25vZGUubmFtZV07XG4gICAgICAgICAgICBpZiAoZ2F0aGVyICYmIGdhdGhlcihub2RlLCBkZWYpIHx8IFNjb3BlTm9kZXMuaGFzKG5vZGUubmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudG8gLSBub2RlLmZyb20gPiA4MTkyKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyBjYWNoaW5nIGZvciBiaWdnZXIgaW50ZXJuYWwgbm9kZXNcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgZ2V0U2NvcGUoZG9jLCBub2RlLm5vZGUpKVxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25zLnB1c2goYyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjYWNoZS5zZXQobm9kZSwgY29tcGxldGlvbnMpO1xuICAgIHJldHVybiBjb21wbGV0aW9ucztcbn1cbmNvbnN0IElkZW50aWZpZXIgPSAvXltcXHckXFx4YTEtXFx1ZmZmZl1bXFx3JFxcZFxceGExLVxcdWZmZmZdKiQvO1xuY29uc3QgZG9udENvbXBsZXRlID0gW1xuICAgIFwiVGVtcGxhdGVTdHJpbmdcIiwgXCJTdHJpbmdcIiwgXCJSZWdFeHBcIixcbiAgICBcIkxpbmVDb21tZW50XCIsIFwiQmxvY2tDb21tZW50XCIsXG4gICAgXCJWYXJpYWJsZURlZmluaXRpb25cIiwgXCJUeXBlRGVmaW5pdGlvblwiLCBcIkxhYmVsXCIsXG4gICAgXCJQcm9wZXJ0eURlZmluaXRpb25cIiwgXCJQcm9wZXJ0eU5hbWVcIixcbiAgICBcIlByaXZhdGVQcm9wZXJ0eURlZmluaXRpb25cIiwgXCJQcml2YXRlUHJvcGVydHlOYW1lXCIsXG4gICAgXCIuXCIsIFwiPy5cIlxuXTtcbi8qKlxuQ29tcGxldGlvbiBzb3VyY2UgdGhhdCBsb29rcyB1cCBsb2NhbGx5IGRlZmluZWQgbmFtZXMgaW5cbkphdmFTY3JpcHQgY29kZS5cbiovXG5mdW5jdGlvbiBsb2NhbENvbXBsZXRpb25Tb3VyY2UoY29udGV4dCkge1xuICAgIGxldCBpbm5lciA9IGxhbmd1YWdlLnN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7XG4gICAgaWYgKGRvbnRDb21wbGV0ZS5pbmRleE9mKGlubmVyLm5hbWUpID4gLTEpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBpc1dvcmQgPSBpbm5lci5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIgfHxcbiAgICAgICAgaW5uZXIudG8gLSBpbm5lci5mcm9tIDwgMjAgJiYgSWRlbnRpZmllci50ZXN0KGNvbnRleHQuc3RhdGUuc2xpY2VEb2MoaW5uZXIuZnJvbSwgaW5uZXIudG8pKTtcbiAgICBpZiAoIWlzV29yZCAmJiAhY29udGV4dC5leHBsaWNpdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG9wdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSBpbm5lcjsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgIGlmIChTY29wZU5vZGVzLmhhcyhwb3MubmFtZSkpXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jb25jYXQoZ2V0U2NvcGUoY29udGV4dC5zdGF0ZS5kb2MsIHBvcykpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmcm9tOiBpc1dvcmQgPyBpbm5lci5mcm9tIDogY29udGV4dC5wb3MsXG4gICAgICAgIHZhbGlkRm9yOiBJZGVudGlmaWVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhdGhGb3IocmVhZCwgbWVtYmVyLCBuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBwYXRoID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgb2JqID0gbWVtYmVyLmZpcnN0Q2hpbGQsIHByb3A7XG4gICAgICAgIGlmICgob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm5hbWUpID09IFwiVmFyaWFibGVOYW1lXCIpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChyZWFkKG9iaikpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogcGF0aC5yZXZlcnNlKCksIG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm5hbWUpID09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmICgoX2EgPSAocHJvcCA9IG9iai5sYXN0Q2hpbGQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT0gXCJQcm9wZXJ0eU5hbWVcIikge1xuICAgICAgICAgICAgcGF0aC5wdXNoKHJlYWQocHJvcCkpO1xuICAgICAgICAgICAgbWVtYmVyID0gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbkhlbHBlciBmdW5jdGlvbiBmb3IgZGVmaW5pbmcgSmF2YVNjcmlwdCBjb21wbGV0aW9uIHNvdXJjZXMuIEl0XG5yZXR1cm5zIHRoZSBjb21wbGV0YWJsZSBuYW1lIGFuZCBvYmplY3QgcGF0aCBmb3IgYSBjb21wbGV0aW9uXG5jb250ZXh0LCBvciBudWxsIGlmIG5vIG5hbWUvcHJvcGVydHkgY29tcGxldGlvbiBzaG91bGQgaGFwcGVuIGF0XG50aGF0IHBvc2l0aW9uLiBGb3IgZXhhbXBsZSwgd2hlbiBjb21wbGV0aW5nIGFmdGVyIGBhLmIuY2AgaXQgd2lsbFxucmV0dXJuIGB7cGF0aDogW1wiYVwiLCBcImJcIl0sIG5hbWU6IFwiY1wifWAuIFdoZW4gY29tcGxldGluZyBhZnRlciBgeGBcbml0IHdpbGwgcmV0dXJuIGB7cGF0aDogW10sIG5hbWU6IFwieFwifWAuIFdoZW4gbm90IGluIGEgcHJvcGVydHkgb3Jcbm5hbWUsIGl0IHdpbGwgcmV0dXJuIG51bGwgaWYgYGNvbnRleHQuZXhwbGljaXRgIGlzIGZhbHNlLCBhbmRcbmB7cGF0aDogW10sIG5hbWU6IFwiXCJ9YCBvdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gY29tcGxldGlvblBhdGgoY29udGV4dCkge1xuICAgIGxldCByZWFkID0gKG5vZGUpID0+IGNvbnRleHQuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKG5vZGUuZnJvbSwgbm9kZS50byk7XG4gICAgbGV0IGlubmVyID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTtcbiAgICBpZiAoaW5uZXIubmFtZSA9PSBcIlByb3BlcnR5TmFtZVwiKSB7XG4gICAgICAgIHJldHVybiBwYXRoRm9yKHJlYWQsIGlubmVyLnBhcmVudCwgcmVhZChpbm5lcikpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoaW5uZXIubmFtZSA9PSBcIi5cIiB8fCBpbm5lci5uYW1lID09IFwiPy5cIikgJiYgaW5uZXIucGFyZW50Lm5hbWUgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhGb3IocmVhZCwgaW5uZXIucGFyZW50LCBcIlwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9udENvbXBsZXRlLmluZGV4T2YoaW5uZXIubmFtZSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5uZXIubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiIHx8IGlubmVyLnRvIC0gaW5uZXIuZnJvbSA8IDIwICYmIElkZW50aWZpZXIudGVzdChyZWFkKGlubmVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogW10sIG5hbWU6IHJlYWQoaW5uZXIpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlubmVyLm5hbWUgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhGb3IocmVhZCwgaW5uZXIsIFwiXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXhwbGljaXQgPyB7IHBhdGg6IFtdLCBuYW1lOiBcIlwiIH0gOiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVudW1lcmF0ZVByb3BlcnR5Q29tcGxldGlvbnMob2JqLCB0b3ApIHtcbiAgICBsZXQgb3B0aW9ucyA9IFtdLCBzZWVuID0gbmV3IFNldDtcbiAgICBmb3IgKGxldCBkZXB0aCA9IDA7OyBkZXB0aCsrKSB7XG4gICAgICAgIGZvciAobGV0IG5hbWUgb2YgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IE9iamVjdC5rZXlzKShvYmopKSB7XG4gICAgICAgICAgICBpZiAoIS9eW2EtekEtWl8kXFx4YWEtXFx1ZmZkY11bXFx3JFxceGFhLVxcdWZmZGNdKiQvLnRlc3QobmFtZSkgfHwgc2Vlbi5oYXMobmFtZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzZWVuLmFkZChuYW1lKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBvYmpbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsYWJlbDogbmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiID8gKC9eW0EtWl0vLnRlc3QobmFtZSkgPyBcImNsYXNzXCIgOiB0b3AgPyBcImZ1bmN0aW9uXCIgOiBcIm1ldGhvZFwiKVxuICAgICAgICAgICAgICAgICAgICA6IHRvcCA/IFwidmFyaWFibGVcIiA6IFwicHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICBib29zdDogLWRlcHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgb2JqID0gbmV4dDtcbiAgICB9XG59XG4vKipcbkRlZmluZXMgYSBbY29tcGxldGlvbiBzb3VyY2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25Tb3VyY2UpIHRoYXRcbmNvbXBsZXRlcyBmcm9tIHRoZSBnaXZlbiBzY29wZSBvYmplY3QgKGZvciBleGFtcGxlIGBnbG9iYWxUaGlzYCkuXG5XaWxsIGVudGVyIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCB3aGVuIGNvbXBsZXRpbmcgcHJvcGVydGllcyBvblxuYSBkaXJlY3RseS1uYW1lZCBwYXRoLlxuKi9cbmZ1bmN0aW9uIHNjb3BlQ29tcGxldGlvblNvdXJjZShzY29wZSkge1xuICAgIGxldCBjYWNoZSA9IG5ldyBNYXA7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCBwYXRoID0gY29tcGxldGlvblBhdGgoY29udGV4dCk7XG4gICAgICAgIGlmICghcGF0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gc2NvcGU7XG4gICAgICAgIGZvciAobGV0IHN0ZXAgb2YgcGF0aC5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbc3RlcF07XG4gICAgICAgICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3B0aW9ucyA9IGNhY2hlLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBjYWNoZS5zZXQodGFyZ2V0LCBvcHRpb25zID0gZW51bWVyYXRlUHJvcGVydHlDb21wbGV0aW9ucyh0YXJnZXQsICFwYXRoLnBhdGgubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBjb250ZXh0LnBvcyAtIHBhdGgubmFtZS5sZW5ndGgsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgdmFsaWRGb3I6IElkZW50aWZpZXJcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG4vKipcbkEgbGFuZ3VhZ2UgcHJvdmlkZXIgYmFzZWQgb24gdGhlIFtMZXplciBKYXZhU2NyaXB0XG5wYXJzZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZXplci1wYXJzZXIvamF2YXNjcmlwdCksIGV4dGVuZGVkIHdpdGhcbmhpZ2hsaWdodGluZyBhbmQgaW5kZW50YXRpb24gaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgamF2YXNjcmlwdExhbmd1YWdlID0gbGFuZ3VhZ2UuTFJMYW5ndWFnZS5kZWZpbmUoe1xuICAgIG5hbWU6IFwiamF2YXNjcmlwdFwiLFxuICAgIHBhcnNlcjogamF2YXNjcmlwdCQxLnBhcnNlci5jb25maWd1cmUoe1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgICAgbGFuZ3VhZ2UuaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBJZlN0YXRlbWVudDogbGFuZ3VhZ2UuY29udGludWVkSW5kZW50KHsgZXhjZXB0OiAvXlxccyooe3xlbHNlXFxiKS8gfSksXG4gICAgICAgICAgICAgICAgVHJ5U3RhdGVtZW50OiBsYW5ndWFnZS5jb250aW51ZWRJbmRlbnQoeyBleGNlcHQ6IC9eXFxzKih7fGNhdGNoXFxifGZpbmFsbHlcXGIpLyB9KSxcbiAgICAgICAgICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBsYW5ndWFnZS5mbGF0SW5kZW50LFxuICAgICAgICAgICAgICAgIFN3aXRjaEJvZHk6IGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBjb250ZXh0LnRleHRBZnRlciwgY2xvc2VkID0gL15cXHMqXFx9Ly50ZXN0KGFmdGVyKSwgaXNDYXNlID0gL15cXHMqKGNhc2V8ZGVmYXVsdClcXGIvLnRlc3QoYWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBpc0Nhc2UgPyAxIDogMikgKiBjb250ZXh0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBCbG9jazogbGFuZ3VhZ2UuZGVsaW1pdGVkSW5kZW50KHsgY2xvc2luZzogXCJ9XCIgfSksXG4gICAgICAgICAgICAgICAgQXJyb3dGdW5jdGlvbjogY3ggPT4gY3guYmFzZUluZGVudCArIGN4LnVuaXQsXG4gICAgICAgICAgICAgICAgXCJUZW1wbGF0ZVN0cmluZyBCbG9ja0NvbW1lbnRcIjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICBcIlN0YXRlbWVudCBQcm9wZXJ0eVwiOiBsYW5ndWFnZS5jb250aW51ZWRJbmRlbnQoeyBleGNlcHQ6IC9eey8gfSksXG4gICAgICAgICAgICAgICAgSlNYRWxlbWVudChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjbG9zZWQgPSAvXlxccyo8XFwvLy50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQubGluZUluZGVudChjb250ZXh0Lm5vZGUuZnJvbSkgKyAoY2xvc2VkID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBKU1hFc2NhcGUoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2xvc2VkID0gL1xccypcXH0vLnRlc3QoY29udGV4dC50ZXh0QWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5saW5lSW5kZW50KGNvbnRleHQubm9kZS5mcm9tKSArIChjbG9zZWQgPyAwIDogY29udGV4dC51bml0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiSlNYT3BlblRhZyBKU1hTZWxmQ2xvc2luZ1RhZ1wiKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29sdW1uKGNvbnRleHQubm9kZS5mcm9tKSArIGNvbnRleHQudW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGxhbmd1YWdlLmZvbGROb2RlUHJvcC5hZGQoe1xuICAgICAgICAgICAgICAgIFwiQmxvY2sgQ2xhc3NCb2R5IFN3aXRjaEJvZHkgRW51bUJvZHkgT2JqZWN0RXhwcmVzc2lvbiBBcnJheUV4cHJlc3Npb24gT2JqZWN0VHlwZVwiOiBsYW5ndWFnZS5mb2xkSW5zaWRlLFxuICAgICAgICAgICAgICAgIEJsb2NrQ29tbWVudCh0cmVlKSB7IHJldHVybiB7IGZyb206IHRyZWUuZnJvbSArIDIsIHRvOiB0cmVlLnRvIC0gMiB9OyB9XG4gICAgICAgICAgICB9KVxuICAgICAgICBdXG4gICAgfSksXG4gICAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgICAgIGNsb3NlQnJhY2tldHM6IHsgYnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJywgXCJgXCJdIH0sXG4gICAgICAgIGNvbW1lbnRUb2tlbnM6IHsgbGluZTogXCIvL1wiLCBibG9jazogeyBvcGVuOiBcIi8qXCIsIGNsb3NlOiBcIiovXCIgfSB9LFxuICAgICAgICBpbmRlbnRPbklucHV0OiAvXlxccyooPzpjYXNlIHxkZWZhdWx0OnxcXHt8XFx9fDxcXC8pJC8sXG4gICAgICAgIHdvcmRDaGFyczogXCIkXCJcbiAgICB9XG59KTtcbmNvbnN0IGpzeFN1Ymxhbmd1YWdlID0ge1xuICAgIHRlc3Q6IG5vZGUgPT4gL15KU1gvLnRlc3Qobm9kZS5uYW1lKSxcbiAgICBmYWNldDogbGFuZ3VhZ2UuZGVmaW5lTGFuZ3VhZ2VGYWNldCh7IGNvbW1lbnRUb2tlbnM6IHsgYmxvY2s6IHsgb3BlbjogXCJ7LypcIiwgY2xvc2U6IFwiKi99XCIgfSB9IH0pXG59O1xuLyoqXG5BIGxhbmd1YWdlIHByb3ZpZGVyIGZvciBUeXBlU2NyaXB0LlxuKi9cbmNvbnN0IHR5cGVzY3JpcHRMYW5ndWFnZSA9IGphdmFzY3JpcHRMYW5ndWFnZS5jb25maWd1cmUoeyBkaWFsZWN0OiBcInRzXCIgfSwgXCJ0eXBlc2NyaXB0XCIpO1xuLyoqXG5MYW5ndWFnZSBwcm92aWRlciBmb3IgSlNYLlxuKi9cbmNvbnN0IGpzeExhbmd1YWdlID0gamF2YXNjcmlwdExhbmd1YWdlLmNvbmZpZ3VyZSh7XG4gICAgZGlhbGVjdDogXCJqc3hcIixcbiAgICBwcm9wczogW2xhbmd1YWdlLnN1Ymxhbmd1YWdlUHJvcC5hZGQobiA9PiBuLmlzVG9wID8gW2pzeFN1Ymxhbmd1YWdlXSA6IHVuZGVmaW5lZCldXG59KTtcbi8qKlxuTGFuZ3VhZ2UgcHJvdmlkZXIgZm9yIEpTWCArIFR5cGVTY3JpcHQuXG4qL1xuY29uc3QgdHN4TGFuZ3VhZ2UgPSBqYXZhc2NyaXB0TGFuZ3VhZ2UuY29uZmlndXJlKHtcbiAgICBkaWFsZWN0OiBcImpzeCB0c1wiLFxuICAgIHByb3BzOiBbbGFuZ3VhZ2Uuc3VibGFuZ3VhZ2VQcm9wLmFkZChuID0+IG4uaXNUb3AgPyBbanN4U3VibGFuZ3VhZ2VdIDogdW5kZWZpbmVkKV1cbn0sIFwidHlwZXNjcmlwdFwiKTtcbmxldCBrd0NvbXBsZXRpb24gPSAobmFtZSkgPT4gKHsgbGFiZWw6IG5hbWUsIHR5cGU6IFwia2V5d29yZFwiIH0pO1xuY29uc3Qga2V5d29yZHMgPSBcImJyZWFrIGNhc2UgY29uc3QgY29udGludWUgZGVmYXVsdCBkZWxldGUgZXhwb3J0IGV4dGVuZHMgZmFsc2UgZmluYWxseSBpbiBpbnN0YW5jZW9mIGxldCBuZXcgcmV0dXJuIHN0YXRpYyBzdXBlciBzd2l0Y2ggdGhpcyB0aHJvdyB0cnVlIHR5cGVvZiB2YXIgeWllbGRcIi5zcGxpdChcIiBcIikubWFwKGt3Q29tcGxldGlvbik7XG5jb25zdCB0eXBlc2NyaXB0S2V5d29yZHMgPSBrZXl3b3Jkcy5jb25jYXQoW1wiZGVjbGFyZVwiLCBcImltcGxlbWVudHNcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCJdLm1hcChrd0NvbXBsZXRpb24pKTtcbi8qKlxuSmF2YVNjcmlwdCBzdXBwb3J0LiBJbmNsdWRlcyBbc25pcHBldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5nLWphdmFzY3JpcHQuc25pcHBldHMpXG5hbmQgbG9jYWwgdmFyaWFibGUgY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBqYXZhc2NyaXB0KGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IGxhbmcgPSBjb25maWcuanN4ID8gKGNvbmZpZy50eXBlc2NyaXB0ID8gdHN4TGFuZ3VhZ2UgOiBqc3hMYW5ndWFnZSlcbiAgICAgICAgOiBjb25maWcudHlwZXNjcmlwdCA/IHR5cGVzY3JpcHRMYW5ndWFnZSA6IGphdmFzY3JpcHRMYW5ndWFnZTtcbiAgICBsZXQgY29tcGxldGlvbnMgPSBjb25maWcudHlwZXNjcmlwdCA/IHR5cGVzY3JpcHRTbmlwcGV0cy5jb25jYXQodHlwZXNjcmlwdEtleXdvcmRzKSA6IHNuaXBwZXRzLmNvbmNhdChrZXl3b3Jkcyk7XG4gICAgcmV0dXJuIG5ldyBsYW5ndWFnZS5MYW5ndWFnZVN1cHBvcnQobGFuZywgW1xuICAgICAgICBqYXZhc2NyaXB0TGFuZ3VhZ2UuZGF0YS5vZih7XG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IGF1dG9jb21wbGV0ZS5pZk5vdEluKGRvbnRDb21wbGV0ZSwgYXV0b2NvbXBsZXRlLmNvbXBsZXRlRnJvbUxpc3QoY29tcGxldGlvbnMpKVxuICAgICAgICB9KSxcbiAgICAgICAgamF2YXNjcmlwdExhbmd1YWdlLmRhdGEub2Yoe1xuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBsb2NhbENvbXBsZXRpb25Tb3VyY2VcbiAgICAgICAgfSksXG4gICAgICAgIGNvbmZpZy5qc3ggPyBhdXRvQ2xvc2VUYWdzIDogW10sXG4gICAgXSk7XG59XG5mdW5jdGlvbiBmaW5kT3BlblRhZyhub2RlKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZS5uYW1lID09IFwiSlNYT3BlblRhZ1wiIHx8IG5vZGUubmFtZSA9PSBcIkpTWFNlbGZDbG9zaW5nVGFnXCIgfHwgbm9kZS5uYW1lID09IFwiSlNYRnJhZ21lbnRUYWdcIilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZS5uYW1lID09IFwiSlNYRXNjYXBlXCIgfHwgIW5vZGUucGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGVtZW50TmFtZShkb2MsIHRyZWUsIG1heCA9IGRvYy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBjaCA9IHRyZWUgPT09IG51bGwgfHwgdHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJlZS5maXJzdENoaWxkOyBjaDsgY2ggPSBjaC5uZXh0U2libGluZykge1xuICAgICAgICBpZiAoY2gubmFtZSA9PSBcIkpTWElkZW50aWZpZXJcIiB8fCBjaC5uYW1lID09IFwiSlNYQnVpbHRpblwiIHx8IGNoLm5hbWUgPT0gXCJKU1hOYW1lc3BhY2VkTmFtZVwiIHx8XG4gICAgICAgICAgICBjaC5uYW1lID09IFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiKVxuICAgICAgICAgICAgcmV0dXJuIGRvYy5zbGljZVN0cmluZyhjaC5mcm9tLCBNYXRoLm1pbihjaC50bywgbWF4KSk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xufVxuY29uc3QgYW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJvYmplY3RcIiAmJiAvQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8qKlxuRXh0ZW5zaW9uIHRoYXQgd2lsbCBhdXRvbWF0aWNhbGx5IGluc2VydCBKU1ggY2xvc2UgdGFncyB3aGVuIGEgYD5gIG9yXG5gL2AgaXMgdHlwZWQuXG4qL1xuY29uc3QgYXV0b0Nsb3NlVGFncyA9IHZpZXcuRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIub2YoKHZpZXcsIGZyb20sIHRvLCB0ZXh0LCBkZWZhdWx0SW5zZXJ0KSA9PiB7XG4gICAgaWYgKChhbmRyb2lkID8gdmlldy5jb21wb3NpbmcgOiB2aWV3LmNvbXBvc2l0aW9uU3RhcnRlZCkgfHwgdmlldy5zdGF0ZS5yZWFkT25seSB8fFxuICAgICAgICBmcm9tICE9IHRvIHx8ICh0ZXh0ICE9IFwiPlwiICYmIHRleHQgIT0gXCIvXCIpIHx8XG4gICAgICAgICFqYXZhc2NyaXB0TGFuZ3VhZ2UuaXNBY3RpdmVBdCh2aWV3LnN0YXRlLCBmcm9tLCAtMSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYmFzZSA9IGRlZmF1bHRJbnNlcnQoKSwgeyBzdGF0ZTogc3RhdGUkMSB9ID0gYmFzZTtcbiAgICBsZXQgY2xvc2VUYWdzID0gc3RhdGUkMS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgeyBoZWFkIH0gPSByYW5nZSwgYXJvdW5kID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShzdGF0ZSQxKS5yZXNvbHZlSW5uZXIoaGVhZCAtIDEsIC0xKSwgbmFtZTtcbiAgICAgICAgaWYgKGFyb3VuZC5uYW1lID09IFwiSlNYU3RhcnRUYWdcIilcbiAgICAgICAgICAgIGFyb3VuZCA9IGFyb3VuZC5wYXJlbnQ7XG4gICAgICAgIGlmIChzdGF0ZSQxLmRvYy5zbGljZVN0cmluZyhoZWFkIC0gMSwgaGVhZCkgIT0gdGV4dCB8fCBhcm91bmQubmFtZSA9PSBcIkpTWEF0dHJpYnV0ZVZhbHVlXCIgJiYgYXJvdW5kLnRvID4gaGVhZCkgO1xuICAgICAgICBlbHNlIGlmICh0ZXh0ID09IFwiPlwiICYmIGFyb3VuZC5uYW1lID09IFwiSlNYRnJhZ21lbnRUYWdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIGNoYW5nZXM6IHsgZnJvbTogaGVhZCwgaW5zZXJ0OiBgPC8+YCB9IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSBcIi9cIiAmJiBhcm91bmQubmFtZSA9PSBcIkpTWFN0YXJ0Q2xvc2VUYWdcIikge1xuICAgICAgICAgICAgbGV0IGVtcHR5ID0gYXJvdW5kLnBhcmVudCwgYmFzZSA9IGVtcHR5LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChiYXNlICYmIGVtcHR5LmZyb20gPT0gaGVhZCAtIDIgJiZcbiAgICAgICAgICAgICAgICAoKG5hbWUgPSBlbGVtZW50TmFtZShzdGF0ZSQxLmRvYywgYmFzZS5maXJzdENoaWxkLCBoZWFkKSkgfHwgKChfYSA9IGJhc2UuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IFwiSlNYRnJhZ21lbnRUYWdcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0ID0gYCR7bmFtZX0+YDtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkICsgaW5zZXJ0Lmxlbmd0aCwgLTEpLCBjaGFuZ2VzOiB7IGZyb206IGhlYWQsIGluc2VydCB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSBcIj5cIikge1xuICAgICAgICAgICAgbGV0IG9wZW5UYWcgPSBmaW5kT3BlblRhZyhhcm91bmQpO1xuICAgICAgICAgICAgaWYgKG9wZW5UYWcgJiYgb3BlblRhZy5uYW1lID09IFwiSlNYT3BlblRhZ1wiICYmXG4gICAgICAgICAgICAgICAgIS9eXFwvPz58XjxcXC8vLnRlc3Qoc3RhdGUkMS5kb2Muc2xpY2VTdHJpbmcoaGVhZCwgaGVhZCArIDIpKSAmJlxuICAgICAgICAgICAgICAgIChuYW1lID0gZWxlbWVudE5hbWUoc3RhdGUkMS5kb2MsIG9wZW5UYWcsIGhlYWQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSwgY2hhbmdlczogeyBmcm9tOiBoZWFkLCBpbnNlcnQ6IGA8LyR7bmFtZX0+YCB9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICB9KTtcbiAgICBpZiAoY2xvc2VUYWdzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKFtcbiAgICAgICAgYmFzZSxcbiAgICAgICAgc3RhdGUkMS51cGRhdGUoY2xvc2VUYWdzLCB7IHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KVxuICAgIF0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5cbi8qKlxuQ29ubmVjdHMgYW4gW0VTTGludF0oaHR0cHM6Ly9lc2xpbnQub3JnLykgbGludGVyIHRvIENvZGVNaXJyb3Inc1xuW2xpbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludCkgaW50ZWdyYXRpb24uIGBlc2xpbnRgIHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiB0aGVcbltgTGludGVyYF0oaHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvZGV2ZWxvcGVyLWd1aWRlL25vZGVqcy1hcGkjbGludGVyKVxuY2xhc3MsIGFuZCBgY29uZmlnYCBhbiBvcHRpb25hbCBFU0xpbnQgY29uZmlndXJhdGlvbi4gVGhlIHJldHVyblxudmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIHRvIFtgbGludGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50LmxpbnRlcilcbnRvIGNyZWF0ZSBhIEphdmFTY3JpcHQgbGludGluZyBleHRlbnNpb24uXG5cbk5vdGUgdGhhdCBFU0xpbnQgdGFyZ2V0cyBub2RlLCBhbmQgaXMgdHJpY2t5IHRvIHJ1biBpbiB0aGVcbmJyb3dzZXIuIFRoZVxuW2VzbGludC1saW50ZXItYnJvd3NlcmlmeV0oaHR0cHM6Ly9naXRodWIuY29tL1V6aVRlY2gvZXNsaW50LWxpbnRlci1icm93c2VyaWZ5KVxucGFja2FnZSBtYXkgaGVscCB3aXRoIHRoYXQgKHNlZVxuW2V4YW1wbGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9VemlUZWNoL2VzbGludC1saW50ZXItYnJvd3NlcmlmeS9ibG9iL21hc3Rlci9leGFtcGxlL3NjcmlwdC5qcykpLlxuKi9cbmZ1bmN0aW9uIGVzTGludChlc2xpbnQsIGNvbmZpZykge1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHBhcnNlck9wdGlvbnM6IHsgZWNtYVZlcnNpb246IDIwMTksIHNvdXJjZVR5cGU6IFwibW9kdWxlXCIgfSxcbiAgICAgICAgICAgIGVudjogeyBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlLCBlczY6IHRydWUsIGVzMjAxNTogdHJ1ZSwgZXMyMDE3OiB0cnVlLCBlczIwMjA6IHRydWUgfSxcbiAgICAgICAgICAgIHJ1bGVzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBlc2xpbnQuZ2V0UnVsZXMoKS5mb3JFYWNoKChkZXNjLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGVzYy5tZXRhLmRvY3MucmVjb21tZW5kZWQpXG4gICAgICAgICAgICAgICAgY29uZmlnLnJ1bGVzW25hbWVdID0gMjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAodmlldykgPT4ge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgZm91bmQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIGphdmFzY3JpcHRMYW5ndWFnZS5maW5kUmVnaW9ucyhzdGF0ZSkpIHtcbiAgICAgICAgICAgIGxldCBmcm9tTGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSksIG9mZnNldCA9IHsgbGluZTogZnJvbUxpbmUubnVtYmVyIC0gMSwgY29sOiBmcm9tIC0gZnJvbUxpbmUuZnJvbSwgcG9zOiBmcm9tIH07XG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGVzbGludC52ZXJpZnkoc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pLCBjb25maWcpKVxuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2godHJhbnNsYXRlRGlhZ25vc3RpYyhkLCBzdGF0ZS5kb2MsIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFwUG9zKGxpbmUsIGNvbCwgZG9jLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZG9jLmxpbmUobGluZSArIG9mZnNldC5saW5lKS5mcm9tICsgY29sICsgKGxpbmUgPT0gMSA/IG9mZnNldC5jb2wgLSAxIDogLTEpO1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlRGlhZ25vc3RpYyhpbnB1dCwgZG9jLCBvZmZzZXQpIHtcbiAgICBsZXQgc3RhcnQgPSBtYXBQb3MoaW5wdXQubGluZSwgaW5wdXQuY29sdW1uLCBkb2MsIG9mZnNldCk7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgZnJvbTogc3RhcnQsXG4gICAgICAgIHRvOiBpbnB1dC5lbmRMaW5lICE9IG51bGwgJiYgaW5wdXQuZW5kQ29sdW1uICE9IDEgPyBtYXBQb3MoaW5wdXQuZW5kTGluZSwgaW5wdXQuZW5kQ29sdW1uLCBkb2MsIG9mZnNldCkgOiBzdGFydCxcbiAgICAgICAgbWVzc2FnZTogaW5wdXQubWVzc2FnZSxcbiAgICAgICAgc291cmNlOiBpbnB1dC5ydWxlSWQgPyBcImVzbGludDpcIiArIGlucHV0LnJ1bGVJZCA6IFwiZXNsaW50XCIsXG4gICAgICAgIHNldmVyaXR5OiBpbnB1dC5zZXZlcml0eSA9PSAxID8gXCJ3YXJuaW5nXCIgOiBcImVycm9yXCIsXG4gICAgfTtcbiAgICBpZiAoaW5wdXQuZml4KSB7XG4gICAgICAgIGxldCB7IHJhbmdlLCB0ZXh0IH0gPSBpbnB1dC5maXgsIGZyb20gPSByYW5nZVswXSArIG9mZnNldC5wb3MgLSBzdGFydCwgdG8gPSByYW5nZVsxXSArIG9mZnNldC5wb3MgLSBzdGFydDtcbiAgICAgICAgcmVzdWx0LmFjdGlvbnMgPSBbe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiZml4XCIsXG4gICAgICAgICAgICAgICAgYXBwbHkodmlldywgc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGNoYW5nZXM6IHsgZnJvbTogc3RhcnQgKyBmcm9tLCB0bzogc3RhcnQgKyB0bywgaW5zZXJ0OiB0ZXh0IH0sIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnRzLmF1dG9DbG9zZVRhZ3MgPSBhdXRvQ2xvc2VUYWdzO1xuZXhwb3J0cy5jb21wbGV0aW9uUGF0aCA9IGNvbXBsZXRpb25QYXRoO1xuZXhwb3J0cy5lc0xpbnQgPSBlc0xpbnQ7XG5leHBvcnRzLmphdmFzY3JpcHQgPSBqYXZhc2NyaXB0O1xuZXhwb3J0cy5qYXZhc2NyaXB0TGFuZ3VhZ2UgPSBqYXZhc2NyaXB0TGFuZ3VhZ2U7XG5leHBvcnRzLmpzeExhbmd1YWdlID0ganN4TGFuZ3VhZ2U7XG5leHBvcnRzLmxvY2FsQ29tcGxldGlvblNvdXJjZSA9IGxvY2FsQ29tcGxldGlvblNvdXJjZTtcbmV4cG9ydHMuc2NvcGVDb21wbGV0aW9uU291cmNlID0gc2NvcGVDb21wbGV0aW9uU291cmNlO1xuZXhwb3J0cy5zbmlwcGV0cyA9IHNuaXBwZXRzO1xuZXhwb3J0cy50c3hMYW5ndWFnZSA9IHRzeExhbmd1YWdlO1xuZXhwb3J0cy50eXBlc2NyaXB0TGFuZ3VhZ2UgPSB0eXBlc2NyaXB0TGFuZ3VhZ2U7XG5leHBvcnRzLnR5cGVzY3JpcHRTbmlwcGV0cyA9IHR5cGVzY3JpcHRTbmlwcGV0cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJ0BsZXplci9jb21tb24nKTtcbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG52YXIgdmlldyA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3ZpZXcnKTtcbnZhciBoaWdobGlnaHQgPSByZXF1aXJlKCdAbGV6ZXIvaGlnaGxpZ2h0Jyk7XG52YXIgc3R5bGVNb2QgPSByZXF1aXJlKCdzdHlsZS1tb2QnKTtcblxudmFyIF9hO1xuLyoqXG5Ob2RlIHByb3Agc3RvcmVkIGluIGEgcGFyc2VyJ3MgdG9wIHN5bnRheCBub2RlIHRvIHByb3ZpZGUgdGhlXG5mYWNldCB0aGF0IHN0b3JlcyBsYW5ndWFnZS1zcGVjaWZpYyBkYXRhIGZvciB0aGF0IGxhbmd1YWdlLlxuKi9cbmNvbnN0IGxhbmd1YWdlRGF0YVByb3AgPSBuZXcgY29tbW9uLk5vZGVQcm9wKCk7XG4vKipcbkhlbHBlciBmdW5jdGlvbiB0byBkZWZpbmUgYSBmYWNldCAodG8gYmUgYWRkZWQgdG8gdGhlIHRvcCBzeW50YXhcbm5vZGUocykgZm9yIGEgbGFuZ3VhZ2UgdmlhXG5bYGxhbmd1YWdlRGF0YVByb3BgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlRGF0YVByb3ApKSwgdGhhdCB3aWxsIGJlXG51c2VkIHRvIGFzc29jaWF0ZSBsYW5ndWFnZSBkYXRhIHdpdGggdGhlIGxhbmd1YWdlLiBZb3VcbnByb2JhYmx5IG9ubHkgbmVlZCB0aGlzIHdoZW4gc3ViY2xhc3NpbmdcbltgTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKS5cbiovXG5mdW5jdGlvbiBkZWZpbmVMYW5ndWFnZUZhY2V0KGJhc2VEYXRhKSB7XG4gICAgcmV0dXJuIHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgICAgIGNvbWJpbmU6IGJhc2VEYXRhID8gdmFsdWVzID0+IHZhbHVlcy5jb25jYXQoYmFzZURhdGEpIDogdW5kZWZpbmVkXG4gICAgfSk7XG59XG4vKipcblN5bnRheCBub2RlIHByb3AgdXNlZCB0byByZWdpc3RlciBzdWJsYW5ndWFnZXMuIFNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHRvcCBsZXZlbCBub2RlIHR5cGUgZm9yIHRoZSBsYW5ndWFnZS5cbiovXG5jb25zdCBzdWJsYW5ndWFnZVByb3AgPSBuZXcgY29tbW9uLk5vZGVQcm9wKCk7XG4vKipcbkEgbGFuZ3VhZ2Ugb2JqZWN0IG1hbmFnZXMgcGFyc2luZyBhbmQgcGVyLWxhbmd1YWdlXG5bbWV0YWRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLiBQYXJzZSBkYXRhIGlzXG5tYW5hZ2VkIGFzIGEgW0xlemVyXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0KSB0cmVlLiBUaGUgY2xhc3NcbmNhbiBiZSB1c2VkIGRpcmVjdGx5LCB2aWEgdGhlIFtgTFJMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTFJMYW5ndWFnZSlcbnN1YmNsYXNzIGZvciBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvKSBMUiBwYXJzZXJzLCBvclxudmlhIHRoZSBbYFN0cmVhbUxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1MYW5ndWFnZSkgc3ViY2xhc3NcbmZvciBzdHJlYW0gcGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbGFuZ3VhZ2Ugb2JqZWN0LiBJZiB5b3UgbmVlZCB0byBpbnZva2UgdGhpc1xuICAgIGRpcmVjdGx5LCBmaXJzdCBkZWZpbmUgYSBkYXRhIGZhY2V0IHdpdGhcbiAgICBbYGRlZmluZUxhbmd1YWdlRmFjZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmRlZmluZUxhbmd1YWdlRmFjZXQpLCBhbmQgdGhlblxuICAgIGNvbmZpZ3VyZSB5b3VyIHBhcnNlciB0byBbYXR0YWNoXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlRGF0YVByb3ApIGl0XG4gICAgdG8gdGhlIGxhbmd1YWdlJ3Mgb3V0ZXIgc3ludGF4IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgW2xhbmd1YWdlIGRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIGZhY2V0XG4gICAgdXNlZCBmb3IgdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGRhdGEsIHBhcnNlciwgZXh0cmFFeHRlbnNpb25zID0gW10sIFxuICAgIC8qKlxuICAgIEEgbGFuZ3VhZ2UgbmFtZS5cbiAgICAqL1xuICAgIG5hbWUgPSBcIlwiKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIC8vIEtsdWRnZSB0byBkZWZpbmUgRWRpdG9yU3RhdGUudHJlZSBhcyBhIGRlYnVnZ2luZyBoZWxwZXIsXG4gICAgICAgIC8vIHdpdGhvdXQgdGhlIEVkaXRvclN0YXRlIHBhY2thZ2UgYWN0dWFsbHkga25vd2luZyBhYm91dFxuICAgICAgICAvLyBsYW5ndWFnZXMgYW5kIGxlemVyIHRyZWVzLlxuICAgICAgICBpZiAoIXN0YXRlLkVkaXRvclN0YXRlLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShcInRyZWVcIikpXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhdGUuRWRpdG9yU3RhdGUucHJvdG90eXBlLCBcInRyZWVcIiwgeyBnZXQoKSB7IHJldHVybiBzeW50YXhUcmVlKHRoaXMpOyB9IH0pO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbXG4gICAgICAgICAgICBsYW5ndWFnZS5vZih0aGlzKSxcbiAgICAgICAgICAgIHN0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YS5vZigoc3RhdGUsIHBvcywgc2lkZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSksIGRhdGEgPSB0b3AudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gc3RhdGUuZmFjZXQoZGF0YSksIHN1YiA9IHRvcC50eXBlLnByb3Aoc3VibGFuZ3VhZ2VQcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lck5vZGUgPSB0b3AucmVzb2x2ZShwb3MgLSB0b3AuZnJvbSwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHN1Ymxhbmcgb2Ygc3ViKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YmxhbmcudGVzdChpbm5lck5vZGUsIHN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gc3RhdGUuZmFjZXQoc3VibGFuZy5mYWNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YmxhbmcudHlwZSA9PSBcInJlcGxhY2VcIiA/IGRhdGEgOiBkYXRhLmNvbmNhdChiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICBdLmNvbmNhdChleHRyYUV4dGVuc2lvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgaXMgYWN0aXZlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGlzQWN0aXZlQXQoc3RhdGUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIHJldHVybiB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSkudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcmVnaW9ucyB0aGF0IHdlcmUgcGFyc2VkIHVzaW5nIHRoaXMgbGFuZ3VhZ2UuXG4gICAgVGhlIHJldHVybmVkIHJlZ2lvbnMgd2lsbCBfaW5jbHVkZV8gYW55IG5lc3RlZCBsYW5ndWFnZXMgcm9vdGVkXG4gICAgaW4gdGhpcyBsYW5ndWFnZSwgd2hlbiB0aG9zZSBleGlzdC5cbiAgICAqL1xuICAgIGZpbmRSZWdpb25zKHN0YXRlKSB7XG4gICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICBpZiAoKGxhbmcgPT09IG51bGwgfHwgbGFuZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFuZy5kYXRhKSA9PSB0aGlzLmRhdGEpXG4gICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogMCwgdG86IHN0YXRlLmRvYy5sZW5ndGggfV07XG4gICAgICAgIGlmICghbGFuZyB8fCAhbGFuZy5hbGxvd3NOZXN0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBleHBsb3JlID0gKHRyZWUsIGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICh0cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3VudCA9IHRyZWUucHJvcChjb21tb24uTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICBpZiAobW91bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQudHJlZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW91bnQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgbW91bnQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb206IHIuZnJvbSArIGZyb20sIHRvOiByLnRvICsgZnJvbSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tOiBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBleHBsb3JlKG1vdW50LnRyZWUsIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSArIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IHNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gdHJlZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggaW5zdGFuY2VvZiBjb21tb24uVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShjaCwgdHJlZS5wb3NpdGlvbnNbaV0gKyBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXhwbG9yZShzeW50YXhUcmVlKHN0YXRlKSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgYWxsb3dzIG5lc3RlZCBsYW5ndWFnZXMuIFRoZVxuICAgIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0cnVlLlxuICAgICovXG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0cnVlOyB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbkxhbmd1YWdlLnNldFN0YXRlID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5mdW5jdGlvbiB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSkge1xuICAgIGxldCB0b3BMYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpLCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSkudG9wTm9kZTtcbiAgICBpZiAoIXRvcExhbmcgfHwgdG9wTGFuZy5hbGxvd3NOZXN0aW5nKSB7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSB0cmVlOyBub2RlOyBub2RlID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIGNvbW1vbi5JdGVyTW9kZS5FeGNsdWRlQnVmZmVycykpXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLmlzVG9wKVxuICAgICAgICAgICAgICAgIHRyZWUgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZTtcbn1cbi8qKlxuQSBzdWJjbGFzcyBvZiBbYExhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgZm9yIHVzZSB3aXRoIExlemVyXG5bTFIgcGFyc2Vyc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNsci5MUlBhcnNlcilcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTFJMYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoZGF0YSwgcGFyc2VyLCBbXSwgbmFtZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBsYW5ndWFnZSBmcm9tIGEgcGFyc2VyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChzcGVjLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZShkYXRhLCBzcGVjLnBhcnNlci5jb25maWd1cmUoe1xuICAgICAgICAgICAgcHJvcHM6IFtsYW5ndWFnZURhdGFQcm9wLmFkZCh0eXBlID0+IHR5cGUuaXNUb3AgPyBkYXRhIDogdW5kZWZpbmVkKV1cbiAgICAgICAgfSksIHNwZWMubmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGxhbmd1YWdlIHdpdGggYSByZWNvbmZpZ3VyZWRcbiAgICB2ZXJzaW9uIG9mIGl0cyBwYXJzZXIgYW5kIG9wdGlvbmFsbHkgYSBuZXcgbmFtZS5cbiAgICAqL1xuICAgIGNvbmZpZ3VyZShvcHRpb25zLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZSh0aGlzLmRhdGEsIHRoaXMucGFyc2VyLmNvbmZpZ3VyZShvcHRpb25zKSwgbmFtZSB8fCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIHRoaXMucGFyc2VyLmhhc1dyYXBwZXJzKCk7IH1cbn1cbi8qKlxuR2V0IHRoZSBzeW50YXggdHJlZSBmb3IgYSBzdGF0ZSwgd2hpY2ggaXMgdGhlIGN1cnJlbnQgKHBvc3NpYmx5XG5pbmNvbXBsZXRlKSBwYXJzZSB0cmVlIG9mIHRoZSBhY3RpdmVcbltsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSksIG9yIHRoZSBlbXB0eSB0cmVlIGlmIHRoZXJlIGlzIG5vXG5sYW5ndWFnZSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZShzdGF0ZSkge1xuICAgIGxldCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZpZWxkID8gZmllbGQudHJlZSA6IGNvbW1vbi5UcmVlLmVtcHR5O1xufVxuLyoqXG5UcnkgdG8gZ2V0IGEgcGFyc2UgdHJlZSB0aGF0IHNwYW5zIGF0IGxlYXN0IHVwIHRvIGB1cHRvYC4gVGhlXG5tZXRob2Qgd2lsbCBkbyBhdCBtb3N0IGB0aW1lb3V0YCBtaWxsaXNlY29uZHMgb2Ygd29yayB0byBwYXJzZVxudXAgdG8gdGhhdCBwb2ludCBpZiB0aGUgdHJlZSBpc24ndCBhbHJlYWR5IGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBlbnN1cmVTeW50YXhUcmVlKHN0YXRlLCB1cHRvLCB0aW1lb3V0ID0gNTApIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBhcnNlID0gKF9hID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRleHQ7XG4gICAgaWYgKCFwYXJzZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG9sZFZpZXBvcnQgPSBwYXJzZS52aWV3cG9ydDtcbiAgICBwYXJzZS51cGRhdGVWaWV3cG9ydCh7IGZyb206IDAsIHRvOiB1cHRvIH0pO1xuICAgIGxldCByZXN1bHQgPSBwYXJzZS5pc0RvbmUodXB0bykgfHwgcGFyc2Uud29yayh0aW1lb3V0LCB1cHRvKSA/IHBhcnNlLnRyZWUgOiBudWxsO1xuICAgIHBhcnNlLnVwZGF0ZVZpZXdwb3J0KG9sZFZpZXBvcnQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcblF1ZXJpZXMgd2hldGhlciB0aGVyZSBpcyBhIGZ1bGwgc3ludGF4IHRyZWUgYXZhaWxhYmxlIHVwIHRvIHRoZVxuZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uIElmIHRoZXJlIGlzbid0LCB0aGUgYmFja2dyb3VuZCBwYXJzZVxucHJvY2VzcyBfbWlnaHRfIHN0aWxsIGJlIHdvcmtpbmcgYW5kIHVwZGF0ZSB0aGUgdHJlZSBmdXJ0aGVyLCBidXRcbnRoZXJlIGlzIG5vIGd1YXJhbnRlZSBvZiB0aGF04oCUdGhlIHBhcnNlciB3aWxsIFtzdG9wXG53b3JraW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFBhcnNlclJ1bm5pbmcpIHdoZW4gaXQgaGFzIHNwZW50IGFcbmNlcnRhaW4gYW1vdW50IG9mIHRpbWUgb3IgaGFzIG1vdmVkIGJleW9uZCB0aGUgdmlzaWJsZSB2aWV3cG9ydC5cbkFsd2F5cyByZXR1cm5zIGZhbHNlIGlmIG5vIGxhbmd1YWdlIGhhcyBiZWVuIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZUF2YWlsYWJsZShzdGF0ZSwgdXB0byA9IHN0YXRlLmRvYy5sZW5ndGgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dC5pc0RvbmUodXB0bykpIHx8IGZhbHNlO1xufVxuLyoqXG5Nb3ZlIHBhcnNpbmcgZm9yd2FyZCwgYW5kIHVwZGF0ZSB0aGUgZWRpdG9yIHN0YXRlIGFmdGVyd2FyZHMgdG9cbnJlZmxlY3QgdGhlIG5ldyB0cmVlLiBXaWxsIHdvcmsgZm9yIGF0IG1vc3QgYHRpbWVvdXRgXG5taWxsaXNlY29uZHMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFyc2VyIG1hbmFnZWQgZ2V0IHRvIHRoZSBnaXZlblxucG9zaXRpb24gaW4gdGhhdCB0aW1lLlxuKi9cbmZ1bmN0aW9uIGZvcmNlUGFyc2luZyh2aWV3LCB1cHRvID0gdmlldy52aWV3cG9ydC50bywgdGltZW91dCA9IDEwMCkge1xuICAgIGxldCBzdWNjZXNzID0gZW5zdXJlU3ludGF4VHJlZSh2aWV3LnN0YXRlLCB1cHRvLCB0aW1lb3V0KTtcbiAgICBpZiAoc3VjY2VzcyAhPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHt9KTtcbiAgICByZXR1cm4gISFzdWNjZXNzO1xufVxuLyoqXG5UZWxscyB5b3Ugd2hldGhlciB0aGUgbGFuZ3VhZ2UgcGFyc2VyIGlzIHBsYW5uaW5nIHRvIGRvIG1vcmVcbnBhcnNpbmcgd29yayAoaW4gYSBgcmVxdWVzdElkbGVDYWxsYmFja2AgcHNldWRvLXRocmVhZCkgb3IgaGFzXG5zdG9wcGVkIHJ1bm5pbmcsIGVpdGhlciBiZWNhdXNlIGl0IHBhcnNlZCB0aGUgZW50aXJlIGRvY3VtZW50LFxuYmVjYXVzZSBpdCBzcGVudCB0b28gbXVjaCB0aW1lIGFuZCB3YXMgY3V0IG9mZiwgb3IgYmVjYXVzZSB0aGVyZVxuaXMgbm8gbGFuZ3VhZ2UgcGFyc2VyIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4UGFyc2VyUnVubmluZyh2aWV3KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGFyc2VXb3JrZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNXb3JraW5nKCkpIHx8IGZhbHNlO1xufVxuLyoqXG5MZXplci1zdHlsZVxuW2BJbnB1dGBdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjY29tbW9uLklucHV0KVxub2JqZWN0IGZvciBhIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dCkgb2JqZWN0LlxuKi9cbmNsYXNzIERvY0lucHV0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5wdXQgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gMDtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLmRvYy5sZW5ndGg7IH1cbiAgICBzeW5jVG8ocG9zKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gdGhpcy5jdXJzb3IubmV4dChwb3MgLSB0aGlzLmN1cnNvclBvcykudmFsdWU7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gcG9zICsgdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGNodW5rKHBvcykge1xuICAgICAgICB0aGlzLnN5bmNUbyhwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IHN0cmluZ1N0YXJ0ID0gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChmcm9tIDwgc3RyaW5nU3RhcnQgfHwgdG8gPj0gdGhpcy5jdXJzb3JQb3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSAtIHN0cmluZ1N0YXJ0LCB0byAtIHN0cmluZ1N0YXJ0KTtcbiAgICB9XG59XG5sZXQgY3VycmVudENvbnRleHQgPSBudWxsO1xuLyoqXG5BIHBhcnNlIGNvbnRleHQgcHJvdmlkZWQgdG8gcGFyc2VycyB3b3JraW5nIG9uIHRoZSBlZGl0b3IgY29udGVudC5cbiovXG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRyZWUgZnJhZ21lbnRzIHRoYXQgY2FuIGJlIHJldXNlZCBieSBpbmNyZW1lbnRhbCByZS1wYXJzZXMuXG4gICAgKi9cbiAgICBmcmFnbWVudHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRyZWVMZW4sIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciB2aWV3cG9ydCAob3Igc29tZSBvdmVyYXBwcm94aW1hdGlvblxuICAgIHRoZXJlb2YpLiBJbnRlbmRlZCB0byBiZSB1c2VkIGZvciBvcHBvcnR1bmlzdGljYWxseSBhdm9pZGluZ1xuICAgIHdvcmsgKGluIHdoaWNoIGNhc2VcbiAgICBbYHNraXBVbnRpbEluVmlld2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuUGFyc2VDb250ZXh0LnNraXBVbnRpbEluVmlldylcbiAgICBzaG91bGQgYmUgY2FsbGVkIHRvIG1ha2Ugc3VyZSB0aGUgcGFyc2VyIGlzIHJlc3RhcnRlZCB3aGVuIHRoZVxuICAgIHNraXBwZWQgcmVnaW9uIGJlY29tZXMgdmlzaWJsZSkuXG4gICAgKi9cbiAgICB2aWV3cG9ydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBza2lwcGVkLCBcbiAgICAvKipcbiAgICBUaGlzIGlzIHdoZXJlIHNraXBwaW5nIHBhcnNlcnMgY2FuIHJlZ2lzdGVyIGEgcHJvbWlzZSB0aGF0LFxuICAgIHdoZW4gcmVzb2x2ZWQsIHdpbGwgc2NoZWR1bGUgYSBuZXcgcGFyc2UuIEl0IGlzIGNsZWFyZWQgd2hlblxuICAgIHRoZSBwYXJzZSB3b3JrZXIgcGlja3MgdXAgdGhlIHByb21pc2UuIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NoZWR1bGVPbikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy50cmVlTGVuID0gdHJlZUxlbjtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnNraXBwZWQgPSBza2lwcGVkO1xuICAgICAgICB0aGlzLnNjaGVkdWxlT24gPSBzY2hlZHVsZU9uO1xuICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRlbXBTa2lwcGVkID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShwYXJzZXIsIHN0YXRlLCB2aWV3cG9ydCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dChwYXJzZXIsIHN0YXRlLCBbXSwgY29tbW9uLlRyZWUuZW1wdHksIDAsIHZpZXdwb3J0LCBbXSwgbnVsbCk7XG4gICAgfVxuICAgIHN0YXJ0UGFyc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5zdGFydFBhcnNlKG5ldyBEb2NJbnB1dCh0aGlzLnN0YXRlLmRvYyksIHRoaXMuZnJhZ21lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB3b3JrKHVudGlsLCB1cHRvKSB7XG4gICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgdXB0byA+PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICB1cHRvID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy50cmVlICE9IGNvbW1vbi5UcmVlLmVtcHR5ICYmIHRoaXMuaXNEb25lKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdW50aWwgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGxldCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIHVudGlsO1xuICAgICAgICAgICAgICAgIHVudGlsID0gKCkgPT4gRGF0ZS5ub3coKSA+IGVuZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMuc3RhcnRQYXJzZSgpO1xuICAgICAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IHVwdG8pICYmXG4gICAgICAgICAgICAgICAgdXB0byA8IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnN0b3BBdCh1cHRvKTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoY29tbW9uLlRyZWVGcmFnbWVudC5hZGRUcmVlKGRvbmUsIHRoaXMuZnJhZ21lbnRzLCB0aGlzLnBhcnNlLnN0b3BwZWRBdCAhPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IChfYSA9IHRoaXMucGFyc2Uuc3RvcHBlZEF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZSA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmVlTGVuIDwgKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW50aWwoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0YWtlVHJlZSgpIHtcbiAgICAgICAgbGV0IHBvcywgdHJlZTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UgJiYgKHBvcyA9IHRoaXMucGFyc2UucGFyc2VkUG9zKSA+PSB0aGlzLnRyZWVMZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gcG9zKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgICAgICB0aGlzLndpdGhDb250ZXh0KCgpID0+IHsgd2hpbGUgKCEodHJlZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpKSkgeyB9IH0pO1xuICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gcG9zO1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoY29tbW9uLlRyZWVGcmFnbWVudC5hZGRUcmVlKHRoaXMudHJlZSwgdGhpcy5mcmFnbWVudHMsIHRydWUpKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhDb250ZXh0KGYpIHtcbiAgICAgICAgbGV0IHByZXYgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgY3VycmVudENvbnRleHQgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gcHJldjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aXRob3V0VGVtcFNraXBwZWQoZnJhZ21lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IHI7IHIgPSB0aGlzLnRlbXBTa2lwcGVkLnBvcCgpOylcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIHIuZnJvbSwgci50byk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hhbmdlcyhjaGFuZ2VzLCBuZXdTdGF0ZSkge1xuICAgICAgICBsZXQgeyBmcmFnbWVudHMsIHRyZWUsIHRyZWVMZW4sIHZpZXdwb3J0LCBza2lwcGVkIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgIGlmICghY2hhbmdlcy5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gcmFuZ2VzLnB1c2goeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0pKTtcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IGNvbW1vbi5UcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgICAgIHRyZWUgPSBjb21tb24uVHJlZS5lbXB0eTtcbiAgICAgICAgICAgIHRyZWVMZW4gPSAwO1xuICAgICAgICAgICAgdmlld3BvcnQgPSB7IGZyb206IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG86IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyhyLmZyb20sIDEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHIudG8sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dCh0aGlzLnBhcnNlciwgbmV3U3RhdGUsIGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQsIHRoaXMuc2NoZWR1bGVPbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXBkYXRlVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQuZnJvbSA9PSB2aWV3cG9ydC5mcm9tICYmIHRoaXMudmlld3BvcnQudG8gPT0gdmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IHN0YXJ0TGVuID0gdGhpcy5za2lwcGVkLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNraXBwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLnNraXBwZWRbaV07XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHZpZXdwb3J0LnRvICYmIHRvID4gdmlld3BvcnQuZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKHRoaXMuZnJhZ21lbnRzLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwcGVkLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoID49IHN0YXJ0TGVuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5wYXJzZSkge1xuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTm90aWZ5IHRoZSBwYXJzZSBzY2hlZHVsZXIgdGhhdCB0aGUgZ2l2ZW4gcmVnaW9uIHdhcyBza2lwcGVkXG4gICAgYmVjYXVzZSBpdCB3YXNuJ3QgaW4gdmlldywgYW5kIHRoZSBwYXJzZSBzaG91bGQgYmUgcmVzdGFydGVkXG4gICAgd2hlbiBpdCBjb21lcyBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBza2lwVW50aWxJblZpZXcoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5za2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHBhcnNlciBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIHBsYWNlaG9sZGVyIHdoZW5cbiAgICBhc3luY2hyb25vdXNseSBsb2FkaW5nIGEgbmVzdGVkIHBhcnNlci4gSXQnbGwgc2tpcCBpdHMgaW5wdXQgYW5kXG4gICAgbWFyayBpdCBhcyBub3QtcmVhbGx5LXBhcnNlZCwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCBwYXJzZVxuICAgIGl0IGFnYWluLlxuICAgIFxuICAgIFdoZW4gYHVudGlsYCBpcyBnaXZlbiwgYSByZXBhcnNlIHdpbGwgYmUgc2NoZWR1bGVkIHdoZW4gdGhhdFxuICAgIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0U2tpcHBpbmdQYXJzZXIodW50aWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzcyBleHRlbmRzIGNvbW1vbi5QYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbMF0uZnJvbSwgdG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFBvczogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjeCA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiByYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnRlbXBTa2lwcGVkLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVudGlsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5zY2hlZHVsZU9uID0gY3guc2NoZWR1bGVPbiA/IFByb21pc2UuYWxsKFtjeC5zY2hlZHVsZU9uLCB1bnRpbF0pIDogdW50aWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IHRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb21tb24uVHJlZShjb21tb24uTm9kZVR5cGUubm9uZSwgW10sIFtdLCB0byAtIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkQXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdCgpIHsgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpc0RvbmUodXB0bykge1xuICAgICAgICB1cHRvID0gTWF0aC5taW4odXB0bywgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IGZyYWdzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVMZW4gPj0gdXB0byAmJiBmcmFncy5sZW5ndGggJiYgZnJhZ3NbMF0uZnJvbSA9PSAwICYmIGZyYWdzWzBdLnRvID49IHVwdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGV4dCBmb3IgdGhlIGN1cnJlbnQgcGFyc2UsIG9yIGBudWxsYCBpZiBubyBlZGl0b3JcbiAgICBwYXJzZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQoKSB7IHJldHVybiBjdXJyZW50Q29udGV4dDsgfVxufVxuZnVuY3Rpb24gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gY29tbW9uLlRyZWVGcmFnbWVudC5hcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBbeyBmcm9tQTogZnJvbSwgdG9BOiB0bywgZnJvbUI6IGZyb20sIHRvQjogdG8gfV0pO1xufVxuY2xhc3MgTGFuZ3VhZ2VTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gQSBtdXRhYmxlIHBhcnNlIHN0YXRlIHRoYXQgaXMgdXNlZCB0byBwcmVzZXJ2ZSB3b3JrIGRvbmUgZHVyaW5nXG4gICAgLy8gdGhlIGxpZmV0aW1lIG9mIGEgc3RhdGUgd2hlbiBtb3ZpbmcgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRyZWUgPSBjb250ZXh0LnRyZWU7XG4gICAgfVxuICAgIGFwcGx5KHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiB0aGlzLnRyZWUgPT0gdGhpcy5jb250ZXh0LnRyZWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IG5ld0N4ID0gdGhpcy5jb250ZXh0LmNoYW5nZXModHIuY2hhbmdlcywgdHIuc3RhdGUpO1xuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgcGFyc2Ugd2Fzbid0IGRvbmUsIGdvIGZvcndhcmQgb25seSB1cCB0byBpdHNcbiAgICAgICAgLy8gZW5kIHBvc2l0aW9uIG9yIHRoZSBlbmQgb2YgdGhlIHZpZXdwb3J0LCB0byBhdm9pZCBzbG93aW5nIGRvd25cbiAgICAgICAgLy8gc3RhdGUgdXBkYXRlcyB3aXRoIHBhcnNlIHdvcmsgYmV5b25kIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgbGV0IHVwdG8gPSB0aGlzLmNvbnRleHQudHJlZUxlbiA9PSB0ci5zdGFydFN0YXRlLmRvYy5sZW5ndGggPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogTWF0aC5tYXgodHIuY2hhbmdlcy5tYXBQb3ModGhpcy5jb250ZXh0LnRyZWVMZW4pLCBuZXdDeC52aWV3cG9ydC50byk7XG4gICAgICAgIGlmICghbmV3Q3gud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB1cHRvKSlcbiAgICAgICAgICAgIG5ld0N4LnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShuZXdDeCk7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KHN0YXRlKSB7XG4gICAgICAgIGxldCB2cFRvID0gTWF0aC5taW4oMzAwMCAvKiBXb3JrLkluaXRWaWV3cG9ydCAqLywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGxldCBwYXJzZVN0YXRlID0gUGFyc2VDb250ZXh0LmNyZWF0ZShzdGF0ZS5mYWNldChsYW5ndWFnZSkucGFyc2VyLCBzdGF0ZSwgeyBmcm9tOiAwLCB0bzogdnBUbyB9KTtcbiAgICAgICAgaWYgKCFwYXJzZVN0YXRlLndvcmsoMjAgLyogV29yay5BcHBseSAqLywgdnBUbykpXG4gICAgICAgICAgICBwYXJzZVN0YXRlLnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShwYXJzZVN0YXRlKTtcbiAgICB9XG59XG5MYW5ndWFnZS5zdGF0ZSA9IHN0YXRlLlN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGU6IExhbmd1YWdlU3RhdGUuaW5pdCxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKExhbmd1YWdlLnNldFN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHRyLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSlcbiAgICAgICAgICAgIHJldHVybiBMYW5ndWFnZVN0YXRlLmluaXQodHIuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodHIpO1xuICAgIH1cbn0pO1xubGV0IHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKCksIDUwMCAvKiBXb3JrLk1heFBhdXNlICovKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufTtcbmlmICh0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayAhPSBcInVuZGVmaW5lZFwiKVxuICAgIHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCBpZGxlID0gLTEsIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlkbGUgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGNhbGxiYWNrLCB7IHRpbWVvdXQ6IDUwMCAvKiBXb3JrLk1heFBhdXNlICovIC0gMTAwIC8qIFdvcmsuTWluUGF1c2UgKi8gfSk7XG4gICAgICAgIH0sIDEwMCAvKiBXb3JrLk1pblBhdXNlICovKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGlkbGUgPCAwID8gY2xlYXJUaW1lb3V0KHRpbWVvdXQpIDogY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGUpO1xuICAgIH07XG5jb25zdCBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hID0gbmF2aWdhdG9yLnNjaGVkdWxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0lucHV0UGVuZGluZylcbiAgICA/ICgpID0+IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nKCkgOiBudWxsO1xuY29uc3QgcGFyc2VXb3JrZXIgPSB2aWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIFBhcnNlV29ya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMud29ya2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCA9IDA7XG4gICAgICAgIC8vIEVuZCBvZiB0aGUgY3VycmVudCB0aW1lIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmtFbmQgPSAtMTtcbiAgICAgICAgLy8gTWlsbGlzZWNvbmRzIG9mIGJ1ZGdldCBsZWZ0IGZvciB0aGlzIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAtMTtcbiAgICAgICAgdGhpcy53b3JrID0gdGhpcy53b3JrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGN4ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKS5jb250ZXh0O1xuICAgICAgICBpZiAoY3gudXBkYXRlVmlld3BvcnQodXBkYXRlLnZpZXcudmlld3BvcnQpIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA+IGN4LnRyZWVMZW4pXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5oYXNGb2N1cylcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ICs9IDUwIC8qIFdvcmsuQ2hhbmdlQm9udXMgKi87XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGN4KTtcbiAgICB9XG4gICAgc2NoZWR1bGVXb3JrKCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKTtcbiAgICAgICAgaWYgKGZpZWxkLnRyZWUgIT0gZmllbGQuY29udGV4dC50cmVlIHx8ICFmaWVsZC5jb250ZXh0LmlzRG9uZShzdGF0ZS5kb2MubGVuZ3RoKSlcbiAgICAgICAgICAgIHRoaXMud29ya2luZyA9IHJlcXVlc3RJZGxlKHRoaXMud29yayk7XG4gICAgfVxuICAgIHdvcmsoZGVhZGxpbmUpIHtcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rRW5kIDwgbm93ICYmICh0aGlzLmNodW5rRW5kIDwgMCB8fCB0aGlzLnZpZXcuaGFzRm9jdXMpKSB7IC8vIFN0YXJ0IGEgbmV3IGNodW5rXG4gICAgICAgICAgICB0aGlzLmNodW5rRW5kID0gbm93ICsgMzAwMDAgLyogV29yay5DaHVua1RpbWUgKi87XG4gICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ID0gMzAwMCAvKiBXb3JrLkNodW5rQnVkZ2V0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0IDw9IDApXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vIG1vcmUgYnVkZ2V0XG4gICAgICAgIGxldCB7IHN0YXRlLCB2aWV3cG9ydDogeyB0bzogdnBUbyB9IH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSA9PSBmaWVsZC5jb250ZXh0LnRyZWUgJiYgZmllbGQuY29udGV4dC5pc0RvbmUodnBUbyArIDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyBNYXRoLm1pbih0aGlzLmNodW5rQnVkZ2V0LCAxMDAgLyogV29yay5TbGljZSAqLywgZGVhZGxpbmUgJiYgIWlzSW5wdXRQZW5kaW5nID8gTWF0aC5tYXgoMjUgLyogV29yay5NaW5TbGljZSAqLywgZGVhZGxpbmUudGltZVJlbWFpbmluZygpIC0gNSkgOiAxZTkpO1xuICAgICAgICBsZXQgdmlld3BvcnRGaXJzdCA9IGZpZWxkLmNvbnRleHQudHJlZUxlbiA8IHZwVG8gJiYgc3RhdGUuZG9jLmxlbmd0aCA+IHZwVG8gKyAxMDAwO1xuICAgICAgICBsZXQgZG9uZSA9IGZpZWxkLmNvbnRleHQud29yaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNJbnB1dFBlbmRpbmcgJiYgaXNJbnB1dFBlbmRpbmcoKSB8fCBEYXRlLm5vdygpID4gZW5kVGltZTtcbiAgICAgICAgfSwgdnBUbyArICh2aWV3cG9ydEZpcnN0ID8gMCA6IDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKTtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCAtPSBEYXRlLm5vdygpIC0gbm93O1xuICAgICAgICBpZiAoZG9uZSB8fCB0aGlzLmNodW5rQnVkZ2V0IDw9IDApIHtcbiAgICAgICAgICAgIGZpZWxkLmNvbnRleHQudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IExhbmd1YWdlLnNldFN0YXRlLm9mKG5ldyBMYW5ndWFnZVN0YXRlKGZpZWxkLmNvbnRleHQpKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0J1ZGdldCA+IDAgJiYgIShkb25lICYmICF2aWV3cG9ydEZpcnN0KSlcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGZpZWxkLmNvbnRleHQpO1xuICAgIH1cbiAgICBjaGVja0FzeW5jU2NoZWR1bGUoY3gpIHtcbiAgICAgICAgaWYgKGN4LnNjaGVkdWxlT24pIHtcbiAgICAgICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCsrO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPblxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVXb3JrKCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB2aWV3LmxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycikpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy53b3JrU2NoZWR1bGVkLS0pO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZylcbiAgICAgICAgICAgIHRoaXMud29ya2luZygpO1xuICAgIH1cbiAgICBpc1dvcmtpbmcoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLndvcmtpbmcgfHwgdGhpcy53b3JrU2NoZWR1bGVkID4gMCk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHsgZm9jdXMoKSB7IHRoaXMuc2NoZWR1bGVXb3JrKCk7IH0gfVxufSk7XG4vKipcblRoZSBmYWNldCB1c2VkIHRvIGFzc29jaWF0ZSBhIGxhbmd1YWdlIHdpdGggYW4gZWRpdG9yIHN0YXRlLiBVc2VkXG5ieSBgTGFuZ3VhZ2VgIG9iamVjdCdzIGBleHRlbnNpb25gIHByb3BlcnR5IChzbyB5b3UgZG9uJ3QgbmVlZCB0b1xubWFudWFsbHkgd3JhcCB5b3VyIGxhbmd1YWdlcyBpbiB0aGlzKS4gQ2FuIGJlIHVzZWQgdG8gYWNjZXNzIHRoZVxuY3VycmVudCBsYW5ndWFnZSBvbiBhIHN0YXRlLlxuKi9cbmNvbnN0IGxhbmd1YWdlID0gc3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGxhbmd1YWdlcykgeyByZXR1cm4gbGFuZ3VhZ2VzLmxlbmd0aCA/IGxhbmd1YWdlc1swXSA6IG51bGw7IH0sXG4gICAgZW5hYmxlczogbGFuZ3VhZ2UgPT4gW1xuICAgICAgICBMYW5ndWFnZS5zdGF0ZSxcbiAgICAgICAgcGFyc2VXb3JrZXIsXG4gICAgICAgIHZpZXcuRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5jb21wdXRlKFtsYW5ndWFnZV0sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGxhbmcgJiYgbGFuZy5uYW1lID8geyBcImRhdGEtbGFuZ3VhZ2VcIjogbGFuZy5uYW1lIH0gOiB7fTtcbiAgICAgICAgfSlcbiAgICBdXG59KTtcbi8qKlxuVGhpcyBjbGFzcyBidW5kbGVzIGEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSB3aXRoIGFuXG5vcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBMYW5ndWFnZSBwYWNrYWdlcyBhcmVcbmVuY291cmFnZWQgdG8gZXhwb3J0IGEgZnVuY3Rpb24gdGhhdCBvcHRpb25hbGx5IHRha2VzIGFcbmNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZCByZXR1cm5zIGEgYExhbmd1YWdlU3VwcG9ydGAgaW5zdGFuY2UsIGFzXG50aGUgbWFpbiB3YXkgZm9yIGNsaWVudCBjb2RlIHRvIHVzZSB0aGUgcGFja2FnZS5cbiovXG5jbGFzcyBMYW5ndWFnZVN1cHBvcnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIHN1cHBvcnQgb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxhbmd1YWdlIG9iamVjdC5cbiAgICAqL1xuICAgIGxhbmd1YWdlLCBcbiAgICAvKipcbiAgICBBbiBvcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBXaGVuIG5lc3RpbmcgYVxuICAgIGxhbmd1YWdlIGluIGFub3RoZXIgbGFuZ3VhZ2UsIHRoZSBvdXRlciBsYW5ndWFnZSBpcyBlbmNvdXJhZ2VkXG4gICAgdG8gaW5jbHVkZSB0aGUgc3VwcG9ydGluZyBleHRlbnNpb25zIGZvciBpdHMgaW5uZXIgbGFuZ3VhZ2VzXG4gICAgaW4gaXRzIG93biBzZXQgb2Ygc3VwcG9ydCBleHRlbnNpb25zLlxuICAgICovXG4gICAgc3VwcG9ydCA9IFtdKSB7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbbGFuZ3VhZ2UsIHN1cHBvcnRdO1xuICAgIH1cbn1cbi8qKlxuTGFuZ3VhZ2UgZGVzY3JpcHRpb25zIGFyZSB1c2VkIHRvIHN0b3JlIG1ldGFkYXRhIGFib3V0IGxhbmd1YWdlc1xuYW5kIHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhlbS4gVGhlaXIgbWFpbiByb2xlIGlzIGZpbmRpbmcgdGhlXG5hcHByb3ByaWF0ZSBsYW5ndWFnZSBmb3IgYSBmaWxlbmFtZSBvciBkeW5hbWljYWxseSBsb2FkaW5nIG5lc3RlZFxucGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZURlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQWx0ZXJuYXRpdmUgbmFtZXMgZm9yIHRoZSBtb2RlIChsb3dlcmNhc2VkLCBpbmNsdWRlcyBgdGhpcy5uYW1lYCkuXG4gICAgKi9cbiAgICBhbGlhcywgXG4gICAgLyoqXG4gICAgRmlsZSBleHRlbnNpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZXh0ZW5zaW9ucywgXG4gICAgLyoqXG4gICAgT3B0aW9uYWwgZmlsZW5hbWUgcGF0dGVybiB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhpc1xuICAgIGxhbmd1YWdlLlxuICAgICovXG4gICAgZmlsZW5hbWUsIGxvYWRGdW5jLCBcbiAgICAvKipcbiAgICBJZiB0aGUgbGFuZ3VhZ2UgaGFzIGJlZW4gbG9hZGVkLCB0aGlzIHdpbGwgaG9sZCBpdHMgdmFsdWUuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmxvYWRGdW5jID0gbG9hZEZ1bmM7XG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXJ0IGxvYWRpbmcgdGhlIHRoZSBsYW5ndWFnZS4gV2lsbCByZXR1cm4gYSBwcm9taXNlIHRoYXRcbiAgICByZXNvbHZlcyB0byBhIFtgTGFuZ3VhZ2VTdXBwb3J0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZVN1cHBvcnQpXG4gICAgb2JqZWN0IHdoZW4gdGhlIGxhbmd1YWdlIHN1Y2Nlc3NmdWxseSBsb2Fkcy5cbiAgICAqL1xuICAgIGxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRpbmcgfHwgKHRoaXMubG9hZGluZyA9IHRoaXMubG9hZEZ1bmMoKS50aGVuKHN1cHBvcnQgPT4gdGhpcy5zdXBwb3J0ID0gc3VwcG9ydCwgZXJyID0+IHsgdGhpcy5sb2FkaW5nID0gbnVsbDsgdGhyb3cgZXJyOyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIGRlc2NyaXB0aW9uLlxuICAgICovXG4gICAgc3RhdGljIG9mKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgbG9hZCwgc3VwcG9ydCB9ID0gc3BlYztcbiAgICAgICAgaWYgKCFsb2FkKSB7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdXN0IHBhc3MgZWl0aGVyICdsb2FkJyBvciAnc3VwcG9ydCcgdG8gTGFuZ3VhZ2VEZXNjcmlwdGlvbi5vZlwiKTtcbiAgICAgICAgICAgIGxvYWQgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoc3VwcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZURlc2NyaXB0aW9uKHNwZWMubmFtZSwgKHNwZWMuYWxpYXMgfHwgW10pLmNvbmNhdChzcGVjLm5hbWUpLm1hcChzID0+IHMudG9Mb3dlckNhc2UoKSksIHNwZWMuZXh0ZW5zaW9ucyB8fCBbXSwgc3BlYy5maWxlbmFtZSwgbG9hZCwgc3VwcG9ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2UgaW4gdGhlIGdpdmVuIGFycmF5IG9mIGRlc2NyaXB0aW9ucyB0aGF0XG4gICAgbWF0Y2hlcyB0aGUgZmlsZW5hbWUuIFdpbGwgZmlyc3QgbWF0Y2hcbiAgICBbYGZpbGVuYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmZpbGVuYW1lKSBwYXR0ZXJucyxcbiAgICBhbmQgdGhlbiBbZXh0ZW5zaW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpLFxuICAgIGFuZCByZXR1cm4gdGhlIGZpcnN0IGxhbmd1YWdlIHRoYXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaEZpbGVuYW1lKGRlc2NzLCBmaWxlbmFtZSkge1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuZmlsZW5hbWUgJiYgZC5maWxlbmFtZS50ZXN0KGZpbGVuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgbGV0IGV4dCA9IC9cXC4oW14uXSspJC8uZXhlYyhmaWxlbmFtZSk7XG4gICAgICAgIGlmIChleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGlmIChkLmV4dGVuc2lvbnMuaW5kZXhPZihleHRbMV0pID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lIG9yIGFsaWFzIG1hdGNoZXMgdGhlIHRoZSBnaXZlblxuICAgIG5hbWUgKGNhc2UtaW5zZW5zaXRpdmVseSkuIElmIGBmdXp6eWAgaXMgdHJ1ZSwgYW5kIG5vIGRpcmVjdFxuICAgIG1hdGNocyBpcyBmb3VuZCwgdGhpcydsbCBhbHNvIHNlYXJjaCBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lXG4gICAgb3IgYWxpYXMgb2NjdXJzIGluIHRoZSBzdHJpbmcgKGZvciBuYW1lcyBzaG9ydGVyIHRoYW4gdGhyZWVcbiAgICBjaGFyYWN0ZXJzLCBvbmx5IHdoZW4gc3Vycm91bmRlZCBieSBub24td29yZCBjaGFyYWN0ZXJzKS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaExhbmd1YWdlTmFtZShkZXNjcywgbmFtZSwgZnV6enkgPSB0cnVlKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5hbGlhcy5zb21lKGEgPT4gYSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgaWYgKGZ1enp5KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhIG9mIGQuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gbmFtZS5pbmRleE9mKGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiAtMSAmJiAoYS5sZW5ndGggPiAyIHx8ICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgLSAxXSkgJiYgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCArIGEubGVuZ3RoXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuRmFjZXQgdGhhdCBkZWZpbmVzIGEgd2F5IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZVxuYXBwcm9wcmlhdGUgaW5kZW50YXRpb24gZGVwdGgsIGFzIGEgY29sdW1uIG51bWJlciAoc2VlXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSksIGF0IHRoZSBzdGFydCBvZiBhIGdpdmVuXG5saW5lLiBBIHJldHVybiB2YWx1ZSBvZiBgbnVsbGAgaW5kaWNhdGVzIG5vIGluZGVudGF0aW9uIGNhbiBiZVxuZGV0ZXJtaW5lZCwgYW5kIHRoZSBsaW5lIHNob3VsZCBpbmhlcml0IHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgb25lXG5hYm92ZSBpdC4gQSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgZGVmZXJzIHRvIHRoZSBuZXh0IGluZGVudFxuc2VydmljZS5cbiovXG5jb25zdCBpbmRlbnRTZXJ2aWNlID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IGZvciBvdmVycmlkaW5nIHRoZSB1bml0IGJ5IHdoaWNoIGluZGVudGF0aW9uIGhhcHBlbnMuIFNob3VsZFxuYmUgYSBzdHJpbmcgY29uc2lzdGluZyBlaXRoZXIgZW50aXJlbHkgb2YgdGhlIHNhbWUgd2hpdGVzcGFjZVxuY2hhcmFjdGVyLiBXaGVuIG5vdCBzZXQsIHRoaXMgZGVmYXVsdHMgdG8gMiBzcGFjZXMuXG4qL1xuY29uc3QgaW5kZW50VW5pdCA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFwiICBcIjtcbiAgICAgICAgbGV0IHVuaXQgPSB2YWx1ZXNbMF07XG4gICAgICAgIGlmICghdW5pdCB8fCAvXFxTLy50ZXN0KHVuaXQpIHx8IEFycmF5LmZyb20odW5pdCkuc29tZShlID0+IGUgIT0gdW5pdFswXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGVudCB1bml0OiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlc1swXSkpO1xuICAgICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJuIHRoZSBfY29sdW1uIHdpZHRoXyBvZiBhbiBpbmRlbnQgdW5pdCBpbiB0aGUgc3RhdGUuXG5EZXRlcm1pbmVkIGJ5IHRoZSBbYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpXG5mYWNldCwgYW5kIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgd2hlbiB0aGF0XG5jb250YWlucyB0YWJzLlxuKi9cbmZ1bmN0aW9uIGdldEluZGVudFVuaXQoc3RhdGUpIHtcbiAgICBsZXQgdW5pdCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpO1xuICAgIHJldHVybiB1bml0LmNoYXJDb2RlQXQoMCkgPT0gOSA/IHN0YXRlLnRhYlNpemUgKiB1bml0Lmxlbmd0aCA6IHVuaXQubGVuZ3RoO1xufVxuLyoqXG5DcmVhdGUgYW4gaW5kZW50YXRpb24gc3RyaW5nIHRoYXQgY292ZXJzIGNvbHVtbnMgMCB0byBgY29sc2AuXG5XaWxsIHVzZSB0YWJzIGZvciBhcyBtdWNoIG9mIHRoZSBjb2x1bW5zIGFzIHBvc3NpYmxlIHdoZW4gdGhlXG5bYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIGZhY2V0IGNvbnRhaW5zXG50YWJzLlxuKi9cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdGF0ZSwgY29scykge1xuICAgIGxldCByZXN1bHQgPSBcIlwiLCB0cyA9IHN0YXRlLnRhYlNpemUsIGNoID0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdClbMF07XG4gICAgaWYgKGNoID09IFwiXFx0XCIpIHtcbiAgICAgICAgd2hpbGUgKGNvbHMgPj0gdHMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgY29scyAtPSB0cztcbiAgICAgICAgfVxuICAgICAgICBjaCA9IFwiIFwiO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHM7IGkrKylcbiAgICAgICAgcmVzdWx0ICs9IGNoO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkdldCB0aGUgaW5kZW50YXRpb24sIGFzIGEgY29sdW1uIG51bWJlciwgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuV2lsbCBmaXJzdCBjb25zdWx0IGFueSBbaW5kZW50IHNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpXG50aGF0IGFyZSByZWdpc3RlcmVkLCBhbmQgaWYgbm9uZSBvZiB0aG9zZSByZXR1cm4gYW4gaW5kZW50YXRpb24sXG50aGlzIHdpbGwgY2hlY2sgdGhlIHN5bnRheCB0cmVlIGZvciB0aGUgW2luZGVudCBub2RlXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudE5vZGVQcm9wKSBhbmQgdXNlIHRoYXQgaWYgZm91bmQuIFJldHVybnMgYVxubnVtYmVyIHdoZW4gYW4gaW5kZW50YXRpb24gY291bGQgYmUgZGV0ZXJtaW5lZCwgYW5kIG51bGxcbm90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBwb3MpIHtcbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIHN0YXRlLkVkaXRvclN0YXRlKVxuICAgICAgICBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoY29udGV4dCk7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBjb250ZXh0LnN0YXRlLmZhY2V0KGluZGVudFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKGNvbnRleHQsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKTtcbiAgICByZXR1cm4gdHJlZS5sZW5ndGggPj0gcG9zID8gc3ludGF4SW5kZW50YXRpb24oY29udGV4dCwgdHJlZSwgcG9zKSA6IG51bGw7XG59XG4vKipcbkNyZWF0ZSBhIGNoYW5nZSBzZXQgdGhhdCBhdXRvLWluZGVudHMgYWxsIGxpbmVzIHRvdWNoZWQgYnkgdGhlXG5naXZlbiBkb2N1bWVudCByYW5nZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRSYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHVwZGF0ZWRbc3RhcnRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTsgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IGZyb207IHBvcyA8PSB0bzspIHtcbiAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG59XG4vKipcbkluZGVudGF0aW9uIGNvbnRleHRzIGFyZSB1c2VkIHdoZW4gY2FsbGluZyBbaW5kZW50YXRpb25cbnNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpLiBUaGV5IHByb3ZpZGUgaGVscGVyIHV0aWxpdGllc1xudXNlZnVsIGluIGluZGVudGF0aW9uIGxvZ2ljLCBhbmQgY2FuIHNlbGVjdGl2ZWx5IG92ZXJyaWRlIHRoZVxuaW5kZW50YXRpb24gcmVwb3J0ZWQgZm9yIHNvbWUgbGluZXMuXG4qL1xuY2xhc3MgSW5kZW50Q29udGV4dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluZGVudCBjb250ZXh0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudW5pdCA9IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIHRha2luZ1xuICAgIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBpbnRvIGFjY291bnQuIElmIHRoZXJlIGlzIHN1Y2ggYSBicmVhayBhdCBgcG9zYCwgdGhlIGBiaWFzYFxuICAgIGFyZ3VtZW50IGRldGVybWluZXMgd2hldGhlciB0aGUgcGFydCBvZiB0aGUgbGluZSBsaW5lIGJlZm9yZSBvclxuICAgIGFmdGVyIHRoZSBicmVhayBpcyB1c2VkLlxuICAgICovXG4gICAgbGluZUF0KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IHsgc2ltdWxhdGVCcmVhaywgc2ltdWxhdGVEb3VibGVCcmVhayB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoc2ltdWxhdGVCcmVhayAhPSBudWxsICYmIHNpbXVsYXRlQnJlYWsgPj0gbGluZS5mcm9tICYmIHNpbXVsYXRlQnJlYWsgPD0gbGluZS50bykge1xuICAgICAgICAgICAgaWYgKHNpbXVsYXRlRG91YmxlQnJlYWsgJiYgc2ltdWxhdGVCcmVhayA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogXCJcIiwgZnJvbTogcG9zIH07XG4gICAgICAgICAgICBlbHNlIGlmIChiaWFzIDwgMCA/IHNpbXVsYXRlQnJlYWsgPCBwb3MgOiBzaW11bGF0ZUJyZWFrIDw9IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2Uoc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IHNpbXVsYXRlQnJlYWsgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2UoMCwgc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IGxpbmUuZnJvbSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHRleHQgZGlyZWN0bHkgYWZ0ZXIgYHBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICB0ZXh0QWZ0ZXJQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbXVsYXRlRG91YmxlQnJlYWsgJiYgcG9zID09IHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKHBvcyAtIGZyb20sIE1hdGgubWluKHRleHQubGVuZ3RoLCBwb3MgKyAxMDAgLSBmcm9tKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgY29sdW1uKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY291bnRDb2x1bW4odGV4dCwgcG9zIC0gZnJvbSk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uID8gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24oZnJvbSkgOiAtMTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID4gLTEpXG4gICAgICAgICAgICByZXN1bHQgKz0gb3ZlcnJpZGUgLSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY29sdW1uIHBvc2l0aW9uICh0YWtpbmcgdGFicyBpbnRvIGFjY291bnQpIG9mIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBjb3VudENvbHVtbihsaW5lLCBwb3MgPSBsaW5lLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RhdGUuY291bnRDb2x1bW4obGluZSwgdGhpcy5zdGF0ZS50YWJTaXplLCBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgICovXG4gICAgbGluZUluZGVudChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uO1xuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZW4gPSBvdmVycmlkZShmcm9tKTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZW4gPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgW3NpbXVsYXRlZCBsaW5lXG4gICAgYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgZm9yIHRoaXMgY29udGV4dCwgaWYgYW55LlxuICAgICovXG4gICAgZ2V0IHNpbXVsYXRlZEJyZWFrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWsgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkEgc3ludGF4IHRyZWUgbm9kZSBwcm9wIHVzZWQgdG8gYXNzb2NpYXRlIGluZGVudGF0aW9uIHN0cmF0ZWdpZXNcbndpdGggbm9kZSB0eXBlcy4gU3VjaCBhIHN0cmF0ZWd5IGlzIGEgZnVuY3Rpb24gZnJvbSBhbiBpbmRlbnRhdGlvblxuY29udGV4dCB0byBhIGNvbHVtbiBudW1iZXIgKHNlZSBhbHNvXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSkgb3IgbnVsbCwgd2hlcmUgbnVsbFxuaW5kaWNhdGVzIHRoYXQgbm8gZGVmaW5pdGl2ZSBpbmRlbnRhdGlvbiBjYW4gYmUgZGV0ZXJtaW5lZC5cbiovXG5jb25zdCBpbmRlbnROb2RlUHJvcCA9IG5ldyBjb21tb24uTm9kZVByb3AoKTtcbi8vIENvbXB1dGUgdGhlIGluZGVudGF0aW9uIGZvciBhIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhlIHN5bnRheCB0cmVlLlxuZnVuY3Rpb24gc3ludGF4SW5kZW50YXRpb24oY3gsIGFzdCwgcG9zKSB7XG4gICAgbGV0IHN0YWNrID0gYXN0LnJlc29sdmVTdGFjayhwb3MpO1xuICAgIGxldCBpbm5lciA9IHN0YWNrLm5vZGUuZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKTtcbiAgICBpZiAoaW5uZXIgIT0gc3RhY2subm9kZSkge1xuICAgICAgICBsZXQgYWRkID0gW107XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGlubmVyOyBjdXIgIT0gc3RhY2subm9kZTsgY3VyID0gY3VyLnBhcmVudClcbiAgICAgICAgICAgIGFkZC5wdXNoKGN1cik7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZGQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBzdGFjayA9IHsgbm9kZTogYWRkW2ldLCBuZXh0OiBzdGFjayB9O1xuICAgIH1cbiAgICByZXR1cm4gaW5kZW50Rm9yKHN0YWNrLCBjeCwgcG9zKTtcbn1cbmZ1bmN0aW9uIGluZGVudEZvcihzdGFjaywgY3gsIHBvcykge1xuICAgIGZvciAobGV0IGN1ciA9IHN0YWNrOyBjdXI7IGN1ciA9IGN1ci5uZXh0KSB7XG4gICAgICAgIGxldCBzdHJhdGVneSA9IGluZGVudFN0cmF0ZWd5KGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKHN0cmF0ZWd5KVxuICAgICAgICAgICAgcmV0dXJuIHN0cmF0ZWd5KFRyZWVJbmRlbnRDb250ZXh0LmNyZWF0ZShjeCwgcG9zLCBjdXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpZ25vcmVDbG9zZWQoY3gpIHtcbiAgICByZXR1cm4gY3gucG9zID09IGN4Lm9wdGlvbnMuc2ltdWxhdGVCcmVhayAmJiBjeC5vcHRpb25zLnNpbXVsYXRlRG91YmxlQnJlYWs7XG59XG5mdW5jdGlvbiBpbmRlbnRTdHJhdGVneSh0cmVlKSB7XG4gICAgbGV0IHN0cmF0ZWd5ID0gdHJlZS50eXBlLnByb3AoaW5kZW50Tm9kZVByb3ApO1xuICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5O1xuICAgIGxldCBmaXJzdCA9IHRyZWUuZmlyc3RDaGlsZCwgY2xvc2U7XG4gICAgaWYgKGZpcnN0ICYmIChjbG9zZSA9IGZpcnN0LnR5cGUucHJvcChjb21tb24uTm9kZVByb3AuY2xvc2VkQnkpKSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRyZWUubGFzdENoaWxkLCBjbG9zZWQgPSBsYXN0ICYmIGNsb3NlLmluZGV4T2YobGFzdC5uYW1lKSA+IC0xO1xuICAgICAgICByZXR1cm4gY3ggPT4gZGVsaW1pdGVkU3RyYXRlZ3koY3gsIHRydWUsIDEsIHVuZGVmaW5lZCwgY2xvc2VkICYmICFpZ25vcmVDbG9zZWQoY3gpID8gbGFzdC5mcm9tIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ID09IG51bGwgPyB0b3BJbmRlbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gdG9wSW5kZW50KCkgeyByZXR1cm4gMDsgfVxuLyoqXG5PYmplY3RzIG9mIHRoaXMgdHlwZSBwcm92aWRlIGNvbnRleHQgaW5mb3JtYXRpb24gYW5kIGhlbHBlclxubWV0aG9kcyB0byBpbmRlbnRhdGlvbiBmdW5jdGlvbnMgcmVnaXN0ZXJlZCBvbiBzeW50YXggbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUluZGVudENvbnRleHQgZXh0ZW5kcyBJbmRlbnRDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggaW5kZW50YXRpb24gaXMgYmVpbmcgY29tcHV0ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29udGV4dCkge1xuICAgICAgICBzdXBlcihiYXNlLnN0YXRlLCBiYXNlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN5bnRheCB0cmVlIG5vZGUgdG8gd2hpY2ggdGhlIGluZGVudGF0aW9uIHN0cmF0ZWd5XG4gICAgYXBwbGllcy5cbiAgICAqL1xuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0Lm5vZGU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoYmFzZSwgcG9zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUluZGVudENvbnRleHQoYmFzZSwgcG9zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGB0aGlzLnBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICBnZXQgdGV4dEFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QWZ0ZXJQb3ModGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGF0IHRoZSByZWZlcmVuY2UgbGluZSBmb3IgYHRoaXMubm9kZWAsIHdoaWNoXG4gICAgaXMgdGhlIGxpbmUgb24gd2hpY2ggaXQgc3RhcnRzLCB1bmxlc3MgdGhlcmUgaXMgYSBub2RlIHRoYXQgaXNcbiAgICBfbm90XyBhIHBhcmVudCBvZiB0aGlzIG5vZGUgY292ZXJpbmcgdGhlIHN0YXJ0IG9mIHRoYXQgbGluZS4gSWZcbiAgICBzbywgdGhlIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHRoYXQgbm9kZSBpcyB0cmllZCwgYWdhaW4gc2tpcHBpbmdcbiAgICBvbiBpZiBpdCBpcyBjb3ZlcmVkIGJ5IGFub3RoZXIgc3VjaCBub2RlLlxuICAgICovXG4gICAgZ2V0IGJhc2VJbmRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VJbmRlbnRGb3IodGhpcy5ub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBmb3IgdGhlIHJlZmVyZW5jZSBsaW5lIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgKHNlZSBbYGJhc2VJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlRyZWVJbmRlbnRDb250ZXh0LmJhc2VJbmRlbnQpKS5cbiAgICAqL1xuICAgIGJhc2VJbmRlbnRGb3Iobm9kZSkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChub2RlLmZyb20pO1xuICAgICAgICAvLyBTa2lwIGxpbmUgc3RhcnRzIHRoYXQgYXJlIGNvdmVyZWQgYnkgYSBzaWJsaW5nIChvciBjb3VzaW4sIGV0YylcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGF0QnJlYWsgPSBub2RlLnJlc29sdmUobGluZS5mcm9tKTtcbiAgICAgICAgICAgIHdoaWxlIChhdEJyZWFrLnBhcmVudCAmJiBhdEJyZWFrLnBhcmVudC5mcm9tID09IGF0QnJlYWsuZnJvbSlcbiAgICAgICAgICAgICAgICBhdEJyZWFrID0gYXRCcmVhay5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQoYXRCcmVhaywgbm9kZSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KGF0QnJlYWsuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUluZGVudChsaW5lLmZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBDb250aW51ZSBsb29raW5nIGZvciBpbmRlbnRhdGlvbnMgaW4gdGhlIG5vZGUncyBwYXJlbnQgbm9kZXMsXG4gICAgYW5kIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoYXQuXG4gICAgKi9cbiAgICBjb250aW51ZSgpIHtcbiAgICAgICAgcmV0dXJuIGluZGVudEZvcih0aGlzLmNvbnRleHQubmV4dCwgdGhpcy5iYXNlLCB0aGlzLnBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQYXJlbnQocGFyZW50LCBvZikge1xuICAgIGZvciAobGV0IGN1ciA9IG9mOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgIGlmIChwYXJlbnQgPT0gY3VyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ2hlY2sgd2hldGhlciBhIGRlbGltaXRlZCBub2RlIGlzIGFsaWduZWQgKG1lYW5pbmcgdGhlcmUgYXJlXG4vLyBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBvcGVuaW5nIGRlbGltaXRlcikuIEFuZFxuLy8gaWYgc28sIHJldHVybiB0aGUgb3BlbmluZyB0b2tlbi5cbmZ1bmN0aW9uIGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkge1xuICAgIGxldCB0cmVlID0gY29udGV4dC5ub2RlO1xuICAgIGxldCBvcGVuVG9rZW4gPSB0cmVlLmNoaWxkQWZ0ZXIodHJlZS5mcm9tKSwgbGFzdCA9IHRyZWUubGFzdENoaWxkO1xuICAgIGlmICghb3BlblRva2VuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2ltID0gY29udGV4dC5vcHRpb25zLnNpbXVsYXRlQnJlYWs7XG4gICAgbGV0IG9wZW5MaW5lID0gY29udGV4dC5zdGF0ZS5kb2MubGluZUF0KG9wZW5Ub2tlbi5mcm9tKTtcbiAgICBsZXQgbGluZUVuZCA9IHNpbSA9PSBudWxsIHx8IHNpbSA8PSBvcGVuTGluZS5mcm9tID8gb3BlbkxpbmUudG8gOiBNYXRoLm1pbihvcGVuTGluZS50bywgc2ltKTtcbiAgICBmb3IgKGxldCBwb3MgPSBvcGVuVG9rZW4udG87Oykge1xuICAgICAgICBsZXQgbmV4dCA9IHRyZWUuY2hpbGRBZnRlcihwb3MpO1xuICAgICAgICBpZiAoIW5leHQgfHwgbmV4dCA9PSBsYXN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghbmV4dC50eXBlLmlzU2tpcHBlZCkge1xuICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA+PSBsaW5lRW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHNwYWNlID0gL14gKi8uZXhlYyhvcGVuTGluZS50ZXh0LnNsaWNlKG9wZW5Ub2tlbi50byAtIG9wZW5MaW5lLmZyb20pKVswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBvcGVuVG9rZW4uZnJvbSwgdG86IG9wZW5Ub2tlbi50byArIHNwYWNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbmV4dC50bztcbiAgICB9XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IGZvciBkZWxpbWl0ZWQgKHVzdWFsbHkgYnJhY2tldGVkKSBub2Rlcy5cbldpbGwsIGJ5IGRlZmF1bHQsIGluZGVudCBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIHBhcmVudCdzIGJhc2VcbmluZGVudCB1bmxlc3MgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSBjbG9zaW5nIHRva2VuLiBXaGVuIGBhbGlnbmBcbmlzIHRydWUgYW5kIHRoZXJlIGFyZSBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgbm9kZSdzIG9wZW5pbmdcbmxpbmUsIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIHdpbGwgYmUgYWxpZ25lZCB3aXRoIHRoZSBlbmQgb2YgdGhlXG5vcGVuaW5nIG5vZGUsIGxpa2UgdGhpczpcblxuICAgIGZvbyhiYXIsXG4gICAgICAgIGJheilcbiovXG5mdW5jdGlvbiBkZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nLCBhbGlnbiA9IHRydWUsIHVuaXRzID0gMSB9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcpO1xufVxuZnVuY3Rpb24gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nLCBjbG9zZWRBdCkge1xuICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBzcGFjZSA9IGFmdGVyLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VkID0gY2xvc2luZyAmJiBhZnRlci5zbGljZShzcGFjZSwgc3BhY2UgKyBjbG9zaW5nLmxlbmd0aCkgPT0gY2xvc2luZyB8fCBjbG9zZWRBdCA9PSBjb250ZXh0LnBvcyArIHNwYWNlO1xuICAgIGxldCBhbGlnbmVkID0gYWxpZ24gPyBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIDogbnVsbDtcbiAgICBpZiAoYWxpZ25lZClcbiAgICAgICAgcmV0dXJuIGNsb3NlZCA/IGNvbnRleHQuY29sdW1uKGFsaWduZWQuZnJvbSkgOiBjb250ZXh0LmNvbHVtbihhbGlnbmVkLnRvKTtcbiAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQgKiB1bml0cyk7XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQgYWxpZ25zIGEgbm9kZSdzIGNvbnRlbnQgdG8gaXRzIGJhc2VcbmluZGVudGF0aW9uLlxuKi9cbmNvbnN0IGZsYXRJbmRlbnQgPSAoY29udGV4dCkgPT4gY29udGV4dC5iYXNlSW5kZW50O1xuLyoqXG5DcmVhdGVzIGFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQsIGJ5IGRlZmF1bHQsIGluZGVudHNcbmNvbnRpbnVlZCBsaW5lcyBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIG5vZGUncyBiYXNlIGluZGVudGF0aW9uLlxuWW91IGNhbiBwcm92aWRlIGBleGNlcHRgIHRvIHByZXZlbnQgaW5kZW50YXRpb24gb2YgbGluZXMgdGhhdFxubWF0Y2ggYSBwYXR0ZXJuIChmb3IgZXhhbXBsZSBgL15lbHNlXFxiL2AgaW4gYGlmYC9gZWxzZWBcbmNvbnN0cnVjdHMpLCBhbmQgeW91IGNhbiBjaGFuZ2UgdGhlIGFtb3VudCBvZiB1bml0cyB1c2VkIHdpdGggdGhlXG5gdW5pdHNgIG9wdGlvbi5cbiovXG5mdW5jdGlvbiBjb250aW51ZWRJbmRlbnQoeyBleGNlcHQsIHVuaXRzID0gMSB9ID0ge30pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoRXhjZXB0ID0gZXhjZXB0ICYmIGV4Y2VwdC50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChtYXRjaEV4Y2VwdCA/IDAgOiB1bml0cyAqIGNvbnRleHQudW5pdCk7XG4gICAgfTtcbn1cbmNvbnN0IERvbnRJbmRlbnRCZXlvbmQgPSAyMDA7XG4vKipcbkVuYWJsZXMgcmVpbmRlbnRhdGlvbiBvbiBpbnB1dC4gV2hlbiBhIGxhbmd1YWdlIGRlZmluZXMgYW5cbmBpbmRlbnRPbklucHV0YCBmaWVsZCBpbiBpdHMgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSwgd2hpY2ggbXVzdCBob2xkIGEgcmVndWxhclxuZXhwcmVzc2lvbiwgdGhlIGxpbmUgYXQgdGhlIGN1cnNvciB3aWxsIGJlIHJlaW5kZW50ZWQgd2hlbmV2ZXIgbmV3XG50ZXh0IGlzIHR5cGVkIGFuZCB0aGUgaW5wdXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdXAgdG8gdGhlXG5jdXJzb3IgbWF0Y2hlcyB0aGF0IHJlZ2V4cC5cblxuVG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVpbmRlbnRzLCBpdCBpcyByZWNvbW1lbmRlZCB0byBzdGFydCB0aGVcbnJlZ2V4cCB3aXRoIGBeYCAodXN1YWxseSBmb2xsb3dlZCBieSBgXFxzKmApLCBhbmQgZW5kIGl0IHdpdGggYCRgLlxuRm9yIGV4YW1wbGUsIGAvXlxccypcXH0kL2Agd2lsbCByZWluZGVudCB3aGVuIGEgY2xvc2luZyBicmFjZSBpc1xuYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRPbklucHV0KCkge1xuICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlci5vZih0ciA9PiB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCB8fCAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmICF0ci5pc1VzZXJFdmVudChcImlucHV0LmNvbXBsZXRlXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgcnVsZXMgPSB0ci5zdGFydFN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiaW5kZW50T25JbnB1dFwiLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGRvYyA9IHRyLm5ld0RvYywgeyBoZWFkIH0gPSB0ci5uZXdTZWxlY3Rpb24ubWFpbiwgbGluZSA9IGRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgIGlmIChoZWFkID4gbGluZS5mcm9tICsgRG9udEluZGVudEJleW9uZClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGRvYy5zbGljZVN0cmluZyhsaW5lLmZyb20sIGhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLnNvbWUociA9PiByLnRlc3QobGluZVN0YXJ0KSkpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgbGFzdCA9IC0xLCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgICAgIGlmIChjdXIgIT0gbm9ybSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXMubGVuZ3RoID8gW3RyLCB7IGNoYW5nZXMsIHNlcXVlbnRpYWw6IHRydWUgfV0gOiB0cjtcbiAgICB9KTtcbn1cblxuLyoqXG5BIGZhY2V0IHRoYXQgcmVnaXN0ZXJzIGEgY29kZSBmb2xkaW5nIHNlcnZpY2UuIFdoZW4gY2FsbGVkIHdpdGhcbnRoZSBleHRlbnQgb2YgYSBsaW5lLCBzdWNoIGEgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZvbGRhYmxlXG5yYW5nZSB0aGF0IHN0YXJ0cyBvbiB0aGF0IGxpbmUgKGJ1dCBjb250aW51ZXMgYmV5b25kIGl0KSwgaWYgb25lXG5jYW4gYmUgZm91bmQuXG4qL1xuY29uc3QgZm9sZFNlcnZpY2UgPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbi8qKlxuVGhpcyBub2RlIHByb3AgaXMgdXNlZCB0byBhc3NvY2lhdGUgZm9sZGluZyBpbmZvcm1hdGlvbiB3aXRoXG5zeW50YXggbm9kZSB0eXBlcy4gR2l2ZW4gYSBzeW50YXggbm9kZSwgaXQgc2hvdWxkIGNoZWNrIHdoZXRoZXJcbnRoYXQgdHJlZSBpcyBmb2xkYWJsZSBhbmQgcmV0dXJuIHRoZSByYW5nZSB0aGF0IGNhbiBiZSBjb2xsYXBzZWRcbndoZW4gaXQgaXMuXG4qL1xuY29uc3QgZm9sZE5vZGVQcm9wID0gbmV3IGNvbW1vbi5Ob2RlUHJvcCgpO1xuLyoqXG5bRm9sZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkTm9kZVByb3ApIGZ1bmN0aW9uIHRoYXQgZm9sZHMgZXZlcnl0aGluZyBidXRcbnRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgY2hpbGQgb2YgYSBzeW50YXggbm9kZS4gVXNlZnVsIGZvciBub2Rlc1xudGhhdCBzdGFydCBhbmQgZW5kIHdpdGggZGVsaW1pdGVycy5cbiovXG5mdW5jdGlvbiBmb2xkSW5zaWRlKG5vZGUpIHtcbiAgICBsZXQgZmlyc3QgPSBub2RlLmZpcnN0Q2hpbGQsIGxhc3QgPSBub2RlLmxhc3RDaGlsZDtcbiAgICByZXR1cm4gZmlyc3QgJiYgZmlyc3QudG8gPCBsYXN0LmZyb20gPyB7IGZyb206IGZpcnN0LnRvLCB0bzogbGFzdC50eXBlLmlzRXJyb3IgPyBub2RlLnRvIDogbGFzdC5mcm9tIH0gOiBudWxsO1xufVxuZnVuY3Rpb24gc3ludGF4Rm9sZGluZyhzdGF0ZSwgc3RhcnQsIGVuZCkge1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSk7XG4gICAgaWYgKHRyZWUubGVuZ3RoIDwgZW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc3RhY2sgPSB0cmVlLnJlc29sdmVTdGFjayhlbmQsIDEpO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgZm9yIChsZXQgaXRlciA9IHN0YWNrOyBpdGVyOyBpdGVyID0gaXRlci5uZXh0KSB7XG4gICAgICAgIGxldCBjdXIgPSBpdGVyLm5vZGU7XG4gICAgICAgIGlmIChjdXIudG8gPD0gZW5kIHx8IGN1ci5mcm9tID4gZW5kKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChmb3VuZCAmJiBjdXIuZnJvbSA8IHN0YXJ0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBwcm9wID0gY3VyLnR5cGUucHJvcChmb2xkTm9kZVByb3ApO1xuICAgICAgICBpZiAocHJvcCAmJiAoY3VyLnRvIDwgdHJlZS5sZW5ndGggLSA1MCB8fCB0cmVlLmxlbmd0aCA9PSBzdGF0ZS5kb2MubGVuZ3RoIHx8ICFpc1VuZmluaXNoZWQoY3VyKSkpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3AoY3VyLCBzdGF0ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuZnJvbSA8PSBlbmQgJiYgdmFsdWUuZnJvbSA+PSBzdGFydCAmJiB2YWx1ZS50byA+IGVuZClcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGlzVW5maW5pc2hlZChub2RlKSB7XG4gICAgbGV0IGNoID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGNoICYmIGNoLnRvID09IG5vZGUudG8gJiYgY2gudHlwZS5pc0Vycm9yO1xufVxuLyoqXG5DaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBsaW5lIGlzIGZvbGRhYmxlLiBGaXJzdCBhc2tzIGFueSBmb2xkXG5zZXJ2aWNlcyByZWdpc3RlcmVkIHRocm91Z2hcbltgZm9sZFNlcnZpY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRTZXJ2aWNlKSwgYW5kIGlmIG5vbmUgb2YgdGhlbSByZXR1cm5cbmEgcmVzdWx0LCB0cmllcyB0byBxdWVyeSB0aGUgW2ZvbGQgbm9kZVxucHJvcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkTm9kZVByb3ApIG9mIHN5bnRheCBub2RlcyB0aGF0IGNvdmVyIHRoZSBlbmRcbm9mIHRoZSBsaW5lLlxuKi9cbmZ1bmN0aW9uIGZvbGRhYmxlKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpIHtcbiAgICBmb3IgKGxldCBzZXJ2aWNlIG9mIHN0YXRlLmZhY2V0KGZvbGRTZXJ2aWNlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBzeW50YXhGb2xkaW5nKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpO1xufVxuZnVuY3Rpb24gbWFwUmFuZ2UocmFuZ2UsIG1hcHBpbmcpIHtcbiAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUG9zKHJhbmdlLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUG9zKHJhbmdlLnRvLCAtMSk7XG4gICAgcmV0dXJuIGZyb20gPj0gdG8gPyB1bmRlZmluZWQgOiB7IGZyb20sIHRvIH07XG59XG4vKipcblN0YXRlIGVmZmVjdCB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRvIGZvbGQgdGhlXG5naXZlbiByYW5nZS4gKFlvdSBwcm9iYWJseSBvbmx5IG5lZWQgdGhpcyBpbiBleGNlcHRpb25hbFxuY2lyY3Vtc3RhbmNlc+KAlHVzdWFsbHkgeW91J2xsIGp1c3Qgd2FudCB0byBsZXRcbltgZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRDb2RlKSBhbmQgdGhlIFtmb2xkXG5ndXR0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEd1dHRlcikgY3JlYXRlIHRoZSB0cmFuc2FjdGlvbnMuKVxuKi9cbmNvbnN0IGZvbGRFZmZlY3QgPSBzdGF0ZS5TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6IG1hcFJhbmdlIH0pO1xuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCB1bmZvbGRzIHRoZSBnaXZlbiByYW5nZSAoaWYgaXQgd2FzIGZvbGRlZCkuXG4qL1xuY29uc3QgdW5mb2xkRWZmZWN0ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiBtYXBSYW5nZSB9KTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZXModmlldykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBpZiAobGluZXMuc29tZShsID0+IGwuZnJvbSA8PSBoZWFkICYmIGwudG8gPj0gaGVhZCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGluZXMucHVzaCh2aWV3LmxpbmVCbG9ja0F0KGhlYWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdGhhdCBzdG9yZXMgdGhlIGZvbGRlZCByYW5nZXMgKGFzIGEgW2RlY29yYXRpb25cbnNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpKS4gQ2FuIGJlIHBhc3NlZCB0b1xuW2BFZGl0b3JTdGF0ZS50b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgYW5kXG5bYGZyb21KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgdG8gc2VyaWFsaXplIHRoZSBmb2xkXG5zdGF0ZS5cbiovXG5jb25zdCBmb2xkU3RhdGUgPSBzdGF0ZS5TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdmlldy5EZWNvcmF0aW9uLm5vbmU7XG4gICAgfSxcbiAgICB1cGRhdGUoZm9sZGVkLCB0cikge1xuICAgICAgICBmb2xkZWQgPSBmb2xkZWQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlLmlzKGZvbGRFZmZlY3QpICYmICFmb2xkRXhpc3RzKGZvbGRlZCwgZS52YWx1ZS5mcm9tLCBlLnZhbHVlLnRvKSkge1xuICAgICAgICAgICAgICAgIGxldCB7IHByZXBhcmVQbGFjZWhvbGRlciB9ID0gdHIuc3RhdGUuZmFjZXQoZm9sZENvbmZpZyk7XG4gICAgICAgICAgICAgICAgbGV0IHdpZGdldCA9ICFwcmVwYXJlUGxhY2Vob2xkZXIgPyBmb2xkV2lkZ2V0IDpcbiAgICAgICAgICAgICAgICAgICAgdmlldy5EZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBQcmVwYXJlZEZvbGRXaWRnZXQocHJlcGFyZVBsYWNlaG9sZGVyKHRyLnN0YXRlLCBlLnZhbHVlKSkgfSk7XG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGFkZDogW3dpZGdldC5yYW5nZShlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUuaXModW5mb2xkRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoeyBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZS52YWx1ZS5mcm9tICE9IGZyb20gfHwgZS52YWx1ZS50byAhPSB0byxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJvbTogZS52YWx1ZS5mcm9tLCBmaWx0ZXJUbzogZS52YWx1ZS50byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBmb2xkZWQgcmFuZ2VzIHRoYXQgY292ZXIgdGhlIHNlbGVjdGlvbiBoZWFkXG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBvblNlbGVjdGlvbiA9IGZhbHNlLCB7IGhlYWQgfSA9IHRyLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgZm9sZGVkLmJldHdlZW4oaGVhZCwgaGVhZCwgKGEsIGIpID0+IHsgaWYgKGEgPCBoZWFkICYmIGIgPiBoZWFkKVxuICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICBpZiAob25TZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGhlYWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRvOiBoZWFkLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IChhLCBiKSA9PiBiIDw9IGhlYWQgfHwgYSA+PSBoZWFkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRlZDtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gdmlldy5FZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiksXG4gICAgdG9KU09OKGZvbGRlZCwgc3RhdGUpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb2xkZWQuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHsgcmFuZ2VzLnB1c2goZnJvbSwgdG8pOyB9KTtcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9LFxuICAgIGZyb21KU09OKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoICUgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIGZvciBmb2xkIHN0YXRlXCIpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSB2YWx1ZVtpKytdLCB0byA9IHZhbHVlW2krK107XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiBmb3IgZm9sZCBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGZvbGRXaWRnZXQucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlldy5EZWNvcmF0aW9uLnNldChyYW5nZXMsIHRydWUpO1xuICAgIH1cbn0pO1xuLyoqXG5HZXQgYSBbcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0KSBjb250YWluaW5nIHRoZSBmb2xkZWQgcmFuZ2VzXG5pbiB0aGUgZ2l2ZW4gc3RhdGUuXG4qL1xuZnVuY3Rpb24gZm9sZGVkUmFuZ2VzKHN0YXRlJDEpIHtcbiAgICByZXR1cm4gc3RhdGUkMS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fCBzdGF0ZS5SYW5nZVNldC5lbXB0eTtcbn1cbmZ1bmN0aW9uIGZpbmRGb2xkKHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIChfYSA9IHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmV0d2Vlbihmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGlmICghZm91bmQgfHwgZm91bmQuZnJvbSA+IGZyb20pXG4gICAgICAgICAgICBmb3VuZCA9IHsgZnJvbSwgdG8gfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBmb2xkRXhpc3RzKGZvbGRlZCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBmb2xkZWQuYmV0d2Vlbihmcm9tLCBmcm9tLCAoYSwgYikgPT4geyBpZiAoYSA9PSBmcm9tICYmIGIgPT0gdG8pXG4gICAgICAgIGZvdW5kID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gbWF5YmVFbmFibGUoc3RhdGUkMSwgb3RoZXIpIHtcbiAgICByZXR1cm4gc3RhdGUkMS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSA/IG90aGVyIDogb3RoZXIuY29uY2F0KHN0YXRlLlN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihjb2RlRm9sZGluZygpKSk7XG59XG4vKipcbkZvbGQgdGhlIGxpbmVzIHRoYXQgYXJlIHNlbGVjdGVkLCBpZiBwb3NzaWJsZS5cbiovXG5jb25zdCBmb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBbZm9sZEVmZmVjdC5vZihyYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSldKSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcblVuZm9sZCBmb2xkZWQgcmFuZ2VzIG9uIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IHVuZm9sZENvZGUgPSB2aWV3ID0+IHtcbiAgICBpZiAoIXZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRlZCwgZmFsc2UpKTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGggPiAwO1xufTtcbmZ1bmN0aW9uIGFubm91bmNlRm9sZCh2aWV3JDEsIHJhbmdlLCBmb2xkID0gdHJ1ZSkge1xuICAgIGxldCBsaW5lRnJvbSA9IHZpZXckMS5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLm51bWJlciwgbGluZVRvID0gdmlldyQxLnN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8pLm51bWJlcjtcbiAgICByZXR1cm4gdmlldy5FZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXckMS5zdGF0ZS5waHJhc2UoZm9sZCA/IFwiRm9sZGVkIGxpbmVzXCIgOiBcIlVuZm9sZGVkIGxpbmVzXCIpfSAke2xpbmVGcm9tfSAke3ZpZXckMS5zdGF0ZS5waHJhc2UoXCJ0b1wiKX0gJHtsaW5lVG99LmApO1xufVxuLyoqXG5Gb2xkIGFsbCB0b3AtbGV2ZWwgZm9sZGFibGUgcmFuZ2VzLiBOb3RlIHRoYXQsIGluIG1vc3QgY2FzZXMsXG5mb2xkaW5nIGluZm9ybWF0aW9uIHdpbGwgZGVwZW5kIG9uIHRoZSBbc3ludGF4XG50cmVlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFRyZWUpLCBhbmQgZm9sZGluZyBldmVyeXRoaW5nIG1heSBub3Qgd29ya1xucmVsaWFibHkgd2hlbiB0aGUgZG9jdW1lbnQgaGFzbid0IGJlZW4gZnVsbHkgcGFyc2VkIChlaXRoZXJcbmJlY2F1c2UgdGhlIGVkaXRvciBzdGF0ZSB3YXMgb25seSBqdXN0IGluaXRpYWxpemVkLCBvciBiZWNhdXNlIHRoZVxuZG9jdW1lbnQgaXMgc28gYmlnIHRoYXQgdGhlIHBhcnNlciBkZWNpZGVkIG5vdCB0byBwYXJzZSBpdFxuZW50aXJlbHkpLlxuKi9cbmNvbnN0IGZvbGRBbGwgPSB2aWV3ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHN0YXRlLmRvYy5sZW5ndGg7KSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpLCByYW5nZSA9IGZvbGRhYmxlKHN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihyYW5nZSkpO1xuICAgICAgICBwb3MgPSAocmFuZ2UgPyB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLnRvKSA6IGxpbmUpLnRvICsgMTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgZWZmZWN0cykgfSk7XG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XG59O1xuLyoqXG5VbmZvbGQgYWxsIGZvbGRlZCBjb2RlLlxuKi9cbmNvbnN0IHVuZm9sZEFsbCA9IHZpZXcgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZCB8fCAhZmllbGQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZmllbGQuYmV0d2VlbigwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4geyBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKHsgZnJvbSwgdG8gfSkpOyB9KTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyBGaW5kIHRoZSBmb2xkYWJsZSByZWdpb24gY29udGFpbmluZyB0aGUgZ2l2ZW4gbGluZSwgaWYgb25lIGV4aXN0c1xuZnVuY3Rpb24gZm9sZGFibGVDb250YWluZXIodmlldywgbGluZUJsb2NrKSB7XG4gICAgLy8gTG9vayBiYWNrd2FyZHMgdGhyb3VnaCBsaW5lIGJsb2NrcyB1bnRpbCB3ZSBmaW5kIGEgZm9sZGFibGUgcmVnaW9uIHRoYXRcbiAgICAvLyBpbnRlcnNlY3RzIHdpdGggdGhlIGxpbmVcbiAgICBmb3IgKGxldCBsaW5lID0gbGluZUJsb2NrOzspIHtcbiAgICAgICAgbGV0IGZvbGRhYmxlUmVnaW9uID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRhYmxlUmVnaW9uICYmIGZvbGRhYmxlUmVnaW9uLnRvID4gbGluZUJsb2NrLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gZm9sZGFibGVSZWdpb247XG4gICAgICAgIGlmICghbGluZS5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KGxpbmUuZnJvbSAtIDEpO1xuICAgIH1cbn1cbi8qKlxuVG9nZ2xlIGZvbGRpbmcgYXQgY3Vyc29ycy4gVW5mb2xkcyBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBmb2xkXG5zdGFydGluZyBpbiB0aGF0IGxpbmUsIHRyaWVzIHRvIGZpbmQgYSBmb2xkYWJsZSByYW5nZSBhcm91bmQgaXRcbm90aGVyd2lzZS5cbiovXG5jb25zdCB0b2dnbGVGb2xkID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvbGRSYW5nZSA9IGZvbGRhYmxlQ29udGFpbmVyKHZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgaWYgKGZvbGRSYW5nZSlcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihmb2xkUmFuZ2UpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZFJhbmdlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoID4gMClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIGVmZmVjdHMpIH0pO1xuICAgIHJldHVybiAhIWVmZmVjdHMubGVuZ3RoO1xufTtcbi8qKlxuRGVmYXVsdCBmb2xkLXJlbGF0ZWQga2V5IGJpbmRpbmdzLlxuXG4gLSBDdHJsLVNoaWZ0LVsgKENtZC1BbHQtWyBvbiBtYWNPUyk6IFtgZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRDb2RlKS5cbiAtIEN0cmwtU2hpZnQtXSAoQ21kLUFsdC1dIG9uIG1hY09TKTogW2B1bmZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRDb2RlKS5cbiAtIEN0cmwtQWx0LVs6IFtgZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEFsbCkuXG4gLSBDdHJsLUFsdC1dOiBbYHVuZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UudW5mb2xkQWxsKS5cbiovXG5jb25zdCBmb2xkS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtW1wiLCBtYWM6IFwiQ21kLUFsdC1bXCIsIHJ1bjogZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLVNoaWZ0LV1cIiwgbWFjOiBcIkNtZC1BbHQtXVwiLCBydW46IHVuZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1bXCIsIHJ1bjogZm9sZEFsbCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LV1cIiwgcnVuOiB1bmZvbGRBbGwgfVxuXTtcbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgcGxhY2Vob2xkZXJET006IG51bGwsXG4gICAgcHJlcGFyZVBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyVGV4dDogXCLigKZcIlxufTtcbmNvbnN0IGZvbGRDb25maWcgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiBzdGF0ZS5jb21iaW5lQ29uZmlnKHZhbHVlcywgZGVmYXVsdENvbmZpZyk7IH1cbn0pO1xuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyBjb2RlIGZvbGRpbmcuXG4qL1xuZnVuY3Rpb24gY29kZUZvbGRpbmcoY29uZmlnKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtmb2xkU3RhdGUsIGJhc2VUaGVtZSQxXTtcbiAgICBpZiAoY29uZmlnKVxuICAgICAgICByZXN1bHQucHVzaChmb2xkQ29uZmlnLm9mKGNvbmZpZykpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3aWRnZXRUb0RPTSh2aWV3LCBwcmVwYXJlZCkge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoZm9sZENvbmZpZyk7XG4gICAgbGV0IG9uY2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHZpZXcucG9zQXRET00oZXZlbnQudGFyZ2V0KSk7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgaWYgKGNvbmYucGxhY2Vob2xkZXJET00pXG4gICAgICAgIHJldHVybiBjb25mLnBsYWNlaG9sZGVyRE9NKHZpZXcsIG9uY2xpY2ssIHByZXBhcmVkKTtcbiAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBjb25mLnBsYWNlaG9sZGVyVGV4dDtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc3RhdGUucGhyYXNlKFwiZm9sZGVkIGNvZGVcIikpO1xuICAgIGVsZW1lbnQudGl0bGUgPSBzdGF0ZS5waHJhc2UoXCJ1bmZvbGRcIik7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImNtLWZvbGRQbGFjZWhvbGRlclwiO1xuICAgIGVsZW1lbnQub25jbGljayA9IG9uY2xpY2s7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5jb25zdCBmb2xkV2lkZ2V0ID0gdmlldy5EZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBjbGFzcyBleHRlbmRzIHZpZXcuV2lkZ2V0VHlwZSB7XG4gICAgICAgIHRvRE9NKHZpZXcpIHsgcmV0dXJuIHdpZGdldFRvRE9NKHZpZXcsIG51bGwpOyB9XG4gICAgfSB9KTtcbmNsYXNzIFByZXBhcmVkRm9sZFdpZGdldCBleHRlbmRzIHZpZXcuV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy52YWx1ZSA9PSBvdGhlci52YWx1ZTsgfVxuICAgIHRvRE9NKHZpZXcpIHsgcmV0dXJuIHdpZGdldFRvRE9NKHZpZXcsIHRoaXMudmFsdWUpOyB9XG59XG5jb25zdCBmb2xkR3V0dGVyRGVmYXVsdHMgPSB7XG4gICAgb3BlblRleHQ6IFwi4oyEXCIsXG4gICAgY2xvc2VkVGV4dDogXCLigLpcIixcbiAgICBtYXJrZXJET006IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge30sXG4gICAgZm9sZGluZ0NoYW5nZWQ6ICgpID0+IGZhbHNlXG59O1xuY2xhc3MgRm9sZE1hcmtlciBleHRlbmRzIHZpZXcuR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIG9wZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNvbmZpZyA9PSBvdGhlci5jb25maWcgJiYgdGhpcy5vcGVuID09IG90aGVyLm9wZW47IH1cbiAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXJrZXJET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubWFya2VyRE9NKHRoaXMub3Blbik7XG4gICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0aGlzLm9wZW4gPyB0aGlzLmNvbmZpZy5vcGVuVGV4dCA6IHRoaXMuY29uZmlnLmNsb3NlZFRleHQ7XG4gICAgICAgIHNwYW4udGl0bGUgPSB2aWV3LnN0YXRlLnBocmFzZSh0aGlzLm9wZW4gPyBcIkZvbGQgbGluZVwiIDogXCJVbmZvbGQgbGluZVwiKTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgcmVnaXN0ZXJzIGEgZm9sZCBndXR0ZXIsIHdoaWNoIHNob3dzIGFcbmZvbGQgc3RhdHVzIGluZGljYXRvciBiZWZvcmUgZm9sZGFibGUgbGluZXMgKHdoaWNoIGNhbiBiZSBjbGlja2VkXG50byBmb2xkIG9yIHVuZm9sZCB0aGUgbGluZSkuXG4qL1xuZnVuY3Rpb24gZm9sZEd1dHRlcihjb25maWcgPSB7fSkge1xuICAgIGxldCBmdWxsQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb2xkR3V0dGVyRGVmYXVsdHMpLCBjb25maWcpO1xuICAgIGxldCBjYW5Gb2xkID0gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgdHJ1ZSksIGNhblVuZm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIGZhbHNlKTtcbiAgICBsZXQgbWFya2VycyA9IHZpZXcuVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB2aWV3LnZpZXdwb3J0LmZyb207XG4gICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmJ1aWxkTWFya2Vycyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgIHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxhbmd1YWdlKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGFuZ3VhZ2UpIHx8XG4gICAgICAgICAgICAgICAgdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgIT0gdXBkYXRlLnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpIHx8XG4gICAgICAgICAgICAgICAgc3ludGF4VHJlZSh1cGRhdGUuc3RhcnRTdGF0ZSkgIT0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpIHx8XG4gICAgICAgICAgICAgICAgZnVsbENvbmZpZy5mb2xkaW5nQ2hhbmdlZCh1cGRhdGUpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VycyA9IHRoaXMuYnVpbGRNYXJrZXJzKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZE1hcmtlcnModmlldykge1xuICAgICAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgc3RhdGUuUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHZpZXcudmlld3BvcnRMaW5lQmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmsgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pID8gY2FuVW5mb2xkXG4gICAgICAgICAgICAgICAgICAgIDogZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKSA/IGNhbkZvbGQgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrKVxuICAgICAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChsaW5lLmZyb20sIGxpbmUuZnJvbSwgbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCB7IGRvbUV2ZW50SGFuZGxlcnMgfSA9IGZ1bGxDb25maWc7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbWFya2VycyxcbiAgICAgICAgdmlldy5ndXR0ZXIoe1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZm9sZEd1dHRlclwiLFxuICAgICAgICAgICAgbWFya2Vycyh2aWV3KSB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihtYXJrZXJzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcmtlcnMpIHx8IHN0YXRlLlJhbmdlU2V0LmVtcHR5OyB9LFxuICAgICAgICAgICAgaW5pdGlhbFNwYWNlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbUV2ZW50SGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZG9tRXZlbnRIYW5kbGVycyksIHsgY2xpY2s6ICh2aWV3LCBsaW5lLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnRIYW5kbGVycy5jbGljayAmJiBkb21FdmVudEhhbmRsZXJzLmNsaWNrKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZm9sZEVmZmVjdC5vZihyYW5nZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSB9KVxuICAgICAgICB9KSxcbiAgICAgICAgY29kZUZvbGRpbmcoKVxuICAgIF07XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IHZpZXcuRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWZvbGRQbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZWVlXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2RkZFwiLFxuICAgICAgICBjb2xvcjogXCIjODg4XCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIuMmVtXCIsXG4gICAgICAgIG1hcmdpbjogXCIwIDFweFwiLFxuICAgICAgICBwYWRkaW5nOiBcIjAgMXB4XCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLWZvbGRHdXR0ZXIgc3BhblwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH1cbn0pO1xuXG4vKipcbkEgaGlnaGxpZ2h0IHN0eWxlIGFzc29jaWF0ZXMgQ1NTIHN0eWxlcyB3aXRoIGhpZ2xpZ2h0aW5nXG5bdGFnc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNoaWdobGlnaHQuVGFnKS5cbiovXG5jbGFzcyBIaWdobGlnaHRTdHlsZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHRhZyBzdHlsZXMgdXNlZCB0byBjcmVhdGUgdGhpcyBoaWdobGlnaHQgc3R5bGUuXG4gICAgKi9cbiAgICBzcGVjcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgIGxldCBtb2RTcGVjO1xuICAgICAgICBmdW5jdGlvbiBkZWYoc3BlYykge1xuICAgICAgICAgICAgbGV0IGNscyA9IHN0eWxlTW9kLlN0eWxlTW9kdWxlLm5ld05hbWUoKTtcbiAgICAgICAgICAgIChtb2RTcGVjIHx8IChtb2RTcGVjID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpW1wiLlwiICsgY2xzXSA9IHNwZWM7XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbCA9IHR5cGVvZiBvcHRpb25zLmFsbCA9PSBcInN0cmluZ1wiID8gb3B0aW9ucy5hbGwgOiBvcHRpb25zLmFsbCA/IGRlZihvcHRpb25zLmFsbCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNjb3BlT3B0ID0gb3B0aW9ucy5zY29wZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlT3B0IGluc3RhbmNlb2YgTGFuZ3VhZ2UgPyAodHlwZSkgPT4gdHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHNjb3BlT3B0LmRhdGFcbiAgICAgICAgICAgIDogc2NvcGVPcHQgPyAodHlwZSkgPT4gdHlwZSA9PSBzY29wZU9wdCA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IGhpZ2hsaWdodC50YWdIaWdobGlnaHRlcihzcGVjcy5tYXAoc3R5bGUgPT4gKHtcbiAgICAgICAgICAgIHRhZzogc3R5bGUudGFnLFxuICAgICAgICAgICAgY2xhc3M6IHN0eWxlLmNsYXNzIHx8IGRlZihPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgeyB0YWc6IG51bGwgfSkpXG4gICAgICAgIH0pKSwge1xuICAgICAgICAgICAgYWxsLFxuICAgICAgICB9KS5zdHlsZTtcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2RTcGVjID8gbmV3IHN0eWxlTW9kLlN0eWxlTW9kdWxlKG1vZFNwZWMpIDogbnVsbDtcbiAgICAgICAgdGhpcy50aGVtZVR5cGUgPSBvcHRpb25zLnRoZW1lVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgaGlnaGxpZ2h0ZXIgc3R5bGUgdGhhdCBhc3NvY2lhdGVzIHRoZSBnaXZlbiBzdHlsZXMgdG9cbiAgICB0aGUgZ2l2ZW4gdGFncy4gVGhlIHNwZWNzIG11c3QgYmUgb2JqZWN0cyB0aGF0IGhvbGQgYSBzdHlsZSB0YWdcbiAgICBvciBhcnJheSBvZiB0YWdzIGluIHRoZWlyIGB0YWdgIHByb3BlcnR5LCBhbmQgZWl0aGVyIGEgc2luZ2xlXG4gICAgYGNsYXNzYCBwcm9wZXJ0eSBwcm92aWRpbmcgYSBzdGF0aWMgQ1NTIGNsYXNzIChmb3IgaGlnaGxpZ2h0ZXJcbiAgICB0aGF0IHJlbHkgb24gZXh0ZXJuYWwgc3R5bGluZyksIG9yIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKS1zdHlsZVxuICAgIHNldCBvZiBDU1MgcHJvcGVydGllcyAod2hpY2ggZGVmaW5lIHRoZSBzdHlsaW5nIGZvciB0aG9zZSB0YWdzKS5cbiAgICBcbiAgICBUaGUgQ1NTIHJ1bGVzIGNyZWF0ZWQgZm9yIGEgaGlnaGxpZ2h0ZXIgd2lsbCBiZSBlbWl0dGVkIGluIHRoZVxuICAgIG9yZGVyIG9mIHRoZSBzcGVjJ3MgcHJvcGVydGllcy4gVGhhdCBtZWFucyB0aGF0IGZvciBlbGVtZW50cyB0aGF0XG4gICAgaGF2ZSBtdWx0aXBsZSB0YWdzIGFzc29jaWF0ZWQgd2l0aCB0aGVtLCBzdHlsZXMgZGVmaW5lZCBmdXJ0aGVyXG4gICAgZG93biBpbiB0aGUgbGlzdCB3aWxsIGhhdmUgYSBoaWdoZXIgQ1NTIHByZWNlZGVuY2UgdGhhbiBzdHlsZXNcbiAgICBkZWZpbmVkIGVhcmxpZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0U3R5bGUoc3BlY3MsIG9wdGlvbnMgfHwge30pO1xuICAgIH1cbn1cbmNvbnN0IGhpZ2hsaWdodGVyRmFjZXQgPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGZhbGxiYWNrSGlnaGxpZ2h0ZXIgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiB2YWx1ZXMubGVuZ3RoID8gW3ZhbHVlc1swXV0gOiBudWxsOyB9XG59KTtcbmZ1bmN0aW9uIGdldEhpZ2hsaWdodGVycyhzdGF0ZSkge1xuICAgIGxldCBtYWluID0gc3RhdGUuZmFjZXQoaGlnaGxpZ2h0ZXJGYWNldCk7XG4gICAgcmV0dXJuIG1haW4ubGVuZ3RoID8gbWFpbiA6IHN0YXRlLmZhY2V0KGZhbGxiYWNrSGlnaGxpZ2h0ZXIpO1xufVxuLyoqXG5XcmFwIGEgaGlnaGxpZ2h0ZXIgaW4gYW4gZWRpdG9yIGV4dGVuc2lvbiB0aGF0IHVzZXMgaXQgdG8gYXBwbHlcbnN5bnRheCBoaWdobGlnaHRpbmcgdG8gdGhlIGVkaXRvciBjb250ZW50LlxuXG5XaGVuIG11bHRpcGxlIChub24tZmFsbGJhY2spIHN0eWxlcyBhcmUgcHJvdmlkZWQsIHRoZSBzdHlsaW5nXG5hcHBsaWVkIGlzIHRoZSB1bmlvbiBvZiB0aGUgY2xhc3NlcyB0aGV5IGVtaXQuXG4qL1xuZnVuY3Rpb24gc3ludGF4SGlnaGxpZ2h0aW5nKGhpZ2hsaWdodGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFt0cmVlSGlnaGxpZ2h0ZXJdLCB0aGVtZVR5cGU7XG4gICAgaWYgKGhpZ2hsaWdodGVyIGluc3RhbmNlb2YgSGlnaGxpZ2h0U3R5bGUpIHtcbiAgICAgICAgaWYgKGhpZ2hsaWdodGVyLm1vZHVsZSlcbiAgICAgICAgICAgIGV4dC5wdXNoKHZpZXcuRWRpdG9yVmlldy5zdHlsZU1vZHVsZS5vZihoaWdobGlnaHRlci5tb2R1bGUpKTtcbiAgICAgICAgdGhlbWVUeXBlID0gaGlnaGxpZ2h0ZXIudGhlbWVUeXBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrKVxuICAgICAgICBleHQucHVzaChmYWxsYmFja0hpZ2hsaWdodGVyLm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgZWxzZSBpZiAodGhlbWVUeXBlKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0LmNvbXB1dGVOKFt2aWV3LkVkaXRvclZpZXcuZGFya1RoZW1lXSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZhY2V0KHZpZXcuRWRpdG9yVmlldy5kYXJrVGhlbWUpID09ICh0aGVtZVR5cGUgPT0gXCJkYXJrXCIpID8gW2hpZ2hsaWdodGVyXSA6IFtdO1xuICAgICAgICB9KSk7XG4gICAgZWxzZVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0Lm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgQ1NTIGNsYXNzZXMgKGlmIGFueSkgdGhhdCB0aGUgaGlnaGxpZ2h0ZXJzIGFjdGl2ZSBpblxudGhlIHN0YXRlIHdvdWxkIGFzc2lnbiB0byB0aGUgZ2l2ZW4gc3R5bGVcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpIGFuZFxuKG9wdGlvbmFsKSBsYW5ndWFnZVxuW3Njb3BlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkhpZ2hsaWdodFN0eWxlXmRlZmluZV5vcHRpb25zLnNjb3BlKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRpbmdGb3Ioc3RhdGUsIHRhZ3MsIHNjb3BlKSB7XG4gICAgbGV0IGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyhzdGF0ZSk7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKGhpZ2hsaWdodGVycylcbiAgICAgICAgZm9yIChsZXQgaGlnaGxpZ2h0ZXIgb2YgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWhpZ2hsaWdodGVyLnNjb3BlIHx8IHNjb3BlICYmIGhpZ2hsaWdodGVyLnNjb3BlKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgIGxldCBjbHMgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPyByZXN1bHQgKyBcIiBcIiArIGNscyA6IGNscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBUcmVlSGlnaGxpZ2h0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5tYXJrQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRyZWUgPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odmlldywgZ2V0SGlnaGxpZ2h0ZXJzKHZpZXcuc3RhdGUpKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0ZWRUbyA9IHZpZXcudmlld3BvcnQudG87XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSksIGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyh1cGRhdGUuc3RhdGUpO1xuICAgICAgICBsZXQgc3R5bGVDaGFuZ2UgPSBoaWdobGlnaHRlcnMgIT0gZ2V0SGlnaGxpZ2h0ZXJzKHVwZGF0ZS5zdGFydFN0YXRlKTtcbiAgICAgICAgbGV0IHsgdmlld3BvcnQgfSA9IHVwZGF0ZS52aWV3LCBkZWNvcmF0ZWRUb01hcHBlZCA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLmRlY29yYXRlZFRvLCAxKTtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoIDwgdmlld3BvcnQudG8gJiYgIXN0eWxlQ2hhbmdlICYmIHRyZWUudHlwZSA9PSB0aGlzLnRyZWUudHlwZSAmJiBkZWNvcmF0ZWRUb01hcHBlZCA+PSB2aWV3cG9ydC50bykge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdGlvbnMubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGVkVG8gPSBkZWNvcmF0ZWRUb01hcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmVlICE9IHRoaXMudHJlZSB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IHN0eWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKHVwZGF0ZS52aWV3LCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZWRUbyA9IHZpZXdwb3J0LnRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkRGVjbyh2aWV3JDEsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBpZiAoIWhpZ2hsaWdodGVycyB8fCAhdGhpcy50cmVlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB2aWV3LkRlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgc3RhdGUuUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiB2aWV3JDEudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgaGlnaGxpZ2h0LmhpZ2hsaWdodFRyZWUodGhpcy50cmVlLCBoaWdobGlnaHRlcnMsIChmcm9tLCB0bywgc3R5bGUpID0+IHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgdGhpcy5tYXJrQ2FjaGVbc3R5bGVdIHx8ICh0aGlzLm1hcmtDYWNoZVtzdHlsZV0gPSB2aWV3LkRlY29yYXRpb24ubWFyayh7IGNsYXNzOiBzdHlsZSB9KSkpO1xuICAgICAgICAgICAgfSwgZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgIH1cbn1cbmNvbnN0IHRyZWVIaWdobGlnaHRlciA9IHN0YXRlLlByZWMuaGlnaCh2aWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKFRyZWVIaWdobGlnaHRlciwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pKTtcbi8qKlxuQSBkZWZhdWx0IGhpZ2hsaWdodCBzdHlsZSAod29ya3Mgd2VsbCB3aXRoIGxpZ2h0IHRoZW1lcykuXG4qL1xuY29uc3QgZGVmYXVsdEhpZ2hsaWdodFN0eWxlID0gSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogaGlnaGxpZ2h0LnRhZ3MubWV0YSxcbiAgICAgICAgY29sb3I6IFwiIzQwNDc0MFwiIH0sXG4gICAgeyB0YWc6IGhpZ2hsaWdodC50YWdzLmxpbmssXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXG4gICAgeyB0YWc6IGhpZ2hsaWdodC50YWdzLmhlYWRpbmcsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiBoaWdobGlnaHQudGFncy5lbXBoYXNpcyxcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXG4gICAgeyB0YWc6IGhpZ2hsaWdodC50YWdzLnN0cm9uZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogaGlnaGxpZ2h0LnRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCxcbiAgICAgICAgY29sb3I6IFwiIzcwOFwiIH0sXG4gICAgeyB0YWc6IFtoaWdobGlnaHQudGFncy5hdG9tLCBoaWdobGlnaHQudGFncy5ib29sLCBoaWdobGlnaHQudGFncy51cmwsIGhpZ2hsaWdodC50YWdzLmNvbnRlbnRTZXBhcmF0b3IsIGhpZ2hsaWdodC50YWdzLmxhYmVsTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyMTlcIiB9LFxuICAgIHsgdGFnOiBbaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCwgaGlnaGxpZ2h0LnRhZ3MuaW5zZXJ0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjMTY0XCIgfSxcbiAgICB7IHRhZzogW2hpZ2hsaWdodC50YWdzLnN0cmluZywgaGlnaGxpZ2h0LnRhZ3MuZGVsZXRlZF0sXG4gICAgICAgIGNvbG9yOiBcIiNhMTFcIiB9LFxuICAgIHsgdGFnOiBbaGlnaGxpZ2h0LnRhZ3MucmVnZXhwLCBoaWdobGlnaHQudGFncy5lc2NhcGUsIGhpZ2hsaWdodC50YWdzLnNwZWNpYWwoaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBcIiNlNDBcIiB9LFxuICAgIHsgdGFnOiBoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKGhpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMwMGZcIiB9LFxuICAgIHsgdGFnOiBoaWdobGlnaHQudGFncy5sb2NhbChoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMzBhXCIgfSxcbiAgICB7IHRhZzogW2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lLCBoaWdobGlnaHQudGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogXCIjMDg1XCIgfSxcbiAgICB7IHRhZzogaGlnaGxpZ2h0LnRhZ3MuY2xhc3NOYW1lLFxuICAgICAgICBjb2xvcjogXCIjMTY3XCIgfSxcbiAgICB7IHRhZzogW2hpZ2hsaWdodC50YWdzLnNwZWNpYWwoaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSwgaGlnaGxpZ2h0LnRhZ3MubWFjcm9OYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzI1NlwiIH0sXG4gICAgeyB0YWc6IGhpZ2hsaWdodC50YWdzLmRlZmluaXRpb24oaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwY1wiIH0sXG4gICAgeyB0YWc6IGhpZ2hsaWdodC50YWdzLmNvbW1lbnQsXG4gICAgICAgIGNvbG9yOiBcIiM5NDBcIiB9LFxuICAgIHsgdGFnOiBoaWdobGlnaHQudGFncy5pbnZhbGlkLFxuICAgICAgICBjb2xvcjogXCIjZjAwXCIgfVxuXSk7XG5cbmNvbnN0IGJhc2VUaGVtZSA9IHZpZXcuRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMyOGM4MjUyXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbm9ubWF0Y2hpbmdCcmFja2V0XCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNiYjU1NTU0NFwiIH1cbn0pO1xuY29uc3QgRGVmYXVsdFNjYW5EaXN0ID0gMTAwMDAsIERlZmF1bHRCcmFja2V0cyA9IFwiKClbXXt9XCI7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdDb25maWcgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gc3RhdGUuY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhZnRlckN1cnNvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJyYWNrZXRzOiBEZWZhdWx0QnJhY2tldHMsXG4gICAgICAgICAgICBtYXhTY2FuRGlzdGFuY2U6IERlZmF1bHRTY2FuRGlzdCxcbiAgICAgICAgICAgIHJlbmRlck1hdGNoOiBkZWZhdWx0UmVuZGVyTWF0Y2hcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBtYXRjaGluZ01hcmsgPSB2aWV3LkRlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW1hdGNoaW5nQnJhY2tldFwiIH0pLCBub25tYXRjaGluZ01hcmsgPSB2aWV3LkRlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW5vbm1hdGNoaW5nQnJhY2tldFwiIH0pO1xuZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1hdGNoKG1hdGNoKSB7XG4gICAgbGV0IGRlY29yYXRpb25zID0gW107XG4gICAgbGV0IG1hcmsgPSBtYXRjaC5tYXRjaGVkID8gbWF0Y2hpbmdNYXJrIDogbm9ubWF0Y2hpbmdNYXJrO1xuICAgIGRlY29yYXRpb25zLnB1c2gobWFyay5yYW5nZShtYXRjaC5zdGFydC5mcm9tLCBtYXRjaC5zdGFydC50bykpO1xuICAgIGlmIChtYXRjaC5lbmQpXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2gobWFyay5yYW5nZShtYXRjaC5lbmQuZnJvbSwgbWF0Y2guZW5kLnRvKSk7XG4gICAgcmV0dXJuIGRlY29yYXRpb25zO1xufVxuY29uc3QgYnJhY2tldE1hdGNoaW5nU3RhdGUgPSBzdGF0ZS5TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gdmlldy5EZWNvcmF0aW9uLm5vbmU7IH0sXG4gICAgdXBkYXRlKGRlY28sIHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiAhdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGRlY287XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoYnJhY2tldE1hdGNoaW5nQ29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdHIuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIC0xLCBjb25maWcpXG4gICAgICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPiAwICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgLSAxLCAxLCBjb25maWcpKVxuICAgICAgICAgICAgICAgIHx8IChjb25maWcuYWZ0ZXJDdXJzb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIDEsIGNvbmZpZykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChyYW5nZS5oZWFkIDwgdHIuc3RhdGUuZG9jLmxlbmd0aCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkICsgMSwgLTEsIGNvbmZpZykpKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucy5jb25jYXQoY29uZmlnLnJlbmRlck1hdGNoKG1hdGNoLCB0ci5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3LkRlY29yYXRpb24uc2V0KGRlY29yYXRpb25zLCB0cnVlKTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gdmlldy5FZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZilcbn0pO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nVW5pcXVlID0gW1xuICAgIGJyYWNrZXRNYXRjaGluZ1N0YXRlLFxuICAgIGJhc2VUaGVtZVxuXTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYnJhY2tldCBtYXRjaGluZy4gV2hlbmV2ZXIgdGhlXG5jdXJzb3IgaXMgbmV4dCB0byBhIGJyYWNrZXQsIHRoYXQgYnJhY2tldCBhbmQgdGhlIG9uZSBpdCBtYXRjaGVzXG5hcmUgaGlnaGxpZ2h0ZWQuIE9yLCB3aGVuIG5vIG1hdGNoaW5nIGJyYWNrZXQgaXMgZm91bmQsIGFub3RoZXJcbmhpZ2hsaWdodGluZyBzdHlsZSBpcyB1c2VkIHRvIGluZGljYXRlIHRoaXMuXG4qL1xuZnVuY3Rpb24gYnJhY2tldE1hdGNoaW5nKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFticmFja2V0TWF0Y2hpbmdDb25maWcub2YoY29uZmlnKSwgYnJhY2tldE1hdGNoaW5nVW5pcXVlXTtcbn1cbi8qKlxuV2hlbiBsYXJnZXIgc3ludGF4IG5vZGVzLCBzdWNoIGFzIEhUTUwgdGFncywgYXJlIG1hcmtlZCBhc1xub3BlbmluZy9jbG9zaW5nLCBpdCBjYW4gYmUgYSBiaXQgbWVzc3kgdG8gdHJlYXQgdGhlIHdob2xlIG5vZGUgYXNcbmEgbWF0Y2hhYmxlIGJyYWNrZXQuIFRoaXMgbm9kZSBwcm9wIGFsbG93cyB5b3UgdG8gZGVmaW5lLCBmb3Igc3VjaFxuYSBub2RlLCBhIOKAmGhhbmRsZeKAmeKAlHRoZSBwYXJ0IG9mIHRoZSBub2RlIHRoYXQgaXMgaGlnaGxpZ2h0ZWQsIGFuZFxudGhhdCB0aGUgY3Vyc29yIG11c3QgYmUgb24gdG8gYWN0aXZhdGUgaGlnaGxpZ2h0aW5nIGluIHRoZSBmaXJzdFxucGxhY2UuXG4qL1xuY29uc3QgYnJhY2tldE1hdGNoaW5nSGFuZGxlID0gbmV3IGNvbW1vbi5Ob2RlUHJvcCgpO1xuZnVuY3Rpb24gbWF0Y2hpbmdOb2Rlcyhub2RlLCBkaXIsIGJyYWNrZXRzKSB7XG4gICAgbGV0IGJ5UHJvcCA9IG5vZGUucHJvcChkaXIgPCAwID8gY29tbW9uLk5vZGVQcm9wLm9wZW5lZEJ5IDogY29tbW9uLk5vZGVQcm9wLmNsb3NlZEJ5KTtcbiAgICBpZiAoYnlQcm9wKVxuICAgICAgICByZXR1cm4gYnlQcm9wO1xuICAgIGlmIChub2RlLm5hbWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gYnJhY2tldHMuaW5kZXhPZihub2RlLm5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSAmJiBpbmRleCAlIDIgPT0gKGRpciA8IDAgPyAxIDogMCkpXG4gICAgICAgICAgICByZXR1cm4gW2JyYWNrZXRzW2luZGV4ICsgZGlyXV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZEhhbmRsZShub2RlKSB7XG4gICAgbGV0IGhhc0hhbmRsZSA9IG5vZGUudHlwZS5wcm9wKGJyYWNrZXRNYXRjaGluZ0hhbmRsZSk7XG4gICAgcmV0dXJuIGhhc0hhbmRsZSA/IGhhc0hhbmRsZShub2RlLm5vZGUpIDogbm9kZTtcbn1cbi8qKlxuRmluZCB0aGUgbWF0Y2hpbmcgYnJhY2tldCBmb3IgdGhlIHRva2VuIGF0IGBwb3NgLCBzY2FubmluZ1xuZGlyZWN0aW9uIGBkaXJgLiBPbmx5IHRoZSBgYnJhY2tldHNgIGFuZCBgbWF4U2NhbkRpc3RhbmNlYFxucHJvcGVydGllcyBhcmUgdXNlZCBmcm9tIGBjb25maWdgLCBpZiBnaXZlbi4gUmV0dXJucyBudWxsIGlmIG5vXG5icmFja2V0IHdhcyBmb3VuZCBhdCBgcG9zYCwgb3IgYSBtYXRjaCByZXN1bHQgb3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjb25maWcgPSB7fSkge1xuICAgIGxldCBtYXhTY2FuRGlzdGFuY2UgPSBjb25maWcubWF4U2NhbkRpc3RhbmNlIHx8IERlZmF1bHRTY2FuRGlzdCwgYnJhY2tldHMgPSBjb25maWcuYnJhY2tldHMgfHwgRGVmYXVsdEJyYWNrZXRzO1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSksIG5vZGUgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIGRpcik7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTsgY3VyOyBjdXIgPSBjdXIucGFyZW50KSB7XG4gICAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hpbmdOb2RlcyhjdXIudHlwZSwgZGlyLCBicmFja2V0cyk7XG4gICAgICAgIGlmIChtYXRjaGVzICYmIGN1ci5mcm9tIDwgY3VyLnRvKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlID0gZmluZEhhbmRsZShjdXIpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZSAmJiAoZGlyID4gMCA/IHBvcyA+PSBoYW5kbGUuZnJvbSAmJiBwb3MgPCBoYW5kbGUudG8gOiBwb3MgPiBoYW5kbGUuZnJvbSAmJiBwb3MgPD0gaGFuZGxlLnRvKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hNYXJrZWRCcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIGN1ciwgaGFuZGxlLCBtYXRjaGVzLCBicmFja2V0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoUGxhaW5CcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIHRyZWUsIG5vZGUudHlwZSwgbWF4U2NhbkRpc3RhbmNlLCBicmFja2V0cyk7XG59XG5mdW5jdGlvbiBtYXRjaE1hcmtlZEJyYWNrZXRzKF9zdGF0ZSwgX3BvcywgZGlyLCB0b2tlbiwgaGFuZGxlLCBtYXRjaGluZywgYnJhY2tldHMpIHtcbiAgICBsZXQgcGFyZW50ID0gdG9rZW4ucGFyZW50LCBmaXJzdFRva2VuID0geyBmcm9tOiBoYW5kbGUuZnJvbSwgdG86IGhhbmRsZS50byB9O1xuICAgIGxldCBkZXB0aCA9IDAsIGN1cnNvciA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jdXJzb3IoKTtcbiAgICBpZiAoY3Vyc29yICYmIChkaXIgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHRva2VuLmZyb20pIDogY3Vyc29yLmNoaWxkQWZ0ZXIodG9rZW4udG8pKSlcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGRpciA8IDAgPyBjdXJzb3IudG8gPD0gdG9rZW4uZnJvbSA6IGN1cnNvci5mcm9tID49IHRva2VuLnRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDAgJiYgbWF0Y2hpbmcuaW5kZXhPZihjdXJzb3IudHlwZS5uYW1lKSA+IC0xICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRIYW5kbGUgPSBmaW5kSGFuZGxlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBlbmQ6IGVuZEhhbmRsZSA/IHsgZnJvbTogZW5kSGFuZGxlLmZyb20sIHRvOiBlbmRIYW5kbGUudG8gfSA6IHVuZGVmaW5lZCwgbWF0Y2hlZDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCBkaXIsIGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCAtZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmRIYW5kbGUgPSBmaW5kSGFuZGxlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmaXJzdFRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kSGFuZGxlICYmIGVuZEhhbmRsZS5mcm9tIDwgZW5kSGFuZGxlLnRvID8geyBmcm9tOiBlbmRIYW5kbGUuZnJvbSwgdG86IGVuZEhhbmRsZS50byB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaXIgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH07XG59XG5mdW5jdGlvbiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCB0b2tlblR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpIHtcbiAgICBsZXQgc3RhcnRDaCA9IGRpciA8IDAgPyBzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpIDogc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKTtcbiAgICBsZXQgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2Yoc3RhcnRDaCk7XG4gICAgaWYgKGJyYWNrZXQgPCAwIHx8IChicmFja2V0ICUgMiA9PSAwKSAhPSAoZGlyID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzdGFydFRva2VuID0geyBmcm9tOiBkaXIgPCAwID8gcG9zIC0gMSA6IHBvcywgdG86IGRpciA+IDAgPyBwb3MgKyAxIDogcG9zIH07XG4gICAgbGV0IGl0ZXIgPSBzdGF0ZS5kb2MuaXRlclJhbmdlKHBvcywgZGlyID4gMCA/IHN0YXRlLmRvYy5sZW5ndGggOiAwKSwgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IGRpc3RhbmNlID0gMDsgIShpdGVyLm5leHQoKSkuZG9uZSAmJiBkaXN0YW5jZSA8PSBtYXhTY2FuRGlzdGFuY2U7KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gaXRlci52YWx1ZTtcbiAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IGJhc2VQb3MgPSBwb3MgKyBkaXN0YW5jZSAqIGRpcjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZGlyID4gMCA/IDAgOiB0ZXh0Lmxlbmd0aCAtIDEsIGVuZCA9IGRpciA+IDAgPyB0ZXh0Lmxlbmd0aCA6IC0xOyBwb3MgIT0gZW5kOyBwb3MgKz0gZGlyKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBicmFja2V0cy5pbmRleE9mKHRleHRbcG9zXSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPCAwIHx8IHRyZWUucmVzb2x2ZUlubmVyKGJhc2VQb3MgKyBwb3MsIDEpLnR5cGUgIT0gdG9rZW5UeXBlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKChmb3VuZCAlIDIgPT0gMCkgPT0gKGRpciA+IDApKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlcHRoID09IDEpIHsgLy8gQ2xvc2luZ1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydFRva2VuLCBlbmQ6IHsgZnJvbTogYmFzZVBvcyArIHBvcywgdG86IGJhc2VQb3MgKyBwb3MgKyAxIH0sIG1hdGNoZWQ6IChmb3VuZCA+PiAxKSA9PSAoYnJhY2tldCA+PiAxKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHRleHQubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gaXRlci5kb25lID8geyBzdGFydDogc3RhcnRUb2tlbiwgbWF0Y2hlZDogZmFsc2UgfSA6IG51bGw7XG59XG5cbi8vIENvdW50cyB0aGUgY29sdW1uIG9mZnNldCBpbiBhIHN0cmluZywgdGFraW5nIHRhYnMgaW50byBhY2NvdW50LlxuLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cbmZ1bmN0aW9uIGNvdW50Q29sKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4ID0gMCwgc3RhcnRWYWx1ZSA9IDApIHtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RyaW5nLnNlYXJjaCgvW15cXHNcXHUwMGEwXS8pO1xuICAgICAgICBpZiAoZW5kID09IC0xKVxuICAgICAgICAgICAgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgbGV0IG4gPSBzdGFydFZhbHVlO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpXG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuKys7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5FbmNhcHN1bGF0ZXMgYSBzaW5nbGUgbGluZSBvZiBpbnB1dC4gR2l2ZW4gdG8gc3RyZWFtIHN5bnRheCBjb2RlLFxud2hpY2ggdXNlcyBpdCB0byB0b2tlbml6ZSB0aGUgY29udGVudC5cbiovXG5jbGFzcyBTdHJpbmdTdHJlYW0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN0cmVhbS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsaW5lLlxuICAgICovXG4gICAgc3RyaW5nLCB0YWJTaXplLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBpbmRlbnQgdW5pdCBzaXplLlxuICAgICovXG4gICAgaW5kZW50VW5pdCwgb3ZlcnJpZGVJbmRlbnQpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemU7XG4gICAgICAgIHRoaXMuaW5kZW50VW5pdCA9IGluZGVudFVuaXQ7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVJbmRlbnQgPSBvdmVycmlkZUluZGVudDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBsaW5lLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBlb2woKSB7IHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBzb2woKSB7IHJldHVybiB0aGlzLnBvcyA9PSAwOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBuZXh0IGNvZGUgdW5pdCBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgb3IgdW5kZWZpbmVkXG4gICAgaWYgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHBlZWsoKSB7IHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZDsgfVxuICAgIC8qKlxuICAgIFJlYWQgdGhlIG5leHQgY29kZSB1bml0IGFuZCBhZHZhbmNlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPCB0aGlzLnN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgbmV4dCBjaGFyYWN0ZXIgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nLCByZWd1bGFyXG4gICAgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlLiBDb25zdW1lIGFuZCByZXR1cm4gaXQgaWYgaXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIGVhdChtYXRjaCkge1xuICAgICAgICBsZXQgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgb2s7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIG9rID0gY2ggPT0gbWF0Y2g7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9rID0gY2ggJiYgKG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpO1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbWF0Y2hpbmcgY2hhcmFjdGVycyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBzdHJpbmcsXG4gICAgcmVndWxhciBleHByZXNzaW9uLCBvciBwcmVkaWNhdGUgZnVuY3Rpb24uIFJldHVybiB0cnVlIGlmIGFueVxuICAgIGNoYXJhY3RlcnMgd2VyZSBjb25zdW1lZC5cbiAgICAqL1xuICAgIGVhdFdoaWxlKG1hdGNoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXQobWF0Y2gpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN1bWUgd2hpdGVzcGFjZSBhaGVhZCBvZiBgdGhpcy5wb3NgLiBSZXR1cm4gdHJ1ZSBpZiBhbnkgd2FzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBlYXRTcGFjZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKVxuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHNraXBUb0VuZCgpIHsgdGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIGRpcmVjdGx5IGJlZm9yZSB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpZiBmb3VuZCBvbiB0aGVcbiAgICBjdXJyZW50IGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG8oY2gpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBmb3VuZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYmFjayBgbmAgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIGJhY2tVcChuKSB7IHRoaXMucG9zIC09IG47IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgY29sdW1uKCkge1xuICAgICAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbCh0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgaW5kZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3ZlcnJpZGVJbmRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvdW50Q29sKHRoaXMuc3RyaW5nLCBudWxsLCB0aGlzLnRhYlNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgaW5wdXQgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICh3aGljaCBzaG91bGQgc3RhcnQgd2l0aCBhIGBeYCkuIFJldHVybiB0cnVlIG9yIHRoZSByZWdleHAgbWF0Y2hcbiAgICBpZiBpdCBtYXRjaGVzLlxuICAgIFxuICAgIFVubGVzcyBgY29uc3VtZWAgaXMgc2V0IHRvIGBmYWxzZWAsIHRoaXMgd2lsbCBtb3ZlIGB0aGlzLnBvc2BcbiAgICBwYXN0IHRoZSBtYXRjaGVkIHRleHQuXG4gICAgXG4gICAgV2hlbiBtYXRjaGluZyBhIHN0cmluZyBgY2FzZUluc2Vuc2l0aXZlYCBjYW4gYmUgc2V0IHRvIHRydWUgdG9cbiAgICBtYWtlIHRoZSBtYXRjaCBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICovXG4gICAgbWF0Y2gocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgY2FzZWQgPSAoc3RyKSA9PiBjYXNlSW5zZW5zaXRpdmUgPyBzdHIudG9Mb3dlckNhc2UoKSA6IHN0cjtcbiAgICAgICAgICAgIGxldCBzdWJzdHIgPSB0aGlzLnN0cmluZy5zdWJzdHIodGhpcy5wb3MsIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChjYXNlZChzdWJzdHIpID09IGNhc2VkKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAqL1xuICAgIGN1cnJlbnQoKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyk7IH1cbn1cblxuZnVuY3Rpb24gZnVsbFBhcnNlcihzcGVjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogc3BlYy5uYW1lIHx8IFwiXCIsXG4gICAgICAgIHRva2VuOiBzcGVjLnRva2VuLFxuICAgICAgICBibGFua0xpbmU6IHNwZWMuYmxhbmtMaW5lIHx8ICgoKSA9PiB7IH0pLFxuICAgICAgICBzdGFydFN0YXRlOiBzcGVjLnN0YXJ0U3RhdGUgfHwgKCgpID0+IHRydWUpLFxuICAgICAgICBjb3B5U3RhdGU6IHNwZWMuY29weVN0YXRlIHx8IGRlZmF1bHRDb3B5U3RhdGUsXG4gICAgICAgIGluZGVudDogc3BlYy5pbmRlbnQgfHwgKCgpID0+IG51bGwpLFxuICAgICAgICBsYW5ndWFnZURhdGE6IHNwZWMubGFuZ3VhZ2VEYXRhIHx8IHt9LFxuICAgICAgICB0b2tlblRhYmxlOiBzcGVjLnRva2VuVGFibGUgfHwgbm9Ub2tlbnNcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENvcHlTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGxldCBuZXdTdGF0ZSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbCA9IHN0YXRlW3Byb3BdO1xuICAgICAgICBuZXdTdGF0ZVtwcm9wXSA9ICh2YWwgaW5zdGFuY2VvZiBBcnJheSA/IHZhbC5zbGljZSgpIDogdmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xufVxuY29uc3QgSW5kZW50ZWRGcm9tID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuQSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGNsYXNzIGJhc2VkIG9uIGEgQ29kZU1pcnJvclxuNS1zdHlsZSBbc3RyZWFtaW5nIHBhcnNlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1QYXJzZXIpLlxuKi9cbmNsYXNzIFN0cmVhbUxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQocGFyc2VyLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIGxldCBwID0gZnVsbFBhcnNlcihwYXJzZXIpLCBzZWxmO1xuICAgICAgICBsZXQgaW1wbCA9IG5ldyBjbGFzcyBleHRlbmRzIGNvbW1vbi5QYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZShzZWxmLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihkYXRhLCBpbXBsLCBbXSwgcGFyc2VyLm5hbWUpO1xuICAgICAgICB0aGlzLnRvcE5vZGUgPSBkb2NJRChkYXRhLCB0aGlzKTtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyID0gcDtcbiAgICAgICAgdGhpcy5zdGF0ZUFmdGVyID0gbmV3IGNvbW1vbi5Ob2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMudG9rZW5UYWJsZSA9IHBhcnNlci50b2tlblRhYmxlID8gbmV3IFRva2VuVGFibGUocC50b2tlblRhYmxlKSA6IGRlZmF1bHRUb2tlblRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBzdHJlYW0gbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHsgcmV0dXJuIG5ldyBTdHJlYW1MYW5ndWFnZShzcGVjKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0SW5kZW50KGN4KSB7XG4gICAgICAgIGxldCBmcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgeyBvdmVycmlkZUluZGVudGF0aW9uIH0gPSBjeC5vcHRpb25zO1xuICAgICAgICBpZiAob3ZlcnJpZGVJbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgZnJvbSA9IEluZGVudGVkRnJvbS5nZXQoY3guc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZyb20gIT0gbnVsbCAmJiBmcm9tIDwgY3gucG9zIC0gMWU0KVxuICAgICAgICAgICAgICAgIGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZmluZFN0YXRlKHRoaXMsIGN4Lm5vZGUudHJlZSwgMCwgY3gubm9kZS5mcm9tLCBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBjeC5wb3MpLCBzdGF0ZVBvcywgc3RhdGU7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gc3RhcnQucG9zICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShjeC51bml0KTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3gucG9zIC0gc3RhdGVQb3MgPiAxMDAwMCAvKiBDLk1heEluZGVudFNjYW5EaXN0ICovKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlIChzdGF0ZVBvcyA8IGN4LnBvcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBjeC5zdGF0ZS5kb2MubGluZUF0KHN0YXRlUG9zKSwgZW5kID0gTWF0aC5taW4oY3gucG9zLCBsaW5lLnRvKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnRhdGlvbiA9IG92ZXJyaWRlSW5kZW50YXRpb24gPyBvdmVycmlkZUluZGVudGF0aW9uKGxpbmUuZnJvbSkgOiAtMTtcbiAgICAgICAgICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGN4LnN0YXRlLnRhYlNpemUsIGN4LnVuaXQsIGluZGVudGF0aW9uIDwgMCA/IHVuZGVmaW5lZCA6IGluZGVudGF0aW9uKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyZWFtLnBvcyA8IGVuZCAtIGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRva2VuKHRoaXMuc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyLmJsYW5rTGluZShzdGF0ZSwgY3gudW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09IGN4LnBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXRlUG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmUgPSBjeC5saW5lQXQoY3gucG9zKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlSW5kZW50YXRpb24gJiYgZnJvbSA9PSBudWxsKVxuICAgICAgICAgICAgSW5kZW50ZWRGcm9tLnNldChjeC5zdGF0ZSwgbGluZS5mcm9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtUGFyc2VyLmluZGVudChzdGF0ZSwgL15cXHMqKC4qKS8uZXhlYyhsaW5lLnRleHQpWzFdLCBjeCk7XG4gICAgfVxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmZ1bmN0aW9uIGZpbmRTdGF0ZShsYW5nLCB0cmVlLCBvZmYsIHN0YXJ0UG9zLCBiZWZvcmUpIHtcbiAgICBsZXQgc3RhdGUgPSBvZmYgPj0gc3RhcnRQb3MgJiYgb2ZmICsgdHJlZS5sZW5ndGggPD0gYmVmb3JlICYmIHRyZWUucHJvcChsYW5nLnN0YXRlQWZ0ZXIpO1xuICAgIGlmIChzdGF0ZSlcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZShzdGF0ZSksIHBvczogb2ZmICsgdHJlZS5sZW5ndGggfTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgY2hpbGQgPSB0cmVlLmNoaWxkcmVuW2ldLCBwb3MgPSBvZmYgKyB0cmVlLnBvc2l0aW9uc1tpXTtcbiAgICAgICAgbGV0IGZvdW5kID0gY2hpbGQgaW5zdGFuY2VvZiBjb21tb24uVHJlZSAmJiBwb3MgPCBiZWZvcmUgJiYgZmluZFN0YXRlKGxhbmcsIGNoaWxkLCBwb3MsIHN0YXJ0UG9zLCBiZWZvcmUpO1xuICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY3V0VHJlZShsYW5nLCB0cmVlLCBmcm9tLCB0bywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSAmJiBmcm9tIDw9IDAgJiYgdG8gPj0gdHJlZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIGlmICghaW5zaWRlICYmIGZyb20gPT0gMCAmJiB0cmVlLnR5cGUgPT0gbGFuZy50b3BOb2RlKVxuICAgICAgICBpbnNpZGUgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBwb3MgPSB0cmVlLnBvc2l0aW9uc1tpXSwgY2hpbGQgPSB0cmVlLmNoaWxkcmVuW2ldLCBpbm5lcjtcbiAgICAgICAgaWYgKHBvcyA8IHRvICYmIGNoaWxkIGluc3RhbmNlb2YgY29tbW9uLlRyZWUpIHtcbiAgICAgICAgICAgIGlmICghKGlubmVyID0gY3V0VHJlZShsYW5nLCBjaGlsZCwgZnJvbSAtIHBvcywgdG8gLSBwb3MsIGluc2lkZSkpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcmV0dXJuICFpbnNpZGUgPyBpbm5lclxuICAgICAgICAgICAgICAgIDogbmV3IGNvbW1vbi5UcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbi5zbGljZSgwLCBpKS5jb25jYXQoaW5uZXIpLCB0cmVlLnBvc2l0aW9ucy5zbGljZSgwLCBpICsgMSksIHBvcyArIGlubmVyLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kU3RhcnRJbkZyYWdtZW50cyhsYW5nLCBmcmFnbWVudHMsIHN0YXJ0UG9zLCBlbmRQb3MsIGVkaXRvclN0YXRlKSB7XG4gICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBmLmZyb20gKyAoZi5vcGVuU3RhcnQgPyAyNSA6IDApLCB0byA9IGYudG8gLSAoZi5vcGVuRW5kID8gMjUgOiAwKTtcbiAgICAgICAgbGV0IGZvdW5kID0gZnJvbSA8PSBzdGFydFBvcyAmJiB0byA+IHN0YXJ0UG9zICYmIGZpbmRTdGF0ZShsYW5nLCBmLnRyZWUsIDAgLSBmLm9mZnNldCwgc3RhcnRQb3MsIHRvKSwgdHJlZTtcbiAgICAgICAgaWYgKGZvdW5kICYmIGZvdW5kLnBvcyA8PSBlbmRQb3MgJiYgKHRyZWUgPSBjdXRUcmVlKGxhbmcsIGYudHJlZSwgc3RhcnRQb3MgKyBmLm9mZnNldCwgZm91bmQucG9zICsgZi5vZmZzZXQsIGZhbHNlKSkpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogZm91bmQuc3RhdGUsIHRyZWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoZWRpdG9yU3RhdGUgPyBnZXRJbmRlbnRVbml0KGVkaXRvclN0YXRlKSA6IDQpLCB0cmVlOiBjb21tb24uVHJlZS5lbXB0eSB9O1xufVxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxhbmcsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLmxhbmcgPSBsYW5nO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gW107XG4gICAgICAgIHRoaXMuY2h1bmsgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1JldXNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50byA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgIGxldCBjb250ZXh0ID0gUGFyc2VDb250ZXh0LmdldCgpLCBmcm9tID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIGxldCB7IHN0YXRlLCB0cmVlIH0gPSBmaW5kU3RhcnRJbkZyYWdtZW50cyhsYW5nLCBmcmFnbWVudHMsIGZyb20sIHRoaXMudG8sIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5zdGF0ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSB0aGlzLmNodW5rU3RhcnQgPSBmcm9tICsgdHJlZS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0cmVlLnBvc2l0aW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgJiYgdGhpcy5wYXJzZWRQb3MgPCBjb250ZXh0LnZpZXdwb3J0LmZyb20gLSAxMDAwMDAgLyogQy5NYXhEaXN0YW5jZUJlZm9yZVZpZXdwb3J0ICovICYmXG4gICAgICAgICAgICByYW5nZXMuc29tZShyID0+IHIuZnJvbSA8PSBjb250ZXh0LnZpZXdwb3J0LmZyb20gJiYgci50byA+PSBjb250ZXh0LnZpZXdwb3J0LmZyb20pKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5sYW5nLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGdldEluZGVudFVuaXQoY29udGV4dC5zdGF0ZSkpO1xuICAgICAgICAgICAgY29udGV4dC5za2lwVW50aWxJblZpZXcodGhpcy5wYXJzZWRQb3MsIGNvbnRleHQudmlld3BvcnQuZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IGNvbnRleHQudmlld3BvcnQuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmVSYW5nZUluZGV4KCk7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gUGFyc2VDb250ZXh0LmdldCgpO1xuICAgICAgICBsZXQgcGFyc2VFbmQgPSB0aGlzLnN0b3BwZWRBdCA9PSBudWxsID8gdGhpcy50byA6IE1hdGgubWluKHRoaXMudG8sIHRoaXMuc3RvcHBlZEF0KTtcbiAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHBhcnNlRW5kLCB0aGlzLmNodW5rU3RhcnQgKyAyMDQ4IC8qIEMuQ2h1bmtTaXplICovKTtcbiAgICAgICAgaWYgKGNvbnRleHQpXG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGNvbnRleHQudmlld3BvcnQudG8pO1xuICAgICAgICB3aGlsZSAodGhpcy5wYXJzZWRQb3MgPCBlbmQpXG4gICAgICAgICAgICB0aGlzLnBhcnNlTGluZShjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtTdGFydCA8IHRoaXMucGFyc2VkUG9zKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuaygpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRQb3MgPj0gcGFyc2VFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgdGhpcy5wYXJzZWRQb3MgPj0gY29udGV4dC52aWV3cG9ydC50bykge1xuICAgICAgICAgICAgY29udGV4dC5za2lwVW50aWxJblZpZXcodGhpcy5wYXJzZWRQb3MsIHBhcnNlRW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgIH1cbiAgICBsaW5lQWZ0ZXIocG9zKSB7XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsocG9zKTtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0LmxpbmVDaHVua3MpIHtcbiAgICAgICAgICAgIGxldCBlb2wgPSBjaHVuay5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICAgICAgaWYgKGVvbCA+IC0xKVxuICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc2xpY2UoMCwgZW9sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaHVuayA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBjaHVuayA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcyArIGNodW5rLmxlbmd0aCA8PSB0aGlzLnRvID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCB0aGlzLnRvIC0gcG9zKTtcbiAgICB9XG4gICAgbmV4dExpbmUoKSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy5wYXJzZWRQb3MsIGxpbmUgPSB0aGlzLmxpbmVBZnRlcihmcm9tKSwgZW5kID0gZnJvbSArIGxpbmUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDs7KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VFbmQgPSB0aGlzLnJhbmdlc1tpbmRleF0udG87XG4gICAgICAgICAgICBpZiAocmFuZ2VFbmQgPj0gZW5kKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgcmFuZ2VFbmQgLSAoZW5kIC0gbGluZS5sZW5ndGgpKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHJhbmdlU3RhcnQgPSB0aGlzLnJhbmdlc1tpbmRleF0uZnJvbTtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHRoaXMubGluZUFmdGVyKHJhbmdlU3RhcnQpO1xuICAgICAgICAgICAgbGluZSArPSBhZnRlcjtcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlU3RhcnQgKyBhZnRlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGluZSwgZW5kIH07XG4gICAgfVxuICAgIHNraXBHYXBzVG8ocG9zLCBvZmZzZXQsIHNpZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8sIG9mZlBvcyA9IHBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChzaWRlID4gMCA/IGVuZCA+IG9mZlBvcyA6IGVuZCA+PSBvZmZQb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF0uZnJvbTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzdGFydCAtIGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBtb3ZlUmFuZ2VJbmRleCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8gPCB0aGlzLnBhcnNlZFBvcylcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCsrO1xuICAgIH1cbiAgICBlbWl0VG9rZW4oaWQsIGZyb20sIHRvLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHNpemUgPSA0O1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKGZyb20sIG9mZnNldCwgMSk7XG4gICAgICAgICAgICBmcm9tICs9IG9mZnNldDtcbiAgICAgICAgICAgIGxldCBsZW4wID0gdGhpcy5jaHVuay5sZW5ndGg7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8odG8sIG9mZnNldCwgLTEpO1xuICAgICAgICAgICAgdG8gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNodW5rLmxlbmd0aCAtIGxlbjA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNodW5rLmxlbmd0aCAtIDQ7XG4gICAgICAgIGlmIChzaXplID09IDQgJiYgbGFzdCA+PSAwICYmIHRoaXMuY2h1bmtbbGFzdF0gPT0gaWQgJiYgdGhpcy5jaHVua1tsYXN0ICsgMl0gPT0gZnJvbSlcbiAgICAgICAgICAgIHRoaXMuY2h1bmtbbGFzdCArIDJdID0gdG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuY2h1bmsucHVzaChpZCwgZnJvbSwgdG8sIHNpemUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBwYXJzZUxpbmUoY29udGV4dCkge1xuICAgICAgICBsZXQgeyBsaW5lLCBlbmQgfSA9IHRoaXMubmV4dExpbmUoKSwgb2Zmc2V0ID0gMCwgeyBzdHJlYW1QYXJzZXIgfSA9IHRoaXMubGFuZztcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZSwgY29udGV4dCA/IGNvbnRleHQuc3RhdGUudGFiU2l6ZSA6IDQsIGNvbnRleHQgPyBnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpIDogMik7XG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgIHN0cmVhbVBhcnNlci5ibGFua0xpbmUodGhpcy5zdGF0ZSwgc3RyZWFtLmluZGVudFVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSByZWFkVG9rZW4oc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5lbWl0VG9rZW4odGhpcy5sYW5nLnRva2VuVGFibGUucmVzb2x2ZSh0b2tlbiksIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnN0YXJ0LCB0aGlzLnBhcnNlZFBvcyArIHN0cmVhbS5wb3MsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5zdGFydCA+IDEwMDAwIC8qIEMuTWF4TGluZUxlbmd0aCAqLylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBlbmQ7XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSW5kZXgoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkUG9zIDwgdGhpcy50bylcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zKys7XG4gICAgfVxuICAgIGZpbmlzaENodW5rKCkge1xuICAgICAgICBsZXQgdHJlZSA9IGNvbW1vbi5UcmVlLmJ1aWxkKHtcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy5jaHVuayxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMucGFyc2VkUG9zIC0gdGhpcy5jaHVua1N0YXJ0LFxuICAgICAgICAgICAgbm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiAwLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiAyMDQ4IC8qIEMuQ2h1bmtTaXplICovLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLmNodW5rUmV1c2VkXG4gICAgICAgIH0pO1xuICAgICAgICB0cmVlID0gbmV3IGNvbW1vbi5UcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbiwgdHJlZS5wb3NpdGlvbnMsIHRyZWUubGVuZ3RoLCBbW3RoaXMubGFuZy5zdGF0ZUFmdGVyLCB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZSh0aGlzLnN0YXRlKV1dKTtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCAtIHRoaXMucmFuZ2VzWzBdLmZyb20pO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IHRoaXMucGFyc2VkUG9zO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29tbW9uLlRyZWUodGhpcy5sYW5nLnRvcE5vZGUsIHRoaXMuY2h1bmtzLCB0aGlzLmNodW5rUG9zLCB0aGlzLnBhcnNlZFBvcyAtIHRoaXMucmFuZ2VzWzBdLmZyb20pLmJhbGFuY2UoKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWFkVG9rZW4odG9rZW4sIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdG9rZW4oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIHBhcnNlciBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpO1xufVxuY29uc3Qgbm9Ub2tlbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgdHlwZUFycmF5ID0gW2NvbW1vbi5Ob2RlVHlwZS5ub25lXTtcbmNvbnN0IG5vZGVTZXQgPSBuZXcgY29tbW9uLk5vZGVTZXQodHlwZUFycmF5KTtcbmNvbnN0IHdhcm5lZCA9IFtdO1xuLy8gQ2FjaGUgb2Ygbm9kZSB0eXBlcyBieSBuYW1lIGFuZCB0YWdzXG5jb25zdCBieVRhZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZWZhdWx0VGFibGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZm9yIChsZXQgW2xlZ2FjeU5hbWUsIG5hbWVdIG9mIFtcbiAgICBbXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlTmFtZVwiXSxcbiAgICBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIl0sXG4gICAgW1wic3RyaW5nLTJcIiwgXCJzdHJpbmcuc3BlY2lhbFwiXSxcbiAgICBbXCJkZWZcIiwgXCJ2YXJpYWJsZU5hbWUuZGVmaW5pdGlvblwiXSxcbiAgICBbXCJ0YWdcIiwgXCJ0YWdOYW1lXCJdLFxuICAgIFtcImF0dHJpYnV0ZVwiLCBcImF0dHJpYnV0ZU5hbWVcIl0sXG4gICAgW1widHlwZVwiLCBcInR5cGVOYW1lXCJdLFxuICAgIFtcImJ1aWx0aW5cIiwgXCJ2YXJpYWJsZU5hbWUuc3RhbmRhcmRcIl0sXG4gICAgW1wicXVhbGlmaWVyXCIsIFwibW9kaWZpZXJcIl0sXG4gICAgW1wiZXJyb3JcIiwgXCJpbnZhbGlkXCJdLFxuICAgIFtcImhlYWRlclwiLCBcImhlYWRpbmdcIl0sXG4gICAgW1wicHJvcGVydHlcIiwgXCJwcm9wZXJ0eU5hbWVcIl1cbl0pXG4gICAgZGVmYXVsdFRhYmxlW2xlZ2FjeU5hbWVdID0gY3JlYXRlVG9rZW5UeXBlKG5vVG9rZW5zLCBuYW1lKTtcbmNsYXNzIFRva2VuVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGV4dHJhKSB7XG4gICAgICAgIHRoaXMuZXh0cmEgPSBleHRyYTtcbiAgICAgICAgdGhpcy50YWJsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgZGVmYXVsdFRhYmxlKTtcbiAgICB9XG4gICAgcmVzb2x2ZSh0YWcpIHtcbiAgICAgICAgcmV0dXJuICF0YWcgPyAwIDogdGhpcy50YWJsZVt0YWddIHx8ICh0aGlzLnRhYmxlW3RhZ10gPSBjcmVhdGVUb2tlblR5cGUodGhpcy5leHRyYSwgdGFnKSk7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdFRva2VuVGFibGUgPSBuZXcgVG9rZW5UYWJsZShub1Rva2Vucyk7XG5mdW5jdGlvbiB3YXJuRm9yUGFydChwYXJ0LCBtc2cpIHtcbiAgICBpZiAod2FybmVkLmluZGV4T2YocGFydCkgPiAtMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHdhcm5lZC5wdXNoKHBhcnQpO1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5UeXBlKGV4dHJhLCB0YWdTdHIpIHtcbiAgICBsZXQgdGFncyA9IFtdO1xuICAgIGZvciAobGV0IG5hbWUgb2YgdGFnU3RyLnNwbGl0KFwiIFwiKSkge1xuICAgICAgICBsZXQgZm91bmQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiBuYW1lLnNwbGl0KFwiLlwiKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gKGV4dHJhW3BhcnRdIHx8IGhpZ2hsaWdodC50YWdzW3BhcnRdKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVW5rbm93biBoaWdobGlnaHRpbmcgdGFnICR7cGFydH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYE1vZGlmaWVyICR7cGFydH0gdXNlZCBhdCBzdGFydCBvZiB0YWdgKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQubWFwKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBUYWcgJHtwYXJ0fSB1c2VkIGFzIG1vZGlmaWVyYCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHRhZyBvZiBmb3VuZClcbiAgICAgICAgICAgIHRhZ3MucHVzaCh0YWcpO1xuICAgIH1cbiAgICBpZiAoIXRhZ3MubGVuZ3RoKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBsZXQgbmFtZSA9IHRhZ1N0ci5yZXBsYWNlKC8gL2csIFwiX1wiKSwga2V5ID0gbmFtZSArIFwiIFwiICsgdGFncy5tYXAodCA9PiB0LmlkKTtcbiAgICBsZXQga25vd24gPSBieVRhZ1trZXldO1xuICAgIGlmIChrbm93bilcbiAgICAgICAgcmV0dXJuIGtub3duLmlkO1xuICAgIGxldCB0eXBlID0gYnlUYWdba2V5XSA9IGNvbW1vbi5Ob2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICBpZDogdHlwZUFycmF5Lmxlbmd0aCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcHM6IFtoaWdobGlnaHQuc3R5bGVUYWdzKHsgW25hbWVdOiB0YWdzIH0pXVxuICAgIH0pO1xuICAgIHR5cGVBcnJheS5wdXNoKHR5cGUpO1xuICAgIHJldHVybiB0eXBlLmlkO1xufVxuZnVuY3Rpb24gZG9jSUQoZGF0YSwgbGFuZykge1xuICAgIGxldCB0eXBlID0gY29tbW9uLk5vZGVUeXBlLmRlZmluZSh7IGlkOiB0eXBlQXJyYXkubGVuZ3RoLCBuYW1lOiBcIkRvY3VtZW50XCIsIHByb3BzOiBbXG4gICAgICAgICAgICBsYW5ndWFnZURhdGFQcm9wLmFkZCgoKSA9PiBkYXRhKSxcbiAgICAgICAgICAgIGluZGVudE5vZGVQcm9wLmFkZCgoKSA9PiBjeCA9PiBsYW5nLmdldEluZGVudChjeCkpXG4gICAgICAgIF0sIHRvcDogdHJ1ZSB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRGb3JMaW5lKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS5sZW5ndGggPD0gNDA5NiAmJiAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY1xcdWZiNTAtXFx1ZmRmZl0vLnRlc3QobGluZSk7XG59XG5mdW5jdGlvbiB0ZXh0SGFzUlRMKHRleHQpIHtcbiAgICBmb3IgKGxldCBpID0gdGV4dC5pdGVyKCk7ICFpLm5leHQoKS5kb25lOylcbiAgICAgICAgaWYgKGJ1aWxkRm9yTGluZShpLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoYW5nZUFkZHNSVEwoY2hhbmdlKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgY2hhbmdlLml0ZXJDaGFuZ2VzKChmQSwgdEEsIGZCLCB0QiwgaW5zKSA9PiB7XG4gICAgICAgIGlmICghYWRkZWQgJiYgdGV4dEhhc1JUTChpbnMpKVxuICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBhZGRlZDtcbn1cbmNvbnN0IGFsd2F5c0lzb2xhdGUgPSBzdGF0ZS5GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KSB9KTtcbi8qKlxuTWFrZSBzdXJlIG5vZGVzXG5bbWFya2VkXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tb24uTm9kZVByb3BeaXNvbGF0ZSlcbmFzIGlzb2xhdGluZyBmb3IgYmlkaXJlY3Rpb25hbCB0ZXh0IGFyZSByZW5kZXJlZCBpbiBhIHdheSB0aGF0XG5pc29sYXRlcyB0aGVtIGZyb20gdGhlIHN1cnJvdW5kaW5nIHRleHQuXG4qL1xuZnVuY3Rpb24gYmlkaUlzb2xhdGVzKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBleHRlbnNpb25zID0gW2lzb2xhdGVNYXJrc107XG4gICAgaWYgKG9wdGlvbnMuYWx3YXlzSXNvbGF0ZSlcbiAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKGFsd2F5c0lzb2xhdGUub2YodHJ1ZSkpO1xuICAgIHJldHVybiBleHRlbnNpb25zO1xufVxuY29uc3QgaXNvbGF0ZU1hcmtzID0gdmlldy5WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3IodmlldyQxKSB7XG4gICAgICAgIHRoaXMuYWx3YXlzID0gdmlldyQxLnN0YXRlLmZhY2V0KGFsd2F5c0lzb2xhdGUpIHx8XG4gICAgICAgICAgICB2aWV3JDEudGV4dERpcmVjdGlvbiAhPSB2aWV3LkRpcmVjdGlvbi5MVFIgfHxcbiAgICAgICAgICAgIHZpZXckMS5zdGF0ZS5mYWNldCh2aWV3LkVkaXRvclZpZXcucGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLmhhc1JUTCA9ICF0aGlzLmFsd2F5cyAmJiB0ZXh0SGFzUlRMKHZpZXckMS5zdGF0ZS5kb2MpO1xuICAgICAgICB0aGlzLnRyZWUgPSBzeW50YXhUcmVlKHZpZXckMS5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmFsd2F5cyB8fCB0aGlzLmhhc1JUTCA/IGJ1aWxkRGVjbyh2aWV3JDEsIHRoaXMudHJlZSwgdGhpcy5hbHdheXMpIDogdmlldy5EZWNvcmF0aW9uLm5vbmU7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGFsd2F5cyA9IHVwZGF0ZS5zdGF0ZS5mYWNldChhbHdheXNJc29sYXRlKSB8fFxuICAgICAgICAgICAgdXBkYXRlLnZpZXcudGV4dERpcmVjdGlvbiAhPSB2aWV3LkRpcmVjdGlvbi5MVFIgfHxcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5mYWNldCh2aWV3LkVkaXRvclZpZXcucGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIWFsd2F5cyAmJiAhdGhpcy5oYXNSVEwgJiYgY2hhbmdlQWRkc1JUTCh1cGRhdGUuY2hhbmdlcykpXG4gICAgICAgICAgICB0aGlzLmhhc1JUTCA9IHRydWU7XG4gICAgICAgIGlmICghYWx3YXlzICYmICF0aGlzLmhhc1JUTClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChhbHdheXMgIT0gdGhpcy5hbHdheXMgfHwgdHJlZSAhPSB0aGlzLnRyZWUgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuYWx3YXlzID0gYWx3YXlzO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGJ1aWxkRGVjbyh1cGRhdGUudmlldywgdHJlZSwgYWx3YXlzKTtcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4ge1xuICAgICAgICBmdW5jdGlvbiBhY2Nlc3ModmlldyQxKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHZpZXckMS5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY29yYXRpb25zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB2aWV3LkRlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ZpZXcuRWRpdG9yVmlldy5vdXRlckRlY29yYXRpb25zLm9mKGFjY2VzcyksXG4gICAgICAgICAgICBzdGF0ZS5QcmVjLmxvd2VzdCh2aWV3LkVkaXRvclZpZXcuYmlkaUlzb2xhdGVkUmFuZ2VzLm9mKGFjY2VzcykpXTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGJ1aWxkRGVjbyh2aWV3LCB0cmVlLCBhbHdheXMpIHtcbiAgICBsZXQgZGVjbyA9IG5ldyBzdGF0ZS5SYW5nZVNldEJ1aWxkZXIoKTtcbiAgICBsZXQgcmFuZ2VzID0gdmlldy52aXNpYmxlUmFuZ2VzO1xuICAgIGlmICghYWx3YXlzKVxuICAgICAgICByYW5nZXMgPSBjbGlwUlRMTGluZXMocmFuZ2VzLCB2aWV3LnN0YXRlLmRvYyk7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHJhbmdlcykge1xuICAgICAgICB0cmVlLml0ZXJhdGUoe1xuICAgICAgICAgICAgZW50ZXI6IG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpc28gPSBub2RlLnR5cGUucHJvcChjb21tb24uTm9kZVByb3AuaXNvbGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzbylcbiAgICAgICAgICAgICAgICAgICAgZGVjby5hZGQobm9kZS5mcm9tLCBub2RlLnRvLCBtYXJrc1tpc29dKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tLCB0b1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY28uZmluaXNoKCk7XG59XG5mdW5jdGlvbiBjbGlwUlRMTGluZXMocmFuZ2VzLCBkb2MpIHtcbiAgICBsZXQgY3VyID0gZG9jLml0ZXIoKSwgcG9zID0gMCwgcmVzdWx0ID0gW10sIGxhc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC50byA+IGZyb20pIHtcbiAgICAgICAgICAgIGZyb20gPSBsYXN0LnRvO1xuICAgICAgICAgICAgaWYgKGZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyArIGN1ci52YWx1ZS5sZW5ndGggPCBmcm9tKSB7XG4gICAgICAgICAgICBjdXIubmV4dChmcm9tIC0gKHBvcyArIGN1ci52YWx1ZS5sZW5ndGgpKTtcbiAgICAgICAgICAgIHBvcyA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcG9zLCBlbmQgPSBwb3MgKyBjdXIudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFjdXIubGluZUJyZWFrICYmIGJ1aWxkRm9yTGluZShjdXIudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC50byA+IHN0YXJ0IC0gMTApXG4gICAgICAgICAgICAgICAgICAgIGxhc3QudG8gPSBNYXRoLm1pbih0bywgZW5kKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxhc3QgPSB7IGZyb206IHN0YXJ0LCB0bzogTWF0aC5taW4odG8sIGVuZCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID49IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgICAgY3VyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgbWFya3MgPSB7XG4gICAgcnRsOiB2aWV3LkRlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWlzb1wiLCBpbmNsdXNpdmU6IHRydWUsIGF0dHJpYnV0ZXM6IHsgZGlyOiBcInJ0bFwiIH0sIGJpZGlJc29sYXRlOiB2aWV3LkRpcmVjdGlvbi5SVEwgfSksXG4gICAgbHRyOiB2aWV3LkRlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWlzb1wiLCBpbmNsdXNpdmU6IHRydWUsIGF0dHJpYnV0ZXM6IHsgZGlyOiBcImx0clwiIH0sIGJpZGlJc29sYXRlOiB2aWV3LkRpcmVjdGlvbi5MVFIgfSksXG4gICAgYXV0bzogdmlldy5EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1pc29cIiwgaW5jbHVzaXZlOiB0cnVlLCBhdHRyaWJ1dGVzOiB7IGRpcjogXCJhdXRvXCIgfSwgYmlkaUlzb2xhdGU6IG51bGwgfSlcbn07XG5cbmV4cG9ydHMuRG9jSW5wdXQgPSBEb2NJbnB1dDtcbmV4cG9ydHMuSGlnaGxpZ2h0U3R5bGUgPSBIaWdobGlnaHRTdHlsZTtcbmV4cG9ydHMuSW5kZW50Q29udGV4dCA9IEluZGVudENvbnRleHQ7XG5leHBvcnRzLkxSTGFuZ3VhZ2UgPSBMUkxhbmd1YWdlO1xuZXhwb3J0cy5MYW5ndWFnZSA9IExhbmd1YWdlO1xuZXhwb3J0cy5MYW5ndWFnZURlc2NyaXB0aW9uID0gTGFuZ3VhZ2VEZXNjcmlwdGlvbjtcbmV4cG9ydHMuTGFuZ3VhZ2VTdXBwb3J0ID0gTGFuZ3VhZ2VTdXBwb3J0O1xuZXhwb3J0cy5QYXJzZUNvbnRleHQgPSBQYXJzZUNvbnRleHQ7XG5leHBvcnRzLlN0cmVhbUxhbmd1YWdlID0gU3RyZWFtTGFuZ3VhZ2U7XG5leHBvcnRzLlN0cmluZ1N0cmVhbSA9IFN0cmluZ1N0cmVhbTtcbmV4cG9ydHMuVHJlZUluZGVudENvbnRleHQgPSBUcmVlSW5kZW50Q29udGV4dDtcbmV4cG9ydHMuYmlkaUlzb2xhdGVzID0gYmlkaUlzb2xhdGVzO1xuZXhwb3J0cy5icmFja2V0TWF0Y2hpbmcgPSBicmFja2V0TWF0Y2hpbmc7XG5leHBvcnRzLmJyYWNrZXRNYXRjaGluZ0hhbmRsZSA9IGJyYWNrZXRNYXRjaGluZ0hhbmRsZTtcbmV4cG9ydHMuY29kZUZvbGRpbmcgPSBjb2RlRm9sZGluZztcbmV4cG9ydHMuY29udGludWVkSW5kZW50ID0gY29udGludWVkSW5kZW50O1xuZXhwb3J0cy5kZWZhdWx0SGlnaGxpZ2h0U3R5bGUgPSBkZWZhdWx0SGlnaGxpZ2h0U3R5bGU7XG5leHBvcnRzLmRlZmluZUxhbmd1YWdlRmFjZXQgPSBkZWZpbmVMYW5ndWFnZUZhY2V0O1xuZXhwb3J0cy5kZWxpbWl0ZWRJbmRlbnQgPSBkZWxpbWl0ZWRJbmRlbnQ7XG5leHBvcnRzLmVuc3VyZVN5bnRheFRyZWUgPSBlbnN1cmVTeW50YXhUcmVlO1xuZXhwb3J0cy5mbGF0SW5kZW50ID0gZmxhdEluZGVudDtcbmV4cG9ydHMuZm9sZEFsbCA9IGZvbGRBbGw7XG5leHBvcnRzLmZvbGRDb2RlID0gZm9sZENvZGU7XG5leHBvcnRzLmZvbGRFZmZlY3QgPSBmb2xkRWZmZWN0O1xuZXhwb3J0cy5mb2xkR3V0dGVyID0gZm9sZEd1dHRlcjtcbmV4cG9ydHMuZm9sZEluc2lkZSA9IGZvbGRJbnNpZGU7XG5leHBvcnRzLmZvbGRLZXltYXAgPSBmb2xkS2V5bWFwO1xuZXhwb3J0cy5mb2xkTm9kZVByb3AgPSBmb2xkTm9kZVByb3A7XG5leHBvcnRzLmZvbGRTZXJ2aWNlID0gZm9sZFNlcnZpY2U7XG5leHBvcnRzLmZvbGRTdGF0ZSA9IGZvbGRTdGF0ZTtcbmV4cG9ydHMuZm9sZGFibGUgPSBmb2xkYWJsZTtcbmV4cG9ydHMuZm9sZGVkUmFuZ2VzID0gZm9sZGVkUmFuZ2VzO1xuZXhwb3J0cy5mb3JjZVBhcnNpbmcgPSBmb3JjZVBhcnNpbmc7XG5leHBvcnRzLmdldEluZGVudFVuaXQgPSBnZXRJbmRlbnRVbml0O1xuZXhwb3J0cy5nZXRJbmRlbnRhdGlvbiA9IGdldEluZGVudGF0aW9uO1xuZXhwb3J0cy5oaWdobGlnaHRpbmdGb3IgPSBoaWdobGlnaHRpbmdGb3I7XG5leHBvcnRzLmluZGVudE5vZGVQcm9wID0gaW5kZW50Tm9kZVByb3A7XG5leHBvcnRzLmluZGVudE9uSW5wdXQgPSBpbmRlbnRPbklucHV0O1xuZXhwb3J0cy5pbmRlbnRSYW5nZSA9IGluZGVudFJhbmdlO1xuZXhwb3J0cy5pbmRlbnRTZXJ2aWNlID0gaW5kZW50U2VydmljZTtcbmV4cG9ydHMuaW5kZW50U3RyaW5nID0gaW5kZW50U3RyaW5nO1xuZXhwb3J0cy5pbmRlbnRVbml0ID0gaW5kZW50VW5pdDtcbmV4cG9ydHMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbmV4cG9ydHMubGFuZ3VhZ2VEYXRhUHJvcCA9IGxhbmd1YWdlRGF0YVByb3A7XG5leHBvcnRzLm1hdGNoQnJhY2tldHMgPSBtYXRjaEJyYWNrZXRzO1xuZXhwb3J0cy5zdWJsYW5ndWFnZVByb3AgPSBzdWJsYW5ndWFnZVByb3A7XG5leHBvcnRzLnN5bnRheEhpZ2hsaWdodGluZyA9IHN5bnRheEhpZ2hsaWdodGluZztcbmV4cG9ydHMuc3ludGF4UGFyc2VyUnVubmluZyA9IHN5bnRheFBhcnNlclJ1bm5pbmc7XG5leHBvcnRzLnN5bnRheFRyZWUgPSBzeW50YXhUcmVlO1xuZXhwb3J0cy5zeW50YXhUcmVlQXZhaWxhYmxlID0gc3ludGF4VHJlZUF2YWlsYWJsZTtcbmV4cG9ydHMudG9nZ2xlRm9sZCA9IHRvZ2dsZUZvbGQ7XG5leHBvcnRzLnVuZm9sZEFsbCA9IHVuZm9sZEFsbDtcbmV4cG9ydHMudW5mb2xkQ29kZSA9IHVuZm9sZENvZGU7XG5leHBvcnRzLnVuZm9sZEVmZmVjdCA9IHVuZm9sZEVmZmVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHZpZXcgPSByZXF1aXJlKCdAY29kZW1pcnJvci92aWV3Jyk7XG52YXIgc3RhdGUgPSByZXF1aXJlKCdAY29kZW1pcnJvci9zdGF0ZScpO1xudmFyIGVsdCA9IHJlcXVpcmUoJ2NyZWx0Jyk7XG5cbmNsYXNzIFNlbGVjdGVkRGlhZ25vc3RpYyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpYWdub3N0aWMpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgIH1cbn1cbmNsYXNzIExpbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZGlhZ25vc3RpY3MsIHBhbmVsLCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdChkaWFnbm9zdGljcywgcGFuZWwsIHN0YXRlJDEpIHtcbiAgICAgICAgLy8gRmlsdGVyIHRoZSBsaXN0IG9mIGRpYWdub3N0aWNzIGZvciB3aGljaCB0byBjcmVhdGUgbWFya2Vyc1xuICAgICAgICBsZXQgbWFya2VkRGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgbGV0IGRpYWdub3N0aWNGaWx0ZXIgPSBzdGF0ZSQxLmZhY2V0KGxpbnRDb25maWcpLm1hcmtlckZpbHRlcjtcbiAgICAgICAgaWYgKGRpYWdub3N0aWNGaWx0ZXIpXG4gICAgICAgICAgICBtYXJrZWREaWFnbm9zdGljcyA9IGRpYWdub3N0aWNGaWx0ZXIobWFya2VkRGlhZ25vc3RpY3MsIHN0YXRlJDEpO1xuICAgICAgICBsZXQgc29ydGVkID0gZGlhZ25vc3RpY3Muc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20gfHwgYS50byAtIGIudG8pO1xuICAgICAgICBsZXQgZGVjbyA9IG5ldyBzdGF0ZS5SYW5nZVNldEJ1aWxkZXIoKSwgYWN0aXZlID0gW10sIHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSBzb3J0ZWQubGVuZ3RoID8gbnVsbCA6IHNvcnRlZFtpXTtcbiAgICAgICAgICAgIGlmICghbmV4dCAmJiAhYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IHBvcztcbiAgICAgICAgICAgICAgICB0byA9IGFjdGl2ZS5yZWR1Y2UoKHAsIGQpID0+IE1hdGgubWluKHAsIGQudG8pLCBuZXh0ICYmIG5leHQuZnJvbSA+IGZyb20gPyBuZXh0LmZyb20gOiAxZTgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IG5leHQuZnJvbTtcbiAgICAgICAgICAgICAgICB0byA9IG5leHQudG87XG4gICAgICAgICAgICAgICAgYWN0aXZlLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPCBzb3J0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBzb3J0ZWRbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA9PSBmcm9tICYmIChuZXh0LnRvID4gbmV4dC5mcm9tIHx8IG5leHQudG8gPT0gZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbihuZXh0LnRvLCB0byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKG5leHQuZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2V2ID0gbWF4U2V2ZXJpdHkoYWN0aXZlKTtcbiAgICAgICAgICAgIGlmIChhY3RpdmUuc29tZShkID0+IGQuZnJvbSA9PSBkLnRvIHx8IChkLmZyb20gPT0gZC50byAtIDEgJiYgc3RhdGUkMS5kb2MubGluZUF0KGQuZnJvbSkudG8gPT0gZC5mcm9tKSkpIHtcbiAgICAgICAgICAgICAgICBkZWNvLmFkZChmcm9tLCBmcm9tLCB2aWV3LkRlY29yYXRpb24ud2lkZ2V0KHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgRGlhZ25vc3RpY1dpZGdldChzZXYpLFxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljczogYWN0aXZlLnNsaWNlKClcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya0NsYXNzID0gYWN0aXZlLnJlZHVjZSgoYywgZCkgPT4gZC5tYXJrQ2xhc3MgPyBjICsgXCIgXCIgKyBkLm1hcmtDbGFzcyA6IGMsIFwiXCIpO1xuICAgICAgICAgICAgICAgIGRlY28uYWRkKGZyb20sIHRvLCB2aWV3LkRlY29yYXRpb24ubWFyayh7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImNtLWxpbnRSYW5nZSBjbS1saW50UmFuZ2UtXCIgKyBzZXYgKyBtYXJrQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzOiBhY3RpdmUuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlRW5kOiBhY3RpdmUuc29tZShhID0+IGEudG8gPiB0bylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPD0gcG9zKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNldCA9IGRlY28uZmluaXNoKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGludFN0YXRlKHNldCwgcGFuZWwsIGZpbmREaWFnbm9zdGljKHNldCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmREaWFnbm9zdGljKGRpYWdub3N0aWNzLCBkaWFnbm9zdGljID0gbnVsbCwgYWZ0ZXIgPSAwKSB7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBkaWFnbm9zdGljcy5iZXR3ZWVuKGFmdGVyLCAxZTksIChmcm9tLCB0bywgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgaWYgKGRpYWdub3N0aWMgJiYgc3BlYy5kaWFnbm9zdGljcy5pbmRleE9mKGRpYWdub3N0aWMpIDwgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIGZvdW5kID0gbmV3IFNlbGVjdGVkRGlhZ25vc3RpYyhmcm9tLCB0bywgZGlhZ25vc3RpYyB8fCBzcGVjLmRpYWdub3N0aWNzWzBdKTtcbiAgICAgICAgZWxzZSBpZiAoc3BlYy5kaWFnbm9zdGljcy5pbmRleE9mKGZvdW5kLmRpYWdub3N0aWMpIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm91bmQgPSBuZXcgU2VsZWN0ZWREaWFnbm9zdGljKGZvdW5kLmZyb20sIHRvLCBmb3VuZC5kaWFnbm9zdGljKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBoaWRlVG9vbHRpcCh0ciwgdG9vbHRpcCkge1xuICAgIGxldCBmcm9tID0gdG9vbHRpcC5wb3MsIHRvID0gdG9vbHRpcC5lbmQgfHwgZnJvbTtcbiAgICBsZXQgcmVzdWx0ID0gdHIuc3RhdGUuZmFjZXQobGludENvbmZpZykuaGlkZU9uKHRyLCBmcm9tLCB0byk7XG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGxldCBsaW5lID0gdHIuc3RhcnRTdGF0ZS5kb2MubGluZUF0KHRvb2x0aXAucG9zKTtcbiAgICByZXR1cm4gISEodHIuZWZmZWN0cy5zb21lKGUgPT4gZS5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHx8IHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGxpbmUuZnJvbSwgTWF0aC5tYXgobGluZS50bywgdG8pKSk7XG59XG5mdW5jdGlvbiBtYXliZUVuYWJsZUxpbnQoc3RhdGUkMSwgZWZmZWN0cykge1xuICAgIHJldHVybiBzdGF0ZSQxLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpID8gZWZmZWN0cyA6IGVmZmVjdHMuY29uY2F0KHN0YXRlLlN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihsaW50RXh0ZW5zaW9ucykpO1xufVxuLyoqXG5SZXR1cm5zIGEgdHJhbnNhY3Rpb24gc3BlYyB3aGljaCB1cGRhdGVzIHRoZSBjdXJyZW50IHNldCBvZlxuZGlhZ25vc3RpY3MsIGFuZCBlbmFibGVzIHRoZSBsaW50IGV4dGVuc2lvbiBpZiBpZiB3YXNuJ3QgYWxyZWFkeVxuYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIHNldERpYWdub3N0aWNzKHN0YXRlLCBkaWFnbm9zdGljcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVmZmVjdHM6IG1heWJlRW5hYmxlTGludChzdGF0ZSwgW3NldERpYWdub3N0aWNzRWZmZWN0Lm9mKGRpYWdub3N0aWNzKV0pXG4gICAgfTtcbn1cbi8qKlxuVGhlIHN0YXRlIGVmZmVjdCB0aGF0IHVwZGF0ZXMgdGhlIHNldCBvZiBhY3RpdmUgZGlhZ25vc3RpY3MuIENhblxuYmUgdXNlZnVsIHdoZW4gd3JpdGluZyBhbiBleHRlbnNpb24gdGhhdCBuZWVkcyB0byB0cmFjayB0aGVzZS5cbiovXG5jb25zdCBzZXREaWFnbm9zdGljc0VmZmVjdCA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgdG9nZ2xlUGFuZWwgPSBzdGF0ZS5TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IG1vdmVQYW5lbFNlbGVjdGlvbiA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgbGludFN0YXRlID0gc3RhdGUuU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW50U3RhdGUodmlldy5EZWNvcmF0aW9uLm5vbmUsIG51bGwsIG51bGwpO1xuICAgIH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBpZiAodHIuZG9jQ2hhbmdlZCAmJiB2YWx1ZS5kaWFnbm9zdGljcy5zaXplKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdmFsdWUuZGlhZ25vc3RpY3MubWFwKHRyLmNoYW5nZXMpLCBzZWxlY3RlZCA9IG51bGwsIHBhbmVsID0gdmFsdWUucGFuZWw7XG4gICAgICAgICAgICBpZiAodmFsdWUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsUG9zID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUuc2VsZWN0ZWQuZnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBmaW5kRGlhZ25vc3RpYyhtYXBwZWQsIHZhbHVlLnNlbGVjdGVkLmRpYWdub3N0aWMsIHNlbFBvcykgfHwgZmluZERpYWdub3N0aWMobWFwcGVkLCBudWxsLCBzZWxQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXBwZWQuc2l6ZSAmJiBwYW5lbCAmJiB0ci5zdGF0ZS5mYWNldChsaW50Q29uZmlnKS5hdXRvUGFuZWwpXG4gICAgICAgICAgICAgICAgcGFuZWwgPSBudWxsO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKG1hcHBlZCwgcGFuZWwsIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFuZWwgPSAhdHIuc3RhdGUuZmFjZXQobGludENvbmZpZykuYXV0b1BhbmVsID8gdmFsdWUucGFuZWwgOiBlZmZlY3QudmFsdWUubGVuZ3RoID8gTGludFBhbmVsLm9wZW4gOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTGludFN0YXRlLmluaXQoZWZmZWN0LnZhbHVlLCBwYW5lbCwgdHIuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHRvZ2dsZVBhbmVsKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZSh2YWx1ZS5kaWFnbm9zdGljcywgZWZmZWN0LnZhbHVlID8gTGludFBhbmVsLm9wZW4gOiBudWxsLCB2YWx1ZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMobW92ZVBhbmVsU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZSh2YWx1ZS5kaWFnbm9zdGljcywgdmFsdWUucGFuZWwsIGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBbdmlldy5zaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsLnBhbmVsKSxcbiAgICAgICAgdmlldy5FZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiwgcyA9PiBzLmRpYWdub3N0aWNzKV1cbn0pO1xuLyoqXG5SZXR1cm5zIHRoZSBudW1iZXIgb2YgYWN0aXZlIGxpbnQgZGlhZ25vc3RpY3MgaW4gdGhlIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGRpYWdub3N0aWNDb3VudChzdGF0ZSkge1xuICAgIGxldCBsaW50ID0gc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGxpbnQgPyBsaW50LmRpYWdub3N0aWNzLnNpemUgOiAwO1xufVxuY29uc3QgYWN0aXZlTWFyayA9IHZpZXcuRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbGludFJhbmdlIGNtLWxpbnRSYW5nZS1hY3RpdmVcIiB9KTtcbmZ1bmN0aW9uIGxpbnRUb29sdGlwKHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCB7IGRpYWdub3N0aWNzIH0gPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgbGV0IGZvdW5kLCBzdGFydCA9IC0xLCBlbmQgPSAtMTtcbiAgICBkaWFnbm9zdGljcy5iZXR3ZWVuKHBvcyAtIChzaWRlIDwgMCA/IDEgOiAwKSwgcG9zICsgKHNpZGUgPiAwID8gMSA6IDApLCAoZnJvbSwgdG8sIHsgc3BlYyB9KSA9PiB7XG4gICAgICAgIGlmIChwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8gJiZcbiAgICAgICAgICAgIChmcm9tID09IHRvIHx8ICgocG9zID4gZnJvbSB8fCBzaWRlID4gMCkgJiYgKHBvcyA8IHRvIHx8IHNpZGUgPCAwKSkpKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHNwZWMuZGlhZ25vc3RpY3M7XG4gICAgICAgICAgICBzdGFydCA9IGZyb207XG4gICAgICAgICAgICBlbmQgPSB0bztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gdmlldy5zdGF0ZS5mYWNldChsaW50Q29uZmlnKS50b29sdGlwRmlsdGVyO1xuICAgIGlmIChmb3VuZCAmJiBkaWFnbm9zdGljRmlsdGVyKVxuICAgICAgICBmb3VuZCA9IGRpYWdub3N0aWNGaWx0ZXIoZm91bmQsIHZpZXcuc3RhdGUpO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvczogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICBhYm92ZTogdmlldy5zdGF0ZS5kb2MubGluZUF0KHN0YXJ0KS50byA8IGVuZCxcbiAgICAgICAgY3JlYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZm91bmQpIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZGlhZ25vc3RpY3NUb29sdGlwKHZpZXcsIGRpYWdub3N0aWNzKSB7XG4gICAgcmV0dXJuIGVsdChcInVsXCIsIHsgY2xhc3M6IFwiY20tdG9vbHRpcC1saW50XCIgfSwgZGlhZ25vc3RpY3MubWFwKGQgPT4gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkLCBmYWxzZSkpKTtcbn1cbi8qKlxuQ29tbWFuZCB0byBvcGVuIGFuZCBmb2N1cyB0aGUgbGludCBwYW5lbC5cbiovXG5jb25zdCBvcGVuTGludFBhbmVsID0gKHZpZXckMSkgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXckMS5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5wYW5lbClcbiAgICAgICAgdmlldyQxLmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGVMaW50KHZpZXckMS5zdGF0ZSwgW3RvZ2dsZVBhbmVsLm9mKHRydWUpXSkgfSk7XG4gICAgbGV0IHBhbmVsID0gdmlldy5nZXRQYW5lbCh2aWV3JDEsIExpbnRQYW5lbC5vcGVuKTtcbiAgICBpZiAocGFuZWwpXG4gICAgICAgIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXBhbmVsLWxpbnQgdWxcIikuZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNvbW1hbmQgdG8gY2xvc2UgdGhlIGxpbnQgcGFuZWwsIHdoZW4gb3Blbi5cbiovXG5jb25zdCBjbG9zZUxpbnRQYW5lbCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5wYW5lbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0b2dnbGVQYW5lbC5vZihmYWxzZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgZGlhZ25vc3RpYy5cbiovXG5jb25zdCBuZXh0RGlhZ25vc3RpYyA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4sIG5leHQgPSBmaWVsZC5kaWFnbm9zdGljcy5pdGVyKHNlbC50byArIDEpO1xuICAgIGlmICghbmV4dC52YWx1ZSkge1xuICAgICAgICBuZXh0ID0gZmllbGQuZGlhZ25vc3RpY3MuaXRlcigwKTtcbiAgICAgICAgaWYgKCFuZXh0LnZhbHVlIHx8IG5leHQuZnJvbSA9PSBzZWwuZnJvbSAmJiBuZXh0LnRvID09IHNlbC50bylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IG5leHQuZnJvbSwgaGVhZDogbmV4dC50byB9LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgZGlhZ25vc3RpYy5cbiovXG5jb25zdCBwcmV2aW91c0RpYWdub3N0aWMgPSAodmlldykgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHByZXZGcm9tLCBwcmV2VG8sIGxhc3RGcm9tLCBsYXN0VG87XG4gICAgZmllbGQuZGlhZ25vc3RpY3MuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgaWYgKHRvIDwgc2VsLnRvICYmIChwcmV2RnJvbSA9PSBudWxsIHx8IHByZXZGcm9tIDwgZnJvbSkpIHtcbiAgICAgICAgICAgIHByZXZGcm9tID0gZnJvbTtcbiAgICAgICAgICAgIHByZXZUbyA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0RnJvbSA9PSBudWxsIHx8IGZyb20gPiBsYXN0RnJvbSkge1xuICAgICAgICAgICAgbGFzdEZyb20gPSBmcm9tO1xuICAgICAgICAgICAgbGFzdFRvID0gdG87XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobGFzdEZyb20gPT0gbnVsbCB8fCBwcmV2RnJvbSA9PSBudWxsICYmIGxhc3RGcm9tID09IHNlbC5mcm9tKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IHByZXZGcm9tICE9PSBudWxsICYmIHByZXZGcm9tICE9PSB2b2lkIDAgPyBwcmV2RnJvbSA6IGxhc3RGcm9tLCBoZWFkOiBwcmV2VG8gIT09IG51bGwgJiYgcHJldlRvICE9PSB2b2lkIDAgPyBwcmV2VG8gOiBsYXN0VG8gfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BIHNldCBvZiBkZWZhdWx0IGtleSBiaW5kaW5ncyBmb3IgdGhlIGxpbnQgZnVuY3Rpb25hbGl0eS5cblxuLSBDdHJsLVNoaWZ0LW0gKENtZC1TaGlmdC1tIG9uIG1hY09TKTogW2BvcGVuTGludFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50Lm9wZW5MaW50UGFuZWwpXG4tIEY4OiBbYG5leHREaWFnbm9zdGljYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50Lm5leHREaWFnbm9zdGljKVxuKi9cbmNvbnN0IGxpbnRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LW1cIiwgcnVuOiBvcGVuTGludFBhbmVsLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkY4XCIsIHJ1bjogbmV4dERpYWdub3N0aWMgfVxuXTtcbmNvbnN0IGxpbnRQbHVnaW4gPSB2aWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnNldCA9IHRydWU7XG4gICAgICAgIGxldCB7IGRlbGF5IH0gPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRDb25maWcpO1xuICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKSArIGRlbGF5O1xuICAgICAgICB0aGlzLnJ1biA9IHRoaXMucnVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5ydW4sIGRlbGF5KTtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgPCB0aGlzLmxpbnRUaW1lIC0gMTApIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5ydW4sIHRoaXMubGludFRpbWUgLSBub3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIHsgc291cmNlcyB9ID0gc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgICAgICBpZiAoc291cmNlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYmF0Y2hSZXN1bHRzKHNvdXJjZXMubWFwKHMgPT4gUHJvbWlzZS5yZXNvbHZlKHModGhpcy52aWV3KSkpLCBhbm5vdGF0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jID09IHN0YXRlLmRvYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaChzZXREaWFnbm9zdGljcyh0aGlzLnZpZXcuc3RhdGUsIGFubm90YXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpKSk7XG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4geyB2aWV3LmxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycm9yKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY29uZmlnID0gdXBkYXRlLnN0YXRlLmZhY2V0KGxpbnRDb25maWcpO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgY29uZmlnICE9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxpbnRDb25maWcpIHx8XG4gICAgICAgICAgICBjb25maWcubmVlZHNSZWZyZXNoICYmIGNvbmZpZy5uZWVkc1JlZnJlc2godXBkYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5saW50VGltZSA9IERhdGUubm93KCkgKyBjb25maWcuZGVsYXk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5ydW4sIGNvbmZpZy5kZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnNldCkge1xuICAgICAgICAgICAgdGhpcy5saW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gYmF0Y2hSZXN1bHRzKHByb21pc2VzLCBzaW5rLCBlcnJvcikge1xuICAgIGxldCBjb2xsZWN0ZWQgPSBbXSwgdGltZW91dCA9IC0xO1xuICAgIGZvciAobGV0IHAgb2YgcHJvbWlzZXMpXG4gICAgICAgIHAudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBjb2xsZWN0ZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICBpZiAoY29sbGVjdGVkLmxlbmd0aCA9PSBwcm9taXNlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgc2luayhjb2xsZWN0ZWQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNpbmsoY29sbGVjdGVkKSwgMjAwKTtcbiAgICAgICAgfSwgZXJyb3IpO1xufVxuY29uc3QgbGludENvbmZpZyA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHNvdXJjZXM6IGlucHV0Lm1hcChpID0+IGkuc291cmNlKS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpIH0sIHN0YXRlLmNvbWJpbmVDb25maWcoaW5wdXQubWFwKGkgPT4gaS5jb25maWcpLCB7XG4gICAgICAgICAgICBkZWxheTogNzUwLFxuICAgICAgICAgICAgbWFya2VyRmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgdG9vbHRpcEZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIG5lZWRzUmVmcmVzaDogbnVsbCxcbiAgICAgICAgICAgIGhpZGVPbjogKCkgPT4gbnVsbCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmVlZHNSZWZyZXNoOiAoYSwgYikgPT4gIWEgPyBiIDogIWIgPyBhIDogdSA9PiBhKHUpIHx8IGIodSlcbiAgICAgICAgfSkpO1xuICAgIH1cbn0pO1xuLyoqXG5HaXZlbiBhIGRpYWdub3N0aWMgc291cmNlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXRcbmVuYWJsZXMgbGludGluZyB3aXRoIHRoYXQgc291cmNlLiBJdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGVcbmVkaXRvciBpcyBpZGxlIChhZnRlciBpdHMgY29udGVudCBjaGFuZ2VkKS4gSWYgYG51bGxgIGlzIGdpdmVuIGFzXG5zb3VyY2UsIHRoaXMgb25seSBjb25maWd1cmVzIHRoZSBsaW50IGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBsaW50ZXIoc291cmNlLCBjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGxpbnRDb25maWcub2YoeyBzb3VyY2UsIGNvbmZpZyB9KSxcbiAgICAgICAgbGludFBsdWdpbixcbiAgICAgICAgbGludEV4dGVuc2lvbnNcbiAgICBdO1xufVxuLyoqXG5Gb3JjZXMgYW55IGxpbnRlcnMgW2NvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5saW50ZXIpIHRvIHJ1biB3aGVuIHRoZVxuZWRpdG9yIGlzIGlkbGUgdG8gcnVuIHJpZ2h0IGF3YXkuXG4qL1xuZnVuY3Rpb24gZm9yY2VMaW50aW5nKHZpZXcpIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4obGludFBsdWdpbik7XG4gICAgaWYgKHBsdWdpbilcbiAgICAgICAgcGx1Z2luLmZvcmNlKCk7XG59XG5mdW5jdGlvbiBhc3NpZ25LZXlzKGFjdGlvbnMpIHtcbiAgICBsZXQgYXNzaWduZWQgPSBbXTtcbiAgICBpZiAoYWN0aW9ucylcbiAgICAgICAgYWN0aW9uczogZm9yIChsZXQgeyBuYW1lIH0gb2YgYWN0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gbmFtZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoL1thLXpBLVpdLy50ZXN0KGNoKSAmJiAhYXNzaWduZWQuc29tZShjID0+IGMudG9Mb3dlckNhc2UoKSA9PSBjaC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgYWN0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25lZC5wdXNoKFwiXCIpO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGFzc2lnbmVkO1xufVxuZnVuY3Rpb24gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkaWFnbm9zdGljLCBpblBhbmVsKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBrZXlzID0gaW5QYW5lbCA/IGFzc2lnbktleXMoZGlhZ25vc3RpYy5hY3Rpb25zKSA6IFtdO1xuICAgIHJldHVybiBlbHQoXCJsaVwiLCB7IGNsYXNzOiBcImNtLWRpYWdub3N0aWMgY20tZGlhZ25vc3RpYy1cIiArIGRpYWdub3N0aWMuc2V2ZXJpdHkgfSwgZWx0KFwic3BhblwiLCB7IGNsYXNzOiBcImNtLWRpYWdub3N0aWNUZXh0XCIgfSwgZGlhZ25vc3RpYy5yZW5kZXJNZXNzYWdlID8gZGlhZ25vc3RpYy5yZW5kZXJNZXNzYWdlKHZpZXcpIDogZGlhZ25vc3RpYy5tZXNzYWdlKSwgKF9hID0gZGlhZ25vc3RpYy5hY3Rpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChhY3Rpb24sIGkpID0+IHtcbiAgICAgICAgbGV0IGZpcmVkID0gZmFsc2UsIGNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChmaXJlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmaW5kRGlhZ25vc3RpYyh2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgIGFjdGlvbi5hcHBseSh2aWV3LCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IG5hbWUgfSA9IGFjdGlvbiwga2V5SW5kZXggPSBrZXlzW2ldID8gbmFtZS5pbmRleE9mKGtleXNbaV0pIDogLTE7XG4gICAgICAgIGxldCBuYW1lRWx0ID0ga2V5SW5kZXggPCAwID8gbmFtZSA6IFtuYW1lLnNsaWNlKDAsIGtleUluZGV4KSxcbiAgICAgICAgICAgIGVsdChcInVcIiwgbmFtZS5zbGljZShrZXlJbmRleCwga2V5SW5kZXggKyAxKSksXG4gICAgICAgICAgICBuYW1lLnNsaWNlKGtleUluZGV4ICsgMSldO1xuICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBjbGFzczogXCJjbS1kaWFnbm9zdGljQWN0aW9uXCIsXG4gICAgICAgICAgICBvbmNsaWNrOiBjbGljayxcbiAgICAgICAgICAgIG9ubW91c2Vkb3duOiBjbGljayxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBgIEFjdGlvbjogJHtuYW1lfSR7a2V5SW5kZXggPCAwID8gXCJcIiA6IGAgKGFjY2VzcyBrZXkgXCIke2tleXNbaV19KVwiYH0uYFxuICAgICAgICB9LCBuYW1lRWx0KTtcbiAgICB9KSwgZGlhZ25vc3RpYy5zb3VyY2UgJiYgZWx0KFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpY1NvdXJjZVwiIH0sIGRpYWdub3N0aWMuc291cmNlKSk7XG59XG5jbGFzcyBEaWFnbm9zdGljV2lkZ2V0IGV4dGVuZHMgdmlldy5XaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXYpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXYgPSBzZXY7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5zZXYgPT0gdGhpcy5zZXY7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgcmV0dXJuIGVsdChcInNwYW5cIiwgeyBjbGFzczogXCJjbS1saW50UG9pbnQgY20tbGludFBvaW50LVwiICsgdGhpcy5zZXYgfSk7XG4gICAgfVxufVxuY2xhc3MgUGFuZWxJdGVtIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBkaWFnbm9zdGljKSB7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IGRpYWdub3N0aWM7XG4gICAgICAgIHRoaXMuaWQgPSBcIml0ZW1fXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIHRoaXMuZG9tID0gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkaWFnbm9zdGljLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kb20uaWQgPSB0aGlzLmlkO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xuICAgIH1cbn1cbmNsYXNzIExpbnRQYW5lbCB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIGxldCBvbmtleWRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KSB7IC8vIEVzY2FwZVxuICAgICAgICAgICAgICAgIGNsb3NlTGludFBhbmVsKHRoaXMudmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM4IHx8IGV2ZW50LmtleUNvZGUgPT0gMzMpIHsgLy8gQXJyb3dVcCwgUGFnZVVwXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKCh0aGlzLnNlbGVjdGVkSW5kZXggLSAxICsgdGhpcy5pdGVtcy5sZW5ndGgpICUgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSA0MCB8fCBldmVudC5rZXlDb2RlID09IDM0KSB7IC8vIEFycm93RG93biwgUGFnZURvd25cbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oKHRoaXMuc2VsZWN0ZWRJbmRleCArIDEpICUgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNikgeyAvLyBIb21lXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNSkgeyAvLyBFbmRcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24odGhpcy5pdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPj0gNjUgJiYgZXZlbnQua2V5Q29kZSA8PSA5MCAmJiB0aGlzLnNlbGVjdGVkSW5kZXggPj0gMCkgeyAvLyBBLVpcbiAgICAgICAgICAgICAgICBsZXQgeyBkaWFnbm9zdGljIH0gPSB0aGlzLml0ZW1zW3RoaXMuc2VsZWN0ZWRJbmRleF0sIGtleXMgPSBhc3NpZ25LZXlzKGRpYWdub3N0aWMuYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tpXS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCkgPT0gZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmluZERpYWdub3N0aWModGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWMuYWN0aW9uc1tpXS5hcHBseSh2aWV3LCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBvbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tpXS5kb20uY29udGFpbnMoZXZlbnQudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3QgPSBlbHQoXCJ1bFwiLCB7XG4gICAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICAgIHJvbGU6IFwibGlzdGJveFwiLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJEaWFnbm9zdGljc1wiKSxcbiAgICAgICAgICAgIG9ua2V5ZG93bixcbiAgICAgICAgICAgIG9uY2xpY2tcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9tID0gZWx0KFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tcGFuZWwtbGludFwiIH0sIHRoaXMubGlzdCwgZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBuYW1lOiBcImNsb3NlXCIsXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogdGhpcy52aWV3LnN0YXRlLnBocmFzZShcImNsb3NlXCIpLFxuICAgICAgICAgICAgb25jbGljazogKCkgPT4gY2xvc2VMaW50UGFuZWwodGhpcy52aWV3KVxuICAgICAgICB9LCBcIsOXXCIpKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpLnNlbGVjdGVkO1xuICAgICAgICBpZiAoIXNlbGVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tpXS5kaWFnbm9zdGljID09IHNlbGVjdGVkLmRpYWdub3N0aWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeyBkaWFnbm9zdGljcywgc2VsZWN0ZWQgfSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgICAgICBsZXQgaSA9IDAsIG5lZWRzU3luYyA9IGZhbHNlLCBuZXdTZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgICBsZXQgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgZGlhZ25vc3RpY3MuYmV0d2VlbigwLCB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgKF9zdGFydCwgX2VuZCwgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGRpYWdub3N0aWMgb2Ygc3BlYy5kaWFnbm9zdGljcykge1xuICAgICAgICAgICAgICAgIGlmIChzZWVuLmhhcyhkaWFnbm9zdGljKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgc2Vlbi5hZGQoZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gLTEsIGl0ZW07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCB0aGlzLml0ZW1zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tqXS5kaWFnbm9zdGljID09IGRpYWdub3N0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gbmV3IFBhbmVsSXRlbSh0aGlzLnZpZXcsIGRpYWdub3N0aWMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCAwLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgZm91bmQgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkICYmIGl0ZW0uZGlhZ25vc3RpYyA9PSBzZWxlY3RlZC5kaWFnbm9zdGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5kb20uaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uZG9tLmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kb20ucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLml0ZW1zLmxlbmd0aCAmJiAhKHRoaXMuaXRlbXMubGVuZ3RoID09IDEgJiYgdGhpcy5pdGVtc1swXS5kaWFnbm9zdGljLmZyb20gPCAwKSkge1xuICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgUGFuZWxJdGVtKHRoaXMudmlldywge1xuICAgICAgICAgICAgICAgIGZyb206IC0xLCB0bzogLTEsXG4gICAgICAgICAgICAgICAgc2V2ZXJpdHk6IFwiaW5mb1wiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJObyBkaWFnbm9zdGljc1wiKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3Quc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIG5ld1NlbGVjdGVkSXRlbS5pZCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoe1xuICAgICAgICAgICAgICAgIGtleTogdGhpcyxcbiAgICAgICAgICAgICAgICByZWFkOiAoKSA9PiAoeyBzZWw6IG5ld1NlbGVjdGVkSXRlbS5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHBhbmVsOiB0aGlzLmxpc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfSksXG4gICAgICAgICAgICAgICAgd3JpdGU6ICh7IHNlbCwgcGFuZWwgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2NhbGVZID0gcGFuZWwuaGVpZ2h0IC8gdGhpcy5saXN0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbC50b3AgPCBwYW5lbC50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3Quc2Nyb2xsVG9wIC09IChwYW5lbC50b3AgLSBzZWwudG9wKSAvIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsLmJvdHRvbSA+IHBhbmVsLmJvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb3AgKz0gKHNlbC5ib3R0b20gLSBwYW5lbC5ib3R0b20pIC8gc2NhbGVZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzU3luYylcbiAgICAgICAgICAgIHRoaXMuc3luYygpO1xuICAgIH1cbiAgICBzeW5jKCkge1xuICAgICAgICBsZXQgZG9tUG9zID0gdGhpcy5saXN0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZ1bmN0aW9uIHJtKCkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBkb21Qb3M7XG4gICAgICAgICAgICBkb21Qb3MgPSBwcmV2Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgcHJldi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmRvbS5wYXJlbnROb2RlID09IHRoaXMubGlzdCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChkb21Qb3MgIT0gaXRlbS5kb20pXG4gICAgICAgICAgICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgICAgICAgZG9tUG9zID0gaXRlbS5kb20ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3QuaW5zZXJ0QmVmb3JlKGl0ZW0uZG9tLCBkb21Qb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkb21Qb3MpXG4gICAgICAgICAgICBybSgpO1xuICAgIH1cbiAgICBtb3ZlU2VsZWN0aW9uKHNlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBmaWVsZCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gZmluZERpYWdub3N0aWMoZmllbGQuZGlhZ25vc3RpY3MsIHRoaXMuaXRlbXNbc2VsZWN0ZWRJbmRleF0uZGlhZ25vc3RpYyk7XG4gICAgICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogc2VsZWN0aW9uLmZyb20sIGhlYWQ6IHNlbGVjdGlvbi50byB9LFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICBlZmZlY3RzOiBtb3ZlUGFuZWxTZWxlY3Rpb24ub2Yoc2VsZWN0aW9uKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIG9wZW4odmlldykgeyByZXR1cm4gbmV3IExpbnRQYW5lbCh2aWV3KTsgfVxufVxuZnVuY3Rpb24gc3ZnKGNvbnRlbnQsIGF0dHJzID0gYHZpZXdCb3g9XCIwIDAgNDAgNDBcImApIHtcbiAgICByZXR1cm4gYHVybCgnZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiICR7YXR0cnN9PiR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvbnRlbnQpfTwvc3ZnPicpYDtcbn1cbmZ1bmN0aW9uIHVuZGVybGluZShjb2xvcikge1xuICAgIHJldHVybiBzdmcoYDxwYXRoIGQ9XCJtMCAyLjUgbDIgLTEuNSBsMSAwIGwyIDEuNSBsMSAwXCIgc3Ryb2tlPVwiJHtjb2xvcn1cIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIi43XCIvPmAsIGB3aWR0aD1cIjZcIiBoZWlnaHQ9XCIzXCJgKTtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IHZpZXcuRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWRpYWdub3N0aWNcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjNweCA2cHggM3B4IDhweFwiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0xcHhcIixcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcInByZS13cmFwXCJcbiAgICB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtZXJyb3JcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCAjZDExXCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLXdhcm5pbmdcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCBvcmFuZ2VcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtaW5mb1wiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkICM5OTlcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtaGludFwiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkICM2NmRcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWNBY3Rpb25cIjoge1xuICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgcGFkZGluZzogXCIycHggNHB4XCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjNDQ0XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIzcHhcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCI4cHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpY1NvdXJjZVwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBvcGFjaXR5OiAuN1xuICAgIH0sXG4gICAgXCIuY20tbGludFJhbmdlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBcImxlZnQgYm90dG9tXCIsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwicmVwZWF0LXhcIixcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogXCIwLjdweFwiLFxuICAgIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWVycm9yXCI6IHsgYmFja2dyb3VuZEltYWdlOiB1bmRlcmxpbmUoXCIjZDExXCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLXdhcm5pbmdcIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IHVuZGVybGluZShcIm9yYW5nZVwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1pbmZvXCI6IHsgYmFja2dyb3VuZEltYWdlOiB1bmRlcmxpbmUoXCIjOTk5XCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWhpbnRcIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IHVuZGVybGluZShcIiM2NmRcIikgfSxcbiAgICBcIi5jbS1saW50UmFuZ2UtYWN0aXZlXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmRkOTk4MFwiIH0sXG4gICAgXCIuY20tdG9vbHRpcC1saW50XCI6IHtcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgbWFyZ2luOiAwXG4gICAgfSxcbiAgICBcIi5jbS1saW50UG9pbnRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIGxlZnQ6IFwiLTJweFwiLFxuICAgICAgICAgICAgYm9yZGVyTGVmdDogXCIzcHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBcIjNweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBcIjRweCBzb2xpZCAjZDExXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50LXdhcm5pbmdcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBib3JkZXJCb3R0b21Db2xvcjogXCJvcmFuZ2VcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1saW50UG9pbnQtaW5mb1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGJvcmRlckJvdHRvbUNvbG9yOiBcIiM5OTlcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1saW50UG9pbnQtaGludFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGJvcmRlckJvdHRvbUNvbG9yOiBcIiM2NmRcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1wYW5lbC5jbS1wYW5lbC1saW50XCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImIHVsXCI6IHtcbiAgICAgICAgICAgIG1heEhlaWdodDogXCIxMDBweFwiLFxuICAgICAgICAgICAgb3ZlcmZsb3dZOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwiJiBbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZGRkXCIsXG4gICAgICAgICAgICAgICAgXCImIHVcIjogeyB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIiB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmZvY3VzIFthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZF9mYWxsYmFjazogXCIjYmRmXCIsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIkhpZ2hsaWdodFwiLFxuICAgICAgICAgICAgICAgIGNvbG9yX2ZhbGxiYWNrOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiSGlnaGxpZ2h0VGV4dFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImIHVcIjogeyB0ZXh0RGVjb3JhdGlvbjogXCJub25lXCIgfSxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgfSxcbiAgICAgICAgXCImIFtuYW1lPWNsb3NlXVwiOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgdG9wOiBcIjBcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcIjJweFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH1cbiAgICB9XG59KTtcbmZ1bmN0aW9uIHNldmVyaXR5V2VpZ2h0KHNldikge1xuICAgIHJldHVybiBzZXYgPT0gXCJlcnJvclwiID8gNCA6IHNldiA9PSBcIndhcm5pbmdcIiA/IDMgOiBzZXYgPT0gXCJpbmZvXCIgPyAyIDogMTtcbn1cbmZ1bmN0aW9uIG1heFNldmVyaXR5KGRpYWdub3N0aWNzKSB7XG4gICAgbGV0IHNldiA9IFwiaGludFwiLCB3ZWlnaHQgPSAxO1xuICAgIGZvciAobGV0IGQgb2YgZGlhZ25vc3RpY3MpIHtcbiAgICAgICAgbGV0IHcgPSBzZXZlcml0eVdlaWdodChkLnNldmVyaXR5KTtcbiAgICAgICAgaWYgKHcgPiB3ZWlnaHQpIHtcbiAgICAgICAgICAgIHdlaWdodCA9IHc7XG4gICAgICAgICAgICBzZXYgPSBkLnNldmVyaXR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXY7XG59XG5jbGFzcyBMaW50R3V0dGVyTWFya2VyIGV4dGVuZHMgdmlldy5HdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKGRpYWdub3N0aWNzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgdGhpcy5zZXZlcml0eSA9IG1heFNldmVyaXR5KGRpYWdub3N0aWNzKTtcbiAgICB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IFwiY20tbGludC1tYXJrZXIgY20tbGludC1tYXJrZXItXCIgKyB0aGlzLnNldmVyaXR5O1xuICAgICAgICBsZXQgZGlhZ25vc3RpY3MgPSB0aGlzLmRpYWdub3N0aWNzO1xuICAgICAgICBsZXQgZGlhZ25vc3RpY3NGaWx0ZXIgPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpLnRvb2x0aXBGaWx0ZXI7XG4gICAgICAgIGlmIChkaWFnbm9zdGljc0ZpbHRlcilcbiAgICAgICAgICAgIGRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3NGaWx0ZXIoZGlhZ25vc3RpY3MsIHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAoZGlhZ25vc3RpY3MubGVuZ3RoKVxuICAgICAgICAgICAgZWx0Lm9ubW91c2VvdmVyID0gKCkgPT4gZ3V0dGVyTWFya2VyTW91c2VPdmVyKHZpZXcsIGVsdCwgZGlhZ25vc3RpY3MpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYWNrSG92ZXJPbih2aWV3LCBtYXJrZXIpIHtcbiAgICBsZXQgbW91c2Vtb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCByZWN0ID0gbWFya2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoZXZlbnQuY2xpZW50WCA+IHJlY3QubGVmdCAtIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJiBldmVudC5jbGllbnRYIDwgcmVjdC5yaWdodCArIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJlxuICAgICAgICAgICAgZXZlbnQuY2xpZW50WSA+IHJlY3QudG9wIC0gMTAgLyogSG92ZXIuTWFyZ2luICovICYmIGV2ZW50LmNsaWVudFkgPCByZWN0LmJvdHRvbSArIDEwIC8qIEhvdmVyLk1hcmdpbiAqLylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0OyB0YXJnZXQ7IHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlID09IDEgJiYgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImNtLXRvb2x0aXAtbGludFwiKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2Vtb3ZlKTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmllbGQobGludEd1dHRlclRvb2x0aXApKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldExpbnRHdXR0ZXJUb29sdGlwLm9mKG51bGwpIH0pO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2Vtb3ZlKTtcbn1cbmZ1bmN0aW9uIGd1dHRlck1hcmtlck1vdXNlT3Zlcih2aWV3LCBtYXJrZXIsIGRpYWdub3N0aWNzKSB7XG4gICAgZnVuY3Rpb24gaG92ZXJlZCgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmVsZW1lbnRBdEhlaWdodChtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgNSAtIHZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICAgICBjb25zdCBsaW5lUG9zID0gdmlldy5jb29yZHNBdFBvcyhsaW5lLmZyb20pO1xuICAgICAgICBpZiAobGluZVBvcykge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldExpbnRHdXR0ZXJUb29sdGlwLm9mKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBsaW5lLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIGFib3ZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2xpcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tOiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZGlhZ25vc3RpY3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvb3JkczogKCkgPT4gbWFya2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyLm9ubW91c2VvdXQgPSBtYXJrZXIub25tb3VzZW1vdmUgPSBudWxsO1xuICAgICAgICB0cmFja0hvdmVyT24odmlldywgbWFya2VyKTtcbiAgICB9XG4gICAgbGV0IHsgaG92ZXJUaW1lIH0gPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpO1xuICAgIGxldCBob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KGhvdmVyZWQsIGhvdmVyVGltZSk7XG4gICAgbWFya2VyLm9ubW91c2VvdXQgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVvdXQpO1xuICAgICAgICBtYXJrZXIub25tb3VzZW91dCA9IG1hcmtlci5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgfTtcbiAgICBtYXJrZXIub25tb3VzZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVvdXQpO1xuICAgICAgICBob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KGhvdmVyZWQsIGhvdmVyVGltZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtlcnNGb3JEaWFnbm9zdGljcyhkb2MsIGRpYWdub3N0aWNzKSB7XG4gICAgbGV0IGJ5TGluZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgZGlhZ25vc3RpYyBvZiBkaWFnbm9zdGljcykge1xuICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQoZGlhZ25vc3RpYy5mcm9tKTtcbiAgICAgICAgKGJ5TGluZVtsaW5lLmZyb21dIHx8IChieUxpbmVbbGluZS5mcm9tXSA9IFtdKSkucHVzaChkaWFnbm9zdGljKTtcbiAgICB9XG4gICAgbGV0IG1hcmtlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIGluIGJ5TGluZSkge1xuICAgICAgICBtYXJrZXJzLnB1c2gobmV3IExpbnRHdXR0ZXJNYXJrZXIoYnlMaW5lW2xpbmVdKS5yYW5nZSgrbGluZSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuUmFuZ2VTZXQub2YobWFya2VycywgdHJ1ZSk7XG59XG5jb25zdCBsaW50R3V0dGVyRXh0ZW5zaW9uID0gdmlldy5ndXR0ZXIoe1xuICAgIGNsYXNzOiBcImNtLWd1dHRlci1saW50XCIsXG4gICAgbWFya2VyczogdmlldyA9PiB2aWV3LnN0YXRlLmZpZWxkKGxpbnRHdXR0ZXJNYXJrZXJzKSxcbiAgICB3aWRnZXRNYXJrZXI6ICh2aWV3LCB3aWRnZXQsIGJsb2NrKSA9PiB7XG4gICAgICAgIGxldCBkaWFnbm9zdGljcyA9IFtdO1xuICAgICAgICB2aWV3LnN0YXRlLmZpZWxkKGxpbnRHdXR0ZXJNYXJrZXJzKS5iZXR3ZWVuKGJsb2NrLmZyb20sIGJsb2NrLnRvLCAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IGJsb2NrLmZyb20gJiYgZnJvbSA8IGJsb2NrLnRvKVxuICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzLnB1c2goLi4udmFsdWUuZGlhZ25vc3RpY3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzLmxlbmd0aCA/IG5ldyBMaW50R3V0dGVyTWFya2VyKGRpYWdub3N0aWNzKSA6IG51bGw7XG4gICAgfVxufSk7XG5jb25zdCBsaW50R3V0dGVyTWFya2VycyA9IHN0YXRlLlN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5SYW5nZVNldC5lbXB0eTtcbiAgICB9LFxuICAgIHVwZGF0ZShtYXJrZXJzLCB0cikge1xuICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gdHIuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZykubWFya2VyRmlsdGVyO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlhZ25vc3RpY3MgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGRpYWdub3N0aWNGaWx0ZXIpXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzID0gZGlhZ25vc3RpY0ZpbHRlcihkaWFnbm9zdGljcyB8fCBbXSwgdHIuc3RhdGUpO1xuICAgICAgICAgICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzRm9yRGlhZ25vc3RpY3ModHIuc3RhdGUuZG9jLCBkaWFnbm9zdGljcy5zbGljZSgwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfVxufSk7XG5jb25zdCBzZXRMaW50R3V0dGVyVG9vbHRpcCA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgbGludEd1dHRlclRvb2x0aXAgPSBzdGF0ZS5TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUodG9vbHRpcCwgdHIpIHtcbiAgICAgICAgaWYgKHRvb2x0aXAgJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHRvb2x0aXAgPSBoaWRlVG9vbHRpcCh0ciwgdG9vbHRpcCkgPyBudWxsIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b29sdGlwKSwgeyBwb3M6IHRyLmNoYW5nZXMubWFwUG9zKHRvb2x0aXAucG9zKSB9KTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKCh0LCBlKSA9PiBlLmlzKHNldExpbnRHdXR0ZXJUb29sdGlwKSA/IGUudmFsdWUgOiB0LCB0b29sdGlwKTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGZpZWxkID0+IHZpZXcuc2hvd1Rvb2x0aXAuZnJvbShmaWVsZClcbn0pO1xuY29uc3QgbGludEd1dHRlclRoZW1lID0gdmlldy5FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZ3V0dGVyLWxpbnRcIjoge1xuICAgICAgICB3aWR0aDogXCIxLjRlbVwiLFxuICAgICAgICBcIiYgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICAgICAgcGFkZGluZzogXCIuMmVtXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXJcIjoge1xuICAgICAgICB3aWR0aDogXCIxZW1cIixcbiAgICAgICAgaGVpZ2h0OiBcIjFlbVwiXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci1pbmZvXCI6IHtcbiAgICAgICAgY29udGVudDogc3ZnKGA8cGF0aCBmaWxsPVwiI2FhZlwiIHN0cm9rZT1cIiM3N2VcIiBzdHJva2Utd2lkdGg9XCI2XCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTUgNUwzNSA1TDM1IDM1TDUgMzVaXCIvPmApXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci13YXJuaW5nXCI6IHtcbiAgICAgICAgY29udGVudDogc3ZnKGA8cGF0aCBmaWxsPVwiI2ZlOFwiIHN0cm9rZT1cIiNmZDdcIiBzdHJva2Utd2lkdGg9XCI2XCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTIwIDZMMzcgMzVMMyAzNVpcIi8+YCksXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci1lcnJvclwiOiB7XG4gICAgICAgIGNvbnRlbnQ6IHN2ZyhgPGNpcmNsZSBjeD1cIjIwXCIgY3k9XCIyMFwiIHI9XCIxNVwiIGZpbGw9XCIjZjg3XCIgc3Ryb2tlPVwiI2Y0M1wiIHN0cm9rZS13aWR0aD1cIjZcIi8+YClcbiAgICB9LFxufSk7XG5jb25zdCBsaW50RXh0ZW5zaW9ucyA9IFtcbiAgICBsaW50U3RhdGUsXG4gICAgdmlldy5FZGl0b3JWaWV3LmRlY29yYXRpb25zLmNvbXB1dGUoW2xpbnRTdGF0ZV0sIHN0YXRlID0+IHtcbiAgICAgICAgbGV0IHsgc2VsZWN0ZWQsIHBhbmVsIH0gPSBzdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgICAgICByZXR1cm4gIXNlbGVjdGVkIHx8ICFwYW5lbCB8fCBzZWxlY3RlZC5mcm9tID09IHNlbGVjdGVkLnRvID8gdmlldy5EZWNvcmF0aW9uLm5vbmUgOiB2aWV3LkRlY29yYXRpb24uc2V0KFtcbiAgICAgICAgICAgIGFjdGl2ZU1hcmsucmFuZ2Uoc2VsZWN0ZWQuZnJvbSwgc2VsZWN0ZWQudG8pXG4gICAgICAgIF0pO1xuICAgIH0pLFxuICAgIHZpZXcuaG92ZXJUb29sdGlwKGxpbnRUb29sdGlwLCB7IGhpZGVPbjogaGlkZVRvb2x0aXAgfSksXG4gICAgYmFzZVRoZW1lXG5dO1xuY29uc3QgbGludEd1dHRlckNvbmZpZyA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGhvdmVyVGltZTogMzAwIC8qIEhvdmVyLlRpbWUgKi8sXG4gICAgICAgICAgICBtYXJrZXJGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwRmlsdGVyOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGluc3RhbGxzIGEgZ3V0dGVyIHNob3dpbmcgbWFya2VycyBmb3JcbmVhY2ggbGluZSB0aGF0IGhhcyBkaWFnbm9zdGljcywgd2hpY2ggY2FuIGJlIGhvdmVyZWQgb3ZlciB0byBzZWVcbnRoZSBkaWFnbm9zdGljcy5cbiovXG5mdW5jdGlvbiBsaW50R3V0dGVyKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtsaW50R3V0dGVyQ29uZmlnLm9mKGNvbmZpZyksIGxpbnRHdXR0ZXJNYXJrZXJzLCBsaW50R3V0dGVyRXh0ZW5zaW9uLCBsaW50R3V0dGVyVGhlbWUsIGxpbnRHdXR0ZXJUb29sdGlwXTtcbn1cbi8qKlxuSXRlcmF0ZSBvdmVyIHRoZSBtYXJrZWQgZGlhZ25vc3RpY3MgZm9yIHRoZSBnaXZlbiBlZGl0b3Igc3RhdGUsXG5jYWxsaW5nIGBmYCBmb3IgZWFjaCBvZiB0aGVtLiBOb3RlIHRoYXQsIGlmIHRoZSBkb2N1bWVudCBjaGFuZ2VkXG5zaW5jZSB0aGUgZGlhZ25vc3RpY3Mgd2VyZSBjcmVhdGVkLCB0aGUgYERpYWdub3N0aWNgIG9iamVjdCB3aWxsXG5ob2xkIHRoZSBvcmlnaW5hbCBvdXRkYXRlZCBwb3NpdGlvbiwgd2hlcmVhcyB0aGUgYHRvYCBhbmQgYGZyb21gXG5hcmd1bWVudHMgaG9sZCB0aGUgZGlhZ25vc3RpYydzIGN1cnJlbnQgcG9zaXRpb24uXG4qL1xuZnVuY3Rpb24gZm9yRWFjaERpYWdub3N0aWMoc3RhdGUkMSwgZikge1xuICAgIGxldCBsU3RhdGUgPSBzdGF0ZSQxLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmIChsU3RhdGUgJiYgbFN0YXRlLmRpYWdub3N0aWNzLnNpemUpIHtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSBbXSwgcGVuZGluZ1N0YXJ0ID0gW10sIGxhc3RFbmQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaXRlciA9IHN0YXRlLlJhbmdlU2V0Lml0ZXIoW2xTdGF0ZS5kaWFnbm9zdGljc10pOzsgaXRlci5uZXh0KCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVuZGluZy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZXIudmFsdWUgfHwgaXRlci52YWx1ZS5zcGVjLmRpYWdub3N0aWNzLmluZGV4T2YocGVuZGluZ1tpXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGYocGVuZGluZ1tpXSwgcGVuZGluZ1N0YXJ0W2ldLCBsYXN0RW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdTdGFydC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZXIudmFsdWUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGl0ZXIudmFsdWUuc3BlYy5kaWFnbm9zdGljcylcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZy5pbmRleE9mKGQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLnB1c2goZCk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdTdGFydC5wdXNoKGl0ZXIuZnJvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEVuZCA9IGl0ZXIudG87XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuY2xvc2VMaW50UGFuZWwgPSBjbG9zZUxpbnRQYW5lbDtcbmV4cG9ydHMuZGlhZ25vc3RpY0NvdW50ID0gZGlhZ25vc3RpY0NvdW50O1xuZXhwb3J0cy5mb3JFYWNoRGlhZ25vc3RpYyA9IGZvckVhY2hEaWFnbm9zdGljO1xuZXhwb3J0cy5mb3JjZUxpbnRpbmcgPSBmb3JjZUxpbnRpbmc7XG5leHBvcnRzLmxpbnRHdXR0ZXIgPSBsaW50R3V0dGVyO1xuZXhwb3J0cy5saW50S2V5bWFwID0gbGludEtleW1hcDtcbmV4cG9ydHMubGludGVyID0gbGludGVyO1xuZXhwb3J0cy5uZXh0RGlhZ25vc3RpYyA9IG5leHREaWFnbm9zdGljO1xuZXhwb3J0cy5vcGVuTGludFBhbmVsID0gb3BlbkxpbnRQYW5lbDtcbmV4cG9ydHMucHJldmlvdXNEaWFnbm9zdGljID0gcHJldmlvdXNEaWFnbm9zdGljO1xuZXhwb3J0cy5zZXREaWFnbm9zdGljcyA9IHNldERpYWdub3N0aWNzO1xuZXhwb3J0cy5zZXREaWFnbm9zdGljc0VmZmVjdCA9IHNldERpYWdub3N0aWNzRWZmZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmlldyA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3ZpZXcnKTtcbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG52YXIgZWx0ID0gcmVxdWlyZSgnY3JlbHQnKTtcblxuY29uc3QgYmFzaWNOb3JtYWxpemUgPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUgPT0gXCJmdW5jdGlvblwiXG4gICAgPyB4ID0+IHgubm9ybWFsaXplKFwiTkZLRFwiKSA6IHggPT4geDtcbi8qKlxuQSBzZWFyY2ggY3Vyc29yIHByb3ZpZGVzIGFuIGl0ZXJhdG9yIG92ZXIgdGV4dCBtYXRjaGVzIGluIGFcbmRvY3VtZW50LlxuKi9cbmNsYXNzIFNlYXJjaEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBjdXJzb3IuIFRoZSBxdWVyeSBpcyB0aGUgc2VhcmNoIHN0cmluZywgYGZyb21gIHRvXG4gICAgYHRvYCBwcm92aWRlcyB0aGUgcmVnaW9uIHRvIHNlYXJjaC5cbiAgICBcbiAgICBXaGVuIGBub3JtYWxpemVgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGNhbGxlZCwgb24gYm90aCB0aGUgcXVlcnlcbiAgICBzdHJpbmcgYW5kIHRoZSBjb250ZW50IGl0IGlzIG1hdGNoZWQgYWdhaW5zdCwgYmVmb3JlIGNvbXBhcmluZy5cbiAgICBZb3UgY2FuLCBmb3IgZXhhbXBsZSwgY3JlYXRlIGEgY2FzZS1pbnNlbnNpdGl2ZSBzZWFyY2ggYnlcbiAgICBwYXNzaW5nIGBzID0+IHMudG9Mb3dlckNhc2UoKWAuXG4gICAgXG4gICAgVGV4dCBpcyBhbHdheXMgbm9ybWFsaXplZCB3aXRoXG4gICAgW2Aubm9ybWFsaXplKFwiTkZLRFwiKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9ub3JtYWxpemUpXG4gICAgKHdoZW4gc3VwcG9ydGVkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCwgbm9ybWFsaXplLCB0ZXN0KSB7XG4gICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBtYXRjaCAob25seSBob2xkcyBhIG1lYW5pbmdmdWwgdmFsdWUgYWZ0ZXJcbiAgICAgICAgW2BuZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLm5leHQpIGhhcyBiZWVuIGNhbGxlZCBhbmQgd2hlblxuICAgICAgICBgZG9uZWAgaXMgZmFsc2UpLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tOiAwLCB0bzogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBpdGVyYXRlZCByZWdpb24gaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemUgPSBub3JtYWxpemUgPyB4ID0+IG5vcm1hbGl6ZShiYXNpY05vcm1hbGl6ZSh4KSkgOiBiYXNpY05vcm1hbGl6ZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMubm9ybWFsaXplKHF1ZXJ5KTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyUG9zID09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJTdGFydCArPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb2RlUG9pbnRBdCh0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciB0aGUgbmV4dCBtYXRjaC4gVXBkYXRlcyB0aGUgaXRlcmF0b3Inc1xuICAgIFtgdmFsdWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IudmFsdWUpIGFuZFxuICAgIFtgZG9uZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci5kb25lKSBwcm9wZXJ0aWVzLiBTaG91bGQgYmUgY2FsbGVkXG4gICAgYXQgbGVhc3Qgb25jZSBiZWZvcmUgdXNpbmcgdGhlIGN1cnNvci5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm1hdGNoZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGBuZXh0YCBtZXRob2Qgd2lsbCBpZ25vcmUgbWF0Y2hlcyB0aGF0IHBhcnRpYWxseSBvdmVybGFwIGFcbiAgICBwcmV2aW91cyBtYXRjaC4gVGhpcyBtZXRob2QgYmVoYXZlcyBsaWtlIGBuZXh0YCwgYnV0IGluY2x1ZGVzXG4gICAgc3VjaCBtYXRjaGVzLlxuICAgICovXG4gICAgbmV4dE92ZXJsYXBwaW5nKCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgaWYgKG5leHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdHIgPSBzdGF0ZS5mcm9tQ29kZVBvaW50KG5leHQpLCBzdGFydCA9IHRoaXMuYnVmZmVyU3RhcnQgKyB0aGlzLmJ1ZmZlclBvcztcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zICs9IHN0YXRlLmNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBsZXQgbm9ybSA9IHRoaXMubm9ybWFsaXplKHN0cik7XG4gICAgICAgICAgICBpZiAobm9ybS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gbm9ybS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoKGNvZGUsIHBvcywgdGhpcy5idWZmZXJQb3MgKyB0aGlzLmJ1ZmZlclN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gbm9ybS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHN0YXJ0ICYmIGkgPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQ29kZUF0KGkpID09IGNvZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2goY29kZSwgcG9zLCBlbmQpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hdGNoZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMubWF0Y2hlc1tpXSwga2VlcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkuY2hhckNvZGVBdChpbmRleCkgPT0gY29kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnF1ZXJ5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB7IGZyb206IHRoaXMubWF0Y2hlc1tpICsgMV0sIHRvOiBlbmQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlc1tpXSsrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KDApID09IGNvZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiBwb3MsIHRvOiBlbmQgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMucHVzaCgxLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCAmJiB0aGlzLnRlc3QgJiYgIXRoaXMudGVzdChtYXRjaC5mcm9tLCBtYXRjaC50bywgdGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyU3RhcnQpKVxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIilcbiAgICBTZWFyY2hDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5jb25zdCBlbXB0eSA9IHsgZnJvbTogLTEsIHRvOiAtMSwgbWF0Y2g6IC8uKi8uZXhlYyhcIlwiKSB9O1xuY29uc3QgYmFzZUZsYWdzID0gXCJnbVwiICsgKC94Ly51bmljb2RlID09IG51bGwgPyBcIlwiIDogXCJ1XCIpO1xuLyoqXG5UaGlzIGNsYXNzIGlzIHNpbWlsYXIgdG8gW2BTZWFyY2hDdXJzb3JgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IpXG5idXQgc2VhcmNoZXMgZm9yIGEgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gaW5zdGVhZCBvZiBhIHBsYWluXG5zdHJpbmcuXG4qL1xuY2xhc3MgUmVnRXhwQ3Vyc29yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBjdXJzb3IgdGhhdCB3aWxsIHNlYXJjaCB0aGUgZ2l2ZW4gcmFuZ2UgaW4gdGhlIGdpdmVuXG4gICAgZG9jdW1lbnQuIGBxdWVyeWAgc2hvdWxkIGJlIHRoZSByYXcgcGF0dGVybiAoYXMgeW91J2QgcGFzcyBpdCB0b1xuICAgIGBuZXcgUmVnRXhwYCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSA9IDAsIHRvID0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgU2V0IHRvIGB0cnVlYCB3aGVuIHRoZSBjdXJzb3IgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoXG4gICAgICAgIHJhbmdlLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdpbGwgY29udGFpbiBhbiBvYmplY3Qgd2l0aCB0aGUgZXh0ZW50IG9mIHRoZSBtYXRjaCBhbmQgdGhlXG4gICAgICAgIG1hdGNoIG9iamVjdCB3aGVuIFtgbmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlJlZ0V4cEN1cnNvci5uZXh0KVxuICAgICAgICBzdWNlc3NmdWxseSBmaW5kcyBhIG1hdGNoLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIGlmICgvXFxcXFtzV0Rucl18XFxufFxccnxcXFtcXF4vLnRlc3QocXVlcnkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aWxpbmVSZWdFeHBDdXJzb3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20sIHRvKTtcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XG4gICAgICAgIHRoaXMudGVzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXN0O1xuICAgICAgICB0aGlzLml0ZXIgPSB0ZXh0Lml0ZXIoKTtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHRleHQubGluZUF0KGZyb20pO1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHN0YXJ0TGluZS5mcm9tO1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRleHQsIGZyb20pO1xuICAgICAgICB0aGlzLmdldExpbmUodGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgIH1cbiAgICBnZXRMaW5lKHNraXApIHtcbiAgICAgICAgdGhpcy5pdGVyLm5leHQoc2tpcCk7XG4gICAgICAgIGlmICh0aGlzLml0ZXIubGluZUJyZWFrKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA+IHRoaXMudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5jdXJMaW5lLnNsaWNlKDAsIHRoaXMudG8gLSB0aGlzLmN1ckxpbmVTdGFydCk7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRMaW5lKCkge1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCA+IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbWF0Y2gsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDs7KSB7XG4gICAgICAgICAgICB0aGlzLnJlLmxhc3RJbmRleCA9IG9mZjtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2hQb3MgPD0gdGhpcy50byAmJiB0aGlzLnJlLmV4ZWModGhpcy5jdXJMaW5lKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5jdXJMaW5lU3RhcnQgKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGZyb20gPCB0byB8fCBmcm9tID4gdGhpcy52YWx1ZS50bykgJiYgKCF0aGlzLnRlc3QgfHwgdGhpcy50ZXN0KGZyb20sIHRvLCBtYXRjaCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2ZmID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuY3VyTGluZVN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoIDwgdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGZsYXR0ZW5lZCA9IG5ldyBXZWFrTWFwKCk7XG4vLyBSZXVzYWJsZSAocGFydGlhbGx5KSBmbGF0dGVuZWQgZG9jdW1lbnQgc3RyaW5nc1xuY2xhc3MgRmxhdHRlbmVkRG9jIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0ZXh0KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBzdGF0aWMgZ2V0KGRvYywgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IGZsYXR0ZW5lZC5nZXQoZG9jKTtcbiAgICAgICAgaWYgKCFjYWNoZWQgfHwgY2FjaGVkLmZyb20gPj0gdG8gfHwgY2FjaGVkLnRvIDw9IGZyb20pIHtcbiAgICAgICAgICAgIGxldCBmbGF0ID0gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCBkb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5zZXQoZG9jLCBmbGF0KTtcbiAgICAgICAgICAgIHJldHVybiBmbGF0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZWQuZnJvbSA9PSBmcm9tICYmIGNhY2hlZC50byA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb206IGNhY2hlZEZyb20gfSA9IGNhY2hlZDtcbiAgICAgICAgaWYgKGNhY2hlZEZyb20gPiBmcm9tKSB7XG4gICAgICAgICAgICB0ZXh0ID0gZG9jLnNsaWNlU3RyaW5nKGZyb20sIGNhY2hlZEZyb20pICsgdGV4dDtcbiAgICAgICAgICAgIGNhY2hlZEZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZWQudG8gPCB0bylcbiAgICAgICAgICAgIHRleHQgKz0gZG9jLnNsaWNlU3RyaW5nKGNhY2hlZC50bywgdG8pO1xuICAgICAgICBmbGF0dGVuZWQuc2V0KGRvYywgbmV3IEZsYXR0ZW5lZERvYyhjYWNoZWRGcm9tLCB0ZXh0KSk7XG4gICAgICAgIHJldHVybiBuZXcgRmxhdHRlbmVkRG9jKGZyb20sIHRleHQuc2xpY2UoZnJvbSAtIGNhY2hlZEZyb20sIHRvIC0gY2FjaGVkRnJvbSkpO1xuICAgIH1cbn1cbmNsYXNzIE11bHRpbGluZVJlZ0V4cEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlbXB0eTtcbiAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0ZXh0LCBmcm9tKTtcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XG4gICAgICAgIHRoaXMudGVzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXN0O1xuICAgICAgICB0aGlzLmZsYXQgPSBGbGF0dGVuZWREb2MuZ2V0KHRleHQsIGZyb20sIHRoaXMuY2h1bmtFbmQoZnJvbSArIDUwMDAgLyogQ2h1bmsuQmFzZSAqLykpO1xuICAgIH1cbiAgICBjaHVua0VuZChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA+PSB0aGlzLnRvID8gdGhpcy50byA6IHRoaXMudGV4dC5saW5lQXQocG9zKS50bztcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG9mZiA9IHRoaXMucmUubGFzdEluZGV4ID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuZmxhdC5mcm9tO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuZmxhdC50ZXh0KTtcbiAgICAgICAgICAgIC8vIFNraXAgZW1wdHkgbWF0Y2hlcyBkaXJlY3RseSBhZnRlciB0aGUgbGFzdCBtYXRjaFxuICAgICAgICAgICAgaWYgKG1hdGNoICYmICFtYXRjaFswXSAmJiBtYXRjaC5pbmRleCA9PSBvZmYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlLmxhc3RJbmRleCA9IG9mZiArIDE7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0aGlzLnJlLmV4ZWModGhpcy5mbGF0LnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSB0aGlzLmZsYXQuZnJvbSArIG1hdGNoLmluZGV4LCB0byA9IGZyb20gKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBtYXRjaCBnb2VzIGFsbW9zdCB0byB0aGUgZW5kIG9mIGEgbm9uY29tcGxldGUgY2h1bmssIHRyeVxuICAgICAgICAgICAgICAgIC8vIGFnYWluLCBzaW5jZSBpdCdsbCBsaWtlbHkgYmUgYWJsZSB0byBtYXRjaCBtb3JlXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLmZsYXQudG8gPj0gdGhpcy50byB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA8PSB0aGlzLmZsYXQudGV4dC5sZW5ndGggLSAxMCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLnRlc3QgfHwgdGhpcy50ZXN0KGZyb20sIHRvLCBtYXRjaCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRoaXMudGV4dCwgdG8gKyAoZnJvbSA9PSB0byA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZsYXQudG8gPT0gdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHcm93IHRoZSBmbGF0dGVuZWQgZG9jXG4gICAgICAgICAgICB0aGlzLmZsYXQgPSBGbGF0dGVuZWREb2MuZ2V0KHRoaXMudGV4dCwgdGhpcy5mbGF0LmZyb20sIHRoaXMuY2h1bmtFbmQodGhpcy5mbGF0LmZyb20gKyB0aGlzLmZsYXQudGV4dC5sZW5ndGggKiAyKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUmVnRXhwQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gTXVsdGlsaW5lUmVnRXhwQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID1cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkUmVnRXhwKHNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAoc291cmNlLCBiYXNlRmxhZ3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0NoYXJFbmQodGV4dCwgcG9zKSB7XG4gICAgaWYgKHBvcyA+PSB0ZXh0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBsZXQgbGluZSA9IHRleHQubGluZUF0KHBvcyksIG5leHQ7XG4gICAgd2hpbGUgKHBvcyA8IGxpbmUudG8gJiYgKG5leHQgPSBsaW5lLnRleHQuY2hhckNvZGVBdChwb3MgLSBsaW5lLmZyb20pKSA+PSAweERDMDAgJiYgbmV4dCA8IDB4RTAwMClcbiAgICAgICAgcG9zKys7XG4gICAgcmV0dXJuIHBvcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGluZURpYWxvZyh2aWV3JDEpIHtcbiAgICBsZXQgbGluZSA9IFN0cmluZyh2aWV3JDEuc3RhdGUuZG9jLmxpbmVBdCh2aWV3JDEuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkubnVtYmVyKTtcbiAgICBsZXQgaW5wdXQgPSBlbHQoXCJpbnB1dFwiLCB7IGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLCBuYW1lOiBcImxpbmVcIiwgdmFsdWU6IGxpbmUgfSk7XG4gICAgbGV0IGRvbSA9IGVsdChcImZvcm1cIiwge1xuICAgICAgICBjbGFzczogXCJjbS1nb3RvTGluZVwiLFxuICAgICAgICBvbmtleWRvd246IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpIHsgLy8gRXNjYXBlXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB2aWV3JDEuZGlzcGF0Y2goeyBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpIH0pO1xuICAgICAgICAgICAgICAgIHZpZXckMS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25zdWJtaXQ6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH1cbiAgICB9LCBlbHQoXCJsYWJlbFwiLCB2aWV3JDEuc3RhdGUucGhyYXNlKFwiR28gdG8gbGluZVwiKSwgXCI6IFwiLCBpbnB1dCksIFwiIFwiLCBlbHQoXCJidXR0b25cIiwgeyBjbGFzczogXCJjbS1idXR0b25cIiwgdHlwZTogXCJzdWJtaXRcIiB9LCB2aWV3JDEuc3RhdGUucGhyYXNlKFwiZ29cIikpKTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gL14oWystXSk/KFxcZCspPyg6XFxkKyk/KCUpPyQvLmV4ZWMoaW5wdXQudmFsdWUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZTogc3RhdGUkMSB9ID0gdmlldyQxLCBzdGFydExpbmUgPSBzdGF0ZSQxLmRvYy5saW5lQXQoc3RhdGUkMS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgbGV0IFssIHNpZ24sIGxuLCBjbCwgcGVyY2VudF0gPSBtYXRjaDtcbiAgICAgICAgbGV0IGNvbCA9IGNsID8gK2NsLnNsaWNlKDEpIDogMDtcbiAgICAgICAgbGV0IGxpbmUgPSBsbiA/ICtsbiA6IHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIGlmIChsbiAmJiBwZXJjZW50KSB7XG4gICAgICAgICAgICBsZXQgcGMgPSBsaW5lIC8gMTAwO1xuICAgICAgICAgICAgaWYgKHNpZ24pXG4gICAgICAgICAgICAgICAgcGMgPSBwYyAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIChzdGFydExpbmUubnVtYmVyIC8gc3RhdGUkMS5kb2MubGluZXMpO1xuICAgICAgICAgICAgbGluZSA9IE1hdGgucm91bmQoc3RhdGUkMS5kb2MubGluZXMgKiBwYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG4gJiYgc2lnbikge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUgKiAoc2lnbiA9PSBcIi1cIiA/IC0xIDogMSkgKyBzdGFydExpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb2NMaW5lID0gc3RhdGUkMS5kb2MubGluZShNYXRoLm1heCgxLCBNYXRoLm1pbihzdGF0ZSQxLmRvYy5saW5lcywgbGluZSkpKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZG9jTGluZS5mcm9tICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oY29sLCBkb2NMaW5lLmxlbmd0aCkpKTtcbiAgICAgICAgdmlldyQxLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGVmZmVjdHM6IFtkaWFsb2dFZmZlY3Qub2YoZmFsc2UpLCB2aWV3LkVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcoc2VsZWN0aW9uLmZyb20sIHsgeTogJ2NlbnRlcicgfSldLFxuICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgdmlldyQxLmZvY3VzKCk7XG4gICAgfVxuICAgIHJldHVybiB7IGRvbSB9O1xufVxuY29uc3QgZGlhbG9nRWZmZWN0ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBkaWFsb2dGaWVsZCA9IHN0YXRlLlN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGUuaXMoZGlhbG9nRWZmZWN0KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGUudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gdmlldy5zaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsID8gY3JlYXRlTGluZURpYWxvZyA6IG51bGwpXG59KTtcbi8qKlxuQ29tbWFuZCB0aGF0IHNob3dzIGEgZGlhbG9nIGFza2luZyB0aGUgdXNlciBmb3IgYSBsaW5lIG51bWJlciwgYW5kXG53aGVuIGEgdmFsaWQgcG9zaXRpb24gaXMgcHJvdmlkZWQsIG1vdmVzIHRoZSBjdXJzb3IgdG8gdGhhdCBsaW5lLlxuXG5TdXBwb3J0cyBsaW5lIG51bWJlcnMsIHJlbGF0aXZlIGxpbmUgb2Zmc2V0cyBwcmVmaXhlZCB3aXRoIGArYCBvclxuYC1gLCBkb2N1bWVudCBwZXJjZW50YWdlcyBzdWZmaXhlZCB3aXRoIGAlYCwgYW5kIGFuIG9wdGlvbmFsXG5jb2x1bW4gcG9zaXRpb24gYnkgYWRkaW5nIGA6YCBhbmQgYSBzZWNvbmQgbnVtYmVyIGFmdGVyIHRoZSBsaW5lXG5udW1iZXIuXG4qL1xuY29uc3QgZ290b0xpbmUgPSB2aWV3JDEgPT4ge1xuICAgIGxldCBwYW5lbCA9IHZpZXcuZ2V0UGFuZWwodmlldyQxLCBjcmVhdGVMaW5lRGlhbG9nKTtcbiAgICBpZiAoIXBhbmVsKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gW2RpYWxvZ0VmZmVjdC5vZih0cnVlKV07XG4gICAgICAgIGlmICh2aWV3JDEuc3RhdGUuZmllbGQoZGlhbG9nRmllbGQsIGZhbHNlKSA9PSBudWxsKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHN0YXRlLlN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbZGlhbG9nRmllbGQsIGJhc2VUaGVtZSQxXSkpO1xuICAgICAgICB2aWV3JDEuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgICAgICBwYW5lbCA9IHZpZXcuZ2V0UGFuZWwodmlldyQxLCBjcmVhdGVMaW5lRGlhbG9nKTtcbiAgICB9XG4gICAgaWYgKHBhbmVsKVxuICAgICAgICBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcImlucHV0XCIpLnNlbGVjdCgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGJhc2VUaGVtZSQxID0gdmlldy5FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tcGFuZWwuY20tZ290b0xpbmVcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7IGZvbnRTaXplOiBcIjgwJVwiIH1cbiAgICB9XG59KTtcblxuY29uc3QgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMgPSB7XG4gICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogZmFsc2UsXG4gICAgbWluU2VsZWN0aW9uTGVuZ3RoOiAxLFxuICAgIG1heE1hdGNoZXM6IDEwMCxcbiAgICB3aG9sZVdvcmRzOiBmYWxzZVxufTtcbmNvbnN0IGhpZ2hsaWdodENvbmZpZyA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb21iaW5lQ29uZmlnKG9wdGlvbnMsIGRlZmF1bHRIaWdobGlnaHRPcHRpb25zLCB7XG4gICAgICAgICAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiLFxuICAgICAgICAgICAgbWluU2VsZWN0aW9uTGVuZ3RoOiBNYXRoLm1pbixcbiAgICAgICAgICAgIG1heE1hdGNoZXM6IE1hdGgubWluXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5UaGlzIGV4dGVuc2lvbiBoaWdobGlnaHRzIHRleHQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rpb24uIEl0IHVzZXNcbnRoZSBgXCJjbS1zZWxlY3Rpb25NYXRjaFwiYCBjbGFzcyBmb3IgdGhlIGhpZ2hsaWdodGluZy4gV2hlblxuYGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3JgIGlzIGVuYWJsZWQsIHRoZSB3b3JkIGF0IHRoZSBjdXJzb3Jcbml0c2VsZiB3aWxsIGJlIGhpZ2hsaWdodGVkIHdpdGggYFwiY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiYC5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzKG9wdGlvbnMpIHtcbiAgICBsZXQgZXh0ID0gW2RlZmF1bHRUaGVtZSwgbWF0Y2hIaWdobGlnaHRlcl07XG4gICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodENvbmZpZy5vZihvcHRpb25zKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbmNvbnN0IG1hdGNoRGVjbyA9IHZpZXcuRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2hcIiB9KTtcbmNvbnN0IG1haW5NYXRjaERlY28gPSB2aWV3LkRlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlbGVjdGlvbk1hdGNoIGNtLXNlbGVjdGlvbk1hdGNoLW1haW5cIiB9KTtcbi8vIFdoZXRoZXIgdGhlIGNoYXJhY3RlcnMgZGlyZWN0bHkgb3V0c2lkZSB0aGUgZ2l2ZW4gcG9zaXRpb25zIGFyZSBub24td29yZCBjaGFyYWN0ZXJzXG5mdW5jdGlvbiBpbnNpZGVXb3JkQm91bmRhcmllcyhjaGVjaywgc3RhdGUkMSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gKGZyb20gPT0gMCB8fCBjaGVjayhzdGF0ZSQxLnNsaWNlRG9jKGZyb20gLSAxLCBmcm9tKSkgIT0gc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICh0byA9PSBzdGF0ZSQxLmRvYy5sZW5ndGggfHwgY2hlY2soc3RhdGUkMS5zbGljZURvYyh0bywgdG8gKyAxKSkgIT0gc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25zIGFyZSB3b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlJDEsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGNoZWNrKHN0YXRlJDEuc2xpY2VEb2MoZnJvbSwgZnJvbSArIDEpKSA9PSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZFxuICAgICAgICAmJiBjaGVjayhzdGF0ZSQxLnNsaWNlRG9jKHRvIC0gMSwgdG8pKSA9PSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZDtcbn1cbmNvbnN0IG1hdGNoSGlnaGxpZ2h0ZXIgPSB2aWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odXBkYXRlLnZpZXcpO1xuICAgIH1cbiAgICBnZXREZWNvKHZpZXckMSkge1xuICAgICAgICBsZXQgY29uZiA9IHZpZXckMS5zdGF0ZS5mYWNldChoaWdobGlnaHRDb25maWcpO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldyQxLCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzZWwucmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm4gdmlldy5EZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbC5tYWluLCBxdWVyeSwgY2hlY2sgPSBudWxsO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGlmICghY29uZi5oaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yKVxuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3LkRlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgaWYgKCF3b3JkKVxuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3LkRlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIGNoZWNrID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyh3b3JkLmZyb20sIHdvcmQudG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHJhbmdlLnRvIC0gcmFuZ2UuZnJvbTtcbiAgICAgICAgICAgIGlmIChsZW4gPCBjb25mLm1pblNlbGVjdGlvbkxlbmd0aCB8fCBsZW4gPiAyMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXcuRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgaWYgKGNvbmYud2hvbGVXb3Jkcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pOyAvLyBUT0RPOiBhbGxvdyBhbmQgaW5jbHVkZSBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlP1xuICAgICAgICAgICAgICAgIGNoZWNrID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgICAgIGlmICghKGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pICYmXG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bykpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldy5EZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldy5EZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlY28gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiB2aWV3JDEudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcGFydC5mcm9tLCBwYXJ0LnRvKTtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrIHx8IGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBmcm9tIDw9IHJhbmdlLmZyb20gJiYgdG8gPj0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWFpbk1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmcm9tID49IHJhbmdlLnRvIHx8IHRvIDw9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNvLmxlbmd0aCA+IGNvbmYubWF4TWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3LkRlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXcuRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuY29uc3QgZGVmYXVsdFRoZW1lID0gdmlldy5FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZmY3NzgwXCIgfSxcbiAgICBcIi5jbS1zZWFyY2hNYXRjaCAuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIiB9XG59KTtcbi8vIFNlbGVjdCB0aGUgd29yZHMgYXJvdW5kIHRoZSBjdXJzb3JzLlxuY29uc3Qgc2VsZWN0V29yZCA9ICh7IHN0YXRlOiBzdGF0ZSQxLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZSQxO1xuICAgIGxldCBuZXdTZWwgPSBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbGVjdGlvbi5yYW5nZXMubWFwKHJhbmdlID0+IHN0YXRlJDEud29yZEF0KHJhbmdlLmhlYWQpIHx8IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCkpLCBzZWxlY3Rpb24ubWFpbkluZGV4KTtcbiAgICBpZiAobmV3U2VsLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZSQxLnVwZGF0ZSh7IHNlbGVjdGlvbjogbmV3U2VsIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyBGaW5kIG5leHQgb2NjdXJyZW5jZSBvZiBxdWVyeSByZWxhdGl2ZSB0byBsYXN0IGN1cnNvci4gV3JhcCBhcm91bmRcbi8vIHRoZSBkb2N1bWVudCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBtYXRjaGVzLlxuZnVuY3Rpb24gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBxdWVyeSkge1xuICAgIGxldCB7IG1haW4sIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KG1haW4uaGVhZCksIGZ1bGxXb3JkID0gd29yZCAmJiB3b3JkLmZyb20gPT0gbWFpbi5mcm9tICYmIHdvcmQudG8gPT0gbWFpbi50bztcbiAgICBmb3IgKGxldCBjeWNsZWQgPSBmYWxzZSwgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHF1ZXJ5LCByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvKTs7KSB7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGN5Y2xlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgMCwgTWF0aC5tYXgoMCwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS5mcm9tIC0gMSkpO1xuICAgICAgICAgICAgY3ljbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjeWNsZWQgJiYgcmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gY3Vyc29yLnZhbHVlLmZyb20pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGZ1bGxXb3JkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmQgPSBzdGF0ZS53b3JkQXQoY3Vyc29yLnZhbHVlLmZyb20pO1xuICAgICAgICAgICAgICAgIGlmICghd29yZCB8fCB3b3JkLmZyb20gIT0gY3Vyc29yLnZhbHVlLmZyb20gfHwgd29yZC50byAhPSBjdXJzb3IudmFsdWUudG8pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuU2VsZWN0IG5leHQgb2NjdXJyZW5jZSBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uIEV4cGFuZCBzZWxlY3Rpb25cbnRvIHRoZSBzdXJyb3VuZGluZyB3b3JkIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eS5cbiovXG5jb25zdCBzZWxlY3ROZXh0T2NjdXJyZW5jZSA9ICh7IHN0YXRlOiBzdGF0ZSQxLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHsgcmFuZ2VzIH0gPSBzdGF0ZSQxLnNlbGVjdGlvbjtcbiAgICBpZiAocmFuZ2VzLnNvbWUoc2VsID0+IHNlbC5mcm9tID09PSBzZWwudG8pKVxuICAgICAgICByZXR1cm4gc2VsZWN0V29yZCh7IHN0YXRlOiBzdGF0ZSQxLCBkaXNwYXRjaCB9KTtcbiAgICBsZXQgc2VhcmNoZWRUZXh0ID0gc3RhdGUkMS5zbGljZURvYyhyYW5nZXNbMF0uZnJvbSwgcmFuZ2VzWzBdLnRvKTtcbiAgICBpZiAoc3RhdGUkMS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiBzdGF0ZSQxLnNsaWNlRG9jKHIuZnJvbSwgci50bykgIT0gc2VhcmNoZWRUZXh0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCByYW5nZSA9IGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSQxLCBzZWFyY2hlZFRleHQpO1xuICAgIGlmICghcmFuZ2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZSQxLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogc3RhdGUkMS5zZWxlY3Rpb24uYWRkUmFuZ2Uoc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmZyb20sIHJhbmdlLnRvKSwgZmFsc2UpLFxuICAgICAgICBlZmZlY3RzOiB2aWV3LkVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UudG8pXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3Qgc2VhcmNoQ29uZmlnRmFjZXQgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gc3RhdGUuY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICB0b3A6IGZhbHNlLFxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgICAgICAgIHJlZ2V4cDogZmFsc2UsXG4gICAgICAgICAgICB3aG9sZVdvcmQ6IGZhbHNlLFxuICAgICAgICAgICAgY3JlYXRlUGFuZWw6IHZpZXcgPT4gbmV3IFNlYXJjaFBhbmVsKHZpZXcpLFxuICAgICAgICAgICAgc2Nyb2xsVG9NYXRjaDogcmFuZ2UgPT4gdmlldy5FZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHJhbmdlKVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuQWRkIHNlYXJjaCBzdGF0ZSB0byB0aGUgZWRpdG9yIGNvbmZpZ3VyYXRpb24sIGFuZCBvcHRpb25hbGx5XG5jb25maWd1cmUgdGhlIHNlYXJjaCBleHRlbnNpb24uXG4oW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpIHdpbGwgYXV0b21hdGljYWxseVxuZW5hYmxlIHRoaXMgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvbikuXG4qL1xuZnVuY3Rpb24gc2VhcmNoKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcgPyBbc2VhcmNoQ29uZmlnRmFjZXQub2YoY29uZmlnKSwgc2VhcmNoRXh0ZW5zaW9uc10gOiBzZWFyY2hFeHRlbnNpb25zO1xufVxuLyoqXG5BIHNlYXJjaCBxdWVyeS4gUGFydCBvZiB0aGUgZWRpdG9yJ3Mgc2VhcmNoIHN0YXRlLlxuKi9cbmNsYXNzIFNlYXJjaFF1ZXJ5IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBxdWVyeSBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBjb25maWcuc2VhcmNoO1xuICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSAhIWNvbmZpZy5jYXNlU2Vuc2l0aXZlO1xuICAgICAgICB0aGlzLmxpdGVyYWwgPSAhIWNvbmZpZy5saXRlcmFsO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9ICEhY29uZmlnLnJlZ2V4cDtcbiAgICAgICAgdGhpcy5yZXBsYWNlID0gY29uZmlnLnJlcGxhY2UgfHwgXCJcIjtcbiAgICAgICAgdGhpcy52YWxpZCA9ICEhdGhpcy5zZWFyY2ggJiYgKCF0aGlzLnJlZ2V4cCB8fCB2YWxpZFJlZ0V4cCh0aGlzLnNlYXJjaCkpO1xuICAgICAgICB0aGlzLnVucXVvdGVkID0gdGhpcy51bnF1b3RlKHRoaXMuc2VhcmNoKTtcbiAgICAgICAgdGhpcy53aG9sZVdvcmQgPSAhIWNvbmZpZy53aG9sZVdvcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdW5xdW90ZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdGVyYWwgPyB0ZXh0IDpcbiAgICAgICAgICAgIHRleHQucmVwbGFjZSgvXFxcXChbbnJ0XFxcXF0pL2csIChfLCBjaCkgPT4gY2ggPT0gXCJuXCIgPyBcIlxcblwiIDogY2ggPT0gXCJyXCIgPyBcIlxcclwiIDogY2ggPT0gXCJ0XCIgPyBcIlxcdFwiIDogXCJcXFxcXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgcXVlcnkgdG8gYW5vdGhlciBxdWVyeS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaCA9PSBvdGhlci5zZWFyY2ggJiYgdGhpcy5yZXBsYWNlID09IG90aGVyLnJlcGxhY2UgJiZcbiAgICAgICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9PSBvdGhlci5jYXNlU2Vuc2l0aXZlICYmIHRoaXMucmVnZXhwID09IG90aGVyLnJlZ2V4cCAmJlxuICAgICAgICAgICAgdGhpcy53aG9sZVdvcmQgPT0gb3RoZXIud2hvbGVXb3JkO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwID8gbmV3IFJlZ0V4cFF1ZXJ5KHRoaXMpIDogbmV3IFN0cmluZ1F1ZXJ5KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBzZWFyY2ggY3Vyc29yIGZvciB0aGlzIHF1ZXJ5LCBzZWFyY2hpbmcgdGhyb3VnaCB0aGUgZ2l2ZW5cbiAgICByYW5nZSBpbiB0aGUgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXRDdXJzb3Ioc3RhdGUkMSwgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGxldCBzdCA9IHN0YXRlJDEuZG9jID8gc3RhdGUkMSA6IHN0YXRlLkVkaXRvclN0YXRlLmNyZWF0ZSh7IGRvYzogc3RhdGUkMSB9KTtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IHN0LmRvYy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IHJlZ2V4cEN1cnNvcih0aGlzLCBzdCwgZnJvbSwgdG8pIDogc3RyaW5nQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5nQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy51bnF1b3RlZCwgZnJvbSwgdG8sIHNwZWMuY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IHggPT4geC50b0xvd2VyQ2FzZSgpLCBzcGVjLndob2xlV29yZCA/IHN0cmluZ1dvcmRUZXN0KHN0YXRlLmRvYywgc3RhdGUuY2hhckNhdGVnb3JpemVyKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBzdHJpbmdXb3JkVGVzdChkb2MsIGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChmcm9tLCB0bywgYnVmLCBidWZQb3MpID0+IHtcbiAgICAgICAgaWYgKGJ1ZlBvcyA+IGZyb20gfHwgYnVmUG9zICsgYnVmLmxlbmd0aCA8IHRvKSB7XG4gICAgICAgICAgICBidWZQb3MgPSBNYXRoLm1heCgwLCBmcm9tIC0gMik7XG4gICAgICAgICAgICBidWYgPSBkb2Muc2xpY2VTdHJpbmcoYnVmUG9zLCBNYXRoLm1pbihkb2MubGVuZ3RoLCB0byArIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJBZnRlcihidWYsIGZyb20gLSBidWZQb3MpKSAhPSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgIChjYXRlZ29yaXplcihjaGFyQWZ0ZXIoYnVmLCB0byAtIGJ1ZlBvcykpICE9IHN0YXRlLkNoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShidWYsIHRvIC0gYnVmUG9zKSkgIT0gc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpO1xuICAgIH07XG59XG5jbGFzcyBTdHJpbmdRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcihzcGVjKTtcbiAgICB9XG4gICAgbmV4dE1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgY3VyRnJvbSArIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIGVuZCkubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvci5kb25lIHx8IGN1cnNvci52YWx1ZS5mcm9tID09IGN1ckZyb20gJiYgY3Vyc29yLnZhbHVlLnRvID09IGN1clRvID8gbnVsbCA6IGN1cnNvci52YWx1ZTtcbiAgICB9XG4gICAgLy8gU2VhcmNoaW5nIGluIHJldmVyc2UgaXMsIHJhdGhlciB0aGFuIGltcGxlbWVudGluZyBhbiBpbnZlcnRlZCBzZWFyY2hcbiAgICAvLyBjdXJzb3IsIGRvbmUgYnkgc2Nhbm5pbmcgY2h1bmsgYWZ0ZXIgY2h1bmsgZm9yd2FyZC5cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0bzs7KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCBwb3MgLSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi8gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHBvcyksIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHRPdmVybGFwcGluZygpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBwb3MgLT0gMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIGZvdW5kID0gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBNYXRoLm1heCgwLCBjdXJUbyAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kICYmIChmb3VuZC5mcm9tICE9IGN1ckZyb20gfHwgZm91bmQudG8gIT0gY3VyVG8pID8gZm91bmQgOiBudWxsO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChfcmVzdWx0KSB7IHJldHVybiB0aGlzLnNwZWMudW5xdW90ZSh0aGlzLnNwZWMucmVwbGFjZSk7IH1cbiAgICBtYXRjaEFsbChzdGF0ZSwgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKSwgcmFuZ2VzID0gW107XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHN0YXRlLCBmcm9tLCB0bywgYWRkKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgTWF0aC5tYXgoMCwgZnJvbSAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpLCBNYXRoLm1pbih0byArIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgsIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnZXhwQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy5zZWFyY2gsIHtcbiAgICAgICAgaWdub3JlQ2FzZTogIXNwZWMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgdGVzdDogc3BlYy53aG9sZVdvcmQgPyByZWdleHBXb3JkVGVzdChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkpIDogdW5kZWZpbmVkXG4gICAgfSwgZnJvbSwgdG8pO1xufVxuZnVuY3Rpb24gY2hhckJlZm9yZShzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZShzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgsIGZhbHNlKSwgaW5kZXgpO1xufVxuZnVuY3Rpb24gY2hhckFmdGVyKHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKGluZGV4LCBzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgpKTtcbn1cbmZ1bmN0aW9uIHJlZ2V4cFdvcmRUZXN0KGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChfZnJvbSwgX3RvLCBtYXRjaCkgPT4gIW1hdGNoWzBdLmxlbmd0aCB8fFxuICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXgpKSAhPSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckFmdGVyKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCkpICE9IHN0YXRlLkNoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJBZnRlcihtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKSAhPSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuY2xhc3MgUmVnRXhwUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpXG4gICAgICAgICAgICBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgY3VyRnJvbSkubmV4dCgpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBzaXplID0gMTs7IHNpemUrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgdG8gLSBzaXplICogMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHRvKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgKHN0YXJ0ID09IGZyb20gfHwgcmFuZ2UuZnJvbSA+IHN0YXJ0ICsgMTApKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlKS5yZXBsYWNlKC9cXCQoWyQmXFxkK10pL2csIChtLCBpKSA9PiBpID09IFwiJFwiID8gXCIkXCJcbiAgICAgICAgICAgIDogaSA9PSBcIiZcIiA/IHJlc3VsdC5tYXRjaFswXVxuICAgICAgICAgICAgICAgIDogaSAhPSBcIjBcIiAmJiAraSA8IHJlc3VsdC5tYXRjaC5sZW5ndGggPyByZXN1bHQubWF0Y2hbaV1cbiAgICAgICAgICAgICAgICAgICAgOiBtKTtcbiAgICB9XG4gICAgbWF0Y2hBbGwoc3RhdGUsIGxpbWl0KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgc3RhdGUuZG9jLmxlbmd0aCksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChzdGF0ZSwgZnJvbSwgdG8sIGFkZCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIE1hdGgubWF4KDAsIGZyb20gLSAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLyksIE1hdGgubWluKHRvICsgMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8sIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuLyoqXG5BIHN0YXRlIGVmZmVjdCB0aGF0IHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5LiBOb3RlIHRoYXRcbnRoaXMgb25seSBoYXMgYW4gZWZmZWN0IGlmIHRoZSBzZWFyY2ggc3RhdGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbihieSBpbmNsdWRpbmcgW2BzZWFyY2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWFyY2gpIGluIHlvdXIgY29uZmlndXJhdGlvbiBvclxuYnkgcnVubmluZyBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgYXQgbGVhc3Rcbm9uY2UpLlxuKi9cbmNvbnN0IHNldFNlYXJjaFF1ZXJ5ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCB0b2dnbGVQYW5lbCA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3Qgc2VhcmNoU3RhdGUgPSBzdGF0ZS5TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoU3RhdGUoZGVmYXVsdFF1ZXJ5KHN0YXRlKS5jcmVhdGUoKSwgbnVsbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZShlZmZlY3QudmFsdWUuY3JlYXRlKCksIHZhbHVlLnBhbmVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUodmFsdWUucXVlcnksIGVmZmVjdC52YWx1ZSA/IGNyZWF0ZVNlYXJjaFBhbmVsIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiB2aWV3LnNob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwucGFuZWwpXG59KTtcbi8qKlxuR2V0IHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeSBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiBnZXRTZWFyY2hRdWVyeShzdGF0ZSkge1xuICAgIGxldCBjdXJTdGF0ZSA9IHN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGN1clN0YXRlID8gY3VyU3RhdGUucXVlcnkuc3BlYyA6IGRlZmF1bHRRdWVyeShzdGF0ZSk7XG59XG4vKipcblF1ZXJ5IHdoZXRoZXIgdGhlIHNlYXJjaCBwYW5lbCBpcyBvcGVuIGluIHRoZSBnaXZlbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gc2VhcmNoUGFuZWxPcGVuKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhbmVsKSAhPSBudWxsO1xufVxuY2xhc3MgU2VhcmNoU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBwYW5lbCkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICB9XG59XG5jb25zdCBtYXRjaE1hcmsgPSB2aWV3LkRlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoXCIgfSksIHNlbGVjdGVkTWF0Y2hNYXJrID0gdmlldy5EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWFyY2hNYXRjaCBjbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiIH0pO1xuY29uc3Qgc2VhcmNoSGlnaGxpZ2h0ZXIgPSB2aWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmhpZ2hsaWdodCh2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlICE9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5oaWdobGlnaHQoc3RhdGUpO1xuICAgIH1cbiAgICBoaWdobGlnaHQoeyBxdWVyeSwgcGFuZWwgfSkge1xuICAgICAgICBpZiAoIXBhbmVsIHx8ICFxdWVyeS5zcGVjLnZhbGlkKVxuICAgICAgICAgICAgcmV0dXJuIHZpZXcuRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICBsZXQgeyB2aWV3OiB2aWV3JDEgfSA9IHRoaXM7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IHN0YXRlLlJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcmFuZ2VzID0gdmlldyQxLnZpc2libGVSYW5nZXMsIGwgPSByYW5nZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsIC0gMSAmJiB0byA+IHJhbmdlc1tpICsgMV0uZnJvbSAtIDIgKiAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICB0byA9IHJhbmdlc1srK2ldLnRvO1xuICAgICAgICAgICAgcXVlcnkuaGlnaGxpZ2h0KHZpZXckMS5zdGF0ZSwgZnJvbSwgdG8sIChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZCA9IHZpZXckMS5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gZnJvbSAmJiByLnRvID09IHRvKTtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgc2VsZWN0ZWQgPyBzZWxlY3RlZE1hdGNoTWFyayA6IG1hdGNoTWFyayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5mdW5jdGlvbiBzZWFyY2hDb21tYW5kKGYpIHtcbiAgICByZXR1cm4gdmlldyA9PiB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnF1ZXJ5LnNwZWMudmFsaWQgPyBmKHZpZXcsIHN0YXRlKSA6IG9wZW5TZWFyY2hQYW5lbCh2aWV3KTtcbiAgICB9O1xufVxuLyoqXG5PcGVuIHRoZSBzZWFyY2ggcGFuZWwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvcGVuLCBhbmQgbW92ZSB0aGVcbnNlbGVjdGlvbiB0byB0aGUgZmlyc3QgbWF0Y2ggYWZ0ZXIgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uXG5XaWxsIHdyYXAgYXJvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgd2hlbiBpdCByZWFjaGVzIHRoZVxuZW5kLlxuKi9cbmNvbnN0IGZpbmROZXh0ID0gc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IG5leHQgPSBxdWVyeS5uZXh0TWF0Y2godmlldy5zdGF0ZSwgdG8sIHRvKTtcbiAgICBpZiAoIW5leHQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsZWN0aW9uID0gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXh0LmZyb20sIG5leHQudG8pO1xuICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBlZmZlY3RzOiBbYW5ub3VuY2VNYXRjaCh2aWV3LCBuZXh0KSwgY29uZmlnLnNjcm9sbFRvTWF0Y2goc2VsZWN0aW9uLm1haW4sIHZpZXcpXSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxuICAgIH0pO1xuICAgIHNlbGVjdFNlYXJjaElucHV0KHZpZXcpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgaW5zdGFuY2Ugb2YgdGhlIHNlYXJjaCBxdWVyeSxcbmJlZm9yZSB0aGUgY3VycmVudCBtYWluIHNlbGVjdGlvbi4gV2lsbCB3cmFwIHBhc3QgdGhlIHN0YXJ0XG5vZiB0aGUgZG9jdW1lbnQgdG8gc3RhcnQgc2VhcmNoaW5nIGF0IHRoZSBlbmQgYWdhaW4uXG4qL1xuY29uc3QgZmluZFByZXZpb3VzID0gc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGU6IHN0YXRlJDEgfSA9IHZpZXcsIHsgZnJvbSB9ID0gc3RhdGUkMS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgcHJldiA9IHF1ZXJ5LnByZXZNYXRjaChzdGF0ZSQxLCBmcm9tLCBmcm9tKTtcbiAgICBpZiAoIXByZXYpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsZWN0aW9uID0gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShwcmV2LmZyb20sIHByZXYudG8pO1xuICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBlZmZlY3RzOiBbYW5ub3VuY2VNYXRjaCh2aWV3LCBwcmV2KSwgY29uZmlnLnNjcm9sbFRvTWF0Y2goc2VsZWN0aW9uLm1haW4sIHZpZXcpXSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxuICAgIH0pO1xuICAgIHNlbGVjdFNlYXJjaElucHV0KHZpZXcpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblNlbGVjdCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hlcyA9IHNlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCByYW5nZXMgPSBxdWVyeS5tYXRjaEFsbCh2aWV3LnN0YXRlLCAxMDAwKTtcbiAgICBpZiAoIXJhbmdlcyB8fCAhcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb246IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLm1hcChyID0+IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmZyb20sIHIudG8pKSksXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoLm1hdGNoZXNcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblNlbGVjdCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dC5cbiovXG5jb25zdCBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzID0gKHsgc3RhdGU6IHN0YXRlJDEsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUkMS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSB8fCBzZWwubWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwubWFpbjtcbiAgICBsZXQgcmFuZ2VzID0gW10sIG1haW4gPSAwO1xuICAgIGZvciAobGV0IGN1ciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUkMS5kb2MsIHN0YXRlJDEuc2xpY2VEb2MoZnJvbSwgdG8pKTsgIWN1ci5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY3VyLnZhbHVlLmZyb20gPT0gZnJvbSlcbiAgICAgICAgICAgIG1haW4gPSByYW5nZXMubGVuZ3RoO1xuICAgICAgICByYW5nZXMucHVzaChzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY3VyLnZhbHVlLmZyb20sIGN1ci52YWx1ZS50bykpO1xuICAgIH1cbiAgICBkaXNwYXRjaChzdGF0ZSQxLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIG1haW4pLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBjdXJyZW50IG1hdGNoIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3QgcmVwbGFjZU5leHQgPSBzZWFyY2hDb21tYW5kKCh2aWV3JDEsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHN0YXRlOiBzdGF0ZSQxIH0gPSB2aWV3JDEsIHsgZnJvbSwgdG8gfSA9IHN0YXRlJDEuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKHN0YXRlJDEucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbWF0Y2ggPSBxdWVyeS5uZXh0TWF0Y2goc3RhdGUkMSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBuZXh0ID0gbWF0Y2g7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgc2VsZWN0aW9uLCByZXBsYWNlbWVudDtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGlmIChuZXh0LmZyb20gPT0gZnJvbSAmJiBuZXh0LnRvID09IHRvKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gc3RhdGUkMS50b1RleHQocXVlcnkuZ2V0UmVwbGFjZW1lbnQobmV4dCkpO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0LmZyb20sIHRvOiBuZXh0LnRvLCBpbnNlcnQ6IHJlcGxhY2VtZW50IH0pO1xuICAgICAgICBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHN0YXRlJDEsIG5leHQuZnJvbSwgbmV4dC50byk7XG4gICAgICAgIGVmZmVjdHMucHVzaCh2aWV3LkVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUkMS5waHJhc2UoXCJyZXBsYWNlZCBtYXRjaCBvbiBsaW5lICRcIiwgc3RhdGUkMS5kb2MubGluZUF0KGZyb20pLm51bWJlcikgKyBcIi5cIikpO1xuICAgIH1cbiAgICBpZiAobmV4dCkge1xuICAgICAgICBsZXQgb2ZmID0gY2hhbmdlcy5sZW5ndGggPT0gMCB8fCBjaGFuZ2VzWzBdLmZyb20gPj0gbWF0Y2gudG8gPyAwIDogbWF0Y2gudG8gLSBtYXRjaC5mcm9tIC0gcmVwbGFjZW1lbnQubGVuZ3RoO1xuICAgICAgICBzZWxlY3Rpb24gPSBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5leHQuZnJvbSAtIG9mZiwgbmV4dC50byAtIG9mZik7XG4gICAgICAgIGVmZmVjdHMucHVzaChhbm5vdW5jZU1hdGNoKHZpZXckMSwgbmV4dCkpO1xuICAgICAgICBlZmZlY3RzLnB1c2goc3RhdGUkMS5mYWNldChzZWFyY2hDb25maWdGYWNldCkuc2Nyb2xsVG9NYXRjaChzZWxlY3Rpb24ubWFpbiwgdmlldyQxKSk7XG4gICAgfVxuICAgIHZpZXckMS5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cyxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2VcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblJlcGxhY2UgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5IHdpdGggdGhlIGdpdmVuXG5yZXBsYWNlbWVudC5cbiovXG5jb25zdCByZXBsYWNlQWxsID0gc2VhcmNoQ29tbWFuZCgodmlldyQxLCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBpZiAodmlldyQxLnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBxdWVyeS5tYXRjaEFsbCh2aWV3JDEuc3RhdGUsIDFlOSkubWFwKG1hdGNoID0+IHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IG1hdGNoO1xuICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgaW5zZXJ0OiBxdWVyeS5nZXRSZXBsYWNlbWVudChtYXRjaCkgfTtcbiAgICB9KTtcbiAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFubm91bmNlVGV4dCA9IHZpZXckMS5zdGF0ZS5waHJhc2UoXCJyZXBsYWNlZCAkIG1hdGNoZXNcIiwgY2hhbmdlcy5sZW5ndGgpICsgXCIuXCI7XG4gICAgdmlldyQxLmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgZWZmZWN0czogdmlldy5FZGl0b3JWaWV3LmFubm91bmNlLm9mKGFubm91bmNlVGV4dCksXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlLmFsbFwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhbmVsKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkuY3JlYXRlUGFuZWwodmlldyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0UXVlcnkoc3RhdGUsIGZhbGxiYWNrKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHNlbFRleHQgPSBzZWwuZW1wdHkgfHwgc2VsLnRvID4gc2VsLmZyb20gKyAxMDAgPyBcIlwiIDogc3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIHNlbC50byk7XG4gICAgaWYgKGZhbGxiYWNrICYmICFzZWxUZXh0KVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgbGV0IGNvbmZpZyA9IHN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICByZXR1cm4gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgc2VhcmNoOiAoKF9hID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmxpdGVyYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbmZpZy5saXRlcmFsKSA/IHNlbFRleHQgOiBzZWxUZXh0LnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlOiAoX2IgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2suY2FzZVNlbnNpdGl2ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uZmlnLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgIGxpdGVyYWw6IChfYyA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5saXRlcmFsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjb25maWcubGl0ZXJhbCxcbiAgICAgICAgcmVnZXhwOiAoX2QgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2sucmVnZXhwKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBjb25maWcucmVnZXhwLFxuICAgICAgICB3aG9sZVdvcmQ6IChfZSA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay53aG9sZVdvcmQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGNvbmZpZy53aG9sZVdvcmRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNlYXJjaElucHV0KHZpZXckMSkge1xuICAgIGxldCBwYW5lbCA9IHZpZXcuZ2V0UGFuZWwodmlldyQxLCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgcmV0dXJuIHBhbmVsICYmIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiW21haW4tZmllbGRdXCIpO1xufVxuZnVuY3Rpb24gc2VsZWN0U2VhcmNoSW5wdXQodmlldykge1xuICAgIGxldCBpbnB1dCA9IGdldFNlYXJjaElucHV0KHZpZXcpO1xuICAgIGlmIChpbnB1dCAmJiBpbnB1dCA9PSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudClcbiAgICAgICAgaW5wdXQuc2VsZWN0KCk7XG59XG4vKipcbk1ha2Ugc3VyZSB0aGUgc2VhcmNoIHBhbmVsIGlzIG9wZW4gYW5kIGZvY3VzZWQuXG4qL1xuY29uc3Qgb3BlblNlYXJjaFBhbmVsID0gdmlldyA9PiB7XG4gICAgbGV0IHN0YXRlJDEgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKHN0YXRlJDEgJiYgc3RhdGUkMS5wYW5lbCkge1xuICAgICAgICBsZXQgc2VhcmNoSW5wdXQgPSBnZXRTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICAgICAgaWYgKHNlYXJjaElucHV0ICYmIHNlYXJjaElucHV0ICE9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSBkZWZhdWx0UXVlcnkodmlldy5zdGF0ZSwgc3RhdGUkMS5xdWVyeS5zcGVjKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS52YWxpZClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHRvZ2dsZVBhbmVsLm9mKHRydWUpLFxuICAgICAgICAgICAgICAgIHN0YXRlJDEgPyBzZXRTZWFyY2hRdWVyeS5vZihkZWZhdWx0UXVlcnkodmlldy5zdGF0ZSwgc3RhdGUkMS5xdWVyeS5zcGVjKSkgOiBzdGF0ZS5TdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2Yoc2VhcmNoRXh0ZW5zaW9ucylcbiAgICAgICAgICAgIF0gfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ2xvc2UgdGhlIHNlYXJjaCBwYW5lbC5cbiovXG5jb25zdCBjbG9zZVNlYXJjaFBhbmVsID0gdmlldyQxID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3JDEuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5wYW5lbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBwYW5lbCA9IHZpZXcuZ2V0UGFuZWwodmlldyQxLCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgaWYgKHBhbmVsICYmIHBhbmVsLmRvbS5jb250YWlucyh2aWV3JDEucm9vdC5hY3RpdmVFbGVtZW50KSlcbiAgICAgICAgdmlldyQxLmZvY3VzKCk7XG4gICAgdmlldyQxLmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRGVmYXVsdCBzZWFyY2gtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIE1vZC1mOiBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbClcbiAtIEYzLCBNb2QtZzogW2BmaW5kTmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmROZXh0KVxuIC0gU2hpZnQtRjMsIFNoaWZ0LU1vZC1nOiBbYGZpbmRQcmV2aW91c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmRQcmV2aW91cylcbiAtIE1vZC1BbHQtZzogW2Bnb3RvTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmdvdG9MaW5lKVxuIC0gTW9kLWQ6IFtgc2VsZWN0TmV4dE9jY3VycmVuY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWxlY3ROZXh0T2NjdXJyZW5jZSlcbiovXG5jb25zdCBzZWFyY2hLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLWZcIiwgcnVuOiBvcGVuU2VhcmNoUGFuZWwsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIkYzXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtZ1wiLCBydW46IGZpbmROZXh0LCBzaGlmdDogZmluZFByZXZpb3VzLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VTZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LWxcIiwgcnVuOiBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFsdC1nXCIsIHJ1bjogZ290b0xpbmUgfSxcbiAgICB7IGtleTogXCJNb2QtZFwiLCBydW46IHNlbGVjdE5leHRPY2N1cnJlbmNlLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuXTtcbmNsYXNzIFNlYXJjaFBhbmVsIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMucXVlcnkgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKS5xdWVyeS5zcGVjO1xuICAgICAgICB0aGlzLmNvbW1pdCA9IHRoaXMuY29tbWl0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkuc2VhcmNoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZSh2aWV3LCBcIkZpbmRcIiksXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiRmluZFwiKSxcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLFxuICAgICAgICAgICAgbmFtZTogXCJzZWFyY2hcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBcIm1haW4tZmllbGRcIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXQsXG4gICAgICAgICAgICBvbmtleXVwOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkucmVwbGFjZSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJSZXBsYWNlXCIpLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdCxcbiAgICAgICAgICAgIG9ua2V5dXA6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwiY2FzZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5LmNhc2VTZW5zaXRpdmUsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS5yZWdleHAsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud29yZEZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJ3b3JkXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkud2hvbGVXb3JkLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBidXR0b24obmFtZSwgb25jbGljaywgY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCBuYW1lLCBvbmNsaWNrLCB0eXBlOiBcImJ1dHRvblwiIH0sIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tID0gZWx0KFwiZGl2XCIsIHsgb25rZXlkb3duOiAoZSkgPT4gdGhpcy5rZXlkb3duKGUpLCBjbGFzczogXCJjbS1zZWFyY2hcIiB9LCBbXG4gICAgICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLFxuICAgICAgICAgICAgYnV0dG9uKFwibmV4dFwiLCAoKSA9PiBmaW5kTmV4dCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcIm5leHRcIildKSxcbiAgICAgICAgICAgIGJ1dHRvbihcInByZXZcIiwgKCkgPT4gZmluZFByZXZpb3VzKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicHJldmlvdXNcIildKSxcbiAgICAgICAgICAgIGJ1dHRvbihcInNlbGVjdFwiLCAoKSA9PiBzZWxlY3RNYXRjaGVzKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwiYWxsXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy5jYXNlRmllbGQsIHBocmFzZSh2aWV3LCBcIm1hdGNoIGNhc2VcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLnJlRmllbGQsIHBocmFzZSh2aWV3LCBcInJlZ2V4cFwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMud29yZEZpZWxkLCBwaHJhc2UodmlldywgXCJieSB3b3JkXCIpXSksXG4gICAgICAgICAgICAuLi52aWV3LnN0YXRlLnJlYWRPbmx5ID8gW10gOiBbXG4gICAgICAgICAgICAgICAgZWx0KFwiYnJcIiksXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQsXG4gICAgICAgICAgICAgICAgYnV0dG9uKFwicmVwbGFjZVwiLCAoKSA9PiByZXBsYWNlTmV4dCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInJlcGxhY2VcIildKSxcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlQWxsXCIsICgpID0+IHJlcGxhY2VBbGwodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlIGFsbFwiKV0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImNsb3NlXCIsXG4gICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gY2xvc2VTZWFyY2hQYW5lbCh2aWV3KSxcbiAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiY2xvc2VcIiksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgICAgICAgICAgfSwgW1wiw5dcIl0pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGxldCBxdWVyeSA9IG5ldyBTZWFyY2hRdWVyeSh7XG4gICAgICAgICAgICBzZWFyY2g6IHRoaXMuc2VhcmNoRmllbGQudmFsdWUsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiB0aGlzLmNhc2VGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVnZXhwOiB0aGlzLnJlRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHdob2xlV29yZDogdGhpcy53b3JkRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFxdWVyeS5lcSh0aGlzLnF1ZXJ5KSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGtleWRvd24oZSkge1xuICAgICAgICBpZiAodmlldy5ydW5TY29wZUhhbmRsZXJzKHRoaXMudmlldywgZSwgXCJzZWFyY2gtcGFuZWxcIikpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5zZWFyY2hGaWVsZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgKGUuc2hpZnRLZXkgPyBmaW5kUHJldmlvdXMgOiBmaW5kTmV4dCkodGhpcy52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5yZXBsYWNlRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlcGxhY2VOZXh0KHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSAmJiAhZWZmZWN0LnZhbHVlLmVxKHRoaXMucXVlcnkpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHNldFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSA9IHF1ZXJ5LnNlYXJjaDtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQudmFsdWUgPSBxdWVyeS5yZXBsYWNlO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZC5jaGVja2VkID0gcXVlcnkuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5yZUZpZWxkLmNoZWNrZWQgPSBxdWVyeS5yZWdleHA7XG4gICAgICAgIHRoaXMud29yZEZpZWxkLmNoZWNrZWQgPSBxdWVyeS53aG9sZVdvcmQ7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLnNlbGVjdCgpO1xuICAgIH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gODA7IH1cbiAgICBnZXQgdG9wKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS50b3A7IH1cbn1cbmZ1bmN0aW9uIHBocmFzZSh2aWV3LCBwaHJhc2UpIHsgcmV0dXJuIHZpZXcuc3RhdGUucGhyYXNlKHBocmFzZSk7IH1cbmNvbnN0IEFubm91bmNlTWFyZ2luID0gMzA7XG5jb25zdCBCcmVhayA9IC9bXFxzXFwuLDo7PyFdLztcbmZ1bmN0aW9uIGFubm91bmNlTWF0Y2godmlldyQxLCB7IGZyb20sIHRvIH0pIHtcbiAgICBsZXQgbGluZSA9IHZpZXckMS5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCBsaW5lRW5kID0gdmlldyQxLnN0YXRlLmRvYy5saW5lQXQodG8pLnRvO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgZnJvbSAtIEFubm91bmNlTWFyZ2luKSwgZW5kID0gTWF0aC5taW4obGluZUVuZCwgdG8gKyBBbm5vdW5jZU1hcmdpbik7XG4gICAgbGV0IHRleHQgPSB2aWV3JDEuc3RhdGUuc2xpY2VEb2Moc3RhcnQsIGVuZCk7XG4gICAgaWYgKHN0YXJ0ICE9IGxpbmUuZnJvbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFubm91bmNlTWFyZ2luOyBpKyspXG4gICAgICAgICAgICBpZiAoIUJyZWFrLnRlc3QodGV4dFtpICsgMV0pICYmIEJyZWFrLnRlc3QodGV4dFtpXSkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCAhPSBsaW5lRW5kKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0ZXh0Lmxlbmd0aCAtIDE7IGkgPiB0ZXh0Lmxlbmd0aCAtIEFubm91bmNlTWFyZ2luOyBpLS0pXG4gICAgICAgICAgICBpZiAoIUJyZWFrLnRlc3QodGV4dFtpIC0gMV0pICYmIEJyZWFrLnRlc3QodGV4dFtpXSkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZpZXcuRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3JDEuc3RhdGUucGhyYXNlKFwiY3VycmVudCBtYXRjaFwiKX0uICR7dGV4dH0gJHt2aWV3JDEuc3RhdGUucGhyYXNlKFwib24gbGluZVwiKX0gJHtsaW5lLm51bWJlcn0uYCk7XG59XG5jb25zdCBiYXNlVGhlbWUgPSB2aWV3LkVkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1zZWFyY2hcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCI0cHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBpbnB1dCwgJiBidXR0b24sICYgbGFiZWxcIjoge1xuICAgICAgICAgICAgbWFyZ2luOiBcIi4yZW0gLjZlbSAuMmVtIDBcIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXRbdHlwZT1jaGVja2JveF1cIjoge1xuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IFwiLjJlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogXCI4MCVcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwZmZmZjhhXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmNmEwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmYwMGZmOGFcIiB9XG59KTtcbmNvbnN0IHNlYXJjaEV4dGVuc2lvbnMgPSBbXG4gICAgc2VhcmNoU3RhdGUsXG4gICAgc3RhdGUuUHJlYy5sb3coc2VhcmNoSGlnaGxpZ2h0ZXIpLFxuICAgIGJhc2VUaGVtZVxuXTtcblxuZXhwb3J0cy5SZWdFeHBDdXJzb3IgPSBSZWdFeHBDdXJzb3I7XG5leHBvcnRzLlNlYXJjaEN1cnNvciA9IFNlYXJjaEN1cnNvcjtcbmV4cG9ydHMuU2VhcmNoUXVlcnkgPSBTZWFyY2hRdWVyeTtcbmV4cG9ydHMuY2xvc2VTZWFyY2hQYW5lbCA9IGNsb3NlU2VhcmNoUGFuZWw7XG5leHBvcnRzLmZpbmROZXh0ID0gZmluZE5leHQ7XG5leHBvcnRzLmZpbmRQcmV2aW91cyA9IGZpbmRQcmV2aW91cztcbmV4cG9ydHMuZ2V0U2VhcmNoUXVlcnkgPSBnZXRTZWFyY2hRdWVyeTtcbmV4cG9ydHMuZ290b0xpbmUgPSBnb3RvTGluZTtcbmV4cG9ydHMuaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcyA9IGhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXM7XG5leHBvcnRzLm9wZW5TZWFyY2hQYW5lbCA9IG9wZW5TZWFyY2hQYW5lbDtcbmV4cG9ydHMucmVwbGFjZUFsbCA9IHJlcGxhY2VBbGw7XG5leHBvcnRzLnJlcGxhY2VOZXh0ID0gcmVwbGFjZU5leHQ7XG5leHBvcnRzLnNlYXJjaCA9IHNlYXJjaDtcbmV4cG9ydHMuc2VhcmNoS2V5bWFwID0gc2VhcmNoS2V5bWFwO1xuZXhwb3J0cy5zZWFyY2hQYW5lbE9wZW4gPSBzZWFyY2hQYW5lbE9wZW47XG5leHBvcnRzLnNlbGVjdE1hdGNoZXMgPSBzZWxlY3RNYXRjaGVzO1xuZXhwb3J0cy5zZWxlY3ROZXh0T2NjdXJyZW5jZSA9IHNlbGVjdE5leHRPY2N1cnJlbmNlO1xuZXhwb3J0cy5zZWxlY3RTZWxlY3Rpb25NYXRjaGVzID0gc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcztcbmV4cG9ydHMuc2V0U2VhcmNoUXVlcnkgPSBzZXRTZWFyY2hRdWVyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG5UaGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIGRvY3VtZW50cy4gQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgVGV4dCB7XG4gICAgLyoqXG4gICAgR2V0IHRoZSBsaW5lIGRlc2NyaXB0aW9uIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBsaW5lQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+IHRoaXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgcG9zaXRpb24gJHtwb3N9IGluIGRvY3VtZW50IG9mIGxlbmd0aCAke3RoaXMubGVuZ3RofWApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIocG9zLCBmYWxzZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZGVzY3JpcHRpb24gZm9yIHRoZSBnaXZlbiAoMS1iYXNlZCkgbGluZSBudW1iZXIuXG4gICAgKi9cbiAgICBsaW5lKG4pIHtcbiAgICAgICAgaWYgKG4gPCAxIHx8IG4gPiB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbGluZSBudW1iZXIgJHtufSBpbiAke3RoaXMubGluZXN9LWxpbmUgZG9jdW1lbnRgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKG4sIHRydWUsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIHRleHQgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoMCwgZnJvbSwgcGFydHMsIDIgLyogT3Blbi5UbyAqLyk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRleHQuZGVjb21wb3NlKDAsIHRleHQubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8gfCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICB0aGlzLmRlY29tcG9zZSh0bywgdGhpcy5sZW5ndGgsIHBhcnRzLCAxIC8qIE9wZW4uRnJvbSAqLyk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgYW5vdGhlciBkb2N1bWVudCB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMubGVuZ3RoLCB0aGlzLmxlbmd0aCwgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdGV4dCBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKGZyb20sIHRvLCBwYXJ0cywgMCk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0byAtIGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyB0ZXh0IGlzIGVxdWFsIHRvIGFub3RoZXIgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob3RoZXIubGVuZ3RoICE9IHRoaXMubGVuZ3RoIHx8IG90aGVyLmxpbmVzICE9IHRoaXMubGluZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgMSksIGVuZCA9IHRoaXMubGVuZ3RoIC0gdGhpcy5zY2FuSWRlbnRpY2FsKG90aGVyLCAtMSk7XG4gICAgICAgIGxldCBhID0gbmV3IFJhd1RleHRDdXJzb3IodGhpcyksIGIgPSBuZXcgUmF3VGV4dEN1cnNvcihvdGhlcik7XG4gICAgICAgIGZvciAobGV0IHNraXAgPSBzdGFydCwgcG9zID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgYS5uZXh0KHNraXApO1xuICAgICAgICAgICAgYi5uZXh0KHNraXApO1xuICAgICAgICAgICAgc2tpcCA9IDA7XG4gICAgICAgICAgICBpZiAoYS5saW5lQnJlYWsgIT0gYi5saW5lQnJlYWsgfHwgYS5kb25lICE9IGIuZG9uZSB8fCBhLnZhbHVlICE9IGIudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcG9zICs9IGEudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGEuZG9uZSB8fCBwb3MgPj0gZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdGV4dC4gV2hlbiBgZGlyYCBpcyBgLTFgLCBpdGVyYXRpb24gaGFwcGVuc1xuICAgIGZyb20gZW5kIHRvIHN0YXJ0LiBUaGlzIHdpbGwgcmV0dXJuIGxpbmVzIGFuZCB0aGUgYnJlYWtzIGJldHdlZW5cbiAgICB0aGVtIGFzIHNlcGFyYXRlIHN0cmluZ3MuXG4gICAgKi9cbiAgICBpdGVyKGRpciA9IDEpIHsgcmV0dXJuIG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMsIGRpcik7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgYSByYW5nZSBvZiB0aGUgdGV4dC4gV2hlbiBgZnJvbWAgPiBgdG9gLCB0aGVcbiAgICBpdGVyYXRvciB3aWxsIHJ1biBpbiByZXZlcnNlLlxuICAgICovXG4gICAgaXRlclJhbmdlKGZyb20sIHRvID0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIG5ldyBQYXJ0aWFsVGV4dEN1cnNvcih0aGlzLCBmcm9tLCB0byk7IH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBjdXJzb3IgdGhhdCBpdGVyYXRlcyBvdmVyIHRoZSBnaXZlbiByYW5nZSBvZiBsaW5lcyxcbiAgICBfd2l0aG91dF8gcmV0dXJuaW5nIHRoZSBsaW5lIGJyZWFrcyBiZXR3ZWVuLCBhbmQgeWllbGRpbmcgZW1wdHlcbiAgICBzdHJpbmdzIGZvciBlbXB0eSBsaW5lcy5cbiAgICBcbiAgICBXaGVuIGBmcm9tYCBhbmQgYHRvYCBhcmUgZ2l2ZW4sIHRoZXkgc2hvdWxkIGJlIDEtYmFzZWQgbGluZSBudW1iZXJzLlxuICAgICovXG4gICAgaXRlckxpbmVzKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBpbm5lcjtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5uZXIgPSB0aGlzLml0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRvID0gdGhpcy5saW5lcyArIDE7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmxpbmUoZnJvbSkuZnJvbTtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyUmFuZ2Uoc3RhcnQsIE1hdGgubWF4KHN0YXJ0LCB0byA9PSB0aGlzLmxpbmVzICsgMSA/IHRoaXMubGVuZ3RoIDogdG8gPD0gMSA/IDAgOiB0aGlzLmxpbmUodG8gLSAxKS50bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGluZUN1cnNvcihpbm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcsIHVzaW5nIG5ld2xpbmUgY2hhcmFjdGVycyB0b1xuICAgIHNlcGFyYXRlIGxpbmVzLlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLnNsaWNlU3RyaW5nKDApOyB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGUgZG9jdW1lbnQgdG8gYW4gYXJyYXkgb2YgbGluZXMgKHdoaWNoIGNhbiBiZVxuICAgIGRlc2VyaWFsaXplZCBhZ2FpbiB2aWEgW2BUZXh0Lm9mYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0Xm9mKSkuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmZsYXR0ZW4obGluZXMpO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgVGV4dGAgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBsaW5lcy5cbiAgICAqL1xuICAgIHN0YXRpYyBvZih0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIGRvY3VtZW50IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGluZVwiKTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEgJiYgIXRleHRbMF0pXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovID8gbmV3IFRleHRMZWFmKHRleHQpIDogVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdCh0ZXh0LCBbXSkpO1xuICAgIH1cbn1cbi8vIExlYXZlcyBzdG9yZSBhbiBhcnJheSBvZiBsaW5lIHN0cmluZ3MuIFRoZXJlIGFyZSBhbHdheXMgbGluZSBicmVha3Ncbi8vIGJldHdlZW4gdGhlc2Ugc3RyaW5ncy4gTGVhdmVzIGFyZSBsaW1pdGVkIGluIHNpemUgYW5kIGhhdmUgdG8gYmVcbi8vIGNvbnRhaW5lZCBpbiBUZXh0Tm9kZSBpbnN0YW5jZXMgZm9yIGJpZ2dlciBkb2N1bWVudHMuXG5jbGFzcyBUZXh0TGVhZiBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGxlbmd0aCA9IHRleHRMZW5ndGgodGV4dCkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGdldCBsaW5lcygpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBudWxsOyB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnRleHRbaV0sIGVuZCA9IG9mZnNldCArIHN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGxpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpbmUob2Zmc2V0LCBlbmQsIGxpbmUsIHN0cmluZyk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZnJvbSA8PSAwICYmIHRvID49IHRoaXMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgVGV4dExlYWYoc2xpY2VUZXh0KHRoaXMudGV4dCwgZnJvbSwgdG8pLCBNYXRoLm1pbih0bywgdGhpcy5sZW5ndGgpIC0gTWF0aC5tYXgoMCwgZnJvbSkpO1xuICAgICAgICBpZiAob3BlbiAmIDEgLyogT3Blbi5Gcm9tICovKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRhcmdldC5wb3AoKTtcbiAgICAgICAgICAgIGxldCBqb2luZWQgPSBhcHBlbmRUZXh0KHRleHQudGV4dCwgcHJldi50ZXh0LnNsaWNlKCksIDAsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChqb2luZWQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZCwgcHJldi5sZW5ndGggKyB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1pZCA9IGpvaW5lZC5sZW5ndGggPj4gMTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKDAsIG1pZCkpLCBuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKG1pZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgaWYgKCEodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmKSlcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgbGluZXMgPSBhcHBlbmRUZXh0KHRoaXMudGV4dCwgYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHNsaWNlVGV4dCh0aGlzLnRleHQsIDAsIGZyb20pKSwgdG8pO1xuICAgICAgICBsZXQgbmV3TGVuID0gdGhpcy5sZW5ndGggKyB0ZXh0Lmxlbmd0aCAtICh0byAtIGZyb20pO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVhZihsaW5lcywgbmV3TGVuKTtcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQobGluZXMsIFtdKSwgbmV3TGVuKTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMudGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnRleHQpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbCgpIHsgcmV0dXJuIDA7IH1cbiAgICBzdGF0aWMgc3BsaXQodGV4dCwgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBwYXJ0ID0gW10sIGxlbiA9IC0xO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHBhcnQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGxlbiArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgcGFydCA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAtMSlcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vLyBOb2RlcyBwcm92aWRlIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgYFRleHRgIHR5cGUuIFRoZXkgc3RvcmUgYVxuLy8gbnVtYmVyIG9mIG90aGVyIG5vZGVzIG9yIGxlYXZlcywgdGFraW5nIGNhcmUgdG8gYmFsYW5jZSB0aGVtc2VsdmVzXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXG4vLyBhIG5vZGUgKGJ1dCBub3QgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZCkuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcbiAgICB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLmxlbmd0aCwgZW5kTGluZSA9IGxpbmUgKyBjaGlsZC5saW5lcyAtIDE7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGVuZExpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUgPSBlbmRMaW5lICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBlbmQgJiYgdG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBPcGVuLkZyb20gKi8gOiAwKSB8IChlbmQgPj0gdG8gPyAyIC8qIE9wZW4uVG8gKi8gOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIGVuZCA8PSB0byAmJiAhY2hpbGRPcGVuKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWNvbXBvc2UoZnJvbSAtIHBvcywgdG8gLSBwb3MsIHRhcmdldCwgY2hpbGRPcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGlmICh0ZXh0LmxpbmVzIDwgdGhpcy5saW5lcylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSBjaGFuZ2Ugb25seSBhZmZlY3RzIG9uZSBjaGlsZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQncyBzaXplIHJlbWFpbnMgaW4gdGhlIGFjY2VwdGFibGUgcmFuZ2UsIG9ubHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjaGlsZFxuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHBvcyAmJiB0byA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSBjaGlsZC5yZXBsYWNlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsTGluZXMgPSB0aGlzLmxpbmVzIC0gY2hpbGQubGluZXMgKyB1cGRhdGVkLmxpbmVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5saW5lcyA8ICh0b3RhbExpbmVzID4+ICg1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8gLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQubGluZXMgPiAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29weSA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlbaV0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZShjb3B5LCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHBvcywgZW5kLCB1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UoZnJvbSwgdG8sIHRleHQpO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkLnNsaWNlU3RyaW5nKGZyb20gLSBwb3MsIHRvIC0gcG9zLCBsaW5lU2VwKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgIGNoaWxkLmZsYXR0ZW4odGFyZ2V0KTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbChvdGhlciwgZGlyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVGV4dE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICBsZXQgW2lBLCBpQiwgZUEsIGVCXSA9IGRpciA+IDAgPyBbMCwgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIG90aGVyLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgICAgIDogW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIC0xXTtcbiAgICAgICAgZm9yICg7OyBpQSArPSBkaXIsIGlCICs9IGRpcikge1xuICAgICAgICAgICAgaWYgKGlBID09IGVBIHx8IGlCID09IGVCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2hBID0gdGhpcy5jaGlsZHJlbltpQV0sIGNoQiA9IG90aGVyLmNoaWxkcmVuW2lCXTtcbiAgICAgICAgICAgIGlmIChjaEEgIT0gY2hCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggKyBjaEEuc2NhbklkZW50aWNhbChjaEIsIGRpcik7XG4gICAgICAgICAgICBsZW5ndGggKz0gY2hBLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb20oY2hpbGRyZW4sIGxlbmd0aCA9IGNoaWxkcmVuLnJlZHVjZSgobCwgY2gpID0+IGwgKyBjaC5sZW5ndGggKyAxLCAtMSkpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBsaW5lcyArPSBjaC5saW5lcztcbiAgICAgICAgaWYgKGxpbmVzIDwgMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgIGxldCBmbGF0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaC5mbGF0dGVuKGZsYXQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVhZihmbGF0LCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaHVuayA9IE1hdGgubWF4KDMyIC8qIFRyZWUuQnJhbmNoICovLCBsaW5lcyA+PiA1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8pLCBtYXhDaHVuayA9IGNodW5rIDw8IDEsIG1pbkNodW5rID0gY2h1bmsgPj4gMTtcbiAgICAgICAgbGV0IGNodW5rZWQgPSBbXSwgY3VycmVudExpbmVzID0gMCwgY3VycmVudExlbiA9IC0xLCBjdXJyZW50Q2h1bmsgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkKGNoaWxkKSB7XG4gICAgICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgICAgIGlmIChjaGlsZC5saW5lcyA+IG1heENodW5rICYmIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIGNoaWxkLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBhZGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5saW5lcyA+IG1pbkNodW5rICYmIChjdXJyZW50TGluZXMgPiBtaW5DaHVuayB8fCAhY3VycmVudExpbmVzKSkge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dExlYWYgJiYgY3VycmVudExpbmVzICYmXG4gICAgICAgICAgICAgICAgKGxhc3QgPSBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdKSBpbnN0YW5jZW9mIFRleHRMZWFmICYmXG4gICAgICAgICAgICAgICAgY2hpbGQubGluZXMgKyBsYXN0LmxpbmVzIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdID0gbmV3IFRleHRMZWFmKGxhc3QudGV4dC5jb25jYXQoY2hpbGQudGV4dCksIGxhc3QubGVuZ3RoICsgMSArIGNoaWxkLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudExpbmVzICsgY2hpbGQubGluZXMgPiBjaHVuaylcbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudExlbiArPSBjaGlsZC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVuay5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGluZXMgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjaHVua2VkLnB1c2goY3VycmVudENodW5rLmxlbmd0aCA9PSAxID8gY3VycmVudENodW5rWzBdIDogVGV4dE5vZGUuZnJvbShjdXJyZW50Q2h1bmssIGN1cnJlbnRMZW4pKTtcbiAgICAgICAgICAgIGN1cnJlbnRMZW4gPSAtMTtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lcyA9IGN1cnJlbnRDaHVuay5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgYWRkKGNoaWxkKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIGNodW5rZWQubGVuZ3RoID09IDEgPyBjaHVua2VkWzBdIDogbmV3IFRleHROb2RlKGNodW5rZWQsIGxlbmd0aCk7XG4gICAgfVxufVxuVGV4dC5lbXB0eSA9IG5ldyBUZXh0TGVhZihbXCJcIl0sIDApO1xuZnVuY3Rpb24gdGV4dExlbmd0aCh0ZXh0KSB7XG4gICAgbGV0IGxlbmd0aCA9IC0xO1xuICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dClcbiAgICAgICAgbGVuZ3RoICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZnVuY3Rpb24gYXBwZW5kVGV4dCh0ZXh0LCB0YXJnZXQsIGZyb20gPSAwLCB0byA9IDFlOSkge1xuICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwLCBmaXJzdCA9IHRydWU7IGkgPCB0ZXh0Lmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xuICAgICAgICBsZXQgbGluZSA9IHRleHRbaV0sIGVuZCA9IHBvcyArIGxpbmUubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCB0byAtIHBvcyk7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShmcm9tIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFt0YXJnZXQubGVuZ3RoIC0gMV0gKz0gbGluZTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzbGljZVRleHQodGV4dCwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gYXBwZW5kVGV4dCh0ZXh0LCBbXCJcIl0sIGZyb20sIHRvKTtcbn1cbmNsYXNzIFJhd1RleHRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGRpciA9IDEpIHtcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0ZXh0XTtcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gW2RpciA+IDAgPyAxIDogKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRleHQudGV4dC5sZW5ndGggOiB0ZXh0LmNoaWxkcmVuLmxlbmd0aCkgPDwgMV07XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5ub2Rlc1tsYXN0XSwgb2Zmc2V0VmFsdWUgPSB0aGlzLm9mZnNldHNbbGFzdF0sIG9mZnNldCA9IG9mZnNldFZhbHVlID4+IDE7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdG9wLnRleHQubGVuZ3RoIDogdG9wLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gKGRpciA+IDAgPyBzaXplIDogMCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0IC0gMV0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChvZmZzZXRWYWx1ZSAmIDEpID09IChkaXIgPiAwID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZikge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgc3RyaW5nXG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AudGV4dFtvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubGVuZ3RoID4gTWF0aC5tYXgoMCwgc2tpcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNraXAgPT0gMCA/IG5leHQgOiBkaXIgPiAwID8gbmV4dC5zbGljZShza2lwKSA6IG5leHQuc2xpY2UoMCwgbmV4dC5sZW5ndGggLSBza2lwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID4gbmV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnB1c2goZGlyID4gMCA/IDEgOiAobmV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gbmV4dC50ZXh0Lmxlbmd0aCA6IG5leHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dElubmVyKC1za2lwLCAoLXRoaXMuZGlyKSk7XG4gICAgICAgICAgICBza2lwID0gdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dElubmVyKHNraXAsIHRoaXMuZGlyKTtcbiAgICB9XG59XG5jbGFzcyBQYXJ0aWFsVGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbmV3IFJhd1RleHRDdXJzb3IodGV4dCwgc3RhcnQgPiBlbmQgPyAtMSA6IDEpO1xuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0ID4gZW5kID8gdGV4dC5sZW5ndGggOiAwO1xuICAgICAgICB0aGlzLmZyb20gPSBNYXRoLm1pbihzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy50byA9IE1hdGgubWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBuZXh0SW5uZXIoc2tpcCwgZGlyKSB7XG4gICAgICAgIGlmIChkaXIgPCAwID8gdGhpcy5wb3MgPD0gdGhpcy5mcm9tIDogdGhpcy5wb3MgPj0gdGhpcy50bykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcCArPSBNYXRoLm1heCgwLCBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLnRvIDogdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBsZXQgbGltaXQgPSBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLmZyb20gOiB0aGlzLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChza2lwID4gbGltaXQpXG4gICAgICAgICAgICBza2lwID0gbGltaXQ7XG4gICAgICAgIGxpbWl0IC09IHNraXA7XG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSB0aGlzLmN1cnNvci5uZXh0KHNraXApO1xuICAgICAgICB0aGlzLnBvcyArPSAodmFsdWUubGVuZ3RoICsgc2tpcCkgKiBkaXI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS5sZW5ndGggPD0gbGltaXQgPyB2YWx1ZSA6IGRpciA8IDAgPyB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBsaW1pdCkgOiB2YWx1ZS5zbGljZSgwLCBsaW1pdCk7XG4gICAgICAgIHRoaXMuZG9uZSA9ICF0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApXG4gICAgICAgICAgICBza2lwID0gTWF0aC5tYXgoc2tpcCwgdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBlbHNlIGlmIChza2lwID4gMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1pbihza2lwLCB0aGlzLnRvIC0gdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5jdXJzb3IuZGlyKTtcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuY3Vyc29yLmxpbmVCcmVhayAmJiB0aGlzLnZhbHVlICE9IFwiXCI7IH1cbn1cbmNsYXNzIExpbmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlubmVyKSB7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGxldCB7IGRvbmUsIGxpbmVCcmVhaywgdmFsdWUgfSA9IHRoaXMuaW5uZXIubmV4dChza2lwKTtcbiAgICAgICAgaWYgKGRvbmUgJiYgdGhpcy5hZnRlckJyZWFrKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFmdGVyQnJlYWspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgVGV4dC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaXRlcigpOyB9O1xuICAgIFJhd1RleHRDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBQYXJ0aWFsVGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XG4gICAgICAgIExpbmVDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuLyoqXG5UaGlzIHR5cGUgZGVzY3JpYmVzIGEgbGluZSBpbiB0aGUgZG9jdW1lbnQuIEl0IGlzIGNyZWF0ZWRcbm9uLWRlbWFuZCB3aGVuIGxpbmVzIGFyZSBbcXVlcmllZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0LmxpbmVBdCkuXG4qL1xuY2xhc3MgTGluZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgKF9iZWZvcmVfIHRoZSBsaW5lIGJyZWFrLFxuICAgIG9yIGF0IHRoZSBlbmQgb2YgZG9jdW1lbnQgZm9yIHRoZSBsYXN0IGxpbmUpLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoaXMgbGluZSdzIGxpbmUgbnVtYmVyICgxLWJhc2VkKS5cbiAgICAqL1xuICAgIG51bWJlciwgXG4gICAgLyoqXG4gICAgVGhlIGxpbmUncyBjb250ZW50LlxuICAgICovXG4gICAgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBsaW5lIChub3QgaW5jbHVkaW5nIGFueSBsaW5lIGJyZWFrIGFmdGVyIGl0KS5cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvIC0gdGhpcy5mcm9tOyB9XG59XG5mdW5jdGlvbiBjbGlwKHRleHQsIGZyb20sIHRvKSB7XG4gICAgZnJvbSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRleHQubGVuZ3RoLCBmcm9tKSk7XG4gICAgcmV0dXJuIFtmcm9tLCBNYXRoLm1heChmcm9tLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgdG8pKV07XG59XG5cbi8vIENvbXByZXNzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIEdyYXBoZW1lX0NsdXN0ZXJfQnJlYWs9RXh0ZW5kXG4vLyBpbmZvcm1hdGlvbiBmcm9tXG4vLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy8xMy4wLjAvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0LlxuLy8gRWFjaCBwYWlyIG9mIGVsZW1lbnRzIHJlcHJlc2VudHMgYSByYW5nZSwgYXMgYW4gb2ZmZXQgZnJvbSB0aGVcbi8vIHByZXZpb3VzIHJhbmdlIGFuZCBhIGxlbmd0aC4gTnVtYmVycyBhcmUgaW4gYmFzZS0zNiwgd2l0aCB0aGUgZW1wdHlcbi8vIHN0cmluZyBiZWluZyBhIHNob3J0aGFuZCBmb3IgMS5cbmxldCBleHRlbmQgPSBcImxjLDM0LDduLDcsN2IsMTksLCwsMiwsMiwsLDIwLGIsMWMsbCxnLCwydCw3LDIsNiwyLDIsLDQseiwsdSxyLDJqLGIsMW0sOSw5LCxvLDQsLDksLDMsLDUsMTcsMywzYixmLCx3LDFqLCwsLDQsOCw0LCwzLDcsYSwyLHQsLDFtLCwsLDIsNCw4LCw5LCxhLDIscSwsMiwyLDFsLCw0LDIsNCwyLDIsMywzLCx1LDIsMywsYiwyLDFsLCw0LDUsLDIsNCwsaywyLG0sNiwsLDFtLCwsMiwsNCw4LCw3LDMsYSwyLHUsLDFuLCwsLGMsLDksLDE0LCwzLCwxbCwzLDUsMywsNCw3LDIsYiwyLHQsLDFtLCwyLCwyLCwzLCw1LDIsNywyLGIsMixzLDIsMWwsMiwsLDIsNCw4LCw5LCxhLDIsdCwsMjAsLDQsLDIsMywsLDgsLDI5LCwyLDcsYyw4LDJxLCwyLDksYiw2LDIyLDIsciwsLCwsLDFqLGUsLDUsLDIsNSxiLCwxMCw5LCwydSw0LCw2LCwyLDIsMixwLDIsNCwzLGcsNCxkLCwyLDIsNiwsZiwsamosMyxxYSwzLHQsMyx0LDIsdSwyLDFzLDIsLDcsOCwsMixiLDksLDE5LDMsM2IsMix5LCwzYSwzLDQsMiw5LCw2LDMsNjMsMiwyLCwxbSwsLDcsLCwsLDIsOCw2LGEsMiwsMWMsaCwxciw0LDFjLDcsLCw1LCwxNCw5LGMsMix3LDQsMiwyLCwzLDFrLCwsMiwzLCwsMywxbSw4LDIsMiw0OCwzLCxkLCw3LDQsLDYsLDMsMiw1aSwxbSwsNSxlaywsNWYseCwyZGEsMywzeCwsMm8sdyxmZSw2LDJ4LDIsbjl3LDQsLGEsdywyLDI4LDIsN2ssLDMsLDQsLHAsMiw1LCw0NywyLHEsaSxkLCwxMiw4LHAsYiwxYSwzLDFjLCwyLDQsMiwyLDEzLCwxdiw2LDIsMiwyLDIsYywsOCwsMWIsLDFmLCwsMywyLDIsNSwyLCwsMTYsMiw4LCw2bSwsMiwsNCwsZm40LCxraCxnLGcsZyxhNiwyLGd0LCw2YSwsNDUsNSwxYWUsMywsMiw1LDQsMTQsMyw0LCw0bCwyLGZ4LDQsYXIsMiw0OSxiLDR3LCwxaSxmLDFrLDMsMWQsNCwyLDIsMXgsMywxMCw1LCw4LDFxLCxjLDIsMWcsOSxhLDQsMiwsMm4sMywyLCwsMiw2LCw0ZywsMyw4LGwsMiwxbCwyLCwsLCxtLCxlLDcsMyw1LDVmLDgsMiwzLCwsbiwsMjksLDIsNiwsLDIsLCwyLCwyLDZqLCwyLDQsNiwyLCwyLHIsMiwyZCw4LDIsLCwyLDJ5LCwsLDIsNiwsLDJ0LDMsMiw0LCw1LDc3LDksLDIsNnQsLGEsMiwsLDQsLDQwLDQsMiwyLDQsLHcsYSwxNCw2LDIsNCw4LCw5LDYsMiwzLDFhLGQsLDIsYmEsNywsNiwsLDJhLG0sMiw3LCwyLCwyLDNlLDYsMywsLDIsLDcsLCwyMCwyLDMsLCwsOW4sMixmMGIsNSwxbiw3LHQ0LCwxciw0LDI5LCxmNWssMiw0M3EsLCwzLDQsNSw4LDgsMiw3LHUsNCw0NCwzLDFpeiwxaiw0LDFlLDgsLGUsLG0sNSwsZiwxMXMsNywsaCwyLDcsLDIsLDUsNzksNyxjNSw0LDE1cyw3LDMxLDcsMjQwLDUsZ3g3aywybywzayw2b1wiLnNwbGl0KFwiLFwiKS5tYXAocyA9PiBzID8gcGFyc2VJbnQocywgMzYpIDogMSk7XG4vLyBDb252ZXJ0IG9mZnNldHMgaW50byBhYnNvbHV0ZSB2YWx1ZXNcbmZvciAobGV0IGkgPSAxOyBpIDwgZXh0ZW5kLmxlbmd0aDsgaSsrKVxuICAgIGV4dGVuZFtpXSArPSBleHRlbmRbaSAtIDFdO1xuZnVuY3Rpb24gaXNFeHRlbmRpbmdDaGFyKGNvZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgaWYgKGV4dGVuZFtpXSA+IGNvZGUpXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kW2kgLSAxXSA8PSBjb2RlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzUmVnaW9uYWxJbmRpY2F0b3IoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDB4MUYxRTYgJiYgY29kZSA8PSAweDFGMUZGO1xufVxuY29uc3QgWldKID0gMHgyMDBkO1xuLyoqXG5SZXR1cm5zIGEgbmV4dCBncmFwaGVtZSBjbHVzdGVyIGJyZWFrIF9hZnRlcl8gKG5vdCBlcXVhbCB0bylcbmBwb3NgLCBpZiBgZm9yd2FyZGAgaXMgdHJ1ZSwgb3IgYmVmb3JlIG90aGVyd2lzZS4gUmV0dXJucyBgcG9zYFxuaXRzZWxmIGlmIG5vIGZ1cnRoZXIgY2x1c3RlciBicmVhayBpcyBhdmFpbGFibGUgaW4gdGhlIHN0cmluZy5cbk1vdmVzIGFjcm9zcyBzdXJyb2dhdGUgcGFpcnMsIGV4dGVuZGluZyBjaGFyYWN0ZXJzICh3aGVuXG5gaW5jbHVkZUV4dGVuZGluZ2AgaXMgdHJ1ZSksIGNoYXJhY3RlcnMgam9pbmVkIHdpdGggemVyby13aWR0aFxuam9pbmVycywgYW5kIGZsYWcgZW1vamkuXG4qL1xuZnVuY3Rpb24gZmluZENsdXN0ZXJCcmVhayhzdHIsIHBvcywgZm9yd2FyZCA9IHRydWUsIGluY2x1ZGVFeHRlbmRpbmcgPSB0cnVlKSB7XG4gICAgcmV0dXJuIChmb3J3YXJkID8gbmV4dENsdXN0ZXJCcmVhayA6IHByZXZDbHVzdGVyQnJlYWspKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKTtcbn1cbmZ1bmN0aW9uIG5leHRDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGluY2x1ZGVFeHRlbmRpbmcpIHtcbiAgICBpZiAocG9zID09IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgLy8gSWYgcG9zIGlzIGluIHRoZSBtaWRkbGUgb2YgYSBzdXJyb2dhdGUgcGFpciwgbW92ZSB0byBpdHMgc3RhcnRcbiAgICBpZiAocG9zICYmIHN1cnJvZ2F0ZUxvdyhzdHIuY2hhckNvZGVBdChwb3MpKSAmJiBzdXJyb2dhdGVIaWdoKHN0ci5jaGFyQ29kZUF0KHBvcyAtIDEpKSlcbiAgICAgICAgcG9zLS07XG4gICAgbGV0IHByZXYgPSBjb2RlUG9pbnRBdChzdHIsIHBvcyk7XG4gICAgcG9zICs9IGNvZGVQb2ludFNpemUocHJldik7XG4gICAgd2hpbGUgKHBvcyA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBjb2RlUG9pbnRBdChzdHIsIHBvcyk7XG4gICAgICAgIGlmIChwcmV2ID09IFpXSiB8fCBuZXh0ID09IFpXSiB8fCBpbmNsdWRlRXh0ZW5kaW5nICYmIGlzRXh0ZW5kaW5nQ2hhcihuZXh0KSkge1xuICAgICAgICAgICAgcG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBwcmV2ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZ2lvbmFsSW5kaWNhdG9yKG5leHQpKSB7XG4gICAgICAgICAgICBsZXQgY291bnRCZWZvcmUgPSAwLCBpID0gcG9zIC0gMjtcbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgaXNSZWdpb25hbEluZGljYXRvcihjb2RlUG9pbnRBdChzdHIsIGkpKSkge1xuICAgICAgICAgICAgICAgIGNvdW50QmVmb3JlKys7XG4gICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50QmVmb3JlICUgMiA9PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIHByZXZDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGluY2x1ZGVFeHRlbmRpbmcpIHtcbiAgICB3aGlsZSAocG9zID4gMCkge1xuICAgICAgICBsZXQgZm91bmQgPSBuZXh0Q2x1c3RlckJyZWFrKHN0ciwgcG9zIC0gMiwgaW5jbHVkZUV4dGVuZGluZyk7XG4gICAgICAgIGlmIChmb3VuZCA8IHBvcylcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgcG9zLS07XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gc3Vycm9nYXRlTG93KGNoKSB7IHJldHVybiBjaCA+PSAweERDMDAgJiYgY2ggPCAweEUwMDA7IH1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUhpZ2goY2gpIHsgcmV0dXJuIGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REMwMDsgfVxuLyoqXG5GaW5kIHRoZSBjb2RlIHBvaW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpbiBhIHN0cmluZyAobGlrZSB0aGVcbltgY29kZVBvaW50QXRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvY29kZVBvaW50QXQpXG5zdHJpbmcgbWV0aG9kKS5cbiovXG5mdW5jdGlvbiBjb2RlUG9pbnRBdChzdHIsIHBvcykge1xuICAgIGxldCBjb2RlMCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFzdXJyb2dhdGVIaWdoKGNvZGUwKSB8fCBwb3MgKyAxID09IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICBsZXQgY29kZTEgPSBzdHIuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAoIXN1cnJvZ2F0ZUxvdyhjb2RlMSkpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICByZXR1cm4gKChjb2RlMCAtIDB4ZDgwMCkgPDwgMTApICsgKGNvZGUxIC0gMHhkYzAwKSArIDB4MTAwMDA7XG59XG4vKipcbkdpdmVuIGEgVW5pY29kZSBjb2RlcG9pbnQsIHJldHVybiB0aGUgSmF2YVNjcmlwdCBzdHJpbmcgdGhhdFxucmVzcHJlc2VudHMgaXQgKGxpa2VcbltgU3RyaW5nLmZyb21Db2RlUG9pbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZnJvbUNvZGVQb2ludCkpLlxuKi9cbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoY29kZSkge1xuICAgIGlmIChjb2RlIDw9IDB4ZmZmZilcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgY29kZSAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4ZDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4ZGMwMCk7XG59XG4vKipcblRoZSBhbW91bnQgb2YgcG9zaXRpb25zIGEgY2hhcmFjdGVyIHRha2VzIHVwIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50U2l6ZShjb2RlKSB7IHJldHVybiBjb2RlIDwgMHgxMDAwMCA/IDEgOiAyOyB9XG5cbmNvbnN0IERlZmF1bHRTcGxpdCA9IC9cXHJcXG4/fFxcbi87XG4vKipcbkRpc3Rpbmd1aXNoZXMgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggcG9zaXRpb25zIGNhbiBiZSBtYXBwZWQuXG4qL1xuZXhwb3J0cy5NYXBNb2RlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChNYXBNb2RlKSB7XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdG8gYSB2YWxpZCBuZXcgcG9zaXRpb24sIGV2ZW4gd2hlbiBpdHMgY29udGV4dFxuICAgIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiU2ltcGxlXCJdID0gMF0gPSBcIlNpbXBsZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIGRlbGV0aW9uIGhhcHBlbnMgYWNyb3NzIHRoZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrRGVsXCJdID0gMV0gPSBcIlRyYWNrRGVsXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYmVmb3JlXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQmVmb3JlXCJdID0gMl0gPSBcIlRyYWNrQmVmb3JlXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYWZ0ZXJfIHRoZSBwb3NpdGlvbiBpcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tBZnRlclwiXSA9IDNdID0gXCJUcmFja0FmdGVyXCI7XG59KShleHBvcnRzLk1hcE1vZGUgfHwgKGV4cG9ydHMuTWFwTW9kZSA9IHt9KSk7XG4vKipcbkEgY2hhbmdlIGRlc2NyaXB0aW9uIGlzIGEgdmFyaWFudCBvZiBbY2hhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQpXG50aGF0IGRvZXNuJ3Qgc3RvcmUgdGhlIGluc2VydGVkIHRleHQuIEFzIHN1Y2gsIGl0IGNhbid0IGJlXG5hcHBsaWVkLCBidXQgaXMgY2hlYXBlciB0byBzdG9yZSBhbmQgbWFuaXB1bGF0ZS5cbiovXG5jbGFzcyBDaGFuZ2VEZXNjIHtcbiAgICAvLyBTZWN0aW9ucyBhcmUgZW5jb2RlZCBhcyBwYWlycyBvZiBpbnRlZ2Vycy4gVGhlIGZpcnN0IGlzIHRoZVxuICAgIC8vIGxlbmd0aCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCwgYW5kIHRoZSBzZWNvbmQgaXMgLTEgZm9yXG4gICAgLy8gdW5hZmZlY3RlZCBzZWN0aW9ucywgYW5kIHRoZSBsZW5ndGggb2YgdGhlIHJlcGxhY2VtZW50IGNvbnRlbnRcbiAgICAvLyBvdGhlcndpc2UuIFNvIGFuIGluc2VydGlvbiB3b3VsZCBiZSAoMCwgbj4wKSwgYSBkZWxldGlvbiAobj4wLFxuICAgIC8vIDApLCBhbmQgYSByZXBsYWNlbWVudCB0d28gcG9zaXRpdmUgbnVtYmVycy5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5zZWN0aW9uc1tpXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhlIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBuZXdMZW5ndGgoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBpbnMgPSB0aGlzLnNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBpbnMgPCAwID8gdGhpcy5zZWN0aW9uc1tpXSA6IGlucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBGYWxzZSB3aGVuIHRoZXJlIGFyZSBhY3R1YWwgY2hhbmdlcyBpbiB0aGlzIHNldC5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnMubGVuZ3RoID09IDAgfHwgdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMiAmJiB0aGlzLnNlY3Rpb25zWzFdIDwgMDsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdW5jaGFuZ2VkIHBhcnRzIGxlZnQgYnkgdGhlc2UgY2hhbmdlcy4gYHBvc0FgXG4gICAgcHJvdmlkZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSByYW5nZSBpbiB0aGUgb2xkIGRvY3VtZW50LCBgcG9zQmBcbiAgICB0aGUgbmV3IHBvc2l0aW9uIGluIHRoZSBjaGFuZ2VkIGRvY3VtZW50LlxuICAgICovXG4gICAgaXRlckdhcHMoZikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zQSA9IDAsIHBvc0IgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgICAgIGYocG9zQSwgcG9zQiwgbGVuKTtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgY2hhbmdlZCBieSB0aGVzZSBjaGFuZ2VzLiAoU2VlXG4gICAgW2BDaGFuZ2VTZXQuaXRlckNoYW5nZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldC5pdGVyQ2hhbmdlcykgZm9yIGFcbiAgICB2YXJpYW50IHRoYXQgYWxzbyBwcm92aWRlcyB5b3Ugd2l0aCB0aGUgaW5zZXJ0ZWQgdGV4dC4pXG4gICAgYGZyb21BYC9gdG9BYCBwcm92aWRlcyB0aGUgZXh0ZW50IG9mIHRoZSBjaGFuZ2UgaW4gdGhlIHN0YXJ0aW5nXG4gICAgZG9jdW1lbnQsIGBmcm9tQmAvYHRvQmAgdGhlIGV4dGVudCBvZiB0aGUgcmVwbGFjZW1lbnQgaW4gdGhlXG4gICAgY2hhbmdlZCBkb2N1bWVudC5cbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzICh3aGljaCBhcmUga2VwdFxuICAgIHNlcGFyYXRlIGZvciBbcG9zaXRpb24gbWFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLm1hcFBvcykpIGFyZVxuICAgIHJlcG9ydGVkIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlZFJhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnZlcnRlZCBmb3JtIG9mIHRoZXNlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBnZXQgaW52ZXJ0ZWREZXNjKCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goaW5zLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhcHBseWluZyBhbm90aGVyIHNldCBvZiBjaGFuZ2VzXG4gICAgYWZ0ZXIgdGhpcyBvbmUuIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoaXMgc2V0IHNob3VsZFxuICAgIG1hdGNoIHRoZSBsZW5ndGggYmVmb3JlIGBvdGhlcmAuXG4gICAgKi9cbiAgICBjb21wb3NlRGVzYyhvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIpOyB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZGVzY3JpcHRpb24sIHdoaWNoIHNob3VsZCBzdGFydCB3aXRoIHRoZSBzYW1lIGRvY3VtZW50XG4gICAgYXMgYG90aGVyYCwgb3ZlciBhbm90aGVyIHNldCBvZiBjaGFuZ2VzLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgIGFwcGxpZWQgYWZ0ZXIgaXQuIFdoZW4gYGJlZm9yZWAgaXMgdHJ1ZSwgbWFwIGFzIGlmIHRoZSBjaGFuZ2VzXG4gICAgaW4gYG90aGVyYCBoYXBwZW5lZCBiZWZvcmUgdGhlIG9uZXMgaW4gYHRoaXNgLlxuICAgICovXG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlKTsgfVxuICAgIG1hcFBvcyhwb3MsIGFzc29jID0gLTEsIG1vZGUgPSBleHBvcnRzLk1hcE1vZGUuU2ltcGxlKSB7XG4gICAgICAgIGxldCBwb3NBID0gMCwgcG9zQiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZEEgPSBwb3NBICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc0IgKyAocG9zIC0gcG9zQSk7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPSBleHBvcnRzLk1hcE1vZGUuU2ltcGxlICYmIGVuZEEgPj0gcG9zICYmXG4gICAgICAgICAgICAgICAgICAgIChtb2RlID09IGV4cG9ydHMuTWFwTW9kZS5UcmFja0RlbCAmJiBwb3NBIDwgcG9zICYmIGVuZEEgPiBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gZXhwb3J0cy5NYXBNb2RlLlRyYWNrQmVmb3JlICYmIHBvc0EgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gZXhwb3J0cy5NYXBNb2RlLlRyYWNrQWZ0ZXIgJiYgZW5kQSA+IHBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChlbmRBID4gcG9zIHx8IGVuZEEgPT0gcG9zICYmIGFzc29jIDwgMCAmJiAhbGVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zID09IHBvc0EgfHwgYXNzb2MgPCAwID8gcG9zQiA6IHBvc0IgKyBpbnM7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID4gcG9zQSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gaXMgb3V0IG9mIHJhbmdlIGZvciBjaGFuZ2VzZXQgb2YgbGVuZ3RoICR7cG9zQX1gKTtcbiAgICAgICAgcmV0dXJuIHBvc0I7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlc2UgY2hhbmdlcyB0b3VjaCBhIGdpdmVuIHJhbmdlLiBXaGVuIG9uZSBvZiB0aGVcbiAgICBjaGFuZ2VzIGVudGlyZWx5IGNvdmVycyB0aGUgcmFuZ2UsIHRoZSBzdHJpbmcgYFwiY292ZXJcImAgaXNcbiAgICByZXR1cm5lZC5cbiAgICAqL1xuICAgIHRvdWNoZXNSYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZCA9IHBvcyArIGxlbjtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCAmJiBwb3MgPD0gdG8gJiYgZW5kID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA8IGZyb20gJiYgZW5kID4gdG8gPyBcImNvdmVyXCIgOiB0cnVlO1xuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICByZXN1bHQgKz0gKHJlc3VsdCA/IFwiIFwiIDogXCJcIikgKyBsZW4gKyAoaW5zID49IDAgPyBcIjpcIiArIGlucyA6IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBkZXNjIHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4gdGhpcy5zZWN0aW9uczsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZSBkZXNjIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gKGFzIHByb2R1Y2VkXG4gICAgYnkgW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSB8fCBqc29uLmxlbmd0aCAlIDIgfHwganNvbi5zb21lKGEgPT4gdHlwZW9mIGEgIT0gXCJudW1iZXJcIikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VEZXNjXCIpO1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURlc2MoanNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzZWN0aW9ucykgeyByZXR1cm4gbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpOyB9XG59XG4vKipcbkEgY2hhbmdlIHNldCByZXByZXNlbnRzIGEgZ3JvdXAgb2YgbW9kaWZpY2F0aW9ucyB0byBhIGRvY3VtZW50LiBJdFxuc3RvcmVzIHRoZSBkb2N1bWVudCBsZW5ndGgsIGFuZCBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGRvY3VtZW50c1xud2l0aCBleGFjdGx5IHRoYXQgbGVuZ3RoLlxuKi9cbmNsYXNzIENoYW5nZVNldCBleHRlbmRzIENoYW5nZURlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHNlY3Rpb25zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGluc2VydGVkKSB7XG4gICAgICAgIHN1cGVyKHNlY3Rpb25zKTtcbiAgICAgICAgdGhpcy5pbnNlcnRlZCA9IGluc2VydGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSB0aGUgY2hhbmdlcyB0byBhIGRvY3VtZW50LCByZXR1cm5pbmcgdGhlIG1vZGlmaWVkXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9IGRvYy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGNoYW5nZSBzZXQgdG8gYSBkb2N1bWVudCB3aXRoIHRoZSB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIChmcm9tQSwgdG9BLCBmcm9tQiwgX3RvQiwgdGV4dCkgPT4gZG9jID0gZG9jLnJlcGxhY2UoZnJvbUIsIGZyb21CICsgKHRvQSAtIGZyb21BKSwgdGV4dCksIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEdpdmVuIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIF9iZWZvcmVfIHRoZSBjaGFuZ2VzLCByZXR1cm4gYVxuICAgIGNoYW5nZSBzZXQgdGhhdCByZXByZXNlbnRzIHRoZSBpbnZlcnNlIG9mIHRoaXMgc2V0LCB3aGljaCBjb3VsZFxuICAgIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSB0aGUgY2hhbmdlcyBiYWNrIHRvXG4gICAgdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgYmVmb3JlIHRoZSBjaGFuZ2VzLlxuICAgICovXG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zLnNsaWNlKCksIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSBzZWN0aW9uc1tpXSwgaW5zID0gc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaV0gPSBpbnM7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaSArIDFdID0gbGVuO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGkgPj4gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChsZW4gPyBkb2Muc2xpY2UocG9zLCBwb3MgKyBsZW4pIDogVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbWJpbmUgdHdvIHN1YnNlcXVlbnQgY2hhbmdlIHNldHMgaW50byBhIHNpbmdsZSBzZXQuIGBvdGhlcmBcbiAgICBtdXN0IHN0YXJ0IGluIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSBgdGhpc2AuIElmIGB0aGlzYCBnb2VzXG4gICAgYGRvY0FgIOKGkiBgZG9jQmAgYW5kIGBvdGhlcmAgcmVwcmVzZW50cyBgZG9jQmAg4oaSIGBkb2NDYCwgdGhlXG4gICAgcmV0dXJuZWQgdmFsdWUgd2lsbCByZXByZXNlbnQgdGhlIGNoYW5nZSBgZG9jQWAg4oaSIGBkb2NDYC5cbiAgICAqL1xuICAgIGNvbXBvc2Uob3RoZXIpIHsgcmV0dXJuIHRoaXMuZW1wdHkgPyBvdGhlciA6IG90aGVyLmVtcHR5ID8gdGhpcyA6IGNvbXBvc2VTZXRzKHRoaXMsIG90aGVyLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEdpdmVuIGFub3RoZXIgY2hhbmdlIHNldCBzdGFydGluZyBpbiB0aGUgc2FtZSBkb2N1bWVudCwgbWFwcyB0aGlzXG4gICAgY2hhbmdlIHNldCBvdmVyIHRoZSBvdGhlciwgcHJvZHVjaW5nIGEgbmV3IGNoYW5nZSBzZXQgdGhhdCBjYW4gYmVcbiAgICBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSBhcHBseWluZyBgb3RoZXJgLiBXaGVuXG4gICAgYGJlZm9yZWAgaXMgYHRydWVgLCBvcmRlciBjaGFuZ2VzIGFzIGlmIGB0aGlzYCBjb21lcyBiZWZvcmVcbiAgICBgb3RoZXJgLCBvdGhlcndpc2UgKHRoZSBkZWZhdWx0KSB0cmVhdCBgb3RoZXJgIGFzIGNvbWluZyBmaXJzdC5cbiAgICBcbiAgICBHaXZlbiB0d28gY2hhbmdlcyBgQWAgYW5kIGBCYCwgYEEuY29tcG9zZShCLm1hcChBKSlgIGFuZFxuICAgIGBCLmNvbXBvc2UoQS5tYXAoQiwgdHJ1ZSkpYCB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgZG9jdW1lbnQuIFRoaXNcbiAgICBwcm92aWRlcyBhIGJhc2ljIGZvcm0gb2YgW29wZXJhdGlvbmFsXG4gICAgdHJhbnNmb3JtYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09wZXJhdGlvbmFsX3RyYW5zZm9ybWF0aW9uKSxcbiAgICBhbmQgY2FuIGJlIHVzZWQgZm9yIGNvbGxhYm9yYXRpdmUgZWRpdGluZy5cbiAgICAqL1xuICAgIG1hcChvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgY2hhbmdlZCByYW5nZXMgaW4gdGhlIGRvY3VtZW50LCBjYWxsaW5nIGBmYCBmb3JcbiAgICBlYWNoLCB3aXRoIHRoZSByYW5nZSBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgKGBmcm9tQWAtYHRvQWApXG4gICAgYW5kIHRoZSByYW5nZSB0aGF0IHJlcGxhY2VzIGl0IGluIHRoZSBuZXcgZG9jdW1lbnRcbiAgICAoYGZyb21CYC1gdG9CYCkuXG4gICAgXG4gICAgV2hlbiBgaW5kaXZpZHVhbGAgaXMgdHJ1ZSwgYWRqYWNlbnQgY2hhbmdlcyBhcmUgcmVwb3J0ZWRcbiAgICBzZXBhcmF0ZWx5LlxuICAgICovXG4gICAgaXRlckNoYW5nZXMoZiwgaW5kaXZpZHVhbCA9IGZhbHNlKSB7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIGYsIGluZGl2aWR1YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbY2hhbmdlIGRlc2NyaXB0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MpIGZvciB0aGlzIGNoYW5nZVxuICAgIHNldC5cbiAgICAqL1xuICAgIGdldCBkZXNjKCkgeyByZXR1cm4gQ2hhbmdlRGVzYy5jcmVhdGUodGhpcy5zZWN0aW9ucyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbHRlcihyYW5nZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdFNlY3Rpb25zID0gW10sIHJlc3VsdEluc2VydGVkID0gW10sIGZpbHRlcmVkU2VjdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGl0ZXIgPSBuZXcgU2VjdGlvbkl0ZXIodGhpcyk7XG4gICAgICAgIGRvbmU6IGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSByYW5nZXMubGVuZ3RoID8gMWU5IDogcmFuZ2VzW2krK107XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgbmV4dCB8fCBwb3MgPT0gbmV4dCAmJiBpdGVyLmxlbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZG9uZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oaXRlci5sZW4sIG5leHQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICAgICAgbGV0IGlucyA9IGl0ZXIuaW5zID09IC0xID8gLTEgOiBpdGVyLm9mZiA9PSAwID8gaXRlci5pbnMgOiAwO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgaW5zKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zID4gMClcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KHJlc3VsdEluc2VydGVkLCByZXN1bHRTZWN0aW9ucywgaXRlci50ZXh0KTtcbiAgICAgICAgICAgICAgICBpdGVyLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuZCA9IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBlbmQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBuZXcgQ2hhbmdlU2V0KHJlc3VsdFNlY3Rpb25zLCByZXN1bHRJbnNlcnRlZCksXG4gICAgICAgICAgICBmaWx0ZXJlZDogQ2hhbmdlRGVzYy5jcmVhdGUoZmlsdGVyZWRTZWN0aW9ucykgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIHNldCB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaV0sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChsZW4pO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5zID09IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXS5jb25jYXQodGhpcy5pbnNlcnRlZFtpID4+IDFdLnRvSlNPTigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gY2hhbmdlcywgZm9yIGEgZG9jdW1lbnQgb2YgdGhlXG4gICAgZ2l2ZW4gbGVuZ3RoLCB1c2luZyBgbGluZVNlcGAgYXMgbGluZSBzZXBhcmF0b3IuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YoY2hhbmdlcywgbGVuZ3RoLCBsaW5lU2VwKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdLCBwb3MgPSAwO1xuICAgICAgICBsZXQgdG90YWwgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBmbHVzaChmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmNlICYmICFzZWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGxlbmd0aClcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW5ndGggLSBwb3MsIC0xKTtcbiAgICAgICAgICAgIGxldCBzZXQgPSBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzZXQubWFwKHRvdGFsKSkgOiBzZXQ7XG4gICAgICAgICAgICBzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJvY2VzcyhzcGVjKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiBzcGVjKVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKHN1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcGVjIGluc3RhbmNlb2YgQ2hhbmdlU2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMubGVuZ3RoICE9IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGggKGdvdCAke3NwZWMubGVuZ3RofSwgZXhwZWN0ZWQgJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc3BlYy5tYXAodG90YWwpKSA6IHNwZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byA9IGZyb20sIGluc2VydCB9ID0gc3BlYztcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IHRvIHx8IGZyb20gPCAwIHx8IHRvID4gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjaGFuZ2UgcmFuZ2UgJHtmcm9tfSB0byAke3RvfSAoaW4gZG9jIG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgbGV0IGluc1RleHQgPSAhaW5zZXJ0ID8gVGV4dC5lbXB0eSA6IHR5cGVvZiBpbnNlcnQgPT0gXCJzdHJpbmdcIiA/IFRleHQub2YoaW5zZXJ0LnNwbGl0KGxpbmVTZXAgfHwgRGVmYXVsdFNwbGl0KSkgOiBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgbGV0IGluc0xlbiA9IGluc1RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIGluc0xlbiA9PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGZyb20gLSBwb3MsIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCB0byAtIGZyb20sIGluc0xlbik7XG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydGVkLCBzZWN0aW9ucywgaW5zVGV4dCk7XG4gICAgICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2VzcyhjaGFuZ2VzKTtcbiAgICAgICAgZmx1c2goIXRvdGFsKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgY2hhbmdlc2V0IG9mIHRoZSBnaXZlbiBsZW5ndGguXG4gICAgKi9cbiAgICBzdGF0aWMgZW1wdHkobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KGxlbmd0aCA/IFtsZW5ndGgsIC0xXSA6IFtdLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZXNldCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZCBieVxuICAgIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBqc29uW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnQsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBhcnQpIHx8IHR5cGVvZiBwYXJ0WzBdICE9IFwibnVtYmVyXCIgfHwgcGFydC5zb21lKChlLCBpKSA9PiBpICYmIHR5cGVvZiBlICE9IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaSlcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFtpXSA9IFRleHQub2YocGFydC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0WzBdLCBpbnNlcnRlZFtpXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGlucywgZm9yY2VKb2luID0gZmFsc2UpIHtcbiAgICBpZiAobGVuID09IDAgJiYgaW5zIDw9IDApXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbGFzdCA9IHNlY3Rpb25zLmxlbmd0aCAtIDI7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiBpbnMgPD0gMCAmJiBpbnMgPT0gc2VjdGlvbnNbbGFzdCArIDFdKVxuICAgICAgICBzZWN0aW9uc1tsYXN0XSArPSBsZW47XG4gICAgZWxzZSBpZiAobGVuID09IDAgJiYgc2VjdGlvbnNbbGFzdF0gPT0gMClcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICBlbHNlIGlmIChmb3JjZUpvaW4pIHtcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xufVxuZnVuY3Rpb24gYWRkSW5zZXJ0KHZhbHVlcywgc2VjdGlvbnMsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGluZGV4ID0gKHNlY3Rpb25zLmxlbmd0aCAtIDIpID4+IDE7XG4gICAgaWYgKGluZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXS5hcHBlbmQodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHZhbHVlcy5sZW5ndGggPCBpbmRleClcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlckNoYW5nZXMoZGVzYywgZiwgaW5kaXZpZHVhbCkge1xuICAgIGxldCBpbnNlcnRlZCA9IGRlc2MuaW5zZXJ0ZWQ7XG4gICAgZm9yIChsZXQgcG9zQSA9IDAsIHBvc0IgPSAwLCBpID0gMDsgaSA8IGRlc2Muc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICBsZXQgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdLCBpbnMgPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVuZEEgPSBwb3NBLCBlbmRCID0gcG9zQiwgdGV4dCA9IFRleHQuZW1wdHk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgZW5kQSArPSBsZW47XG4gICAgICAgICAgICAgICAgZW5kQiArPSBpbnM7XG4gICAgICAgICAgICAgICAgaWYgKGlucyAmJiBpbnNlcnRlZClcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuYXBwZW5kKGluc2VydGVkWyhpIC0gMikgPj4gMV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpdmlkdWFsIHx8IGkgPT0gZGVzYy5zZWN0aW9ucy5sZW5ndGggfHwgZGVzYy5zZWN0aW9uc1tpICsgMV0gPCAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICAgICAgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZihwb3NBLCBlbmRBLCBwb3NCLCBlbmRCLCB0ZXh0KTtcbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xuICAgICAgICAgICAgcG9zQiA9IGVuZEI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXBTZXQoc2V0QSwgc2V0QiwgYmVmb3JlLCBta1NldCA9IGZhbHNlKSB7XG4gICAgLy8gUHJvZHVjZSBhIGNvcHkgb2Ygc2V0QSB0aGF0IGFwcGxpZXMgdG8gdGhlIGRvY3VtZW50IGFmdGVyIHNldEJcbiAgICAvLyBoYXMgYmVlbiBhcHBsaWVkIChhc3N1bWluZyBib3RoIHN0YXJ0IGF0IHRoZSBzYW1lIGRvY3VtZW50KS5cbiAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGJvdGggc2V0cyBpbiBwYXJhbGxlbC4gaW5zZXJ0ZWQgdHJhY2tzLCBmb3IgY2hhbmdlc1xuICAgIC8vIGluIEEgdGhhdCBoYXZlIHRvIGJlIHByb2Nlc3NlZCBwaWVjZS1ieS1waWVjZSwgd2hldGhlciB0aGVpclxuICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gaW5zZXJ0ZWQgYWxyZWFkeSwgYW5kIHJlZmVycyB0byB0aGUgc2VjdGlvblxuICAgIC8vIGluZGV4LlxuICAgIGZvciAobGV0IGluc2VydGVkID0gLTE7Oykge1xuICAgICAgICBpZiAoYS5pbnMgPT0gLTEgJiYgYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgYWNyb3NzIHJhbmdlcyBza2lwcGVkIGJ5IGJvdGggc2V0cy5cbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbiwgYi5sZW4pO1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICBhLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgIGIuZm9yd2FyZChsZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIuaW5zID49IDAgJiYgKGEuaW5zIDwgMCB8fCBpbnNlcnRlZCA9PSBhLmkgfHwgYS5vZmYgPT0gMCAmJiAoYi5sZW4gPCBhLmxlbiB8fCBiLmxlbiA9PSBhLmxlbiAmJiAhYmVmb3JlKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjaGFuZ2UgaW4gQiB0aGF0IGNvbWVzIGJlZm9yZSB0aGUgbmV4dCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIEEgKG9yZGVyZWQgYnkgc3RhcnQgcG9zLCB0aGVuIGxlbiwgdGhlbiBiZWZvcmUgZmxhZyksIHNraXBcbiAgICAgICAgICAgIC8vIHRoYXQgKGFuZCBwcm9jZXNzIGFueSBjaGFuZ2VzIGluIEEgaXQgY292ZXJzKS5cbiAgICAgICAgICAgIGxldCBsZW4gPSBiLmxlbjtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGIuaW5zLCAtMSk7XG4gICAgICAgICAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gTWF0aC5taW4oYS5sZW4sIGxlbik7XG4gICAgICAgICAgICAgICAgaWYgKGEuaW5zID49IDAgJiYgaW5zZXJ0ZWQgPCBhLmkgJiYgYS5sZW4gPD0gcGllY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYS5pbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIGxlbiAtPSBwaWVjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID49IDApIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHBhcnQgb2YgYSBjaGFuZ2UgaW4gQSB1cCB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHRcbiAgICAgICAgICAgIC8vIG5vbi1kZWxldGlvbiBjaGFuZ2UgaW4gQiAoaWYgb3ZlcmxhcHBpbmcpLlxuICAgICAgICAgICAgbGV0IGxlbiA9IDAsIGxlZnQgPSBhLmxlbjtcbiAgICAgICAgICAgIHdoaWxlIChsZWZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGxlZnQsIGIubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBiLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAwICYmIGIubGVuIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IGIubGVuO1xuICAgICAgICAgICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zZXJ0ZWQgPCBhLmkgPyBhLmlucyA6IDApO1xuICAgICAgICAgICAgaWYgKGluc2VydCAmJiBpbnNlcnRlZCA8IGEuaSlcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcbiAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgYS5mb3J3YXJkKGEubGVuIC0gbGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lICYmIGIuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydCA/IENoYW5nZVNldC5jcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydCkgOiBDaGFuZ2VEZXNjLmNyZWF0ZShzZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTZXRzKHNldEEsIHNldEIsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICBsZXQgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgZm9yIChsZXQgb3BlbiA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID09IDApIHsgLy8gRGVsZXRpb24gaW4gQVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5sZW4sIDAsIG9wZW4pO1xuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5sZW4gPT0gMCAmJiAhYi5kb25lKSB7IC8vIEluc2VydGlvbiBpbiBCXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCAwLCBiLmlucywgb3Blbik7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lIHx8IGIuZG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4yLCBiLmxlbiksIHNlY3Rpb25MZW4gPSBzZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYS5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zQiA9IGIuaW5zID09IC0xID8gLTEgOiBiLm9mZiA/IDAgOiBiLmlucztcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc0IsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zQilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBsZW4sIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHRCaXQobGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgYi5vZmYgPyAwIDogYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgIWIub2ZmKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW4gPSAoYS5pbnMgPiBsZW4gfHwgYi5pbnMgPj0gMCAmJiBiLmxlbiA+IGxlbikgJiYgKG9wZW4gfHwgc2VjdGlvbnMubGVuZ3RoID4gc2VjdGlvbkxlbik7XG4gICAgICAgICAgICBhLmZvcndhcmQyKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNlY3Rpb25JdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgeyBzZWN0aW9ucyB9ID0gdGhpcy5zZXQ7XG4gICAgICAgIGlmICh0aGlzLmkgPCBzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGVuID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSBzZWN0aW9uc1t0aGlzLmkrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmlucyA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZ2V0IGRvbmUoKSB7IHJldHVybiB0aGlzLmlucyA9PSAtMjsgfVxuICAgIGdldCBsZW4yKCkgeyByZXR1cm4gdGhpcy5pbnMgPCAwID8gdGhpcy5sZW4gOiB0aGlzLmluczsgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggPyBUZXh0LmVtcHR5IDogaW5zZXJ0ZWRbaW5kZXhdO1xuICAgIH1cbiAgICB0ZXh0Qml0KGxlbikge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggJiYgIWxlbiA/IFRleHQuZW1wdHlcbiAgICAgICAgICAgIDogaW5zZXJ0ZWRbaW5kZXhdLnNsaWNlKHRoaXMub2ZmLCBsZW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRoaXMub2ZmICsgbGVuKTtcbiAgICB9XG4gICAgZm9yd2FyZChsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PSB0aGlzLmxlbilcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVuIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3J3YXJkMihsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zID09IC0xKVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PSB0aGlzLmlucylcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG5BIHNpbmdsZSBzZWxlY3Rpb24gcmFuZ2UuIFdoZW5cbltgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKVxuaXMgZW5hYmxlZCwgYSBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbikgbWF5IGhvbGRcbm11bHRpcGxlIHJhbmdlcy4gQnkgZGVmYXVsdCwgc2VsZWN0aW9ucyBob2xkIGV4YWN0bHkgb25lIHJhbmdlLlxuKi9cbmNsYXNzIFNlbGVjdGlvblJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBmbGFncykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGFuY2hvciBvZiB0aGUgcmFuZ2XigJR0aGUgc2lkZSB0aGF0IGRvZXNuJ3QgbW92ZSB3aGVuIHlvdVxuICAgIGV4dGVuZCBpdC5cbiAgICAqL1xuICAgIGdldCBhbmNob3IoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMzIgLyogUmFuZ2VGbGFnLkludmVydGVkICovID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxuICAgIC8qKlxuICAgIFRoZSBoZWFkIG9mIHRoZSByYW5nZSwgd2hpY2ggaXMgbW92ZWQgd2hlbiB0aGUgcmFuZ2UgaXNcbiAgICBbZXh0ZW5kZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UuZXh0ZW5kKS5cbiAgICAqL1xuICAgIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDMyIC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMuZnJvbSA6IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gYGFuY2hvcmAgYW5kIGBoZWFkYCBhcmUgYXQgdGhlIHNhbWUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZyb20gPT0gdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSBjdXJzb3IgdGhhdCBpcyBleHBsaWNpdGx5IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICBjaGFyYWN0ZXIgb24gb25lIG9mIGl0cyBzaWRlcywgdGhpcyByZXR1cm5zIHRoZSBzaWRlLiAtMSBtZWFuc1xuICAgIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGl0cyBwb3NpdGlvbiwgMSB0aGUgY2hhcmFjdGVyIGFmdGVyLCBhbmQgMFxuICAgIG1lYW5zIG5vIGFzc29jaWF0aW9uLlxuICAgICovXG4gICAgZ2V0IGFzc29jKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovID8gLTEgOiB0aGlzLmZsYWdzICYgMTYgLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8gPyAxIDogMDsgfVxuICAgIC8qKlxuICAgIFRoZSBiaWRpcmVjdGlvbmFsIHRleHQgbGV2ZWwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY3Vyc29yLCBpZlxuICAgIGFueS5cbiAgICAqL1xuICAgIGdldCBiaWRpTGV2ZWwoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IHRoaXMuZmxhZ3MgJiA3IC8qIFJhbmdlRmxhZy5CaWRpTGV2ZWxNYXNrICovO1xuICAgICAgICByZXR1cm4gbGV2ZWwgPT0gNyA/IG51bGwgOiBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGdvYWwgY29sdW1uIChzdG9yZWQgdmVydGljYWwgb2Zmc2V0KSBhc3NvY2lhdGVkIHdpdGggYVxuICAgIGN1cnNvci4gVGhpcyBpcyB1c2VkIHRvIHByZXNlcnZlIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB3aGVuXG4gICAgW21vdmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIGFjcm9zc1xuICAgIGxpbmVzIG9mIGRpZmZlcmVudCBsZW5ndGguXG4gICAgKi9cbiAgICBnZXQgZ29hbENvbHVtbigpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5mbGFncyA+PiA2IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gMTY3NzcyMTUgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLyA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSB0aHJvdWdoIGEgY2hhbmdlLCBwcm9kdWNpbmcgYSB2YWxpZCByYW5nZSBpbiB0aGVcbiAgICB1cGRhdGVkIGRvY3VtZW50LlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBsZXQgZnJvbSwgdG87XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICBmcm9tID0gdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMuZnJvbSwgYXNzb2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCAxKTtcbiAgICAgICAgICAgIHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLnRvLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdGhpcy5mcm9tICYmIHRvID09IHRoaXMudG8gPyB0aGlzIDogbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgcmFuZ2UgdG8gY292ZXIgYXQgbGVhc3QgYGZyb21gIHRvIGB0b2AuXG4gICAgKi9cbiAgICBleHRlbmQoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IHRoaXMuYW5jaG9yICYmIHRvID49IHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIGxldCBoZWFkID0gTWF0aC5hYnMoZnJvbSAtIHRoaXMuYW5jaG9yKSA+IE1hdGguYWJzKHRvIC0gdGhpcy5hbmNob3IpID8gZnJvbSA6IHRvO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRoaXMuYW5jaG9yLCBoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHJhbmdlIHRvIGFub3RoZXIgcmFuZ2UuXG4gICAgKi9cbiAgICBlcShvdGhlciwgaW5jbHVkZUFzc29jID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yID09IG90aGVyLmFuY2hvciAmJiB0aGlzLmhlYWQgPT0gb3RoZXIuaGVhZCAmJlxuICAgICAgICAgICAgKCFpbmNsdWRlQXNzb2MgfHwgIXRoaXMuZW1wdHkgfHwgdGhpcy5hc3NvYyA9PSBvdGhlci5hc3NvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJhbmdlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4geyBhbmNob3I6IHRoaXMuYW5jaG9yLCBoZWFkOiB0aGlzLmhlYWQgfTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgcmFuZ2UgdG8gYSBgU2VsZWN0aW9uUmFuZ2VgXG4gICAgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIFNlbGVjdGlvblJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGpzb24uYW5jaG9yLCBqc29uLmhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZnJvbSwgdG8sIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIGZsYWdzKTtcbiAgICB9XG59XG4vKipcbkFuIGVkaXRvciBzZWxlY3Rpb24gaG9sZHMgb25lIG9yIG1vcmUgc2VsZWN0aW9uIHJhbmdlcy5cbiovXG5jbGFzcyBFZGl0b3JTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZXMgaW4gdGhlIHNlbGVjdGlvbiwgc29ydGVkIGJ5IHBvc2l0aW9uLiBSYW5nZXMgY2Fubm90XG4gICAgb3ZlcmxhcCAoYnV0IHRoZXkgbWF5IHRvdWNoLCBpZiB0aGV5IGFyZW4ndCBlbXB0eSkuXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBvZiB0aGUgX21haW5fIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24gKHdoaWNoIGlzXG4gICAgdXN1YWxseSB0aGUgcmFuZ2UgdGhhdCB3YXMgYWRkZWQgbGFzdCkuXG4gICAgKi9cbiAgICBtYWluSW5kZXgpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMubWFpbkluZGV4ID0gbWFpbkluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBzZWxlY3Rpb24gdGhyb3VnaCBhIGNoYW5nZS4gVXNlZCB0byBhZGp1c3QgdGhlIHNlbGVjdGlvblxuICAgIHBvc2l0aW9uIGZvciBjaGFuZ2VzLlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBpZiAoY2hhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHRoaXMucmFuZ2VzLm1hcChyID0+IHIubWFwKGNoYW5nZSwgYXNzb2MpKSwgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgc2VsZWN0aW9uIHRvIGFub3RoZXIgc2VsZWN0aW9uLiBCeSBkZWZhdWx0LCByYW5nZXNcbiAgICBhcmUgY29tcGFyZWQgb25seSBieSBwb3NpdGlvbi4gV2hlbiBgaW5jbHVkZUFzc29jYCBpcyB0cnVlLFxuICAgIGN1cnNvciByYW5nZXMgbXVzdCBhbHNvIGhhdmUgdGhlIHNhbWVcbiAgICBbYGFzc29jYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5hc3NvYykgdmFsdWUuXG4gICAgKi9cbiAgICBlcShvdGhlciwgaW5jbHVkZUFzc29jID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCAhPSBvdGhlci5yYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLm1haW5JbmRleCAhPSBvdGhlci5tYWluSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMucmFuZ2VzW2ldLmVxKG90aGVyLnJhbmdlc1tpXSwgaW5jbHVkZUFzc29jKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHByaW1hcnkgc2VsZWN0aW9uIHJhbmdlLiBVc3VhbGx5LCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZVxuICAgIHlvdXIgY29kZSBhcHBsaWVzIHRvIF9hbGxfIHJhbmdlcywgYnkgdXNpbmcgbWV0aG9kcyBsaWtlXG4gICAgW2BjaGFuZ2VCeVJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFuZ2VCeVJhbmdlKS5cbiAgICAqL1xuICAgIGdldCBtYWluKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5tYWluSW5kZXhdOyB9XG4gICAgLyoqXG4gICAgTWFrZSBzdXJlIHRoZSBzZWxlY3Rpb24gb25seSBoYXMgb25lIHJhbmdlLiBSZXR1cm5zIGEgc2VsZWN0aW9uXG4gICAgaG9sZGluZyBvbmx5IHRoZSBtYWluIHJhbmdlIGZyb20gdGhpcyBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBhc1NpbmdsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLmxlbmd0aCA9PSAxID8gdGhpcyA6IG5ldyBFZGl0b3JTZWxlY3Rpb24oW3RoaXMubWFpbl0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRlbmQgdGhpcyBzZWxlY3Rpb24gd2l0aCBhbiBleHRyYSByYW5nZS5cbiAgICAqL1xuICAgIGFkZFJhbmdlKHJhbmdlLCBtYWluID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdLmNvbmNhdCh0aGlzLnJhbmdlcyksIG1haW4gPyAwIDogdGhpcy5tYWluSW5kZXggKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIGdpdmVuIHJhbmdlIHdpdGggYW5vdGhlciByYW5nZSwgYW5kIHRoZW4gbm9ybWFsaXplIHRoZVxuICAgIHNlbGVjdGlvbiB0byBtZXJnZSBhbmQgc29ydCByYW5nZXMgaWYgbmVjZXNzYXJ5LlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlKHJhbmdlLCB3aGljaCA9IHRoaXMubWFpbkluZGV4KSB7XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLnJhbmdlcy5zbGljZSgpO1xuICAgICAgICByYW5nZXNbd2hpY2hdID0gcmFuZ2U7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgc2VsZWN0aW9uIHRvIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBzZXJpYWxpemVkIHRvXG4gICAgSlNPTi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2VzOiB0aGlzLnJhbmdlcy5tYXAociA9PiByLnRvSlNPTigpKSwgbWFpbjogdGhpcy5tYWluSW5kZXggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIGZyb20gYSBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFBcnJheS5pc0FycmF5KGpzb24ucmFuZ2VzKSB8fCB0eXBlb2YganNvbi5tYWluICE9IFwibnVtYmVyXCIgfHwganNvbi5tYWluID49IGpzb24ucmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBFZGl0b3JTZWxlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKGpzb24ucmFuZ2VzLm1hcCgocikgPT4gU2VsZWN0aW9uUmFuZ2UuZnJvbUpTT04ocikpLCBqc29uLm1haW4pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gaG9sZGluZyBhIHNpbmdsZSByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyBzaW5nbGUoYW5jaG9yLCBoZWFkID0gYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKFtFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoYW5jaG9yLCBoZWFkKV0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBTb3J0IGFuZCBtZXJnZSB0aGUgZ2l2ZW4gc2V0IG9mIHJhbmdlcywgY3JlYXRpbmcgYSB2YWxpZFxuICAgIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgc2VsZWN0aW9uIG5lZWRzIGF0IGxlYXN0IG9uZSByYW5nZVwiKTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcG9zIDogcmFuZ2UuZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLm5vcm1hbGl6ZWQocmFuZ2VzLnNsaWNlKCksIG1haW5JbmRleCk7XG4gICAgICAgICAgICBwb3MgPSByYW5nZS50bztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihyYW5nZXMsIG1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGN1cnNvciBzZWxlY3Rpb24gcmFuZ2UgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBZb3UgY2FuXG4gICAgc2FmZWx5IGlnbm9yZSB0aGUgb3B0aW9uYWwgYXJndW1lbnRzIGluIG1vc3Qgc2l0dWF0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjdXJzb3IocG9zLCBhc3NvYyA9IDAsIGJpZGlMZXZlbCwgZ29hbENvbHVtbikge1xuICAgICAgICByZXR1cm4gU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKHBvcywgcG9zLCAoYXNzb2MgPT0gMCA/IDAgOiBhc3NvYyA8IDAgPyA4IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA6IDE2IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovKSB8XG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyA3IDogTWF0aC5taW4oNiwgYmlkaUxldmVsKSkgfFxuICAgICAgICAgICAgKChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAxNjc3NzIxNSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovKSA8PCA2IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyByYW5nZShhbmNob3IsIGhlYWQsIGdvYWxDb2x1bW4sIGJpZGlMZXZlbCkge1xuICAgICAgICBsZXQgZmxhZ3MgPSAoKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDE2Nzc3MjE1IC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi8pIHxcbiAgICAgICAgICAgIChiaWRpTGV2ZWwgPT0gbnVsbCA/IDcgOiBNYXRoLm1pbig2LCBiaWRpTGV2ZWwpKTtcbiAgICAgICAgcmV0dXJuIGhlYWQgPCBhbmNob3IgPyBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoaGVhZCwgYW5jaG9yLCAzMiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gfCAxNiAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyB8IGZsYWdzKVxuICAgICAgICAgICAgOiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoYW5jaG9yLCBoZWFkLCAoaGVhZCA+IGFuY2hvciA/IDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMCkgfCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZWQocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBtYWluID0gcmFuZ2VzW21haW5JbmRleF07XG4gICAgICAgIHJhbmdlcy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICBtYWluSW5kZXggPSByYW5nZXMuaW5kZXhPZihtYWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHByZXYudG8gOiByYW5nZS5mcm9tIDwgcHJldi50bykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcHJldi5mcm9tLCB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCBwcmV2LnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBtYWluSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIG1haW5JbmRleC0tO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvY0xlbmd0aCkge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmIChyYW5nZS50byA+IGRvY0xlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBvaW50cyBvdXRzaWRlIG9mIGRvY3VtZW50XCIpO1xufVxuXG5sZXQgbmV4dElEID0gMDtcbi8qKlxuQSBmYWNldCBpcyBhIGxhYmVsZWQgdmFsdWUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYW4gZWRpdG9yXG5zdGF0ZS4gSXQgdGFrZXMgaW5wdXRzIGZyb20gYW55IG51bWJlciBvZiBleHRlbnNpb25zLCBhbmQgY29tYmluZXNcbnRob3NlIGludG8gYSBzaW5nbGUgb3V0cHV0IHZhbHVlLlxuXG5FeGFtcGxlcyBvZiB1c2VzIG9mIGZhY2V0cyBhcmUgdGhlIFt0YWJcbnNpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSksIFtlZGl0b3JcbmF0dHJpYnV0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRvckF0dHJpYnV0ZXMpLCBhbmQgW3VwZGF0ZVxubGlzdGVuZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld151cGRhdGVMaXN0ZW5lcikuXG5cbk5vdGUgdGhhdCBgRmFjZXRgIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhbnl3aGVyZSB3aGVyZVxuW2BGYWNldFJlYWRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXRSZWFkZXIpIGlzIGV4cGVjdGVkLlxuKi9cbmNsYXNzIEZhY2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbWJpbmUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZUlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUsIGlzU3RhdGljLCBlbmFibGVzKSB7XG4gICAgICAgIHRoaXMuY29tYmluZSA9IGNvbWJpbmU7XG4gICAgICAgIHRoaXMuY29tcGFyZUlucHV0ID0gY29tcGFyZUlucHV0O1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBjb21iaW5lKFtdKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gdHlwZW9mIGVuYWJsZXMgPT0gXCJmdW5jdGlvblwiID8gZW5hYmxlcyh0aGlzKSA6IGVuYWJsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSBmYWNldCByZWFkZXIgZm9yIHRoaXMgZmFjZXQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gICAgW3JlYWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuZmFjZXQpIGl0IGJ1dCBub3QgdG8gZGVmaW5lIHZhbHVlcyBmb3IgaXQuXG4gICAgKi9cbiAgICBnZXQgcmVhZGVyKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBmYWNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldChjb25maWcuY29tYmluZSB8fCAoKGEpID0+IGEpLCBjb25maWcuY29tcGFyZUlucHV0IHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZy5jb21wYXJlIHx8ICghY29uZmlnLmNvbWJpbmUgPyBzYW1lQXJyYXkgOiAoYSwgYikgPT4gYSA9PT0gYiksICEhY29uZmlnLnN0YXRpYywgY29uZmlnLmVuYWJsZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoaXMgZmFjZXQuXG4gICAgKi9cbiAgICBvZih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoW10sIHRoaXMsIDAgLyogUHJvdmlkZXIuU3RhdGljICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyBhIHZhbHVlIGZvciB0aGUgZmFjZXQgZnJvbSBhXG4gICAgc3RhdGUuIFlvdSBtdXN0IHRha2UgY2FyZSB0byBkZWNsYXJlIHRoZSBwYXJ0cyBvZiB0aGUgc3RhdGUgdGhhdFxuICAgIHRoaXMgdmFsdWUgZGVwZW5kcyBvbiwgc2luY2UgeW91ciBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBhZ2FpblxuICAgIGZvciBhIG5ldyBzdGF0ZSB3aGVuIG9uZSBvZiB0aG9zZSBwYXJ0cyBjaGFuZ2VkLlxuICAgIFxuICAgIEluIGNhc2VzIHdoZXJlIHlvdXIgdmFsdWUgZGVwZW5kcyBvbmx5IG9uIGEgc2luZ2xlIGZpZWxkLCB5b3UnbGxcbiAgICB3YW50IHRvIHVzZSB0aGUgW2Bmcm9tYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldC5mcm9tKSBtZXRob2QgaW5zdGVhZC5cbiAgICAqL1xuICAgIGNvbXB1dGUoZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDEgLyogUHJvdmlkZXIuU2luZ2xlICovLCBnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgemVybyBvciBtb3JlIHZhbHVlcyBmb3IgdGhpc1xuICAgIGZhY2V0IGZyb20gYSBzdGF0ZS5cbiAgICAqL1xuICAgIGNvbXB1dGVOKGRlcHMsIGdldCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXRpYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihkZXBzLCB0aGlzLCAyIC8qIFByb3ZpZGVyLk11bHRpICovLCBnZXQpO1xuICAgIH1cbiAgICBmcm9tKGZpZWxkLCBnZXQpIHtcbiAgICAgICAgaWYgKCFnZXQpXG4gICAgICAgICAgICBnZXQgPSB4ID0+IHg7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGUoW2ZpZWxkXSwgc3RhdGUgPT4gZ2V0KHN0YXRlLmZpZWxkKGZpZWxkKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiBlID09PSBiW2ldKTtcbn1cbmNsYXNzIEZhY2V0UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlcGVuZGVuY2llcywgZmFjZXQsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgIH1cbiAgICBkeW5hbWljU2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZ2V0dGVyID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IGNvbXBhcmUgPSB0aGlzLmZhY2V0LmNvbXBhcmVJbnB1dDtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5pZCwgaWR4ID0gYWRkcmVzc2VzW2lkXSA+PiAxLCBtdWx0aSA9IHRoaXMudHlwZSA9PSAyIC8qIFByb3ZpZGVyLk11bHRpICovO1xuICAgICAgICBsZXQgZGVwRG9jID0gZmFsc2UsIGRlcFNlbCA9IGZhbHNlLCBkZXBBZGRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkZXAgb2YgdGhpcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGlmIChkZXAgPT0gXCJkb2NcIilcbiAgICAgICAgICAgICAgICBkZXBEb2MgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVwID09IFwic2VsZWN0aW9uXCIpXG4gICAgICAgICAgICAgICAgZGVwU2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCgoKF9hID0gYWRkcmVzc2VzW2RlcC5pZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpICYgMSkgPT0gMClcbiAgICAgICAgICAgICAgICBkZXBBZGRycy5wdXNoKGFkZHJlc3Nlc1tkZXAuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChkZXBEb2MgJiYgdHIuZG9jQ2hhbmdlZCkgfHwgKGRlcFNlbCAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pKSB8fCBlbnN1cmVBbGwoc3RhdGUsIGRlcEFkZHJzKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsID0gZ2V0dGVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpID8gIWNvbXBhcmVBcnJheShuZXdWYWwsIHN0YXRlLnZhbHVlc1tpZHhdLCBjb21wYXJlKSA6ICFjb21wYXJlKG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWNvbmZpZ3VyZTogKHN0YXRlLCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBuZXdWYWwsIG9sZEFkZHIgPSBvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKG9sZEFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2xkVmFsID0gZ2V0QWRkcihvbGRTdGF0ZSwgb2xkQWRkcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY2llcy5ldmVyeShkZXAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcCBpbnN0YW5jZW9mIEZhY2V0ID8gb2xkU3RhdGUuZmFjZXQoZGVwKSA9PT0gc3RhdGUuZmFjZXQoZGVwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwIGluc3RhbmNlb2YgU3RhdGVGaWVsZCA/IG9sZFN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpID09IHN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSkgfHwgKG11bHRpID8gY29tcGFyZUFycmF5KG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCwgY29tcGFyZSkgOiBjb21wYXJlKG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZUFycmF5KGEsIGIsIGNvbXBhcmUpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghY29tcGFyZShhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFsbChzdGF0ZSwgYWRkcnMpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGFkZHIgb2YgYWRkcnMpXG4gICAgICAgIGlmIChlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKSAmIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBkeW5hbWljRmFjZXRTbG90KGFkZHJlc3NlcywgZmFjZXQsIHByb3ZpZGVycykge1xuICAgIGxldCBwcm92aWRlckFkZHJzID0gcHJvdmlkZXJzLm1hcChwID0+IGFkZHJlc3Nlc1twLmlkXSk7XG4gICAgbGV0IHByb3ZpZGVyVHlwZXMgPSBwcm92aWRlcnMubWFwKHAgPT4gcC50eXBlKTtcbiAgICBsZXQgZHluYW1pYyA9IHByb3ZpZGVyQWRkcnMuZmlsdGVyKHAgPT4gIShwICYgMSkpO1xuICAgIGxldCBpZHggPSBhZGRyZXNzZXNbZmFjZXQuaWRdID4+IDE7XG4gICAgZnVuY3Rpb24gZ2V0KHN0YXRlKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm92aWRlckFkZHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRBZGRyKHN0YXRlLCBwcm92aWRlckFkZHJzW2ldKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlclR5cGVzW2ldID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdmFsIG9mIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFjZXQuY29tYmluZSh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGFkZHIgb2YgcHJvdmlkZXJBZGRycylcbiAgICAgICAgICAgICAgICBlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKTtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICAgICAgaWYgKCFlbnN1cmVBbGwoc3RhdGUsIGR5bmFtaWMpKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBzdGF0ZS52YWx1ZXNbaWR4XSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICByZWNvbmZpZ3VyZShzdGF0ZSwgb2xkU3RhdGUpIHtcbiAgICAgICAgICAgIGxldCBkZXBDaGFuZ2VkID0gZW5zdXJlQWxsKHN0YXRlLCBwcm92aWRlckFkZHJzKTtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRTdGF0ZS5jb25maWcuZmFjZXRzW2ZhY2V0LmlkXSwgb2xkVmFsdWUgPSBvbGRTdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgICAgICBpZiAob2xkUHJvdmlkZXJzICYmICFkZXBDaGFuZ2VkICYmIHNhbWVBcnJheShwcm92aWRlcnMsIG9sZFByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBpbml0RmllbGQgPSBGYWNldC5kZWZpbmUoeyBzdGF0aWM6IHRydWUgfSk7XG4vKipcbkZpZWxkcyBjYW4gc3RvcmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpbiBhbiBlZGl0b3Igc3RhdGUsIGFuZFxua2VlcCBpdCBpbiBzeW5jIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YXRlRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIGNyZWF0ZUYsIHVwZGF0ZUYsIGNvbXBhcmVGLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZUYgPSBjcmVhdGVGO1xuICAgICAgICB0aGlzLnVwZGF0ZUYgPSB1cGRhdGVGO1xuICAgICAgICB0aGlzLmNvbXBhcmVGID0gY29tcGFyZUY7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm92aWRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RhdGUgZmllbGQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNvbmZpZykge1xuICAgICAgICBsZXQgZmllbGQgPSBuZXcgU3RhdGVGaWVsZChuZXh0SUQrKywgY29uZmlnLmNyZWF0ZSwgY29uZmlnLnVwZGF0ZSwgY29uZmlnLmNvbXBhcmUgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm92aWRlKVxuICAgICAgICAgICAgZmllbGQucHJvdmlkZXMgPSBjb25maWcucHJvdmlkZShmaWVsZCk7XG4gICAgICAgIHJldHVybiBmaWVsZDtcbiAgICB9XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIGxldCBpbml0ID0gc3RhdGUuZmFjZXQoaW5pdEZpZWxkKS5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKTtcbiAgICAgICAgcmV0dXJuICgoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmNyZWF0ZSkgfHwgdGhpcy5jcmVhdGVGKShzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1t0aGlzLmlkXSA+PiAxO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlOiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHRoaXMuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiAoc3RhdGUsIHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IHN0YXRlLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudXBkYXRlRihvbGRWYWwsIHRyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlRihvbGRWYWwsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb25maWd1cmU6IChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbdGhpcy5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFN0YXRlLmZpZWxkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgdGhpcyBmaWVsZCBhbmQgb3ZlcnJpZGVzIHRoZVxuICAgIHdheSBpdCBpcyBpbml0aWFsaXplZC4gQ2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHByb3ZpZGUgYVxuICAgIG5vbi1kZWZhdWx0IHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgZmllbGQuXG4gICAgKi9cbiAgICBpbml0KGNyZWF0ZSkge1xuICAgICAgICByZXR1cm4gW3RoaXMsIGluaXRGaWVsZC5vZih7IGZpZWxkOiB0aGlzLCBjcmVhdGUgfSldO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGF0ZSBmaWVsZCBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgYXNcbiAgICBbYEV4dGVuc2lvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRXh0ZW5zaW9uKSB2YWx1ZXMgdG8gZW5hYmxlIHRoZSBmaWVsZCBpbiBhXG4gICAgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgZXh0ZW5zaW9uKCkgeyByZXR1cm4gdGhpczsgfVxufVxuY29uc3QgUHJlY18gPSB7IGxvd2VzdDogNCwgbG93OiAzLCBkZWZhdWx0OiAyLCBoaWdoOiAxLCBoaWdoZXN0OiAwIH07XG5mdW5jdGlvbiBwcmVjKHZhbHVlKSB7XG4gICAgcmV0dXJuIChleHQpID0+IG5ldyBQcmVjRXh0ZW5zaW9uKGV4dCwgdmFsdWUpO1xufVxuLyoqXG5CeSBkZWZhdWx0IGV4dGVuc2lvbnMgYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGZvdW5kXG5pbiB0aGUgZmxhdHRlbmVkIGZvcm0gb2YgbmVzdGVkIGFycmF5IHRoYXQgd2FzIHByb3ZpZGVkLlxuSW5kaXZpZHVhbCBleHRlbnNpb24gdmFsdWVzIGNhbiBiZSBhc3NpZ25lZCBhIHByZWNlZGVuY2UgdG9cbm92ZXJyaWRlIHRoaXMuIEV4dGVuc2lvbnMgdGhhdCBkbyBub3QgaGF2ZSBhIHByZWNlZGVuY2Ugc2V0IGdldFxudGhlIHByZWNlZGVuY2Ugb2YgdGhlIG5lYXJlc3QgcGFyZW50IHdpdGggYSBwcmVjZWRlbmNlLCBvclxuW2BkZWZhdWx0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5QcmVjLmRlZmF1bHQpIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcGFyZW50LiBUaGVcbmZpbmFsIG9yZGVyaW5nIG9mIGV4dGVuc2lvbnMgaXMgZGV0ZXJtaW5lZCBieSBmaXJzdCBzb3J0aW5nIGJ5XG5wcmVjZWRlbmNlIGFuZCB0aGVuIGJ5IG9yZGVyIHdpdGhpbiBlYWNoIHByZWNlZGVuY2UuXG4qL1xuY29uc3QgUHJlYyA9IHtcbiAgICAvKipcbiAgICBUaGUgaGlnaGVzdCBwcmVjZWRlbmNlIGxldmVsLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBzdGFydCBvZiB0aGUgcHJlY2VkZW5jZSBvcmRlcmluZy5cbiAgICAqL1xuICAgIGhpZ2hlc3Q6IHByZWMoUHJlY18uaGlnaGVzdCksXG4gICAgLyoqXG4gICAgQSBoaWdoZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UsIGZvciBleHRlbnNpb25zIHRoYXQgc2hvdWxkXG4gICAgY29tZSBiZWZvcmUgdGhvc2Ugd2l0aCBkZWZhdWx0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBoaWdoOiBwcmVjKFByZWNfLmhpZ2gpLFxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHByZWNlZGVuY2UsIHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgZXh0ZW5zaW9uc1xuICAgIHdpdGhvdXQgYW4gZXhwbGljaXQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGRlZmF1bHQ6IHByZWMoUHJlY18uZGVmYXVsdCksXG4gICAgLyoqXG4gICAgQSBsb3dlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGxvdzogcHJlYyhQcmVjXy5sb3cpLFxuICAgIC8qKlxuICAgIFRoZSBsb3dlc3QgcHJlY2VkZW5jZSBsZXZlbC4gTWVhbnQgZm9yIHRoaW5ncyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBlbmQgb2YgdGhlIGV4dGVuc2lvbiBvcmRlci5cbiAgICAqL1xuICAgIGxvd2VzdDogcHJlYyhQcmVjXy5sb3dlc3QpXG59O1xuY2xhc3MgUHJlY0V4dGVuc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIsIHByZWMpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLnByZWMgPSBwcmVjO1xuICAgIH1cbn1cbi8qKlxuRXh0ZW5zaW9uIGNvbXBhcnRtZW50cyBjYW4gYmUgdXNlZCB0byBtYWtlIGEgY29uZmlndXJhdGlvblxuZHluYW1pYy4gQnkgW3dyYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50Lm9mKSBwYXJ0IG9mIHlvdXJcbmNvbmZpZ3VyYXRpb24gaW4gYSBjb21wYXJ0bWVudCwgeW91IGNhbiBsYXRlclxuW3JlcGxhY2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpIHRoYXQgcGFydCB0aHJvdWdoIGFcbnRyYW5zYWN0aW9uLlxuKi9cbmNsYXNzIENvbXBhcnRtZW50IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjb21wYXJ0bWVudCB0byBhZGQgdG8geW91ciBbc3RhdGVcbiAgICBjb25maWd1cmF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlQ29uZmlnLmV4dGVuc2lvbnMpLlxuICAgICovXG4gICAgb2YoZXh0KSB7IHJldHVybiBuZXcgQ29tcGFydG1lbnRJbnN0YW5jZSh0aGlzLCBleHQpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRoYXRcbiAgICByZWNvbmZpZ3VyZXMgdGhpcyBjb21wYXJ0bWVudC5cbiAgICAqL1xuICAgIHJlY29uZmlndXJlKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIENvbXBhcnRtZW50LnJlY29uZmlndXJlLm9mKHsgY29tcGFydG1lbnQ6IHRoaXMsIGV4dGVuc2lvbjogY29udGVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgdGhlIGNvbXBhcnRtZW50IGluIHRoZSBzdGF0ZSwgb3JcbiAgICBgdW5kZWZpbmVkYCBpZiBpdCBpc24ndCBwcmVzZW50LlxuICAgICovXG4gICAgZ2V0KHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb25maWcuY29tcGFydG1lbnRzLmdldCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBDb21wYXJ0bWVudEluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJ0bWVudCwgaW5uZXIpIHtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudCA9IGNvbXBhcnRtZW50O1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgY29tcGFydG1lbnRzLCBkeW5hbWljU2xvdHMsIGFkZHJlc3MsIHN0YXRpY1ZhbHVlcywgZmFjZXRzKSB7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMuY29tcGFydG1lbnRzID0gY29tcGFydG1lbnRzO1xuICAgICAgICB0aGlzLmR5bmFtaWNTbG90cyA9IGR5bmFtaWNTbG90cztcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5zdGF0aWNWYWx1ZXMgPSBzdGF0aWNWYWx1ZXM7XG4gICAgICAgIHRoaXMuZmFjZXRzID0gZmFjZXRzO1xuICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YXR1c1RlbXBsYXRlLmxlbmd0aCA8IGR5bmFtaWNTbG90cy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlLnB1c2goMCAvKiBTbG90U3RhdHVzLlVucmVzb2x2ZWQgKi8pO1xuICAgIH1cbiAgICBzdGF0aWNGYWNldChmYWNldCkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuYWRkcmVzc1tmYWNldC5pZF07XG4gICAgICAgIHJldHVybiBhZGRyID09IG51bGwgPyBmYWNldC5kZWZhdWx0IDogdGhpcy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXTtcbiAgICB9XG4gICAgc3RhdGljIHJlc29sdmUoYmFzZSwgY29tcGFydG1lbnRzLCBvbGRTdGF0ZSkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG4gICAgICAgIGxldCBmYWNldHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgbmV3Q29tcGFydG1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBleHQgb2YgZmxhdHRlbihiYXNlLCBjb21wYXJ0bWVudHMsIG5ld0NvbXBhcnRtZW50cykpIHtcbiAgICAgICAgICAgIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKVxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGV4dCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgKGZhY2V0c1tleHQuZmFjZXQuaWRdIHx8IChmYWNldHNbZXh0LmZhY2V0LmlkXSA9IFtdKSkucHVzaChleHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZGRyZXNzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IHN0YXRpY1ZhbHVlcyA9IFtdO1xuICAgICAgICBsZXQgZHluYW1pY1Nsb3RzID0gW107XG4gICAgICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgYWRkcmVzc1tmaWVsZC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGZpZWxkLnNsb3QoYSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvbGRGYWNldHMgPSBvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuY29uZmlnLmZhY2V0cztcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gZmFjZXRzKSB7XG4gICAgICAgICAgICBsZXQgcHJvdmlkZXJzID0gZmFjZXRzW2lkXSwgZmFjZXQgPSBwcm92aWRlcnNbMF0uZmFjZXQ7XG4gICAgICAgICAgICBsZXQgb2xkUHJvdmlkZXJzID0gb2xkRmFjZXRzICYmIG9sZEZhY2V0c1tpZF0gfHwgW107XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJzLmV2ZXJ5KHAgPT4gcC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3NbZmFjZXQuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgIGlmIChzYW1lQXJyYXkob2xkUHJvdmlkZXJzLCBwcm92aWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKG9sZFN0YXRlLmZhY2V0KGZhY2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBmYWNldC5jb21iaW5lKHByb3ZpZGVycy5tYXAocCA9PiBwLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKG9sZFN0YXRlICYmIGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFN0YXRlLmZhY2V0KGZhY2V0KSkgPyBvbGRTdGF0ZS5mYWNldChmYWNldCkgOiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PSAwIC8qIFByb3ZpZGVyLlN0YXRpYyAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1twLmlkXSA9IChzdGF0aWNWYWx1ZXMubGVuZ3RoIDw8IDEpIHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKHAudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1twLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gcC5keW5hbWljU2xvdChhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBkeW5hbWljRmFjZXRTbG90KGEsIGZhY2V0LCBwcm92aWRlcnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNTbG90cy5tYXAoZiA9PiBmKGFkZHJlc3MpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25maWd1cmF0aW9uKGJhc2UsIG5ld0NvbXBhcnRtZW50cywgZHluYW1pYywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZsYXR0ZW4oZXh0ZW5zaW9uLCBjb21wYXJ0bWVudHMsIG5ld0NvbXBhcnRtZW50cykge1xuICAgIGxldCByZXN1bHQgPSBbW10sIFtdLCBbXSwgW10sIFtdXTtcbiAgICBsZXQgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBpbm5lcihleHQsIHByZWMpIHtcbiAgICAgICAgbGV0IGtub3duID0gc2Vlbi5nZXQoZXh0KTtcbiAgICAgICAgaWYgKGtub3duICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrbm93biA8PSBwcmVjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHJlc3VsdFtrbm93bl0uaW5kZXhPZihleHQpO1xuICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tub3duXS5zcGxpY2UoZm91bmQsIDEpO1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLmRlbGV0ZShleHQuY29tcGFydG1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uc2V0KGV4dCwgcHJlYyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4dCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGUgb2YgZXh0KVxuICAgICAgICAgICAgICAgIGlubmVyKGUsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChuZXdDb21wYXJ0bWVudHMuaGFzKGV4dC5jb21wYXJ0bWVudCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYER1cGxpY2F0ZSB1c2Ugb2YgY29tcGFydG1lbnQgaW4gZXh0ZW5zaW9uc2ApO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBjb21wYXJ0bWVudHMuZ2V0KGV4dC5jb21wYXJ0bWVudCkgfHwgZXh0LmlubmVyO1xuICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLnNldChleHQuY29tcGFydG1lbnQsIGNvbnRlbnQpO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgUHJlY0V4dGVuc2lvbikge1xuICAgICAgICAgICAgaW5uZXIoZXh0LmlubmVyLCBleHQucHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZCkge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWNdLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGlmIChleHQucHJvdmlkZXMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LnByb3ZpZGVzLCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBGYWNldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5mYWNldC5leHRlbnNpb25zKVxuICAgICAgICAgICAgICAgIGlubmVyKGV4dC5mYWNldC5leHRlbnNpb25zLCBQcmVjXy5kZWZhdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gZXh0LmV4dGVuc2lvbjtcbiAgICAgICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBleHRlbnNpb24gdmFsdWUgaW4gZXh0ZW5zaW9uIHNldCAoJHtleHR9KS4gVGhpcyBzb21ldGltZXMgaGFwcGVucyBiZWNhdXNlIG11bHRpcGxlIGluc3RhbmNlcyBvZiBAY29kZW1pcnJvci9zdGF0ZSBhcmUgbG9hZGVkLCBicmVha2luZyBpbnN0YW5jZW9mIGNoZWNrcy5gKTtcbiAgICAgICAgICAgIGlubmVyKGNvbnRlbnQsIHByZWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlubmVyKGV4dGVuc2lvbiwgUHJlY18uZGVmYXVsdCk7XG4gICAgcmV0dXJuIHJlc3VsdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICBpZiAoYWRkciAmIDEpXG4gICAgICAgIHJldHVybiAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi87XG4gICAgbGV0IGlkeCA9IGFkZHIgPj4gMTtcbiAgICBsZXQgc3RhdHVzID0gc3RhdGUuc3RhdHVzW2lkeF07XG4gICAgaWYgKHN0YXR1cyA9PSA0IC8qIFNsb3RTdGF0dXMuQ29tcHV0aW5nICovKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBiZXR3ZWVuIGZpZWxkcyBhbmQvb3IgZmFjZXRzXCIpO1xuICAgIGlmIChzdGF0dXMgJiAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8pXG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgc3RhdGUuc3RhdHVzW2lkeF0gPSA0IC8qIFNsb3RTdGF0dXMuQ29tcHV0aW5nICovO1xuICAgIGxldCBjaGFuZ2VkID0gc3RhdGUuY29tcHV0ZVNsb3Qoc3RhdGUsIHN0YXRlLmNvbmZpZy5keW5hbWljU2xvdHNbaWR4XSk7XG4gICAgcmV0dXJuIHN0YXRlLnN0YXR1c1tpZHhdID0gMiAvKiBTbG90U3RhdHVzLkNvbXB1dGVkICovIHwgY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGdldEFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICByZXR1cm4gYWRkciAmIDEgPyBzdGF0ZS5jb25maWcuc3RhdGljVmFsdWVzW2FkZHIgPj4gMV0gOiBzdGF0ZS52YWx1ZXNbYWRkciA+PiAxXTtcbn1cblxuY29uc3QgbGFuZ3VhZ2VEYXRhID0gRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IEZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHYgPT4gdiksXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGxpbmVTZXBhcmF0b3IgPSBGYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogdW5kZWZpbmVkLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBjaGFuZ2VGaWx0ZXIgPSBGYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRmlsdGVyID0gRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB0cmFuc2FjdGlvbkV4dGVuZGVyID0gRmFjZXQuZGVmaW5lKCk7XG5jb25zdCByZWFkT25seSA9IEZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiBmYWxzZVxufSk7XG5cbi8qKlxuQW5ub3RhdGlvbnMgYXJlIHRhZ2dlZCB2YWx1ZXMgdGhhdCBhcmUgdXNlZCB0byBhZGQgbWV0YWRhdGEgdG9cbnRyYW5zYWN0aW9ucyBpbiBhbiBleHRlbnNpYmxlIHdheS4gVGhleSBzaG91bGQgYmUgdXNlZCB0byBtb2RlbFxudGhpbmdzIHRoYXQgZWZmZWN0IHRoZSBlbnRpcmUgdHJhbnNhY3Rpb24gKHN1Y2ggYXMgaXRzIFt0aW1lXG5zdGFtcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl50aW1lKSBvciBpbmZvcm1hdGlvbiBhYm91dCBpdHNcbltvcmlnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSkuIEZvciBlZmZlY3RzIHRoYXQgaGFwcGVuXG5fYWxvbmdzaWRlXyB0aGUgb3RoZXIgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbiwgW3N0YXRlXG5lZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBhcmUgbW9yZSBhcHByb3ByaWF0ZS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhbm5vdGF0aW9uIHR5cGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgdHlwZSBvZiBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZSgpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uVHlwZSgpOyB9XG59XG4vKipcbk1hcmtlciB0aGF0IGlkZW50aWZpZXMgYSB0eXBlIG9mIFthbm5vdGF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkFubm90YXRpb24pLlxuKi9cbmNsYXNzIEFubm90YXRpb25UeXBlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5SZXByZXNlbnRhdGlvbiBvZiBhIHR5cGUgb2Ygc3RhdGUgZWZmZWN0LiBEZWZpbmVkIHdpdGhcbltgU3RhdGVFZmZlY3QuZGVmaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5kZWZpbmUpLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0VHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgYGFueWAgdHlwZXMgaW4gdGhlc2UgZnVuY3Rpb24gdHlwZXMgYXJlIHRoZXJlIHRvIHdvcmtcbiAgICAvLyBhcm91bmQgVHlwZVNjcmlwdCBpc3N1ZSAjMzc2MzEsIHdoZXJlIHRoZSB0eXBlIGd1YXJkIG9uXG4gICAgLy8gYFN0YXRlRWZmZWN0LmlzYCBteXN0ZXJpb3VzbHkgc3RvcHMgd29ya2luZyB3aGVuIHRoZXNlIHByb3Blcmx5XG4gICAgLy8gaGF2ZSB0eXBlIGBWYWx1ZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtzdGF0ZSBlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGluc3RhbmNlIG9mIHRoaXNcbiAgICB0eXBlLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdCh0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuU3RhdGUgZWZmZWN0cyBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYWRkaXRpb25hbCBlZmZlY3RzXG5hc3NvY2lhdGVkIHdpdGggYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uZWZmZWN0cykuIFRoZXlcbmFyZSBvZnRlbiB1c2VmdWwgdG8gbW9kZWwgY2hhbmdlcyB0byBjdXN0b20gW3N0YXRlXG5maWVsZHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCksIHdoZW4gdGhvc2UgY2hhbmdlcyBhcmVuJ3QgaW1wbGljaXQgaW5cbmRvY3VtZW50IG9yIHNlbGVjdGlvbiBjaGFuZ2VzLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgZWZmZWN0LlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBlZmZlY3QgdGhyb3VnaCBhIHBvc2l0aW9uIG1hcHBpbmcuIFdpbGwgcmV0dXJuXG4gICAgYHVuZGVmaW5lZGAgd2hlbiB0aGF0IGVuZHMgdXAgZGVsZXRpbmcgdGhlIGVmZmVjdC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLnR5cGUubWFwKHRoaXMudmFsdWUsIG1hcHBpbmcpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtYXBwZWQgPT0gdGhpcy52YWx1ZSA/IHRoaXMgOiBuZXcgU3RhdGVFZmZlY3QodGhpcy50eXBlLCBtYXBwZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIGVmZmVjdCBvYmplY3QgaXMgb2YgYSBnaXZlblxuICAgIFt0eXBlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0VHlwZSkuXG4gICAgKi9cbiAgICBpcyh0eXBlKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZTsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBlZmZlY3QgdHlwZS4gVGhlIHR5cGUgcGFyYW1ldGVyIGluZGljYXRlcyB0aGUgdHlwZVxuICAgIG9mIHZhbHVlcyB0aGF0IGhpcyBlZmZlY3QgaG9sZHMuIEl0IHNob3VsZCBiZSBhIHR5cGUgdGhhdFxuICAgIGRvZXNuJ3QgaW5jbHVkZSBgdW5kZWZpbmVkYCwgc2luY2UgdGhhdCBpcyB1c2VkIGluXG4gICAgW21hcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QubWFwKSB0byBpbmRpY2F0ZSB0aGF0IGFuIGVmZmVjdCBpc1xuICAgIHJlbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlRWZmZWN0VHlwZShzcGVjLm1hcCB8fCAodiA9PiB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhbiBhcnJheSBvZiBlZmZlY3RzIHRocm91Z2ggYSBjaGFuZ2Ugc2V0LlxuICAgICovXG4gICAgc3RhdGljIG1hcEVmZmVjdHMoZWZmZWN0cywgbWFwcGluZykge1xuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBlZmZlY3QubWFwKG1hcHBpbmcpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGlzIGVmZmVjdCBjYW4gYmUgdXNlZCB0byByZWNvbmZpZ3VyZSB0aGUgcm9vdCBleHRlbnNpb25zIG9mXG50aGUgZWRpdG9yLiBEb2luZyB0aGlzIHdpbGwgZGlzY2FyZCBhbnkgZXh0ZW5zaW9uc1xuW2FwcGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmFwcGVuZENvbmZpZyksIGJ1dCBkb2VzIG5vdCByZXNldFxudGhlIGNvbnRlbnQgb2YgW3JlY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSlcbmNvbXBhcnRtZW50cy5cbiovXG5TdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSA9IFN0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5BcHBlbmQgZXh0ZW5zaW9ucyB0byB0aGUgdG9wLWxldmVsIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGVkaXRvci5cbiovXG5TdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcgPSBTdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQ2hhbmdlcyB0byB0aGUgZWRpdG9yIHN0YXRlIGFyZSBncm91cGVkIGludG8gdHJhbnNhY3Rpb25zLlxuVHlwaWNhbGx5LCBhIHVzZXIgYWN0aW9uIGNyZWF0ZXMgYSBzaW5nbGUgdHJhbnNhY3Rpb24sIHdoaWNoIG1heVxuY29udGFpbiBhbnkgbnVtYmVyIG9mIGRvY3VtZW50IGNoYW5nZXMsIG1heSBjaGFuZ2UgdGhlIHNlbGVjdGlvbixcbm9yIGhhdmUgb3RoZXIgZWZmZWN0cy4gQ3JlYXRlIGEgdHJhbnNhY3Rpb24gYnkgY2FsbGluZ1xuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSksIG9yIGltbWVkaWF0ZWx5XG5kaXNwYXRjaCBvbmUgYnkgY2FsbGluZ1xuW2BFZGl0b3JWaWV3LmRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpLlxuKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhdGUgZnJvbSB3aGljaCB0aGUgdHJhbnNhY3Rpb24gc3RhcnRzLlxuICAgICovXG4gICAgc3RhcnRTdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIGRvY3VtZW50IGNoYW5nZXMgbWFkZSBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgY2hhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbiBzZXQgYnkgdGhpcyB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIGl0XG4gICAgZG9lc24ndCBleHBsaWNpdGx5IHNldCBhIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHNlbGVjdGlvbiwgXG4gICAgLyoqXG4gICAgVGhlIGVmZmVjdHMgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZWZmZWN0cywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhbm5vdGF0aW9ucywgXG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYWZ0ZXIgdGhpc1xuICAgIHRyYW5zYWN0aW9uIGlzIGRpc3BhdGNoZWQuXG4gICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSBzdGFydFN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3ID0gc2Nyb2xsSW50b1ZpZXc7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZG9jID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGNoYW5nZXMubmV3TGVuZ3RoKTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucy5zb21lKChhKSA9PiBhLnR5cGUgPT0gVHJhbnNhY3Rpb24udGltZSkpXG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuY29uY2F0KFRyYW5zYWN0aW9uLnRpbWUub2YoRGF0ZS5ub3coKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoc3RhcnRTdGF0ZSwgY2hhbmdlcywgc2VsZWN0aW9uLCBlZmZlY3RzLCBhbm5vdGF0aW9ucywgc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb250cmFyeSB0b1xuICAgIFtgLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSlgLmRvY2AsIGFjY2Vzc2luZyB0aGlzIHdvbid0XG4gICAgZm9yY2UgdGhlIGVudGlyZSBuZXcgc3RhdGUgdG8gYmUgY29tcHV0ZWQgcmlnaHQgYXdheSwgc28gaXQgaXNcbiAgICByZWNvbW1lbmRlZCB0aGF0IFt0cmFuc2FjdGlvblxuICAgIGZpbHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpIHVzZSB0aGlzIGdldHRlclxuICAgIHdoZW4gdGhleSBuZWVkIHRvIGxvb2sgYXQgdGhlIG5ldyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBuZXdEb2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2MgfHwgKHRoaXMuX2RvYyA9IHRoaXMuY2hhbmdlcy5hcHBseSh0aGlzLnN0YXJ0U3RhdGUuZG9jKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgc2VsZWN0aW9uIHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gSWZcbiAgICBbYHRoaXMuc2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZWxlY3Rpb24pIGlzIHVuZGVmaW5lZCxcbiAgICB0aGlzIHdpbGwgW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ubWFwKSB0aGUgc3RhcnQgc3RhdGUnc1xuICAgIGN1cnJlbnQgc2VsZWN0aW9uIHRocm91Z2ggdGhlIGNoYW5nZXMgbWFkZSBieSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgbmV3U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24gfHwgdGhpcy5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYXAodGhpcy5jaGFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzdGF0ZSBjcmVhdGVkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gQ29tcHV0ZWQgb24gZGVtYW5kXG4gICAgKGJ1dCByZXRhaW5lZCBmb3Igc3Vic2VxdWVudCBhY2Nlc3MpLCBzbyBpdCBpcyByZWNvbW1lbmRlZCBub3QgdG9cbiAgICBhY2Nlc3MgaXQgaW4gW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgd2hlbiBwb3NzaWJsZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZSlcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTdGF0ZS5hcHBseVRyYW5zYWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGFubm90YXRpb24gdHlwZSwgaWYgYW55LlxuICAgICovXG4gICAgYW5ub3RhdGlvbih0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGFubiBvZiB0aGlzLmFubm90YXRpb25zKVxuICAgICAgICAgICAgaWYgKGFubi50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIGNoYW5nZWQgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7IHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB0cmFuc2FjdGlvbiByZWNvbmZpZ3VyZXMgdGhlIHN0YXRlXG4gICAgKHRocm91Z2ggYSBbY29uZmlndXJhdGlvbiBjb21wYXJ0bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudCkgb3JcbiAgICB3aXRoIGEgdG9wLWxldmVsIGNvbmZpZ3VyYXRpb25cbiAgICBbZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XnJlY29uZmlndXJlKS5cbiAgICAqL1xuICAgIGdldCByZWNvbmZpZ3VyZWQoKSB7IHJldHVybiB0aGlzLnN0YXJ0U3RhdGUuY29uZmlnICE9IHRoaXMuc3RhdGUuY29uZmlnOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgYSBbdXNlclxuICAgIGV2ZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnVzZXJFdmVudCkgYW5ub3RhdGlvbiB0aGF0IGlzIGVxdWFsIHRvXG4gICAgb3IgbW9yZSBzcGVjaWZpYyB0aGFuIGBldmVudGAuIEZvciBleGFtcGxlLCBpZiB0aGUgdHJhbnNhY3Rpb25cbiAgICBoYXMgYFwic2VsZWN0LnBvaW50ZXJcImAgYXMgdXNlciBldmVudCwgYFwic2VsZWN0XCJgIGFuZFxuICAgIGBcInNlbGVjdC5wb2ludGVyXCJgIHdpbGwgbWF0Y2ggaXQuXG4gICAgKi9cbiAgICBpc1VzZXJFdmVudChldmVudCkge1xuICAgICAgICBsZXQgZSA9IHRoaXMuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICByZXR1cm4gISEoZSAmJiAoZSA9PSBldmVudCB8fCBlLmxlbmd0aCA+IGV2ZW50Lmxlbmd0aCAmJiBlLnNsaWNlKDAsIGV2ZW50Lmxlbmd0aCkgPT0gZXZlbnQgJiYgZVtldmVudC5sZW5ndGhdID09IFwiLlwiKSk7XG4gICAgfVxufVxuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gc3RvcmUgdHJhbnNhY3Rpb24gdGltZXN0YW1wcy4gQXV0b21hdGljYWxseVxuYWRkZWQgdG8gZXZlcnkgdHJhbnNhY3Rpb24sIGhvbGRpbmcgYERhdGUubm93KClgLlxuKi9cblRyYW5zYWN0aW9uLnRpbWUgPSBBbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHVzZXIgaW50ZXJmYWNlXG5ldmVudC4gSG9sZHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIGV2ZW50LCB1c2luZyBhXG5kb3Qtc2VwYXJhdGVkIGZvcm1hdCB0byBzdXBwb3J0IGF0dGFjaGluZyBtb3JlIHNwZWNpZmljXG5pbmZvcm1hdGlvbi4gVGhlIGV2ZW50cyB1c2VkIGJ5IHRoZSBjb3JlIGxpYnJhcmllcyBhcmU6XG5cbiAtIGBcImlucHV0XCJgIHdoZW4gY29udGVudCBpcyBlbnRlcmVkXG4gICAtIGBcImlucHV0LnR5cGVcImAgZm9yIHR5cGVkIGlucHV0XG4gICAgIC0gYFwiaW5wdXQudHlwZS5jb21wb3NlXCJgIGZvciBjb21wb3NpdGlvblxuICAgLSBgXCJpbnB1dC5wYXN0ZVwiYCBmb3IgcGFzdGVkIGlucHV0XG4gICAtIGBcImlucHV0LmRyb3BcImAgd2hlbiBhZGRpbmcgY29udGVudCB3aXRoIGRyYWctYW5kLWRyb3BcbiAgIC0gYFwiaW5wdXQuY29tcGxldGVcImAgd2hlbiBhdXRvY29tcGxldGluZ1xuIC0gYFwiZGVsZXRlXCJgIHdoZW4gdGhlIHVzZXIgZGVsZXRlcyBjb250ZW50XG4gICAtIGBcImRlbGV0ZS5zZWxlY3Rpb25cImAgd2hlbiBkZWxldGluZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5mb3J3YXJkXCJgIHdoZW4gZGVsZXRpbmcgZm9yd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmJhY2t3YXJkXCJgIHdoZW4gZGVsZXRpbmcgYmFja3dhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5jdXRcImAgd2hlbiBjdXR0aW5nIHRvIHRoZSBjbGlwYm9hcmRcbiAtIGBcIm1vdmVcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkXG4gICAtIGBcIm1vdmUuZHJvcFwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWQgd2l0aGluIHRoZSBlZGl0b3IgdGhyb3VnaCBkcmFnLWFuZC1kcm9wXG4gLSBgXCJzZWxlY3RcImAgd2hlbiBleHBsaWNpdGx5IGNoYW5naW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwic2VsZWN0LnBvaW50ZXJcImAgd2hlbiBzZWxlY3Rpbmcgd2l0aCBhIG1vdXNlIG9yIG90aGVyIHBvaW50aW5nIGRldmljZVxuIC0gYFwidW5kb1wiYCBhbmQgYFwicmVkb1wiYCBmb3IgaGlzdG9yeSBhY3Rpb25zXG5cblVzZSBbYGlzVXNlckV2ZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5pc1VzZXJFdmVudCkgdG8gY2hlY2tcbndoZXRoZXIgdGhlIGFubm90YXRpb24gbWF0Y2hlcyBhIGdpdmVuIGV2ZW50LlxuKi9cblRyYW5zYWN0aW9uLnVzZXJFdmVudCA9IEFubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyB3aGV0aGVyIGEgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFkZGVkIHRvXG50aGUgdW5kbyBoaXN0b3J5IG9yIG5vdC5cbiovXG5UcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkgPSBBbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgKHdoZW4gcHJlc2VudCBhbmQgdHJ1ZSkgdGhhdCBhIHRyYW5zYWN0aW9uXG5yZXByZXNlbnRzIGEgY2hhbmdlIG1hZGUgYnkgc29tZSBvdGhlciBhY3Rvciwgbm90IHRoZSB1c2VyLiBUaGlzXG5pcyB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gdGFnIG90aGVyIHBlb3BsZSdzIGNoYW5nZXMgaW5cbmNvbGxhYm9yYXRpdmUgZWRpdGluZy5cbiovXG5UcmFuc2FjdGlvbi5yZW1vdGUgPSBBbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gam9pblJhbmdlcyhhLCBiKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICBpZiAoaUEgPCBhLmxlbmd0aCAmJiAoaUIgPT0gYi5sZW5ndGggfHwgYltpQl0gPj0gYVtpQV0pKSB7XG4gICAgICAgICAgICBmcm9tID0gYVtpQSsrXTtcbiAgICAgICAgICAgIHRvID0gYVtpQSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpQiA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tID0gYltpQisrXTtcbiAgICAgICAgICAgIHRvID0gYltpQisrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IGZyb20pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCB0bylcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVRyYW5zYWN0aW9uKGEsIGIsIHNlcXVlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG1hcEZvckEsIG1hcEZvckIsIGNoYW5nZXM7XG4gICAgaWYgKHNlcXVlbnRpYWwpIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcztcbiAgICAgICAgbWFwRm9yQiA9IENoYW5nZVNldC5lbXB0eShiLmNoYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKGIuY2hhbmdlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzLm1hcChhLmNoYW5nZXMpO1xuICAgICAgICBtYXBGb3JCID0gYS5jaGFuZ2VzLm1hcERlc2MoYi5jaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKG1hcEZvckEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IGIuc2VsZWN0aW9uID8gYi5zZWxlY3Rpb24ubWFwKG1hcEZvckIpIDogKF9hID0gYS5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAobWFwRm9yQSksXG4gICAgICAgIGVmZmVjdHM6IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYS5lZmZlY3RzLCBtYXBGb3JBKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhiLmVmZmVjdHMsIG1hcEZvckIpKSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IGEuYW5ub3RhdGlvbnMubGVuZ3RoID8gYS5hbm5vdGF0aW9ucy5jb25jYXQoYi5hbm5vdGF0aW9ucykgOiBiLmFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogYS5zY3JvbGxJbnRvVmlldyB8fCBiLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjLCBkb2NTaXplKSB7XG4gICAgbGV0IHNlbCA9IHNwZWMuc2VsZWN0aW9uLCBhbm5vdGF0aW9ucyA9IGFzQXJyYXkoc3BlYy5hbm5vdGF0aW9ucyk7XG4gICAgaWYgKHNwZWMudXNlckV2ZW50KVxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi51c2VyRXZlbnQub2Yoc3BlYy51c2VyRXZlbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiBzcGVjLmNoYW5nZXMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQgPyBzcGVjLmNoYW5nZXNcbiAgICAgICAgICAgIDogQ2hhbmdlU2V0Lm9mKHNwZWMuY2hhbmdlcyB8fCBbXSwgZG9jU2l6ZSwgc3RhdGUuZmFjZXQobGluZVNlcGFyYXRvcikpLFxuICAgICAgICBzZWxlY3Rpb246IHNlbCAmJiAoc2VsIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gc2VsIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShzZWwuYW5jaG9yLCBzZWwuaGVhZCkpLFxuICAgICAgICBlZmZlY3RzOiBhc0FycmF5KHNwZWMuZWZmZWN0cyksXG4gICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogISFzcGVjLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgc3BlY3MsIGZpbHRlcikge1xuICAgIGxldCBzID0gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzLmxlbmd0aCA/IHNwZWNzWzBdIDoge30sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIGlmIChzcGVjcy5sZW5ndGggJiYgc3BlY3NbMF0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3BlY3NbaV0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VxID0gISFzcGVjc1tpXS5zZXF1ZW50aWFsO1xuICAgICAgICBzID0gbWVyZ2VUcmFuc2FjdGlvbihzLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3NbaV0sIHNlcSA/IHMuY2hhbmdlcy5uZXdMZW5ndGggOiBzdGF0ZS5kb2MubGVuZ3RoKSwgc2VxKTtcbiAgICB9XG4gICAgbGV0IHRyID0gVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCBzLmNoYW5nZXMsIHMuc2VsZWN0aW9uLCBzLmVmZmVjdHMsIHMuYW5ub3RhdGlvbnMsIHMuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIHJldHVybiBleHRlbmRUcmFuc2FjdGlvbihmaWx0ZXIgPyBmaWx0ZXJUcmFuc2FjdGlvbih0cikgOiB0cik7XG59XG4vLyBGaW5pc2ggYSB0cmFuc2FjdGlvbiBieSBhcHBseWluZyBmaWx0ZXJzIGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZTtcbiAgICAvLyBDaGFuZ2UgZmlsdGVyc1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChjaGFuZ2VGaWx0ZXIpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZpbHRlcih0cik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB0cnVlID8gdmFsdWUgOiBqb2luUmFuZ2VzKHJlc3VsdCwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzLCBiYWNrO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFjayA9IHRyLmNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgICAgICAgICAgY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eShzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHRyLmNoYW5nZXMuZmlsdGVyKHJlc3VsdCk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gZmlsdGVyZWQuY2hhbmdlcztcbiAgICAgICAgICAgIGJhY2sgPSBmaWx0ZXJlZC5maWx0ZXJlZC5tYXBEZXNjKGZpbHRlcmVkLmNoYW5nZXMpLmludmVydGVkRGVzYztcbiAgICAgICAgfVxuICAgICAgICB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgY2hhbmdlcywgdHIuc2VsZWN0aW9uICYmIHRyLnNlbGVjdGlvbi5tYXAoYmFjayksIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHModHIuZWZmZWN0cywgYmFjayksIHRyLmFubm90YXRpb25zLCB0ci5zY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8vIFRyYW5zYWN0aW9uIGZpbHRlcnNcbiAgICBsZXQgZmlsdGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRmlsdGVyKTtcbiAgICBmb3IgKGxldCBpID0gZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSBmaWx0ZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB0ciA9IGZpbHRlcmVkO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcmVkKSAmJiBmaWx0ZXJlZC5sZW5ndGggPT0gMSAmJiBmaWx0ZXJlZFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZFswXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIgPSByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIGFzQXJyYXkoZmlsdGVyZWQpLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGV4dGVuZFRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZSwgZXh0ZW5kZXJzID0gc3RhdGUuZmFjZXQodHJhbnNhY3Rpb25FeHRlbmRlciksIHNwZWMgPSB0cjtcbiAgICBmb3IgKGxldCBpID0gZXh0ZW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbmRlcnNbaV0odHIpO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIE9iamVjdC5rZXlzKGV4dGVuc2lvbikubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYyA9IG1lcmdlVHJhbnNhY3Rpb24oc3BlYywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIGV4dGVuc2lvbiwgdHIuY2hhbmdlcy5uZXdMZW5ndGgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMgPT0gdHIgPyB0ciA6IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgdHIuY2hhbmdlcywgdHIuc2VsZWN0aW9uLCBzcGVjLmVmZmVjdHMsIHNwZWMuYW5ub3RhdGlvbnMsIHNwZWMuc2Nyb2xsSW50b1ZpZXcpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gbm9uZSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vKipcblRoZSBjYXRlZ29yaWVzIHByb2R1Y2VkIGJ5IGEgW2NoYXJhY3RlclxuY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKS4gVGhlc2UgYXJlIHVzZWRcbmRvIHRoaW5ncyBsaWtlIHNlbGVjdGluZyBieSB3b3JkLlxuKi9cbmV4cG9ydHMuQ2hhckNhdGVnb3J5ID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChDaGFyQ2F0ZWdvcnkpIHtcbiAgICAvKipcbiAgICBXb3JkIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiV29yZFwiXSA9IDBdID0gXCJXb3JkXCI7XG4gICAgLyoqXG4gICAgV2hpdGVzcGFjZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJTcGFjZVwiXSA9IDFdID0gXCJTcGFjZVwiO1xuICAgIC8qKlxuICAgIEFueXRoaW5nIGVsc2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiT3RoZXJcIl0gPSAyXSA9IFwiT3RoZXJcIjtcbn0pKGV4cG9ydHMuQ2hhckNhdGVnb3J5IHx8IChleHBvcnRzLkNoYXJDYXRlZ29yeSA9IHt9KSk7XG5jb25zdCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbmxldCB3b3JkQ2hhcjtcbnRyeSB7XG4gICAgd29yZENoYXIgPSBuZXcgUmVnRXhwKFwiW1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV9dXCIsIFwidVwiKTtcbn1cbmNhdGNoIChfKSB7IH1cbmZ1bmN0aW9uIGhhc1dvcmRDaGFyKHN0cikge1xuICAgIGlmICh3b3JkQ2hhcilcbiAgICAgICAgcmV0dXJuIHdvcmRDaGFyLnRlc3Qoc3RyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2ggPSBzdHJbaV07XG4gICAgICAgIGlmICgvXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFwiXFx4ODBcIiAmJiAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBtYWtlQ2F0ZWdvcml6ZXIod29yZENoYXJzKSB7XG4gICAgcmV0dXJuIChjaGFyKSA9PiB7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChjaGFyKSlcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkNoYXJDYXRlZ29yeS5TcGFjZTtcbiAgICAgICAgaWYgKGhhc1dvcmRDaGFyKGNoYXIpKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNoYXIuaW5kZXhPZih3b3JkQ2hhcnNbaV0pID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkNoYXJDYXRlZ29yeS5PdGhlcjtcbiAgICB9O1xufVxuXG4vKipcblRoZSBlZGl0b3Igc3RhdGUgY2xhc3MgaXMgYSBwZXJzaXN0ZW50IChpbW11dGFibGUpIGRhdGEgc3RydWN0dXJlLlxuVG8gdXBkYXRlIGEgc3RhdGUsIHlvdSBbY3JlYXRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkgYVxuW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSwgd2hpY2ggcHJvZHVjZXMgYSBfbmV3XyBzdGF0ZVxuaW5zdGFuY2UsIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG5cbkFzIHN1Y2gsIF9uZXZlcl8gbXV0YXRlIHByb3BlcnRpZXMgb2YgYSBzdGF0ZSBkaXJlY3RseS4gVGhhdCdsbFxuanVzdCBicmVhayB0aGluZ3MuXG4qL1xuY2xhc3MgRWRpdG9yU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHZhbHVlcywgY29tcHV0ZVNsb3QsIHRyKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGNvbmZpZy5zdGF0dXNUZW1wbGF0ZS5zbGljZSgpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gY29tcHV0ZVNsb3Q7XG4gICAgICAgIC8vIEZpbGwgaW4gdGhlIGNvbXB1dGVkIHN0YXRlIGltbWVkaWF0ZWx5LCBzbyB0aGF0IGZ1cnRoZXIgcXVlcmllc1xuICAgICAgICAvLyBmb3IgaXQgbWFkZSBkdXJpbmcgdGhlIHVwZGF0ZSByZXR1cm4gdGhpcyBzdGF0ZVxuICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICB0ci5fc3RhdGUgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLmR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGVuc3VyZUFkZHIodGhpcywgaSA8PCAxKTtcbiAgICAgICAgdGhpcy5jb21wdXRlU2xvdCA9IG51bGw7XG4gICAgfVxuICAgIGZpZWxkKGZpZWxkLCByZXF1aXJlID0gdHJ1ZSkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmllbGQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVxdWlyZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZpZWxkIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgc3RhdGVcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pIHRoYXQgdXBkYXRlcyB0aGlzXG4gICAgc3RhdGUuIEFueSBudW1iZXIgb2YgW3RyYW5zYWN0aW9uIHNwZWNzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYylcbiAgICBjYW4gYmUgcGFzc2VkLiBVbmxlc3NcbiAgICBbYHNlcXVlbnRpYWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZXF1ZW50aWFsKSBpcyBzZXQsIHRoZVxuICAgIFtjaGFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5jaGFuZ2VzKSAoaWYgYW55KSBvZiBlYWNoIHNwZWNcbiAgICBhcmUgYXNzdW1lZCB0byBzdGFydCBpbiB0aGUgX2N1cnJlbnRfIGRvY3VtZW50IChub3QgdGhlIGRvY3VtZW50XG4gICAgcHJvZHVjZWQgYnkgcHJldmlvdXMgc3BlY3MpLCBhbmQgaXRzXG4gICAgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBhbmRcbiAgICBbZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgYXJlIGFzc3VtZWQgdG8gcmVmZXJcbiAgICB0byB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSBpdHMgX293bl8gY2hhbmdlcy4gVGhlIHJlc3VsdGluZ1xuICAgIHRyYW5zYWN0aW9uIGNvbnRhaW5zIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYWxsIHRoZSBkaWZmZXJlbnRcbiAgICBzcGVjcy4gRm9yIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbiksIGxhdGVyXG4gICAgc3BlY3MgdGFrZSBwcmVjZWRlbmNlIG92ZXIgZWFybGllciBvbmVzLlxuICAgICovXG4gICAgdXBkYXRlKC4uLnNwZWNzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNhY3Rpb24odGhpcywgc3BlY3MsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5VHJhbnNhY3Rpb24odHIpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLmNvbmZpZywgeyBiYXNlLCBjb21wYXJ0bWVudHMgfSA9IGNvbmY7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKENvbXBhcnRtZW50LnJlY29uZmlndXJlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25mKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cyA9IG5ldyBNYXA7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYuY29tcGFydG1lbnRzLmZvckVhY2goKHZhbCwga2V5KSA9PiBjb21wYXJ0bWVudHMuc2V0KGtleSwgdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMuc2V0KGVmZmVjdC52YWx1ZS5jb21wYXJ0bWVudCwgZWZmZWN0LnZhbHVlLmV4dGVuc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoU3RhdGVFZmZlY3QucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGFzQXJyYXkoYmFzZSkuY29uY2F0KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0VmFsdWVzO1xuICAgICAgICBpZiAoIWNvbmYpIHtcbiAgICAgICAgICAgIGNvbmYgPSBDb25maWd1cmF0aW9uLnJlc29sdmUoYmFzZSwgY29tcGFydG1lbnRzLCB0aGlzKTtcbiAgICAgICAgICAgIGxldCBpbnRlcm1lZGlhdGVTdGF0ZSA9IG5ldyBFZGl0b3JTdGF0ZShjb25mLCB0aGlzLmRvYywgdGhpcy5zZWxlY3Rpb24sIGNvbmYuZHluYW1pY1Nsb3RzLm1hcCgoKSA9PiBudWxsKSwgKHN0YXRlLCBzbG90KSA9PiBzbG90LnJlY29uZmlndXJlKHN0YXRlLCB0aGlzKSwgbnVsbCk7XG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IGludGVybWVkaWF0ZVN0YXRlLnZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gdHIuc3RhcnRTdGF0ZS52YWx1ZXMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdHIuc3RhcnRTdGF0ZS5mYWNldChhbGxvd011bHRpcGxlU2VsZWN0aW9ucykgPyB0ci5uZXdTZWxlY3Rpb24gOiB0ci5uZXdTZWxlY3Rpb24uYXNTaW5nbGUoKTtcbiAgICAgICAgbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRyLm5ld0RvYywgc2VsZWN0aW9uLCBzdGFydFZhbHVlcywgKHN0YXRlLCBzbG90KSA9PiBzbG90LnVwZGF0ZShzdGF0ZSwgdHIpLCB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbiBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYykgdGhhdFxuICAgIHJlcGxhY2VzIGV2ZXJ5IHNlbGVjdGlvbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGV4dCA9IHRoaXMudG9UZXh0KHRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+ICh7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyB0ZXh0Lmxlbmd0aCkgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgY2hhbmdlcyBhbmQgYSBuZXcgc2VsZWN0aW9uIGJ5IHJ1bm5pbmcgdGhlIGdpdmVuXG4gICAgZnVuY3Rpb24gZm9yIGVhY2ggcmFuZ2UgaW4gdGhlIGFjdGl2ZSBzZWxlY3Rpb24uIFRoZSBmdW5jdGlvblxuICAgIGNhbiByZXR1cm4gYW4gb3B0aW9uYWwgc2V0IG9mIGNoYW5nZXMgKGluIHRoZSBjb29yZGluYXRlIHNwYWNlXG4gICAgb2YgdGhlIHN0YXJ0IGRvY3VtZW50KSwgcGx1cyBhbiB1cGRhdGVkIHJhbmdlIChpbiB0aGUgY29vcmRpbmF0ZVxuICAgIHNwYWNlIG9mIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgY2FsbCdzIG93biBjaGFuZ2VzKS4gVGhpc1xuICAgIG1ldGhvZCB3aWxsIG1lcmdlIGFsbCB0aGUgY2hhbmdlcyBhbmQgcmFuZ2VzIGludG8gYSBzaW5nbGVcbiAgICBjaGFuZ2VzZXQgYW5kIHNlbGVjdGlvbiwgYW5kIHJldHVybiBpdCBhcyBhIFt0cmFuc2FjdGlvblxuICAgIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSwgd2hpY2ggY2FuIGJlIHBhc3NlZCB0b1xuICAgIFtgdXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpLlxuICAgICovXG4gICAgY2hhbmdlQnlSYW5nZShmKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJlc3VsdDEgPSBmKHNlbC5yYW5nZXNbMF0pO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHRoaXMuY2hhbmdlcyhyZXN1bHQxLmNoYW5nZXMpLCByYW5nZXMgPSBbcmVzdWx0MS5yYW5nZV07XG4gICAgICAgIGxldCBlZmZlY3RzID0gYXNBcnJheShyZXN1bHQxLmVmZmVjdHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmKHNlbC5yYW5nZXNbaV0pO1xuICAgICAgICAgICAgbGV0IG5ld0NoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0LmNoYW5nZXMpLCBuZXdNYXBwZWQgPSBuZXdDaGFuZ2VzLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKVxuICAgICAgICAgICAgICAgIHJhbmdlc1tqXSA9IHJhbmdlc1tqXS5tYXAobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGxldCBtYXBCeSA9IGNoYW5nZXMubWFwRGVzYyhuZXdDaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJlc3VsdC5yYW5nZS5tYXAobWFwQnkpKTtcbiAgICAgICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzLmNvbXBvc2UobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGVmZmVjdHMgPSBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGVmZmVjdHMsIG5ld01hcHBlZCkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYXNBcnJheShyZXN1bHQuZWZmZWN0cyksIG1hcEJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzZWwubWFpbkluZGV4KSxcbiAgICAgICAgICAgIGVmZmVjdHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KSBmcm9tIHRoZSBnaXZlbiBjaGFuZ2VcbiAgICBkZXNjcmlwdGlvbiwgdGFraW5nIHRoZSBzdGF0ZSdzIGRvY3VtZW50IGxlbmd0aCBhbmQgbGluZVxuICAgIHNlcGFyYXRvciBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICBjaGFuZ2VzKHNwZWMgPSBbXSkge1xuICAgICAgICBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldClcbiAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICByZXR1cm4gQ2hhbmdlU2V0Lm9mKHNwZWMsIHRoaXMuZG9jLmxlbmd0aCwgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVzaW5nIHRoZSBzdGF0ZSdzIFtsaW5lXG4gICAgc2VwYXJhdG9yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpLCBjcmVhdGUgYVxuICAgIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dCkgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgdG9UZXh0KHN0cmluZykge1xuICAgICAgICByZXR1cm4gVGV4dC5vZihzdHJpbmcuc3BsaXQodGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBnaXZlbiByYW5nZSBvZiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcuXG4gICAgKi9cbiAgICBzbGljZURvYyhmcm9tID0gMCwgdG8gPSB0aGlzLmRvYy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCB0aGlzLmxpbmVCcmVhayk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzdGF0ZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXQpLlxuICAgICovXG4gICAgZmFjZXQoZmFjZXQpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmNvbmZpZy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgaWYgKGFkZHIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWNldC5kZWZhdWx0O1xuICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGFkZHIpO1xuICAgICAgICByZXR1cm4gZ2V0QWRkcih0aGlzLCBhZGRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIHN0YXRlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0LiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgc2VyaWFsaXplZCwgeW91IGNhbiBwYXNzIHRoZW0gaW4gYXMgYW4gb2JqZWN0XG4gICAgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyAoaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsIHdoaWNoIHNob3VsZFxuICAgIG5vdCB1c2UgYGRvY2Agb3IgYHNlbGVjdGlvbmApIHRvIGZpZWxkcy5cbiAgICAqL1xuICAgIHRvSlNPTihmaWVsZHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGRvYzogdGhpcy5zbGljZURvYygpLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBmaWVsZHNbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGVGaWVsZCAmJiB0aGlzLmNvbmZpZy5hZGRyZXNzW3ZhbHVlLmlkXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZS5zcGVjLnRvSlNPTih0aGlzLmZpZWxkKGZpZWxkc1twcm9wXSksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHN0YXRlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdoZW4gY3VzdG9tXG4gICAgZmllbGRzIHNob3VsZCBiZSBkZXNlcmlhbGl6ZWQsIHBhc3MgdGhlIHNhbWUgb2JqZWN0IHlvdSBwYXNzZWRcbiAgICB0byBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSB3aGVuIHNlcmlhbGl6aW5nIGFzXG4gICAgdGhpcmQgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbiwgY29uZmlnID0ge30sIGZpZWxkcykge1xuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uZG9jICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU3RhdGVcIik7XG4gICAgICAgIGxldCBmaWVsZEluaXQgPSBbXTtcbiAgICAgICAgaWYgKGZpZWxkcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBmaWVsZHNbcHJvcF0sIHZhbHVlID0ganNvbltwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbml0LnB1c2goZmllbGQuaW5pdChzdGF0ZSA9PiBmaWVsZC5zcGVjLmZyb21KU09OKHZhbHVlLCBzdGF0ZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgZG9jOiBqc29uLmRvYyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKGpzb24uc2VsZWN0aW9uKSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IGNvbmZpZy5leHRlbnNpb25zID8gZmllbGRJbml0LmNvbmNhdChbY29uZmlnLmV4dGVuc2lvbnNdKSA6IGZpZWxkSW5pdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLiBZb3UnbGwgdXN1YWxseSBvbmx5IG5lZWQgdGhpcyB3aGVuXG4gICAgaW5pdGlhbGl6aW5nIGFuIGVkaXRvcuKAlHVwZGF0ZWQgc3RhdGVzIGFyZSBjcmVhdGVkIGJ5IGFwcGx5aW5nXG4gICAgdHJhbnNhY3Rpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShjb25maWcuZXh0ZW5zaW9ucyB8fCBbXSwgbmV3IE1hcCk7XG4gICAgICAgIGxldCBkb2MgPSBjb25maWcuZG9jIGluc3RhbmNlb2YgVGV4dCA/IGNvbmZpZy5kb2NcbiAgICAgICAgICAgIDogVGV4dC5vZigoY29uZmlnLmRvYyB8fCBcIlwiKS5zcGxpdChjb25maWd1cmF0aW9uLnN0YXRpY0ZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IERlZmF1bHRTcGxpdCkpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gIWNvbmZpZy5zZWxlY3Rpb24gPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKDApXG4gICAgICAgICAgICA6IGNvbmZpZy5zZWxlY3Rpb24gaW5zdGFuY2VvZiBFZGl0b3JTZWxlY3Rpb24gPyBjb25maWcuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgOiBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGNvbmZpZy5zZWxlY3Rpb24uYW5jaG9yLCBjb25maWcuc2VsZWN0aW9uLmhlYWQpO1xuICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvYy5sZW5ndGgpO1xuICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpKVxuICAgICAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLmFzU2luZ2xlKCk7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU3RhdGUoY29uZmlndXJhdGlvbiwgZG9jLCBzZWxlY3Rpb24sIGNvbmZpZ3VyYXRpb24uZHluYW1pY1Nsb3RzLm1hcCgoKSA9PiBudWxsKSwgKHN0YXRlLCBzbG90KSA9PiBzbG90LmNyZWF0ZShzdGF0ZSksIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSAoaW4gY29sdW1ucykgb2YgYSB0YWIgaW4gdGhlIGRvY3VtZW50LCBkZXRlcm1pbmVkIGJ5XG4gICAgdGhlIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgZmFjZXQuXG4gICAgKi9cbiAgICBnZXQgdGFiU2l6ZSgpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUudGFiU2l6ZSk7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHByb3BlciBbbGluZS1icmVha10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKVxuICAgIHN0cmluZyBmb3IgdGhpcyBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IFwiXFxuXCI7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgW2NvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVecmVhZE9ubHkpIHRvIGJlIHJlYWQtb25seS5cbiAgICAqL1xuICAgIGdldCByZWFkT25seSgpIHsgcmV0dXJuIHRoaXMuZmFjZXQocmVhZE9ubHkpOyB9XG4gICAgLyoqXG4gICAgTG9vayB1cCBhIHRyYW5zbGF0aW9uIGZvciB0aGUgZ2l2ZW4gcGhyYXNlICh2aWEgdGhlXG4gICAgW2BwaHJhc2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5waHJhc2VzKSBmYWNldCksIG9yIHJldHVybiB0aGVcbiAgICBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdHJhbnNsYXRpb24gaXMgZm91bmQuXG4gICAgXG4gICAgSWYgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHBhc3NlZCwgdGhleSB3aWxsIGJlIGluc2VydGVkIGluXG4gICAgcGxhY2Ugb2YgbWFya2VycyBsaWtlIGAkMWAgKGZvciB0aGUgZmlyc3QgdmFsdWUpIGFuZCBgJDJgLCBldGMuXG4gICAgQSBzaW5nbGUgYCRgIGlzIGVxdWl2YWxlbnQgdG8gYCQxYCwgYW5kIGAkJGAgd2lsbCBwcm9kdWNlIGFcbiAgICBsaXRlcmFsIGRvbGxhciBzaWduLlxuICAgICovXG4gICAgcGhyYXNlKHBocmFzZSwgLi4uaW5zZXJ0KSB7XG4gICAgICAgIGZvciAobGV0IG1hcCBvZiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIHBocmFzZSkpIHtcbiAgICAgICAgICAgICAgICBwaHJhc2UgPSBtYXBbcGhyYXNlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGluc2VydC5sZW5ndGgpXG4gICAgICAgICAgICBwaHJhc2UgPSBwaHJhc2UucmVwbGFjZSgvXFwkKFxcJHxcXGQqKS9nLCAobSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpID09IFwiJFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSArKGkgfHwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFuIHx8IG4gPiBpbnNlcnQubGVuZ3RoID8gbSA6IGluc2VydFtuIC0gMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBocmFzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdmFsdWVzIGZvciBhIGdpdmVuIGxhbmd1YWdlIGRhdGEgZmllbGQsIHByb3ZpZGVkIGJ5IHRoZVxuICAgIHRoZSBbYGxhbmd1YWdlRGF0YWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGFuZ3VhZ2VEYXRhKSBmYWNldC5cbiAgICBcbiAgICBFeGFtcGxlcyBvZiBsYW5ndWFnZSBkYXRhIGZpZWxkcyBhcmUuLi5cbiAgICBcbiAgICAtIFtgXCJjb21tZW50VG9rZW5zXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIGZvciBzcGVjaWZ5aW5nXG4gICAgICBjb21tZW50IHN5bnRheC5cbiAgICAtIFtgXCJhdXRvY29tcGxldGVcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmF1dG9jb21wbGV0aW9uXmNvbmZpZy5vdmVycmlkZSlcbiAgICAgIGZvciBwcm92aWRpbmcgbGFuZ3VhZ2Utc3BlY2lmaWMgY29tcGxldGlvbiBzb3VyY2VzLlxuICAgIC0gW2BcIndvcmRDaGFyc1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpIGZvciBhZGRpbmdcbiAgICAgIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIHdvcmRzIGluIHRoaXNcbiAgICAgIGxhbmd1YWdlLlxuICAgIC0gW2BcImNsb3NlQnJhY2tldHNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNsb3NlQnJhY2tldENvbmZpZykgY29udHJvbHNcbiAgICAgIGJyYWNrZXQgY2xvc2luZyBiZWhhdmlvci5cbiAgICAqL1xuICAgIGxhbmd1YWdlRGF0YUF0KG5hbWUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcHJvdmlkZXIgb2YgdGhpcy5mYWNldChsYW5ndWFnZURhdGEpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByZXN1bHQgb2YgcHJvdmlkZXIodGhpcywgcG9zLCBzaWRlKSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocmVzdWx0W25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBjYXRlZ29yaXplIHN0cmluZ3MgKGV4cGVjdGVkIHRvXG4gICAgcmVwcmVzZW50IGEgc2luZ2xlIFtncmFwaGVtZSBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLmZpbmRDbHVzdGVyQnJlYWspKVxuICAgIGludG8gb25lIG9mOlxuICAgIFxuICAgICAtIFdvcmQgKGNvbnRhaW5zIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIgb3IgYSBjaGFyYWN0ZXJcbiAgICAgICBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgbG9jYWwgbGFuZ3VhZ2UncyBgXCJ3b3JkQ2hhcnNcImBcbiAgICAgICBsYW5ndWFnZSBkYXRhLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcpXG4gICAgIC0gU3BhY2UgKGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZSlcbiAgICAgLSBPdGhlciAoYW55dGhpbmcgZWxzZSlcbiAgICAqL1xuICAgIGNoYXJDYXRlZ29yaXplcihhdCkge1xuICAgICAgICByZXR1cm4gbWFrZUNhdGVnb3JpemVyKHRoaXMubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgYXQpLmpvaW4oXCJcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgbWVhbmluZyB0aGUgcmFuZ2VcbiAgICBjb250YWluaW5nIGFsbCBbd29yZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkgY2hhcmFjdGVyc1xuICAgIGFyb3VuZCBpdC4gSWYgbm8gd29yZCBjaGFyYWN0ZXJzIGFyZSBhZGphY2VudCB0byB0aGUgcG9zaXRpb24sXG4gICAgdGhpcyByZXR1cm5zIG51bGwuXG4gICAgKi9cbiAgICB3b3JkQXQocG9zKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20sIGxlbmd0aCB9ID0gdGhpcy5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBjYXQgPSB0aGlzLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBwb3MgLSBmcm9tLCBlbmQgPSBwb3MgLSBmcm9tO1xuICAgICAgICB3aGlsZSAoc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dC5zbGljZShwcmV2LCBzdGFydCkpICE9IGV4cG9ydHMuQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdGFydCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVuZCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKHRleHQsIGVuZCk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UoZW5kLCBuZXh0KSkgIT0gZXhwb3J0cy5DaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVuZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0ID09IGVuZCA/IG51bGwgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoc3RhcnQgKyBmcm9tLCBlbmQgKyBmcm9tKTtcbiAgICB9XG59XG4vKipcbkEgZmFjZXQgdGhhdCwgd2hlbiBlbmFibGVkLCBjYXVzZXMgdGhlIGVkaXRvciB0byBhbGxvdyBtdWx0aXBsZVxucmFuZ2VzIHRvIGJlIHNlbGVjdGVkLiBCZSBjYXJlZnVsIHRob3VnaCwgYmVjYXVzZSBieSBkZWZhdWx0IHRoZVxuZWRpdG9yIHJlbGllcyBvbiB0aGUgbmF0aXZlIERPTSBzZWxlY3Rpb24sIHdoaWNoIGNhbm5vdCBoYW5kbGVcbm11bHRpcGxlIHNlbGVjdGlvbnMuIEFuIGV4dGVuc2lvbiBsaWtlXG5bYGRyYXdTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbikgY2FuIGJlIHVzZWQgdG8gbWFrZVxuc2Vjb25kYXJ5IHNlbGVjdGlvbnMgdmlzaWJsZSB0byB0aGUgdXNlci5cbiovXG5FZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zO1xuLyoqXG5Db25maWd1cmVzIHRoZSB0YWIgc2l6ZSB0byB1c2UgaW4gdGhpcyBzdGF0ZS4gVGhlIGZpcnN0XG4oaGlnaGVzdC1wcmVjZWRlbmNlKSB2YWx1ZSBvZiB0aGUgZmFjZXQgaXMgdXNlZC4gSWYgbm8gdmFsdWUgaXNcbmdpdmVuLCB0aGlzIGRlZmF1bHRzIHRvIDQuXG4qL1xuRWRpdG9yU3RhdGUudGFiU2l6ZSA9IEZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiA0XG59KTtcbi8qKlxuVGhlIGxpbmUgc2VwYXJhdG9yIHRvIHVzZS4gQnkgZGVmYXVsdCwgYW55IG9mIGBcIlxcblwiYCwgYFwiXFxyXFxuXCJgXG5hbmQgYFwiXFxyXCJgIGlzIHRyZWF0ZWQgYXMgYSBzZXBhcmF0b3Igd2hlbiBzcGxpdHRpbmcgbGluZXMsIGFuZFxubGluZXMgYXJlIGpvaW5lZCB3aXRoIGBcIlxcblwiYC5cblxuV2hlbiB5b3UgY29uZmlndXJlIGEgdmFsdWUgaGVyZSwgb25seSB0aGF0IHByZWNpc2Ugc2VwYXJhdG9yXG53aWxsIGJlIHVzZWQsIGFsbG93aW5nIHlvdSB0byByb3VuZC10cmlwIGRvY3VtZW50cyB0aHJvdWdoIHRoZVxuZWRpdG9yIHdpdGhvdXQgbm9ybWFsaXppbmcgbGluZSBzZXBhcmF0b3JzLlxuKi9cbkVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IgPSBsaW5lU2VwYXJhdG9yO1xuLyoqXG5UaGlzIGZhY2V0IGNvbnRyb2xzIHRoZSB2YWx1ZSBvZiB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBnZXR0ZXIsIHdoaWNoIGlzXG5jb25zdWx0ZWQgYnkgY29tbWFuZHMgYW5kIGV4dGVuc2lvbnMgdGhhdCBpbXBsZW1lbnQgZWRpdGluZ1xuZnVuY3Rpb25hbGl0eSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGV5IHNob3VsZCBhcHBseS4gSXRcbmRlZmF1bHRzIHRvIGZhbHNlLCBidXQgd2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzXG5gdHJ1ZWAsIHN1Y2ggZnVuY3Rpb25hbGl0eSBkaXNhYmxlcyBpdHNlbGYuXG5cbk5vdCB0byBiZSBjb25mdXNlZCB3aXRoXG5bYEVkaXRvclZpZXcuZWRpdGFibGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15lZGl0YWJsZSksIHdoaWNoXG5jb250cm9scyB3aGV0aGVyIHRoZSBlZGl0b3IncyBET00gaXMgc2V0IHRvIGJlIGVkaXRhYmxlIChhbmRcbnRodXMgZm9jdXNhYmxlKS5cbiovXG5FZGl0b3JTdGF0ZS5yZWFkT25seSA9IHJlYWRPbmx5O1xuLyoqXG5SZWdpc3RlcnMgdHJhbnNsYXRpb24gcGhyYXNlcy4gVGhlXG5bYHBocmFzZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucGhyYXNlKSBtZXRob2Qgd2lsbCBsb29rIHRocm91Z2hcbmFsbCBvYmplY3RzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGZhY2V0IHRvIGZpbmQgdHJhbnNsYXRpb25zIGZvclxuaXRzIGFyZ3VtZW50LlxuKi9cbkVkaXRvclN0YXRlLnBocmFzZXMgPSBGYWNldC5kZWZpbmUoe1xuICAgIGNvbXBhcmUoYSwgYikge1xuICAgICAgICBsZXQga0EgPSBPYmplY3Qua2V5cyhhKSwga0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtBLmxlbmd0aCA9PSBrQi5sZW5ndGggJiYga0EuZXZlcnkoayA9PiBhW2tdID09IGJba10pO1xuICAgIH1cbn0pO1xuLyoqXG5BIGZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSBwcm92aWRlcnMuXG4qL1xuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhID0gbGFuZ3VhZ2VEYXRhO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGNoYW5nZSBmaWx0ZXJzLCB3aGljaCBhcmUgY2FsbGVkIGZvciBlYWNoXG50cmFuc2FjdGlvbiAodW5sZXNzIGV4cGxpY2l0bHlcbltkaXNhYmxlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSksIGFuZCBjYW4gc3VwcHJlc3NcbnBhcnQgb2YgdGhlIHRyYW5zYWN0aW9uJ3MgY2hhbmdlcy5cblxuU3VjaCBhIGZ1bmN0aW9uIGNhbiByZXR1cm4gYHRydWVgIHRvIGluZGljYXRlIHRoYXQgaXQgZG9lc24ndFxud2FudCB0byBkbyBhbnl0aGluZywgYGZhbHNlYCB0byBjb21wbGV0ZWx5IHN0b3AgdGhlIGNoYW5nZXMgaW5cbnRoZSB0cmFuc2FjdGlvbiwgb3IgYSBzZXQgb2YgcmFuZ2VzIGluIHdoaWNoIGNoYW5nZXMgc2hvdWxkIGJlXG5zdXBwcmVzc2VkLiBTdWNoIHJhbmdlcyBhcmUgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgbnVtYmVycyxcbndpdGggZWFjaCBwYWlyIG9mIHR3byBudW1iZXJzIGluZGljYXRpbmcgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgYVxucmFuZ2UuIFNvIGZvciBleGFtcGxlIGBbMTAsIDIwLCAxMDAsIDExMF1gIHN1cHByZXNzZXMgY2hhbmdlc1xuYmV0d2VlbiAxMCBhbmQgMjAsIGFuZCBiZXR3ZWVuIDEwMCBhbmQgMTEwLlxuKi9cbkVkaXRvclN0YXRlLmNoYW5nZUZpbHRlciA9IGNoYW5nZUZpbHRlcjtcbi8qKlxuRmFjZXQgdXNlZCB0byByZWdpc3RlciBhIGhvb2sgdGhhdCBnZXRzIGEgY2hhbmNlIHRvIHVwZGF0ZSBvclxucmVwbGFjZSB0cmFuc2FjdGlvbiBzcGVjcyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZC4gVGhpcyB3aWxsXG5vbmx5IGJlIGFwcGxpZWQgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGRvbid0IGhhdmVcbltgZmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSBzZXQgdG8gYGZhbHNlYC4gWW91XG5jYW4gZWl0aGVyIHJldHVybiBhIHNpbmdsZSB0cmFuc2FjdGlvbiBzcGVjIChwb3NzaWJseSB0aGUgaW5wdXRcbnRyYW5zYWN0aW9uKSwgb3IgYW4gYXJyYXkgb2Ygc3BlY3MgKHdoaWNoIHdpbGwgYmUgY29tYmluZWQgaW5cbnRoZSBzYW1lIHdheSBhcyB0aGUgYXJndW1lbnRzIHRvXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSkuXG5cbldoZW4gcG9zc2libGUsIGl0IGlzIHJlY29tbWVuZGVkIHRvIGF2b2lkIGFjY2Vzc2luZ1xuW2BUcmFuc2FjdGlvbi5zdGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc3RhdGUpIGluIGEgZmlsdGVyLFxuc2luY2UgaXQgd2lsbCBmb3JjZSBjcmVhdGlvbiBvZiBhIHN0YXRlIHRoYXQgd2lsbCB0aGVuIGJlXG5kaXNjYXJkZWQgYWdhaW4sIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhY3R1YWxseSBmaWx0ZXJlZC5cblxuKFRoaXMgZnVuY3Rpb25hbGl0eSBzaG91bGQgYmUgdXNlZCB3aXRoIGNhcmUuIEluZGlzY3JpbWluYXRlbHlcbm1vZGlmeWluZyB0cmFuc2FjdGlvbiBpcyBsaWtlbHkgdG8gYnJlYWsgc29tZXRoaW5nIG9yIGRlZ3JhZGVcbnRoZSB1c2VyIGV4cGVyaWVuY2UuKVxuKi9cbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRmlsdGVyID0gdHJhbnNhY3Rpb25GaWx0ZXI7XG4vKipcblRoaXMgaXMgYSBtb3JlIGxpbWl0ZWQgZm9ybSBvZlxuW2B0cmFuc2FjdGlvbkZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpLFxud2hpY2ggY2FuIG9ubHkgYWRkXG5bYW5ub3RhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmFubm90YXRpb25zKSBhbmRcbltlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKS4gX0J1dF8sIHRoaXMgdHlwZVxub2YgZmlsdGVyIHJ1bnMgZXZlbiBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGRpc2FibGVkIHJlZ3VsYXJcbltmaWx0ZXJpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlciksIG1ha2luZyBpdCBzdWl0YWJsZVxuZm9yIGVmZmVjdHMgdGhhdCBkb24ndCBuZWVkIHRvIHRvdWNoIHRoZSBjaGFuZ2VzIG9yIHNlbGVjdGlvbixcbmJ1dCBkbyB3YW50IHRvIHByb2Nlc3MgZXZlcnkgdHJhbnNhY3Rpb24uXG5cbkV4dGVuZGVycyBydW4gX2FmdGVyXyBmaWx0ZXJzLCB3aGVuIGJvdGggYXJlIHByZXNlbnQuXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25FeHRlbmRlciA9IHRyYW5zYWN0aW9uRXh0ZW5kZXI7XG5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSA9IFN0YXRlRWZmZWN0LmRlZmluZSgpO1xuXG4vKipcblV0aWxpdHkgZnVuY3Rpb24gZm9yIGNvbWJpbmluZyBiZWhhdmlvcnMgdG8gZmlsbCBpbiBhIGNvbmZpZ1xub2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgcHJvdmlkZWQgY29uZmlncy4gYGRlZmF1bHRzYCBzaG91bGQgaG9sZFxuZGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCBvcHRpb25hbCBmaWVsZHMgaW4gYENvbmZpZ2AuXG5cblRoZSBmdW5jdGlvbiB3aWxsLCBieSBkZWZhdWx0LCBlcnJvclxud2hlbiBhIGZpZWxkIGdldHMgdHdvIHZhbHVlcyB0aGF0IGFyZW4ndCBgPT09YC1lcXVhbCwgYnV0IHlvdSBjYW5cbnByb3ZpZGUgY29tYmluZSBmdW5jdGlvbnMgcGVyIGZpZWxkIHRvIGRvIHNvbWV0aGluZyBlbHNlLlxuKi9cbmZ1bmN0aW9uIGNvbWJpbmVDb25maWcoY29uZmlncywgZGVmYXVsdHMsIC8vIFNob3VsZCBob2xkIG9ubHkgdGhlIG9wdGlvbmFsIHByb3BlcnRpZXMgb2YgQ29uZmlnLCBidXQgSSBoYXZlbid0IG1hbmFnZWQgdG8gZXhwcmVzcyB0aGF0XG5jb21iaW5lID0ge30pIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjb25maWdba2V5XSwgY3VycmVudCA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgOyAvLyBObyBjb25mbGljdFxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY29tYmluZSwga2V5KSlcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNvbWJpbmVba2V5XShjdXJyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlnIG1lcmdlIGNvbmZsaWN0IGZvciBmaWVsZCBcIiArIGtleSk7XG4gICAgICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gZGVmYXVsdHMpXG4gICAgICAgIGlmIChyZXN1bHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuRWFjaCByYW5nZSBpcyBhc3NvY2lhdGVkIHdpdGggYSB2YWx1ZSwgd2hpY2ggbXVzdCBpbmhlcml0IGZyb21cbnRoaXMgY2xhc3MuXG4qL1xuY2xhc3MgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHZhbHVlIHdpdGggYW5vdGhlciB2YWx1ZS4gVXNlZCB3aGVuIGNvbXBhcmluZ1xuICAgIHJhbmdlc2V0cy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gY29tcGFyZXMgYnkgaWRlbnRpdHkuXG4gICAgVW5sZXNzIHlvdSBhcmUgb25seSBjcmVhdGluZyBhIGZpeGVkIG51bWJlciBvZiB1bmlxdWUgaW5zdGFuY2VzXG4gICAgb2YgeW91ciB2YWx1ZSB0eXBlLCBpdCBpcyBhIGdvb2QgaWRlYSB0byBpbXBsZW1lbnQgdGhpc1xuICAgIHByb3Blcmx5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMgPT0gb3RoZXI7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIHdpdGggdGhpcyB2YWx1ZS5cbiAgICAqL1xuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkgeyByZXR1cm4gUmFuZ2UuY3JlYXRlKGZyb20sIHRvLCB0aGlzKTsgfVxufVxuUmFuZ2VWYWx1ZS5wcm90b3R5cGUuc3RhcnRTaWRlID0gUmFuZ2VWYWx1ZS5wcm90b3R5cGUuZW5kU2lkZSA9IDA7XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5wb2ludCA9IGZhbHNlO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUubWFwTW9kZSA9IGV4cG9ydHMuTWFwTW9kZS5UcmFja0RlbDtcbi8qKlxuQSByYW5nZSBhc3NvY2lhdGVzIGEgdmFsdWUgd2l0aCBhIHJhbmdlIG9mIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBJdHMgZW5kIHBvc2l0aW9uLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyByYW5nZS5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoZnJvbSwgdG8sIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbXBSYW5nZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnZhbHVlLnN0YXJ0U2lkZSAtIGIudmFsdWUuc3RhcnRTaWRlO1xufVxuY2xhc3MgQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCB2YWx1ZSwgXG4gICAgLy8gQ2h1bmtzIGFyZSBtYXJrZWQgd2l0aCB0aGUgbGFyZ2VzdCBwb2ludCB0aGF0IG9jY3Vyc1xuICAgIC8vIGluIHRoZW0gKG9yIC0xIGZvciBubyBwb2ludHMpLCBzbyB0aGF0IHNjYW5zIHRoYXQgYXJlXG4gICAgLy8gb25seSBpbnRlcmVzdGVkIGluIHBvaW50cyAoc3VjaCBhcyB0aGVcbiAgICAvLyBoZWlnaHRtYXAtcmVsYXRlZCBsb2dpYykgY2FuIHNraXAgcmFuZ2Utb25seSBjaHVua3MuXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG9bdGhpcy50by5sZW5ndGggLSAxXTsgfVxuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS4gVXNlIHRoZSByYW5nZXMnXG4gICAgLy8gYGZyb21gIHBvcyB3aGVuIGBlbmQgPT0gZmFsc2VgLCBgdG9gIHdoZW4gYGVuZCA9PSB0cnVlYC5cbiAgICBmaW5kSW5kZXgocG9zLCBzaWRlLCBlbmQsIHN0YXJ0QXQgPSAwKSB7XG4gICAgICAgIGxldCBhcnIgPSBlbmQgPyB0aGlzLnRvIDogdGhpcy5mcm9tO1xuICAgICAgICBmb3IgKGxldCBsbyA9IHN0YXJ0QXQsIGhpID0gYXJyLmxlbmd0aDs7KSB7XG4gICAgICAgICAgICBpZiAobG8gPT0gaGkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhcnJbbWlkXSAtIHBvcyB8fCAoZW5kID8gdGhpcy52YWx1ZVttaWRdLmVuZFNpZGUgOiB0aGlzLnZhbHVlW21pZF0uc3RhcnRTaWRlKSAtIHNpZGU7XG4gICAgICAgICAgICBpZiAobWlkID09IGxvKVxuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmID49IDAgPyBsbyA6IGhpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPj0gMClcbiAgICAgICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmV0d2VlbihvZmZzZXQsIGZyb20sIHRvLCBmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbmRJbmRleChmcm9tLCAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLywgdHJ1ZSksIGUgPSB0aGlzLmZpbmRJbmRleCh0bywgMTAwMDAwMDAwMCAvKiBDLkZhciAqLywgZmFsc2UsIGkpOyBpIDwgZTsgaSsrKVxuICAgICAgICAgICAgaWYgKGYodGhpcy5mcm9tW2ldICsgb2Zmc2V0LCB0aGlzLnRvW2ldICsgb2Zmc2V0LCB0aGlzLnZhbHVlW2ldKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXAob2Zmc2V0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFtdLCBmcm9tID0gW10sIHRvID0gW10sIG5ld1BvcyA9IC0xLCBtYXhQb2ludCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSB0aGlzLnZhbHVlW2ldLCBjdXJGcm9tID0gdGhpcy5mcm9tW2ldICsgb2Zmc2V0LCBjdXJUbyA9IHRoaXMudG9baV0gKyBvZmZzZXQsIG5ld0Zyb20sIG5ld1RvO1xuICAgICAgICAgICAgaWYgKGN1ckZyb20gPT0gY3VyVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFwcGVkID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSwgdmFsLm1hcE1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IG5ld1RvID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWwuc3RhcnRTaWRlICE9IHZhbC5lbmRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VG8gPCBuZXdGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyVG8sIHZhbC5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RnJvbSA+IG5ld1RvIHx8IG5ld0Zyb20gPT0gbmV3VG8gJiYgdmFsLnN0YXJ0U2lkZSA+IDAgJiYgdmFsLmVuZFNpZGUgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG5ld1RvIC0gbmV3RnJvbSB8fCB2YWwuZW5kU2lkZSAtIHZhbC5zdGFydFNpZGUpIDwgMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZXdQb3MgPCAwKVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IG5ld0Zyb207XG4gICAgICAgICAgICBpZiAodmFsLnBvaW50KVxuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG5ld1RvIC0gbmV3RnJvbSk7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKHZhbCk7XG4gICAgICAgICAgICBmcm9tLnB1c2gobmV3RnJvbSAtIG5ld1Bvcyk7XG4gICAgICAgICAgICB0by5wdXNoKG5ld1RvIC0gbmV3UG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXBwZWQ6IHZhbHVlLmxlbmd0aCA/IG5ldyBDaHVuayhmcm9tLCB0bywgdmFsdWUsIG1heFBvaW50KSA6IG51bGwsIHBvczogbmV3UG9zIH07XG4gICAgfVxufVxuLyoqXG5BIHJhbmdlIHNldCBzdG9yZXMgYSBjb2xsZWN0aW9uIG9mIFtyYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIGluIGFcbndheSB0aGF0IG1ha2VzIHRoZW0gZWZmaWNpZW50IHRvIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQubWFwKSBhbmRcblt1cGRhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQudXBkYXRlKS4gVGhpcyBpcyBhbiBpbW11dGFibGUgZGF0YVxuc3RydWN0dXJlLlxuKi9cbmNsYXNzIFJhbmdlU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rUG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5leHRMYXllciwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXhQb2ludCkge1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gY2h1bmtQb3M7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIgPSBuZXh0TGF5ZXI7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNodW5rUG9zLCBjaHVuaywgbmV4dExheWVyLCBtYXhQb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVuaywgbmV4dExheWVyLCBtYXhQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNodW5rLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBsYXN0IDwgMCA/IDAgOiBNYXRoLm1heCh0aGlzLmNodW5rRW5kKGxhc3QpLCB0aGlzLm5leHRMYXllci5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIHJhbmdlcyBpbiB0aGUgc2V0LlxuICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLm5leHRMYXllci5zaXplO1xuICAgICAgICBmb3IgKGxldCBjaHVuayBvZiB0aGlzLmNodW5rKVxuICAgICAgICAgICAgc2l6ZSArPSBjaHVuay52YWx1ZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rRW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNodW5rUG9zW2luZGV4XSArIHRoaXMuY2h1bmtbaW5kZXhdLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSByYW5nZSBzZXQsIG9wdGlvbmFsbHkgYWRkaW5nIG5ldyByYW5nZXMgb3IgZmlsdGVyaW5nXG4gICAgb3V0IGV4aXN0aW5nIG9uZXMuXG4gICAgXG4gICAgKE5vdGU6IFRoZSB0eXBlIHBhcmFtZXRlciBpcyBqdXN0IHRoZXJlIGFzIGEga2x1ZGdlIHRvIHdvcmtcbiAgICBhcm91bmQgVHlwZVNjcmlwdCB2YXJpYW5jZSBpc3N1ZXMgdGhhdCBwcmV2ZW50ZWQgYFJhbmdlU2V0PFg+YFxuICAgIGZyb20gYmVpbmcgYSBzdWJ0eXBlIG9mIGBSYW5nZVNldDxZPmAgd2hlbiBgWGAgaXMgYSBzdWJ0eXBlIG9mXG4gICAgYFlgLilcbiAgICAqL1xuICAgIHVwZGF0ZSh1cGRhdGVTcGVjKSB7XG4gICAgICAgIGxldCB7IGFkZCA9IFtdLCBzb3J0ID0gZmFsc2UsIGZpbHRlckZyb20gPSAwLCBmaWx0ZXJUbyA9IHRoaXMubGVuZ3RoIH0gPSB1cGRhdGVTcGVjO1xuICAgICAgICBsZXQgZmlsdGVyID0gdXBkYXRlU3BlYy5maWx0ZXI7XG4gICAgICAgIGlmIChhZGQubGVuZ3RoID09IDAgJiYgIWZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoc29ydClcbiAgICAgICAgICAgIGFkZCA9IGFkZC5zbGljZSgpLnNvcnQoY21wUmFuZ2UpO1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGFkZC5sZW5ndGggPyBSYW5nZVNldC5vZihhZGQpIDogdGhpcztcbiAgICAgICAgbGV0IGN1ciA9IG5ldyBMYXllckN1cnNvcih0aGlzLCBudWxsLCAtMSkuZ290bygwKSwgaSA9IDAsIHNwaWxsID0gW107XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICB3aGlsZSAoY3VyLnZhbHVlIHx8IGkgPCBhZGQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGFkZC5sZW5ndGggJiYgKGN1ci5mcm9tIC0gYWRkW2ldLmZyb20gfHwgY3VyLnN0YXJ0U2lkZSAtIGFkZFtpXS52YWx1ZS5zdGFydFNpZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBhZGRbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXIucmFuZ2VJbmRleCA9PSAxICYmIGN1ci5jaHVua0luZGV4IDwgdGhpcy5jaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoaSA9PSBhZGQubGVuZ3RoIHx8IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIDwgYWRkW2ldLmZyb20pICYmXG4gICAgICAgICAgICAgICAgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIHx8IGZpbHRlclRvIDwgdGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0pICYmXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRDaHVuayh0aGlzLmNodW5rUG9zW2N1ci5jaHVua0luZGV4XSwgdGhpcy5jaHVua1tjdXIuY2h1bmtJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY3VyLm5leHRDaHVuaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IGN1ci50byB8fCBmaWx0ZXJUbyA8IGN1ci5mcm9tIHx8IGZpbHRlcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChSYW5nZS5jcmVhdGUoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoSW5uZXIodGhpcy5uZXh0TGF5ZXIuaXNFbXB0eSAmJiAhc3BpbGwubGVuZ3RoID8gUmFuZ2VTZXQuZW1wdHlcbiAgICAgICAgICAgIDogdGhpcy5uZXh0TGF5ZXIudXBkYXRlKHsgYWRkOiBzcGlsbCwgZmlsdGVyLCBmaWx0ZXJGcm9tLCBmaWx0ZXJUbyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHNldCB0aHJvdWdoIGEgc2V0IG9mIGNoYW5nZXMsIHJldHVybiB0aGUgbmV3IHNldC5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmVtcHR5IHx8IHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgY2h1bmtzID0gW10sIGNodW5rUG9zID0gW10sIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgbGV0IHRvdWNoID0gY2hhbmdlcy50b3VjaGVzUmFuZ2Uoc3RhcnQsIHN0YXJ0ICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh0b3VjaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2goY2hhbmdlcy5tYXBQb3Moc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWFwcGVkLCBwb3MgfSA9IGNodW5rLm1hcChzdGFydCwgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBtYXBwZWQubWF4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua1Bvcy5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5uZXh0TGF5ZXIubWFwKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4gY2h1bmtzLmxlbmd0aCA9PSAwID8gbmV4dCA6IG5ldyBSYW5nZVNldChjaHVua1BvcywgY2h1bmtzLCBuZXh0IHx8IFJhbmdlU2V0LmVtcHR5LCBtYXhQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIHRoYXQgdG91Y2ggdGhlIHJlZ2lvbiBgZnJvbWAgdG8gYHRvYCxcbiAgICBjYWxsaW5nIGBmYCBmb3IgZWFjaC4gVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlcyB3aWxsXG4gICAgYmUgcmVwb3J0ZWQgaW4gYW55IHNwZWNpZmljIG9yZGVyLiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAgYGZhbHNlYCwgaXRlcmF0aW9uIHN0b3BzLlxuICAgICovXG4gICAgYmV0d2Vlbihmcm9tLCB0bywgZikge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcbiAgICAgICAgICAgIGlmICh0byA+PSBzdGFydCAmJiBmcm9tIDw9IHN0YXJ0ICsgY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgY2h1bmsuYmV0d2VlbihzdGFydCwgZnJvbSAtIHN0YXJ0LCB0byAtIHN0YXJ0LCBmKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dExheWVyLmJldHdlZW4oZnJvbSwgdG8sIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiB0aGlzIHNldCwgaW4gb3JkZXIsIGluY2x1ZGluZyBhbGxcbiAgICByYW5nZXMgdGhhdCBlbmQgYXQgb3IgYWZ0ZXIgYGZyb21gLlxuICAgICovXG4gICAgaXRlcihmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKFt0aGlzXSkuZ290byhmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaXNFbXB0eSgpIHsgcmV0dXJuIHRoaXMubmV4dExheWVyID09IHRoaXM7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiBhIGNvbGxlY3Rpb24gb2Ygc2V0cywgaW4gb3JkZXIsXG4gICAgc3RhcnRpbmcgZnJvbSBgZnJvbWAuXG4gICAgKi9cbiAgICBzdGF0aWMgaXRlcihzZXRzLCBmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKHNldHMpLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0d28gZ3JvdXBzIG9mIHNldHMsIGNhbGxpbmcgbWV0aG9kcyBvbiBgY29tcGFyYXRvcmBcbiAgICB0byBub3RpZnkgaXQgb2YgcG9zc2libGUgZGlmZmVyZW5jZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZShvbGRTZXRzLCBuZXdTZXRzLCBcbiAgICAvKipcbiAgICBUaGlzIGluZGljYXRlcyBob3cgdGhlIHVuZGVybHlpbmcgZGF0YSBjaGFuZ2VkIGJldHdlZW4gdGhlc2VcbiAgICByYW5nZXMsIGFuZCBpcyBuZWVkZWQgdG8gc3luY2hyb25pemUgdGhlIGl0ZXJhdGlvbi5cbiAgICAqL1xuICAgIHRleHREaWZmLCBjb21wYXJhdG9yLCBcbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBpZ25vcmUgYWxsIG5vbi1wb2ludCByYW5nZXMsIGFuZCBwb2ludHMgYmVsb3dcbiAgICB0aGUgZ2l2ZW4gc2l6ZS4gV2hlbiAtMSwgYWxsIHJhbmdlcyBhcmUgY29tcGFyZWQuXG4gICAgKi9cbiAgICBtaW5Qb2ludFNpemUgPSAtMSkge1xuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID4gMCB8fCAhc2V0LmlzRW1wdHkgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIHRleHREaWZmLml0ZXJHYXBzKChmcm9tQSwgZnJvbUIsIGxlbmd0aCkgPT4gY29tcGFyZShzaWRlQSwgZnJvbUEsIHNpZGVCLCBmcm9tQiwgbGVuZ3RoLCBjb21wYXJhdG9yKSk7XG4gICAgICAgIGlmICh0ZXh0RGlmZi5lbXB0eSAmJiB0ZXh0RGlmZi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGNvbXBhcmUoc2lkZUEsIDAsIHNpZGVCLCAwLCAwLCBjb21wYXJhdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgY29udGVudHMgb2YgdHdvIGdyb3VwcyBvZiByYW5nZSBzZXRzLCByZXR1cm5pbmcgdHJ1ZVxuICAgIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQgaW4gdGhlIGdpdmVuIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIGVxKG9sZFNldHMsIG5ld1NldHMsIGZyb20gPSAwLCB0bykge1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLyAtIDE7XG4gICAgICAgIGxldCBhID0gb2xkU2V0cy5maWx0ZXIoc2V0ID0+ICFzZXQuaXNFbXB0eSAmJiBuZXdTZXRzLmluZGV4T2Yoc2V0KSA8IDApO1xuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiAhc2V0LmlzRW1wdHkgJiYgb2xkU2V0cy5pbmRleE9mKHNldCkgPCAwKTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWEubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIpO1xuICAgICAgICBsZXQgc2lkZUEgPSBuZXcgU3BhbkN1cnNvcihhLCBzaGFyZWRDaHVua3MsIDApLmdvdG8oZnJvbSksIHNpZGVCID0gbmV3IFNwYW5DdXJzb3IoYiwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoc2lkZUEudG8gIT0gc2lkZUIudG8gfHxcbiAgICAgICAgICAgICAgICAhc2FtZVZhbHVlcyhzaWRlQS5hY3RpdmUsIHNpZGVCLmFjdGl2ZSkgfHxcbiAgICAgICAgICAgICAgICBzaWRlQS5wb2ludCAmJiAoIXNpZGVCLnBvaW50IHx8ICFzaWRlQS5wb2ludC5lcShzaWRlQi5wb2ludCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc2lkZUEubmV4dCgpO1xuICAgICAgICAgICAgc2lkZUIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciBhIGdyb3VwIG9mIHJhbmdlIHNldHMgYXQgdGhlIHNhbWUgdGltZSwgbm90aWZ5aW5nXG4gICAgdGhlIGl0ZXJhdG9yIGFib3V0IHRoZSByYW5nZXMgY292ZXJpbmcgZXZlcnkgZ2l2ZW4gcGllY2Ugb2ZcbiAgICBjb250ZW50LiBSZXR1cm5zIHRoZSBvcGVuIGNvdW50IChzZWVcbiAgICBbYFNwYW5JdGVyYXRvci5zcGFuYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TcGFuSXRlcmF0b3Iuc3BhbikpIGF0IHRoZSBlbmRcbiAgICBvZiB0aGUgaXRlcmF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHNwYW5zKHNldHMsIGZyb20sIHRvLCBpdGVyYXRvciwgXG4gICAgLyoqXG4gICAgV2hlbiBnaXZlbiBhbmQgZ3JlYXRlciB0aGFuIC0xLCBvbmx5IHBvaW50cyBvZiBhdCBsZWFzdCB0aGlzXG4gICAgc2l6ZSBhcmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTcGFuQ3Vyc29yKHNldHMsIG51bGwsIG1pblBvaW50U2l6ZSkuZ290byhmcm9tKSwgcG9zID0gZnJvbTtcbiAgICAgICAgbGV0IG9wZW5SYW5nZXMgPSBjdXJzb3Iub3BlblN0YXJ0O1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgY3VyVG8gPSBNYXRoLm1pbihjdXJzb3IudG8sIHRvKTtcbiAgICAgICAgICAgIGlmIChjdXJzb3IucG9pbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gY3Vyc29yLmFjdGl2ZUZvclBvaW50KGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgbGV0IG9wZW5Db3VudCA9IGN1cnNvci5wb2ludEZyb20gPCBmcm9tID8gYWN0aXZlLmxlbmd0aCArIDFcbiAgICAgICAgICAgICAgICAgICAgOiBjdXJzb3IucG9pbnQuc3RhcnRTaWRlIDwgMCA/IGFjdGl2ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4oYWN0aXZlLmxlbmd0aCwgb3BlblJhbmdlcyk7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IucG9pbnQocG9zLCBjdXJUbywgY3Vyc29yLnBvaW50LCBhY3RpdmUsIG9wZW5Db3VudCwgY3Vyc29yLnBvaW50UmFuayk7XG4gICAgICAgICAgICAgICAgb3BlblJhbmdlcyA9IE1hdGgubWluKGN1cnNvci5vcGVuRW5kKGN1clRvKSwgYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJUbyA+IHBvcykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnNwYW4ocG9zLCBjdXJUbywgY3Vyc29yLmFjdGl2ZSwgb3BlblJhbmdlcyk7XG4gICAgICAgICAgICAgICAgb3BlblJhbmdlcyA9IGN1cnNvci5vcGVuRW5kKGN1clRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlblJhbmdlcyArIChjdXJzb3IucG9pbnQgJiYgY3Vyc29yLnRvID4gdG8gPyAxIDogMCk7XG4gICAgICAgICAgICBwb3MgPSBjdXJzb3IudG87XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlIHNldCBmb3IgdGhlIGdpdmVuIHJhbmdlIG9yIGFycmF5IG9mIHJhbmdlcy4gQnlcbiAgICBkZWZhdWx0LCB0aGlzIGV4cGVjdHMgdGhlIHJhbmdlcyB0byBiZSBfc29ydGVkXyAoYnkgc3RhcnRcbiAgICBwb3NpdGlvbiBhbmQsIGlmIHR3byBzdGFydCBhdCB0aGUgc2FtZSBwb3NpdGlvbixcbiAgICBgdmFsdWUuc3RhcnRTaWRlYCkuIFlvdSBjYW4gcGFzcyBgdHJ1ZWAgYXMgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgY2F1c2UgdGhlIG1ldGhvZCB0byBzb3J0IHRoZW0uXG4gICAgKi9cbiAgICBzdGF0aWMgb2YocmFuZ2VzLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiByYW5nZXMgaW5zdGFuY2VvZiBSYW5nZSA/IFtyYW5nZXNdIDogc29ydCA/IGxhenlTb3J0KHJhbmdlcykgOiByYW5nZXMpXG4gICAgICAgICAgICBidWlsZC5hZGQocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBKb2luIGFuIGFycmF5IG9mIHJhbmdlIHNldHMgaW50byBhIHNpbmdsZSBzZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgam9pbihzZXRzKSB7XG4gICAgICAgIGlmICghc2V0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gUmFuZ2VTZXQuZW1wdHk7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXRzW3NldHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAobGV0IGkgPSBzZXRzLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBsYXllciA9IHNldHNbaV07IGxheWVyICE9IFJhbmdlU2V0LmVtcHR5OyBsYXllciA9IGxheWVyLm5leHRMYXllcilcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgUmFuZ2VTZXQobGF5ZXIuY2h1bmtQb3MsIGxheWVyLmNodW5rLCByZXN1bHQsIE1hdGgubWF4KGxheWVyLm1heFBvaW50LCByZXN1bHQubWF4UG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiByYW5nZXMuXG4qL1xuUmFuZ2VTZXQuZW1wdHkgPSBuZXcgUmFuZ2VTZXQoW10sIFtdLCBudWxsLCAtMSk7XG5mdW5jdGlvbiBsYXp5U29ydChyYW5nZXMpIHtcbiAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIGZvciAobGV0IHByZXYgPSByYW5nZXNbMF0sIGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNtcFJhbmdlKHByZXYsIGN1cikgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXMuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuUmFuZ2VTZXQuZW1wdHkubmV4dExheWVyID0gUmFuZ2VTZXQuZW1wdHk7XG4vKipcbkEgcmFuZ2Ugc2V0IGJ1aWxkZXIgaXMgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGhlbHBzIGJ1aWxkIHVwIGFcbltyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGRpcmVjdGx5LCB3aXRob3V0IGZpcnN0IGFsbG9jYXRpbmdcbmFuIGFycmF5IG9mIFtgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBvYmplY3RzLlxuKi9cbmNsYXNzIFJhbmdlU2V0QnVpbGRlciB7XG4gICAgZmluaXNoQ2h1bmsobmV3QXJyYXlzKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IENodW5rKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy52YWx1ZSwgdGhpcy5tYXhQb2ludCkpO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCB0aGlzLm1heFBvaW50KTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICBpZiAobmV3QXJyYXlzKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudG8gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgYnVpbGRlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMubGFzdFRvID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMuZnJvbSA9IFtdO1xuICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgcmFuZ2UuIFJhbmdlcyBzaG91bGQgYmUgYWRkZWQgaW4gc29ydGVkIChieSBgZnJvbWAgYW5kXG4gICAgYHZhbHVlLnN0YXJ0U2lkZWApIG9yZGVyLlxuICAgICovXG4gICAgYWRkKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSlcbiAgICAgICAgICAgICh0aGlzLm5leHRMYXllciB8fCAodGhpcy5uZXh0TGF5ZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKSkuYWRkKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gZnJvbSAtIHRoaXMubGFzdFRvIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlO1xuICAgICAgICBpZiAoZGlmZiA8PSAwICYmIChmcm9tIC0gdGhpcy5sYXN0RnJvbSB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3Quc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZXMgbXVzdCBiZSBhZGRlZCBzb3J0ZWQgYnkgYGZyb21gIHBvc2l0aW9uIGFuZCBgc3RhcnRTaWRlYFwiKTtcbiAgICAgICAgaWYgKGRpZmYgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aCA9PSAyNTAgLyogQy5DaHVua1NpemUgKi8pXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMuZnJvbS5wdXNoKGZyb20gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLnRvLnB1c2godG8gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmxhc3QgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZS5wb2ludClcbiAgICAgICAgICAgIHRoaXMubWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLm1heFBvaW50LCB0byAtIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRDaHVuayhmcm9tLCBjaHVuaykge1xuICAgICAgICBpZiAoKGZyb20gLSB0aGlzLmxhc3RUbyB8fCBjaHVuay52YWx1ZVswXS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZSkgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2goZnJvbSk7XG4gICAgICAgIGxldCBsYXN0ID0gY2h1bmsudmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gY2h1bmsudmFsdWVbbGFzdF07XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBjaHVuay5mcm9tW2xhc3RdICsgZnJvbTtcbiAgICAgICAgdGhpcy5sYXN0VG8gPSBjaHVuay50b1tsYXN0XSArIGZyb207XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5pc2ggdGhlIHJhbmdlIHNldC4gUmV0dXJucyB0aGUgbmV3IHNldC4gVGhlIGJ1aWxkZXIgY2FuJ3QgYmVcbiAgICB1c2VkIGFueW1vcmUgYWZ0ZXIgdGhpcyBoYXMgYmVlbiBjYWxsZWQuXG4gICAgKi9cbiAgICBmaW5pc2goKSB7IHJldHVybiB0aGlzLmZpbmlzaElubmVyKFJhbmdlU2V0LmVtcHR5KTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluaXNoSW5uZXIobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJhbmdlU2V0LmNyZWF0ZSh0aGlzLmNodW5rUG9zLCB0aGlzLmNodW5rcywgdGhpcy5uZXh0TGF5ZXIgPyB0aGlzLm5leHRMYXllci5maW5pc2hJbm5lcihuZXh0KSA6IG5leHQsIHRoaXMuc2V0TWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmZyb20gPSBudWxsOyAvLyBNYWtlIHN1cmUgZnVydGhlciBgYWRkYCBjYWxscyBwcm9kdWNlIGVycm9yc1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpIHtcbiAgICBsZXQgaW5BID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBhKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXQuY2h1bmtbaV0ubWF4UG9pbnQgPD0gMClcbiAgICAgICAgICAgICAgICBpbkEuc2V0KHNldC5jaHVua1tpXSwgc2V0LmNodW5rUG9zW2ldKTtcbiAgICBsZXQgc2hhcmVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBiKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGtub3duID0gaW5BLmdldChzZXQuY2h1bmtbaV0pO1xuICAgICAgICAgICAgaWYgKGtub3duICE9IG51bGwgJiYgKHRleHREaWZmID8gdGV4dERpZmYubWFwUG9zKGtub3duKSA6IGtub3duKSA9PSBzZXQuY2h1bmtQb3NbaV0gJiZcbiAgICAgICAgICAgICAgICAhKHRleHREaWZmID09PSBudWxsIHx8IHRleHREaWZmID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0RGlmZi50b3VjaGVzUmFuZ2Uoa25vd24sIGtub3duICsgc2V0LmNodW5rW2ldLmxlbmd0aCkpKVxuICAgICAgICAgICAgICAgIHNoYXJlZC5hZGQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBzaGFyZWQ7XG59XG5jbGFzcyBMYXllckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IobGF5ZXIsIHNraXAsIG1pblBvaW50LCByYW5rID0gMCkge1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gICAgICAgIHRoaXMubWluUG9pbnQgPSBtaW5Qb2ludDtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnZXQgZW5kU2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmVuZFNpZGUgOiAwOyB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXggPSB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdvdG9Jbm5lcihwb3MsIHNpZGUsIGZvcndhcmQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuc2tpcCAmJiB0aGlzLnNraXAuaGFzKG5leHQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sYXllci5jaHVua0VuZCh0aGlzLmNodW5rSW5kZXgpIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgbmV4dC5tYXhQb2ludCA8IHRoaXMubWluUG9pbnQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBmb3J3YXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VJbmRleCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS5maW5kSW5kZXgocG9zIC0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBzaWRlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghZm9yd2FyZCB8fCB0aGlzLnJhbmdlSW5kZXggPCByYW5nZUluZGV4KVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleChyYW5nZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMuZ290b0lubmVyKHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPT0gdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjaHVua1BvcyA9IHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgY2h1bmsgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaHVua1BvcyArIGNodW5rLmZyb21bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSBjaHVua1BvcyArIGNodW5rLnRvW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNodW5rLnZhbHVlW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHRoaXMucmFuZ2VJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pblBvaW50IDwgMCB8fCB0aGlzLnZhbHVlLnBvaW50ICYmIHRoaXMudG8gLSB0aGlzLmZyb20gPj0gdGhpcy5taW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UmFuZ2VJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoICYmIHRoaXMuc2tpcC5oYXModGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dENodW5rKCkge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbSAtIG90aGVyLmZyb20gfHwgdGhpcy5zdGFydFNpZGUgLSBvdGhlci5zdGFydFNpZGUgfHwgdGhpcy5yYW5rIC0gb3RoZXIucmFuayB8fFxuICAgICAgICAgICAgdGhpcy50byAtIG90aGVyLnRvIHx8IHRoaXMuZW5kU2lkZSAtIG90aGVyLmVuZFNpZGU7XG4gICAgfVxufVxuY2xhc3MgSGVhcEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaGVhcCkge1xuICAgICAgICB0aGlzLmhlYXAgPSBoZWFwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzZXRzLCBza2lwID0gbnVsbCwgbWluUG9pbnQgPSAtMSkge1xuICAgICAgICBsZXQgaGVhcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IHNldHNbaV07ICFjdXIuaXNFbXB0eTsgY3VyID0gY3VyLm5leHRMYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIubWF4UG9pbnQgPj0gbWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGhlYXAucHVzaChuZXcgTGF5ZXJDdXJzb3IoY3VyLCBza2lwLCBtaW5Qb2ludCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwLmxlbmd0aCA9PSAxID8gaGVhcFswXSA6IG5ldyBIZWFwQ3Vyc29yKGhlYXApO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgY3VyIG9mIHRoaXMuaGVhcClcbiAgICAgICAgICAgIGN1ci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIGkpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZm9yd2FyZChwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMudmFsdWUuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5oZWFwLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5oZWFwWzBdO1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdG9wLmZyb207XG4gICAgICAgICAgICB0aGlzLnRvID0gdG9wLnRvO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRvcC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IHRvcC5yYW5rO1xuICAgICAgICAgICAgaWYgKHRvcC52YWx1ZSlcbiAgICAgICAgICAgICAgICB0b3AubmV4dCgpO1xuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGVhcEJ1YmJsZShoZWFwLCBpbmRleCkge1xuICAgIGZvciAobGV0IGN1ciA9IGhlYXBbaW5kZXhdOzspIHtcbiAgICAgICAgbGV0IGNoaWxkSW5kZXggPSAoaW5kZXggPDwgMSkgKyAxO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCA+PSBoZWFwLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCArIDEgPCBoZWFwLmxlbmd0aCAmJiBjaGlsZC5jb21wYXJlKGhlYXBbY2hpbGRJbmRleCArIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleCArIDFdO1xuICAgICAgICAgICAgY2hpbGRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIuY29tcGFyZShjaGlsZCkgPCAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGhlYXBbY2hpbGRJbmRleF0gPSBjdXI7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gY2hpbGQ7XG4gICAgICAgIGluZGV4ID0gY2hpbGRJbmRleDtcbiAgICB9XG59XG5jbGFzcyBTcGFuQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzZXRzLCBza2lwLCBtaW5Qb2ludCkge1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlVG8gPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVSYW5rID0gW107XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIC8vIEEgY3VycmVudGx5IGFjdGl2ZSBwb2ludCByYW5nZSwgaWYgYW55XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50RnJvbSA9IDA7XG4gICAgICAgIHRoaXMucG9pbnRSYW5rID0gMDtcbiAgICAgICAgdGhpcy50byA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSAwO1xuICAgICAgICAvLyBUaGUgYW1vdW50IG9mIG9wZW4gYWN0aXZlIHJhbmdlcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAvLyBOb3QgaW5jbHVkaW5nIHBvaW50cy5cbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBIZWFwQ3Vyc29yLmZyb20oc2V0cywgc2tpcCwgbWluUG9pbnQpO1xuICAgIH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yLmdvdG8ocG9zLCBzaWRlKTtcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gdGhpcy5hY3RpdmVUby5sZW5ndGggPSB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgdGhpcy50byA9IHBvcztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gc2lkZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5taW5BY3RpdmUgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1t0aGlzLm1pbkFjdGl2ZV0gLSBwb3MgfHwgdGhpcy5hY3RpdmVbdGhpcy5taW5BY3RpdmVdLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZSh0aGlzLm1pbkFjdGl2ZSk7XG4gICAgICAgIHRoaXMuY3Vyc29yLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgcmVtb3ZlQWN0aXZlKGluZGV4KSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZSwgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVUbywgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVSYW5rLCBpbmRleCk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgYWRkQWN0aXZlKHRyYWNrT3Blbikge1xuICAgICAgICBsZXQgaSA9IDAsIHsgdmFsdWUsIHRvLCByYW5rIH0gPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgLy8gT3JnYW5pemUgYWN0aXZlIG1hcmtzIGJ5IHJhbmsgZmlyc3QsIHRoZW4gYnkgc2l6ZVxuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuYWN0aXZlUmFuay5sZW5ndGggJiYgKHJhbmsgLSB0aGlzLmFjdGl2ZVJhbmtbaV0gfHwgdG8gLSB0aGlzLmFjdGl2ZVRvW2ldKSA+IDApXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZSwgaSwgdmFsdWUpO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmVUbywgaSwgdG8pO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmVSYW5rLCBpLCByYW5rKTtcbiAgICAgICAgaWYgKHRyYWNrT3BlbilcbiAgICAgICAgICAgIGluc2VydCh0cmFja09wZW4sIGksIHRoaXMuY3Vyc29yLmZyb20pO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IGZpbmRNaW5JbmRleCh0aGlzLmFjdGl2ZSwgdGhpcy5hY3RpdmVUbyk7XG4gICAgfVxuICAgIC8vIEFmdGVyIGNhbGxpbmcgdGhpcywgaWYgYHRoaXMucG9pbnRgICE9IG51bGwsIHRoZSBuZXh0IHJhbmdlIGlzIGFcbiAgICAvLyBwb2ludC4gT3RoZXJ3aXNlLCBpdCdzIGEgcmVndWxhciByYW5nZSwgY292ZXJlZCBieSBgdGhpcy5hY3RpdmVgLlxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy50bywgd2FzUG9pbnQgPSB0aGlzLnBvaW50O1xuICAgICAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICAgICAgbGV0IHRyYWNrT3BlbiA9IHRoaXMub3BlblN0YXJ0IDwgMCA/IFtdIDogbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGEgPSB0aGlzLm1pbkFjdGl2ZTtcbiAgICAgICAgICAgIGlmIChhID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bYV0gLSB0aGlzLmN1cnNvci5mcm9tIHx8IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGUgLSB0aGlzLmN1cnNvci5zdGFydFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRvW2FdID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5hY3RpdmVUb1thXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5hY3RpdmVbYV0uZW5kU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKGEpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSh0cmFja09wZW4sIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY3Vyc29yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuZW5kU2lkZSA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnNvci5mcm9tID4gZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci5mcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IHRoaXMuY3Vyc29yLnN0YXJ0U2lkZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0VmFsID0gdGhpcy5jdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0VmFsLnBvaW50KSB7IC8vIE9wZW5pbmcgYSByYW5nZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEFjdGl2ZSh0cmFja09wZW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc1BvaW50ICYmIHRoaXMuY3Vyc29yLnRvID09IHRoaXMudG8gJiYgdGhpcy5jdXJzb3IuZnJvbSA8IHRoaXMuY3Vyc29yLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgbm9uLWVtcHR5IHBvaW50cyB0aGF0IGVuZCBwcmVjaXNlbHkgYXQgdGhlIGVuZCBvZiB0aGUgcHJldiBwb2ludFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBOZXcgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCA9IG5leHRWYWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRGcm9tID0gdGhpcy5jdXJzb3IuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludFJhbmsgPSB0aGlzLmN1cnNvci5yYW5rO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IudG87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IG5leHRWYWwuZW5kU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmQodGhpcy50bywgdGhpcy5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0cmFja09wZW4ubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHRyYWNrT3BlbltpXSA8IGZyb207IGktLSlcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5TdGFydCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGl2ZUZvclBvaW50KHRvKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgYWN0aXZlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlUmFua1tpXSA8IHRoaXMucG9pbnRSYW5rKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9baV0gPiB0byB8fCB0aGlzLmFjdGl2ZVRvW2ldID09IHRvICYmIHRoaXMuYWN0aXZlW2ldLmVuZFNpZGUgPj0gdGhpcy5wb2ludC5lbmRTaWRlKVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHRoaXMuYWN0aXZlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgb3BlbkVuZCh0bykge1xuICAgICAgICBsZXQgb3BlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZVRvLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiB0aGlzLmFjdGl2ZVRvW2ldID4gdG87IGktLSlcbiAgICAgICAgICAgIG9wZW4rKztcbiAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZShhLCBzdGFydEEsIGIsIHN0YXJ0QiwgbGVuZ3RoLCBjb21wYXJhdG9yKSB7XG4gICAgYS5nb3RvKHN0YXJ0QSk7XG4gICAgYi5nb3RvKHN0YXJ0Qik7XG4gICAgbGV0IGVuZEIgPSBzdGFydEIgKyBsZW5ndGg7XG4gICAgbGV0IHBvcyA9IHN0YXJ0QiwgZFBvcyA9IHN0YXJ0QiAtIHN0YXJ0QTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBkaWZmID0gKGEudG8gKyBkUG9zKSAtIGIudG8gfHwgYS5lbmRTaWRlIC0gYi5lbmRTaWRlO1xuICAgICAgICBsZXQgZW5kID0gZGlmZiA8IDAgPyBhLnRvICsgZFBvcyA6IGIudG8sIGNsaXBFbmQgPSBNYXRoLm1pbihlbmQsIGVuZEIpO1xuICAgICAgICBpZiAoYS5wb2ludCB8fCBiLnBvaW50KSB7XG4gICAgICAgICAgICBpZiAoIShhLnBvaW50ICYmIGIucG9pbnQgJiYgKGEucG9pbnQgPT0gYi5wb2ludCB8fCBhLnBvaW50LmVxKGIucG9pbnQpKSAmJlxuICAgICAgICAgICAgICAgIHNhbWVWYWx1ZXMoYS5hY3RpdmVGb3JQb2ludChhLnRvKSwgYi5hY3RpdmVGb3JQb2ludChiLnRvKSkpKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZVBvaW50KHBvcywgY2xpcEVuZCwgYS5wb2ludCwgYi5wb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2xpcEVuZCA+IHBvcyAmJiAhc2FtZVZhbHVlcyhhLmFjdGl2ZSwgYi5hY3RpdmUpKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZVJhbmdlKHBvcywgY2xpcEVuZCwgYS5hY3RpdmUsIGIuYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID4gZW5kQilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIGlmIChkaWZmIDw9IDApXG4gICAgICAgICAgICBhLm5leHQoKTtcbiAgICAgICAgaWYgKGRpZmYgPj0gMClcbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVWYWx1ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGFbaV0gIT0gYltpXSAmJiAhYVtpXS5lcShiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShhcnJheSwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBpID0gaW5kZXgsIGUgPSBhcnJheS5sZW5ndGggLSAxOyBpIDwgZTsgaSsrKVxuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgKyAxXTtcbiAgICBhcnJheS5wb3AoKTtcbn1cbmZ1bmN0aW9uIGluc2VydChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gaW5kZXg7IGktLSlcbiAgICAgICAgYXJyYXlbaSArIDFdID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG59XG5mdW5jdGlvbiBmaW5kTWluSW5kZXgodmFsdWUsIGFycmF5KSB7XG4gICAgbGV0IGZvdW5kID0gLTEsIGZvdW5kUG9zID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoKGFycmF5W2ldIC0gZm91bmRQb3MgfHwgdmFsdWVbaV0uZW5kU2lkZSAtIHZhbHVlW2ZvdW5kXS5lbmRTaWRlKSA8IDApIHtcbiAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgIGZvdW5kUG9zID0gYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbi8qKlxuQ291bnQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGludG8gdGhlIHN0cmluZyxcbnRha2luZyBleHRlbmRpbmcgY2hhcmFjdGVycyBhbmQgdGFiIHNpemUgaW50byBhY2NvdW50LlxuKi9cbmZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgdGFiU2l6ZSwgdG8gPSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG87KSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KSB7XG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgaSA9IGZpbmRDbHVzdGVyQnJlYWsoc3RyaW5nLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRmluZCB0aGUgb2Zmc2V0IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGNvbHVtbiBwb3NpdGlvbiBpbiBhXG5zdHJpbmcsIHRha2luZyBleHRlbmRpbmcgY2hhcmFjdGVycyBhbmQgdGFiIHNpemUgaW50byBhY2NvdW50LiBCeVxuZGVmYXVsdCwgdGhlIHN0cmluZyBsZW5ndGggaXMgcmV0dXJuZWQgd2hlbiBpdCBpcyB0b28gc2hvcnQgdG9cbnJlYWNoIHRoZSBjb2x1bW4uIFBhc3MgYHN0cmljdGAgdHJ1ZSB0byBtYWtlIGl0IHJldHVybiAtMSBpbiB0aGF0XG5zaXR1YXRpb24uXG4qL1xuZnVuY3Rpb24gZmluZENvbHVtbihzdHJpbmcsIGNvbCwgdGFiU2l6ZSwgc3RyaWN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSAwOzspIHtcbiAgICAgICAgaWYgKG4gPj0gY29sKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIGlmIChpID09IHN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbiArPSBzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5ID8gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSkgOiAxO1xuICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaWN0ID09PSB0cnVlID8gLTEgOiBzdHJpbmcubGVuZ3RoO1xufVxuXG5leHBvcnRzLkFubm90YXRpb24gPSBBbm5vdGF0aW9uO1xuZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZSA9IEFubm90YXRpb25UeXBlO1xuZXhwb3J0cy5DaGFuZ2VEZXNjID0gQ2hhbmdlRGVzYztcbmV4cG9ydHMuQ2hhbmdlU2V0ID0gQ2hhbmdlU2V0O1xuZXhwb3J0cy5Db21wYXJ0bWVudCA9IENvbXBhcnRtZW50O1xuZXhwb3J0cy5FZGl0b3JTZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb247XG5leHBvcnRzLkVkaXRvclN0YXRlID0gRWRpdG9yU3RhdGU7XG5leHBvcnRzLkZhY2V0ID0gRmFjZXQ7XG5leHBvcnRzLkxpbmUgPSBMaW5lO1xuZXhwb3J0cy5QcmVjID0gUHJlYztcbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmV4cG9ydHMuUmFuZ2VTZXQgPSBSYW5nZVNldDtcbmV4cG9ydHMuUmFuZ2VTZXRCdWlsZGVyID0gUmFuZ2VTZXRCdWlsZGVyO1xuZXhwb3J0cy5SYW5nZVZhbHVlID0gUmFuZ2VWYWx1ZTtcbmV4cG9ydHMuU2VsZWN0aW9uUmFuZ2UgPSBTZWxlY3Rpb25SYW5nZTtcbmV4cG9ydHMuU3RhdGVFZmZlY3QgPSBTdGF0ZUVmZmVjdDtcbmV4cG9ydHMuU3RhdGVFZmZlY3RUeXBlID0gU3RhdGVFZmZlY3RUeXBlO1xuZXhwb3J0cy5TdGF0ZUZpZWxkID0gU3RhdGVGaWVsZDtcbmV4cG9ydHMuVGV4dCA9IFRleHQ7XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG5leHBvcnRzLmNvZGVQb2ludEF0ID0gY29kZVBvaW50QXQ7XG5leHBvcnRzLmNvZGVQb2ludFNpemUgPSBjb2RlUG9pbnRTaXplO1xuZXhwb3J0cy5jb21iaW5lQ29uZmlnID0gY29tYmluZUNvbmZpZztcbmV4cG9ydHMuY291bnRDb2x1bW4gPSBjb3VudENvbHVtbjtcbmV4cG9ydHMuZmluZENsdXN0ZXJCcmVhayA9IGZpbmRDbHVzdGVyQnJlYWs7XG5leHBvcnRzLmZpbmRDb2x1bW4gPSBmaW5kQ29sdW1uO1xuZXhwb3J0cy5mcm9tQ29kZVBvaW50ID0gZnJvbUNvZGVQb2ludDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0YXRlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3Ivc3RhdGUnKTtcbnZhciBzdHlsZU1vZCA9IHJlcXVpcmUoJ3N0eWxlLW1vZCcpO1xudmFyIHczY0tleW5hbWUgPSByZXF1aXJlKCd3M2Mta2V5bmFtZScpO1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24ocm9vdCkge1xuICAgIGxldCB0YXJnZXQ7XG4gICAgLy8gQnJvd3NlcnMgZGlmZmVyIG9uIHdoZXRoZXIgc2hhZG93IHJvb3RzIGhhdmUgYSBnZXRTZWxlY3Rpb25cbiAgICAvLyBtZXRob2QuIElmIGl0IGV4aXN0cywgdXNlIHRoYXQsIG90aGVyd2lzZSwgY2FsbCBpdCBvbiB0aGVcbiAgICAvLyBkb2N1bWVudC5cbiAgICBpZiAocm9vdC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICB0YXJnZXQgPSByb290LmdldFNlbGVjdGlvbiA/IHJvb3QgOiByb290Lm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSByb290O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LmdldFNlbGVjdGlvbigpO1xufVxuZnVuY3Rpb24gY29udGFpbnMoZG9tLCBub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgPyBkb20gPT0gbm9kZSB8fCBkb20uY29udGFpbnMobm9kZS5ub2RlVHlwZSAhPSAxID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbihkb20sIHNlbGVjdGlvbikge1xuICAgIGlmICghc2VsZWN0aW9uLmFuY2hvck5vZGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAgICAgLy8gcHJvcGVydGllcyBvZiBgc2VsLmFuY2hvck5vZGVgIHdoZW4gaXQncyBpbiBhIGdlbmVyYXRlZCBDU1NcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGRvbSwgc2VsZWN0aW9uLmFuY2hvck5vZGUpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xpZW50UmVjdHNGb3IoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gdGV4dFJhbmdlKGRvbSwgMCwgZG9tLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpXG4gICAgICAgIHJldHVybiBkb20uZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBbXTtcbn1cbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmZ1bmN0aW9uIGlzRXF1aXZhbGVudFBvc2l0aW9uKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgPyAoc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgLTEpIHx8XG4gICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZG9tSW5kZXgobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNCbG9ja0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDEgJiYgL14oRElWfFB8TEl8VUx8T0x8QkxPQ0tRVU9URXxERHxEVHxIXFxkfFNFQ1RJT058UFJFKSQvLnRlc3Qobm9kZS5ub2RlTmFtZSk7XG59XG5mdW5jdGlvbiBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCBkaXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG1heE9mZnNldChub2RlKSkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZGlyIDwgMCA/IG1heE9mZnNldChub2RlKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXhPZmZzZXQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gZmxhdHRlblJlY3QocmVjdCwgbGVmdCkge1xuICAgIGxldCB4ID0gbGVmdCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gICAgcmV0dXJuIHsgbGVmdDogeCwgcmlnaHQ6IHgsIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC5ib3R0b20gfTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1JlY3Qod2luKSB7XG4gICAgbGV0IHZwID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICAgIGlmICh2cClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IDAsIHJpZ2h0OiB2cC53aWR0aCxcbiAgICAgICAgICAgIHRvcDogMCwgYm90dG9tOiB2cC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogd2luLmlubmVyV2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIGdldFNjYWxlKGVsdCwgcmVjdCkge1xuICAgIGxldCBzY2FsZVggPSByZWN0LndpZHRoIC8gZWx0Lm9mZnNldFdpZHRoO1xuICAgIGxldCBzY2FsZVkgPSByZWN0LmhlaWdodCAvIGVsdC5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKHNjYWxlWCA+IDAuOTk1ICYmIHNjYWxlWCA8IDEuMDA1IHx8ICFpc0Zpbml0ZShzY2FsZVgpIHx8IE1hdGguYWJzKHJlY3Qud2lkdGggLSBlbHQub2Zmc2V0V2lkdGgpIDwgMSlcbiAgICAgICAgc2NhbGVYID0gMTtcbiAgICBpZiAoc2NhbGVZID4gMC45OTUgJiYgc2NhbGVZIDwgMS4wMDUgfHwgIWlzRmluaXRlKHNjYWxlWSkgfHwgTWF0aC5hYnMocmVjdC5oZWlnaHQgLSBlbHQub2Zmc2V0SGVpZ2h0KSA8IDEpXG4gICAgICAgIHNjYWxlWSA9IDE7XG4gICAgcmV0dXJuIHsgc2NhbGVYLCBzY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyhkb20sIHJlY3QsIHNpZGUsIHgsIHksIHhNYXJnaW4sIHlNYXJnaW4sIGx0cikge1xuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudCwgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICBmb3IgKGxldCBjdXIgPSBkb20sIHN0b3AgPSBmYWxzZTsgY3VyICYmICFzdG9wOykge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHsgLy8gRWxlbWVudFxuICAgICAgICAgICAgbGV0IGJvdW5kaW5nLCB0b3AgPSBjdXIgPT0gZG9jLmJvZHk7XG4gICAgICAgICAgICBsZXQgc2NhbGVYID0gMSwgc2NhbGVZID0gMTtcbiAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHdpbmRvd1JlY3Qod2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgvXihmaXhlZHxzdGlja3kpJC8udGVzdChnZXRDb21wdXRlZFN0eWxlKGN1cikucG9zaXRpb24pKVxuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLnNjcm9sbEhlaWdodCA8PSBjdXIuY2xpZW50SGVpZ2h0ICYmIGN1ci5zY3JvbGxXaWR0aCA8PSBjdXIuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gY3VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICh7IHNjYWxlWCwgc2NhbGVZIH0gPSBnZXRTY2FsZShjdXIsIHJlY3QpKTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0ICsgY3VyLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgY3VyLmNsaWVudEhlaWdodCAqIHNjYWxlWSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vdmVYID0gMCwgbW92ZVkgPSAwO1xuICAgICAgICAgICAgaWYgKHkgPT0gXCJuZWFyZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCAtIHJlY3QudG9wICsgeU1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID4gMCAmJiByZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSArIG1vdmVZKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIG1vdmVZICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCAmJiAocmVjdC50b3AgLSBtb3ZlWSkgPCBib3VuZGluZy50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wICsgbW92ZVkgLSByZWN0LnRvcCArIHlNYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCByZWN0SGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcCwgYm91bmRpbmdIZWlnaHQgPSBib3VuZGluZy5ib3R0b20gLSBib3VuZGluZy50b3A7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFRvcCA9IHkgPT0gXCJjZW50ZXJcIiAmJiByZWN0SGVpZ2h0IDw9IGJvdW5kaW5nSGVpZ2h0ID8gcmVjdC50b3AgKyByZWN0SGVpZ2h0IC8gMiAtIGJvdW5kaW5nSGVpZ2h0IC8gMiA6XG4gICAgICAgICAgICAgICAgICAgIHkgPT0gXCJzdGFydFwiIHx8IHkgPT0gXCJjZW50ZXJcIiAmJiBzaWRlIDwgMCA/IHJlY3QudG9wIC0geU1hcmdpbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LmJvdHRvbSAtIGJvdW5kaW5nSGVpZ2h0ICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICBtb3ZlWSA9IHRhcmdldFRvcCAtIGJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID09IFwibmVhcmVzdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgLSByZWN0LmxlZnQgKyB4TWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPiAwICYmIHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCArIG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyBtb3ZlWCArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCAmJiByZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgbW92ZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCArIG1vdmVYIC0gcmVjdC5sZWZ0ICsgeE1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldExlZnQgPSB4ID09IFwiY2VudGVyXCIgPyByZWN0LmxlZnQgKyAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgLyAyIC0gKGJvdW5kaW5nLnJpZ2h0IC0gYm91bmRpbmcubGVmdCkgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHggPT0gXCJzdGFydFwiKSA9PSBsdHIgPyByZWN0LmxlZnQgLSB4TWFyZ2luIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QucmlnaHQgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgbW92ZVggPSB0YXJnZXRMZWZ0IC0gYm91bmRpbmcubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luLnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW92ZWRYID0gMCwgbW92ZWRZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnNjcm9sbFRvcCArPSBtb3ZlWSAvIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkWSA9IChjdXIuc2Nyb2xsVG9wIC0gc3RhcnQpICogc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY3VyLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsTGVmdCArPSBtb3ZlWCAvIHNjYWxlWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkWCA9IChjdXIuc2Nyb2xsTGVmdCAtIHN0YXJ0KSAqIHNjYWxlWDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBtb3ZlZFgsIHRvcDogcmVjdC50b3AgLSBtb3ZlZFksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCAtIG1vdmVkWCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIG1vdmVkWSB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRYICYmIE1hdGguYWJzKG1vdmVkWCAtIG1vdmVYKSA8IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gXCJuZWFyZXN0XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFkgJiYgTWF0aC5hYnMobW92ZWRZIC0gbW92ZVkpIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMTEpIHsgLy8gQSBzaGFkb3cgcm9vdFxuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNjcm9sbGFibGVQYXJlbnRzKGRvbSkge1xuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudCwgeCwgeTtcbiAgICBmb3IgKGxldCBjdXIgPSBkb20ucGFyZW50Tm9kZTsgY3VyOykge1xuICAgICAgICBpZiAoY3VyID09IGRvYy5ib2R5IHx8ICh4ICYmIHkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgaWYgKCF5ICYmIGN1ci5zY3JvbGxIZWlnaHQgPiBjdXIuY2xpZW50SGVpZ2h0KVxuICAgICAgICAgICAgICAgIHkgPSBjdXI7XG4gICAgICAgICAgICBpZiAoIXggJiYgY3VyLnNjcm9sbFdpZHRoID4gY3VyLmNsaWVudFdpZHRoKVxuICAgICAgICAgICAgICAgIHggPSBjdXI7XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkge1xuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB4LCB5IH07XG59XG5jbGFzcyBET01TZWxlY3Rpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZXEoZG9tU2VsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuY2hvck5vZGUgPT0gZG9tU2VsLmFuY2hvck5vZGUgJiYgdGhpcy5hbmNob3JPZmZzZXQgPT0gZG9tU2VsLmFuY2hvck9mZnNldCAmJlxuICAgICAgICAgICAgdGhpcy5mb2N1c05vZGUgPT0gZG9tU2VsLmZvY3VzTm9kZSAmJiB0aGlzLmZvY3VzT2Zmc2V0ID09IGRvbVNlbC5mb2N1c09mZnNldDtcbiAgICB9XG4gICAgc2V0UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgYW5jaG9yTm9kZSwgZm9jdXNOb2RlIH0gPSByYW5nZTtcbiAgICAgICAgLy8gQ2xpcCBvZmZzZXRzIHRvIG5vZGUgc2l6ZSB0byBhdm9pZCBjcmFzaGVzIHdoZW4gU2FmYXJpIHJlcG9ydHMgYm9ndXMgb2Zmc2V0cyAoIzExNTIpXG4gICAgICAgIHRoaXMuc2V0KGFuY2hvck5vZGUsIE1hdGgubWluKHJhbmdlLmFuY2hvck9mZnNldCwgYW5jaG9yTm9kZSA/IG1heE9mZnNldChhbmNob3JOb2RlKSA6IDApLCBmb2N1c05vZGUsIE1hdGgubWluKHJhbmdlLmZvY3VzT2Zmc2V0LCBmb2N1c05vZGUgPyBtYXhPZmZzZXQoZm9jdXNOb2RlKSA6IDApKTtcbiAgICB9XG4gICAgc2V0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBhbmNob3JOb2RlO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IGFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBmb2N1c05vZGU7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICB9XG59XG5sZXQgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IG51bGw7XG4vLyBGZWF0dXJlLWRldGVjdHMgc3VwcG9ydCBmb3IgLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSksIGFuZCB1c2VzXG4vLyBhIGZhbGxiYWNrIGtsdWRnZSB3aGVuIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBmb2N1c1ByZXZlbnRTY3JvbGwoZG9tKSB7XG4gICAgaWYgKGRvbS5zZXRBY3RpdmUpXG4gICAgICAgIHJldHVybiBkb20uc2V0QWN0aXZlKCk7IC8vIGluIElFXG4gICAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCk7XG4gICAgbGV0IHN0YWNrID0gW107XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHN0YWNrLnB1c2goY3VyLCBjdXIuc2Nyb2xsVG9wLCBjdXIuc2Nyb2xsTGVmdCk7XG4gICAgICAgIGlmIChjdXIgPT0gY3VyLm93bmVyRG9jdW1lbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcbiAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0geyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHN0YWNrW2krK10sIHRvcCA9IHN0YWNrW2krK10sIGxlZnQgPSBzdGFja1tpKytdO1xuICAgICAgICAgICAgaWYgKGVsdC5zY3JvbGxUb3AgIT0gdG9wKVxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbExlZnQgIT0gbGVmdClcbiAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgc2NyYXRjaFJhbmdlO1xuZnVuY3Rpb24gdGV4dFJhbmdlKG5vZGUsIGZyb20sIHRvID0gZnJvbSkge1xuICAgIGxldCByYW5nZSA9IHNjcmF0Y2hSYW5nZSB8fCAoc2NyYXRjaFJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSk7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIHRvKTtcbiAgICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tKTtcbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEtleShlbHQsIG5hbWUsIGNvZGUsIG1vZHMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHsga2V5OiBuYW1lLCBjb2RlOiBuYW1lLCBrZXlDb2RlOiBjb2RlLCB3aGljaDogY29kZSwgY2FuY2VsYWJsZTogdHJ1ZSB9O1xuICAgIGlmIChtb2RzKVxuICAgICAgICAoeyBhbHRLZXk6IG9wdGlvbnMuYWx0S2V5LCBjdHJsS2V5OiBvcHRpb25zLmN0cmxLZXksIHNoaWZ0S2V5OiBvcHRpb25zLnNoaWZ0S2V5LCBtZXRhS2V5OiBvcHRpb25zLm1ldGFLZXkgfSA9IG1vZHMpO1xuICAgIGxldCBkb3duID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXlkb3duXCIsIG9wdGlvbnMpO1xuICAgIGRvd24uc3ludGhldGljID0gdHJ1ZTtcbiAgICBlbHQuZGlzcGF0Y2hFdmVudChkb3duKTtcbiAgICBsZXQgdXAgPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleXVwXCIsIG9wdGlvbnMpO1xuICAgIHVwLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgZWx0LmRpc3BhdGNoRXZlbnQodXApO1xuICAgIHJldHVybiBkb3duLmRlZmF1bHRQcmV2ZW50ZWQgfHwgdXAuZGVmYXVsdFByZXZlbnRlZDtcbn1cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlICYmIChub2RlLm5vZGVUeXBlID09IDkgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSAmJiBub2RlLmhvc3QpKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2xlYXJBdHRyaWJ1dGVzKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5hdHRyaWJ1dGVzLmxlbmd0aClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOb2RlKG5vZGUuYXR0cmlidXRlc1swXSk7XG59XG5mdW5jdGlvbiBhdEVsZW1lbnRTdGFydChkb2MsIHNlbGVjdGlvbikge1xuICAgIGxldCBub2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSB8fCBzZWxlY3Rpb24uYW5jaG9yTm9kZSAhPSBub2RlIHx8IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgIT0gb2Zmc2V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gU2FmYXJpIGNhbiByZXBvcnQgYm9ndXMgb2Zmc2V0cyAoIzExNTIpXG4gICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBtYXhPZmZzZXQobm9kZSkpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gcHJldjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSA9PSBkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTY3JvbGxlZFRvQm90dG9tKGVsdCkge1xuICAgIHJldHVybiBlbHQuc2Nyb2xsVG9wID4gTWF0aC5tYXgoMSwgZWx0LnNjcm9sbEhlaWdodCAtIGVsdC5jbGllbnRIZWlnaHQgLSA0KTtcbn1cbmZ1bmN0aW9uIHRleHROb2RlQmVmb3JlKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpIHtcbiAgICBmb3IgKGxldCBub2RlID0gc3RhcnROb2RlLCBvZmZzZXQgPSBzdGFydE9mZnNldDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbm9kZSwgb2Zmc2V0OiBvZmZzZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICYmICFpc0Jsb2NrRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUFmdGVyKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpIHtcbiAgICBmb3IgKGxldCBub2RlID0gc3RhcnROb2RlLCBvZmZzZXQgPSBzdGFydE9mZnNldDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgJiYgb2Zmc2V0IDwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBvZmZzZXQ6IG9mZnNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgJiYgIWlzQmxvY2tFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKSArIDE7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIERPTVBvcyB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgb2Zmc2V0LCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wcmVjaXNlID0gcHJlY2lzZTtcbiAgICB9XG4gICAgc3RhdGljIGJlZm9yZShkb20sIHByZWNpc2UpIHsgcmV0dXJuIG5ldyBET01Qb3MoZG9tLnBhcmVudE5vZGUsIGRvbUluZGV4KGRvbSksIHByZWNpc2UpOyB9XG4gICAgc3RhdGljIGFmdGVyKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSArIDEsIHByZWNpc2UpOyB9XG59XG5jb25zdCBub0NoaWxkcmVuID0gW107XG5jbGFzcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgICAgICB0aGlzLmZsYWdzID0gMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZSh0aGlzKSA6IDA7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3NCZWZvcmUodmlldykge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT0gdmlldylcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNoaWxkIGluIHBvc0JlZm9yZVwiKTtcbiAgICB9XG4gICAgcG9zQWZ0ZXIodmlldykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUodmlldykgKyB2aWV3Lmxlbmd0aDtcbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICBpZiAodGhpcy5mbGFncyAmIDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5kb207XG4gICAgICAgICAgICBsZXQgcHJldiA9IG51bGwsIG5leHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmRvbSAmJiAobmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFZpZXcgPSBDb250ZW50Vmlldy5nZXQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRWaWV3IHx8ICFjb250ZW50Vmlldy5wYXJlbnQgJiYgY29udGVudFZpZXcuY2FuUmV1c2VET00oY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnJldXNlRE9NKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrICYmICF0cmFjay53cml0dGVuICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLmRvbSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXYgPSBjaGlsZC5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQpXG4gICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2VET00oX2RvbSkgeyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgYWZ0ZXI7XG4gICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMuZG9tLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gbWF4T2Zmc2V0KG5vZGUpID09IDAgPyAwIDogb2Zmc2V0ID09IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoYmlhcyA9PSAwICYmIHBhcmVudC5maXJzdENoaWxkICE9IHBhcmVudC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZnRlciA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmdGVyID09IHRoaXMuZG9tLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgd2hpbGUgKGFmdGVyICYmICFDb250ZW50Vmlldy5nZXQoYWZ0ZXIpKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQuZG9tID09IGFmdGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGZyb21JID0gLTEsIGZyb21TdGFydCA9IC0xLCB0b0kgPSAtMSwgdG9FbmQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IG9mZnNldCwgcHJldkVuZCA9IG9mZnNldDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tICYmIGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5kb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIHBvcyk7XG4gICAgICAgICAgICBpZiAoZW5kID49IGZyb20gJiYgZnJvbUkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmcm9tSSA9IGk7XG4gICAgICAgICAgICAgICAgZnJvbVN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA+IHRvICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdG9JID0gaTtcbiAgICAgICAgICAgICAgICB0b0VuZCA9IHByZXZFbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RW5kID0gZW5kO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tU3RhcnQsIHRvOiB0b0VuZCA8IDAgPyBvZmZzZXQgKyB0aGlzLmxlbmd0aCA6IHRvRW5kLFxuICAgICAgICAgICAgc3RhcnRET006IChmcm9tSSA/IHRoaXMuY2hpbGRyZW5bZnJvbUkgLSAxXS5kb20ubmV4dFNpYmxpbmcgOiBudWxsKSB8fCB0aGlzLmRvbS5maXJzdENoaWxkLFxuICAgICAgICAgICAgZW5kRE9NOiB0b0kgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiB0b0kgPj0gMCA/IHRoaXMuY2hpbGRyZW5bdG9JXS5kb20gOiBudWxsIH07XG4gICAgfVxuICAgIG1hcmtEaXJ0eShhbmRQYXJlbnQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZsYWdzIHw9IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICB0aGlzLm1hcmtQYXJlbnRzRGlydHkoYW5kUGFyZW50KTtcbiAgICB9XG4gICAgbWFya1BhcmVudHNEaXJ0eShjaGlsZExpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkTGlzdClcbiAgICAgICAgICAgICAgICBwYXJlbnQuZmxhZ3MgfD0gMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgICAgICAgICBpZiAocGFyZW50LmZsYWdzICYgMSAvKiBWaWV3RmxhZy5DaGlsZERpcnR5ICovKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBhcmVudC5mbGFncyB8PSAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi87XG4gICAgICAgICAgICBjaGlsZExpc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRET00oZG9tKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNtVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICBkb20uY21WaWV3ID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IHJvb3RWaWV3KCkge1xuICAgICAgICBmb3IgKGxldCB2ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdi5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIHYgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZUNoaWxkcmVuKGZyb20sIHRvLCBjaGlsZHJlbiA9IG5vQ2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PSB0aGlzICYmIGNoaWxkcmVuLmluZGV4T2YoY2hpbGQpIDwgMClcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA8IDI1MClcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGZyb20sIHRvIC0gZnJvbSwgLi4uY2hpbGRyZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW10uY29uY2F0KHRoaXMuY2hpbGRyZW4uc2xpY2UoMCwgZnJvbSksIGNoaWxkcmVuLCB0aGlzLmNoaWxkcmVuLnNsaWNlKHRvKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjaGlsZHJlbltpXS5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKF9yZWMpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWdub3JlRXZlbnQoX2V2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGNoaWxkQ3Vyc29yKHBvcyA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hpbGRDdXJzb3IodGhpcy5jaGlsZHJlbiwgcG9zLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICAgIGNoaWxkUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDdXJzb3IoKS5maW5kUG9zKHBvcywgYmlhcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZS5yZXBsYWNlKFwiVmlld1wiLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyAodGhpcy5jaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIHRoaXMuY2hpbGRyZW4uam9pbigpICsgXCIpXCIgOlxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPyBcIltcIiArIChuYW1lID09IFwiVGV4dFwiID8gdGhpcy50ZXh0IDogdGhpcy5sZW5ndGgpICsgXCJdXCIgOiBcIlwiKSArXG4gICAgICAgICAgICAodGhpcy5icmVha0FmdGVyID8gXCIjXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgc3RhdGljIGdldChub2RlKSB7IHJldHVybiBub2RlLmNtVmlldzsgfVxuICAgIGdldCBpc0VkaXRhYmxlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpc1dpZGdldCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBoYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYmVjb21lKG90aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGNhblJldXNlRE9NKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5jb25zdHJ1Y3RvciA9PSB0aGlzLmNvbnN0cnVjdG9yICYmICEoKHRoaXMuZmxhZ3MgfCBvdGhlci5mbGFncykgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKTtcbiAgICB9XG4gICAgLy8gV2hlbiB0aGlzIGlzIGEgemVyby1sZW5ndGggdmlldyB3aXRoIGEgc2lkZSwgdGhpcyBzaG91bGQgcmV0dXJuIGFcbiAgICAvLyBudW1iZXIgPD0gMCB0byBpbmRpY2F0ZSBpdCBpcyBiZWZvcmUgaXRzIHBvc2l0aW9uLCBvciBhXG4gICAgLy8gbnVtYmVyID4gMCB3aGVuIGFmdGVyIGl0cyBwb3NpdGlvbi5cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gMDsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09IHRoaXMpXG4gICAgICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgfVxufVxuQ29udGVudFZpZXcucHJvdG90eXBlLmJyZWFrQWZ0ZXIgPSAwO1xuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0kMShkb20pIHtcbiAgICBsZXQgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuICAgIHJldHVybiBuZXh0O1xufVxuY2xhc3MgQ2hpbGRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBwb3MsIGkpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5pID0gaTtcbiAgICAgICAgdGhpcy5vZmYgPSAwO1xuICAgIH1cbiAgICBmaW5kUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHBvcyA+IHRoaXMucG9zIHx8IHBvcyA9PSB0aGlzLnBvcyAmJlxuICAgICAgICAgICAgICAgIChiaWFzID4gMCB8fCB0aGlzLmkgPT0gMCB8fCB0aGlzLmNoaWxkcmVuW3RoaXMuaSAtIDFdLmJyZWFrQWZ0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYgPSBwb3MgLSB0aGlzLnBvcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5jaGlsZHJlblstLXRoaXMuaV07XG4gICAgICAgICAgICB0aGlzLnBvcyAtPSBuZXh0Lmxlbmd0aCArIG5leHQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZShwYXJlbnQsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBpbnNlcnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IHBhcmVudDtcbiAgICBsZXQgYmVmb3JlID0gY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW5bZnJvbUldIDogbnVsbDtcbiAgICBsZXQgbGFzdCA9IGluc2VydC5sZW5ndGggPyBpbnNlcnRbaW5zZXJ0Lmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICBsZXQgYnJlYWtBdEVuZCA9IGxhc3QgPyBsYXN0LmJyZWFrQWZ0ZXIgOiBicmVha0F0U3RhcnQ7XG4gICAgLy8gQ2hhbmdlIHdpdGhpbiBhIHNpbmdsZSBjaGlsZFxuICAgIGlmIChmcm9tSSA9PSB0b0kgJiYgYmVmb3JlICYmICFicmVha0F0U3RhcnQgJiYgIWJyZWFrQXRFbmQgJiYgaW5zZXJ0Lmxlbmd0aCA8IDIgJiZcbiAgICAgICAgYmVmb3JlLm1lcmdlKGZyb21PZmYsIHRvT2ZmLCBpbnNlcnQubGVuZ3RoID8gbGFzdCA6IG51bGwsIGZyb21PZmYgPT0gMCwgb3BlblN0YXJ0LCBvcGVuRW5kKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0b0kgPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gY2hpbGRyZW5bdG9JXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBlbmQgb2YgdGhlIGNoaWxkIGFmdGVyIHRoZSB1cGRhdGUgaXMgcHJlc2VydmVkIGluIGBhZnRlcmBcbiAgICAgICAgaWYgKGFmdGVyICYmICh0b09mZiA8IGFmdGVyLmxlbmd0aCB8fCBhZnRlci5icmVha0FmdGVyICYmIChsYXN0ID09PSBudWxsIHx8IGxhc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3QuYnJlYWtBZnRlcikpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBzcGxpdHRpbmcgYSBjaGlsZCwgc2VwYXJhdGUgcGFydCBvZiBpdCB0byBhdm9pZCB0aGF0XG4gICAgICAgICAgICAvLyBiZWluZyBtYW5nbGVkIHdoZW4gdXBkYXRpbmcgdGhlIGNoaWxkIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICAgICAgICAgaWYgKGZyb21JID09IHRvSSkge1xuICAgICAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIuc3BsaXQodG9PZmYpO1xuICAgICAgICAgICAgICAgIHRvT2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGFmdGVyIHRoZSByZXBsYWNlbWVudCBzaG91bGQgYmUgbWVyZ2VkIHdpdGhcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IHJlcGxhY2luZyBlbGVtZW50LCB1cGRhdGUgYGNvbnRlbnRgXG4gICAgICAgICAgICBpZiAoIWJyZWFrQXRFbmQgJiYgbGFzdCAmJiBhZnRlci5tZXJnZSgwLCB0b09mZiwgbGFzdCwgdHJ1ZSwgMCwgb3BlbkVuZCkpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRbaW5zZXJ0Lmxlbmd0aCAtIDFdID0gYWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHN0YXJ0IG9mIHRoZSBhZnRlciBlbGVtZW50LCBpZiBuZWNlc3NhcnksIGFuZFxuICAgICAgICAgICAgICAgIC8vIGFkZCBpdCB0byBgY29udGVudGAuXG4gICAgICAgICAgICAgICAgaWYgKHRvT2ZmIHx8IGFmdGVyLmNoaWxkcmVuLmxlbmd0aCAmJiAhYWZ0ZXIuY2hpbGRyZW5bMF0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBhZnRlci5tZXJnZSgwLCB0b09mZiwgbnVsbCwgZmFsc2UsIDAsIG9wZW5FbmQpO1xuICAgICAgICAgICAgICAgIGluc2VydC5wdXNoKGFmdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhZnRlciA9PT0gbnVsbCB8fCBhZnRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWZ0ZXIuYnJlYWtBZnRlcikge1xuICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgYXQgYHRvSWAgaXMgZW50aXJlbHkgY292ZXJlZCBieSB0aGlzIHJhbmdlLlxuICAgICAgICAgICAgLy8gUHJlc2VydmUgaXRzIGxpbmUgYnJlYWssIGlmIGFueS5cbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIGxhc3QuYnJlYWtBZnRlciA9IDE7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWtBdFN0YXJ0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBoYW5kbGVkIHRoZSBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50c1xuICAgICAgICAvLyBub3csIG1ha2Ugc3VyZSBgdG9JYCBwb2ludHMgYWZ0ZXIgdGhhdC5cbiAgICAgICAgdG9JKys7XG4gICAgfVxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgYmVmb3JlLmJyZWFrQWZ0ZXIgPSBicmVha0F0U3RhcnQ7XG4gICAgICAgIGlmIChmcm9tT2ZmID4gMCkge1xuICAgICAgICAgICAgaWYgKCFicmVha0F0U3RhcnQgJiYgaW5zZXJ0Lmxlbmd0aCAmJiBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgYmVmb3JlLmxlbmd0aCwgaW5zZXJ0WzBdLCBmYWxzZSwgb3BlblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgIGJlZm9yZS5icmVha0FmdGVyID0gaW5zZXJ0LnNoaWZ0KCkuYnJlYWtBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21PZmYgPCBiZWZvcmUubGVuZ3RoIHx8IGJlZm9yZS5jaGlsZHJlbi5sZW5ndGggJiYgYmVmb3JlLmNoaWxkcmVuW2JlZm9yZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCBiZWZvcmUubGVuZ3RoLCBudWxsLCBmYWxzZSwgb3BlblN0YXJ0LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21JKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIG1lcmdlIHdpZGdldHMgb24gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgd2hpbGUgKGZyb21JIDwgdG9JICYmIGluc2VydC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW3RvSSAtIDFdLmJlY29tZShpbnNlcnRbaW5zZXJ0Lmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgdG9JLS07XG4gICAgICAgICAgICBpbnNlcnQucG9wKCk7XG4gICAgICAgICAgICBvcGVuRW5kID0gaW5zZXJ0Lmxlbmd0aCA/IDAgOiBvcGVuU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGRyZW5bZnJvbUldLmJlY29tZShpbnNlcnRbMF0pKSB7XG4gICAgICAgICAgICBmcm9tSSsrO1xuICAgICAgICAgICAgaW5zZXJ0LnNoaWZ0KCk7XG4gICAgICAgICAgICBvcGVuU3RhcnQgPSBpbnNlcnQubGVuZ3RoID8gMCA6IG9wZW5FbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWluc2VydC5sZW5ndGggJiYgZnJvbUkgJiYgdG9JIDwgY2hpbGRyZW4ubGVuZ3RoICYmICFjaGlsZHJlbltmcm9tSSAtIDFdLmJyZWFrQWZ0ZXIgJiZcbiAgICAgICAgY2hpbGRyZW5bdG9JXS5tZXJnZSgwLCAwLCBjaGlsZHJlbltmcm9tSSAtIDFdLCBmYWxzZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSlcbiAgICAgICAgZnJvbUktLTtcbiAgICBpZiAoZnJvbUkgPCB0b0kgfHwgaW5zZXJ0Lmxlbmd0aClcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZHJlbihmcm9tSSwgdG9JLCBpbnNlcnQpO1xufVxuZnVuY3Rpb24gbWVyZ2VDaGlsZHJlbkludG8ocGFyZW50LCBmcm9tLCB0bywgaW5zZXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBsZXQgY3VyID0gcGFyZW50LmNoaWxkQ3Vyc29yKCk7XG4gICAgbGV0IHsgaTogdG9JLCBvZmY6IHRvT2ZmIH0gPSBjdXIuZmluZFBvcyh0bywgMSk7XG4gICAgbGV0IHsgaTogZnJvbUksIG9mZjogZnJvbU9mZiB9ID0gY3VyLmZpbmRQb3MoZnJvbSwgLTEpO1xuICAgIGxldCBkTGVuID0gZnJvbSAtIHRvO1xuICAgIGZvciAobGV0IHZpZXcgb2YgaW5zZXJ0KVxuICAgICAgICBkTGVuICs9IHZpZXcubGVuZ3RoO1xuICAgIHBhcmVudC5sZW5ndGggKz0gZExlbjtcbiAgICByZXBsYWNlUmFuZ2UocGFyZW50LCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgaW5zZXJ0LCAwLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xufVxuXG5sZXQgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yIDogeyB1c2VyQWdlbnQ6IFwiXCIsIHZlbmRvcjogXCJcIiwgcGxhdGZvcm06IFwiXCIgfTtcbmxldCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogeyBkb2N1bWVudEVsZW1lbnQ6IHsgc3R5bGU6IHt9IH0gfTtcbmNvbnN0IGllX2VkZ2UgPSAvRWRnZVxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IGllX3VwdG8xMCA9IC9NU0lFIFxcZC8udGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xuY29uc3QgZ2Vja28gPSAhaWUgJiYgL2dlY2tvXFwvKFxcZCspL2kudGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGNocm9tZSA9ICFpZSAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2LnZlbmRvcik7XG5jb25zdCBpb3MgPSBzYWZhcmkgJiYgKC9Nb2JpbGVcXC9cXHcrLy50ZXN0KG5hdi51c2VyQWdlbnQpIHx8IG5hdi5tYXhUb3VjaFBvaW50cyA+IDIpO1xudmFyIGJyb3dzZXIgPSB7XG4gICAgbWFjOiBpb3MgfHwgL01hYy8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIHdpbmRvd3M6IC9XaW4vLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICBsaW51eDogL0xpbnV4fFgxMS8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIGllLFxuICAgIGllX3ZlcnNpb246IGllX3VwdG8xMCA/IGRvYy5kb2N1bWVudE1vZGUgfHwgNiA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDAsXG4gICAgZ2Vja28sXG4gICAgZ2Vja29fdmVyc2lvbjogZ2Vja28gPyArKC9GaXJlZm94XFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIGNocm9tZTogISFjaHJvbWUsXG4gICAgY2hyb21lX3ZlcnNpb246IGNocm9tZSA/ICtjaHJvbWVbMV0gOiAwLFxuICAgIGlvcyxcbiAgICBhbmRyb2lkOiAvQW5kcm9pZFxcYi8udGVzdChuYXYudXNlckFnZW50KSxcbiAgICB3ZWJraXQsXG4gICAgc2FmYXJpLFxuICAgIHdlYmtpdF92ZXJzaW9uOiB3ZWJraXQgPyArKC9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICB0YWJTaXplOiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnRhYlNpemUgIT0gbnVsbCA/IFwidGFiLXNpemVcIiA6IFwiLW1vei10YWItc2l6ZVwiXG59O1xuXG5jb25zdCBNYXhKb2luTGVuID0gMjU2O1xuY2xhc3MgVGV4dFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IodGV4dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIGNyZWF0ZURPTSh0ZXh0RE9NKSB7XG4gICAgICAgIHRoaXMuc2V0RE9NKHRleHRET00gfHwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KSk7XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRE9NKCk7XG4gICAgICAgIGlmICh0aGlzLmRvbS5ub2RlVmFsdWUgIT0gdGhpcy50ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2subm9kZSA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLm5vZGVWYWx1ZSA9IHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZURPTShkb20pIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oZG9tKTtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSkge1xuICAgICAgICBpZiAoKHRoaXMuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKSB8fFxuICAgICAgICAgICAgc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFRleHRWaWV3KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyBzb3VyY2UubGVuZ3RoID4gTWF4Sm9pbkxlbiB8fFxuICAgICAgICAgICAgICAgIChzb3VyY2UuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKSArIChzb3VyY2UgPyBzb3VyY2UudGV4dCA6IFwiXCIpICsgdGhpcy50ZXh0LnNsaWNlKHRvKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBUZXh0Vmlldyh0aGlzLnRleHQuc2xpY2UoZnJvbSkpO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgZnJvbSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJlc3VsdC5mbGFncyB8PSB0aGlzLmZsYWdzICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbm9kZSA9PSB0aGlzLmRvbSA/IG9mZnNldCA6IG9mZnNldCA/IHRoaXMudGV4dC5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHsgcmV0dXJuIG5ldyBET01Qb3ModGhpcy5kb20sIHBvcyk7IH1cbiAgICBkb21Cb3VuZHNBcm91bmQoX2Zyb20sIF90bywgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IGZyb206IG9mZnNldCwgdG86IG9mZnNldCArIHRoaXMubGVuZ3RoLCBzdGFydERPTTogdGhpcy5kb20sIGVuZERPTTogdGhpcy5kb20ubmV4dFNpYmxpbmcgfTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29vcmRzKHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgIH1cbn1cbmNsYXNzIE1hcmtWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG1hcmssIGNoaWxkcmVuID0gW10sIGxlbmd0aCA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBjaC5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIHNldEF0dHJzKGRvbSkge1xuICAgICAgICBjbGVhckF0dHJpYnV0ZXMoZG9tKTtcbiAgICAgICAgaWYgKHRoaXMubWFyay5jbGFzcylcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSB0aGlzLm1hcmsuY2xhc3M7XG4gICAgICAgIGlmICh0aGlzLm1hcmsuYXR0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIHRoaXMubWFyay5hdHRyc1tuYW1lXSk7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGNhblJldXNlRE9NKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5jYW5SZXVzZURPTShvdGhlcikgJiYgISgodGhpcy5mbGFncyB8IG90aGVyLmZsYWdzKSAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IHRoaXMubWFyay50YWdOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8gfCAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLnNldEF0dHJzKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5tYXJrLnRhZ05hbWUpKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmxhZ3MgJiA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8pXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJzKHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIF9oYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgc291cmNlLm1hcmsuZXEodGhpcy5tYXJrKSkgfHxcbiAgICAgICAgICAgIChmcm9tICYmIG9wZW5TdGFydCA8PSAwKSB8fCAodG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbWVyZ2VDaGlsZHJlbkludG8odGhpcywgZnJvbSwgdG8sIHNvdXJjZSA/IHNvdXJjZS5jaGlsZHJlbi5zbGljZSgpIDogW10sIG9wZW5TdGFydCAtIDEsIG9wZW5FbmQgLSAxKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBvZmYgPSAwLCBkZXRhY2hGcm9tID0gLTEsIGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGVuZCA9IG9mZiArIGVsdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvZmYgPCBmcm9tID8gZWx0LnNwbGl0KGZyb20gLSBvZmYpIDogZWx0KTtcbiAgICAgICAgICAgIGlmIChkZXRhY2hGcm9tIDwgMCAmJiBvZmYgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICBkZXRhY2hGcm9tID0gaTtcbiAgICAgICAgICAgIG9mZiA9IGVuZDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5sZW5ndGggLSBmcm9tO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb207XG4gICAgICAgIGlmIChkZXRhY2hGcm9tID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gZGV0YWNoRnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlldyh0aGlzLm1hcmssIHJlc3VsdCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLCBwb3MpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0luQ2hpbGRyZW4odGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0ZXh0Q29vcmRzKHRleHQsIHBvcywgc2lkZSkge1xuICAgIGxldCBsZW5ndGggPSB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgaWYgKHBvcyA+IGxlbmd0aClcbiAgICAgICAgcG9zID0gbGVuZ3RoO1xuICAgIGxldCBmcm9tID0gcG9zLCB0byA9IHBvcywgZmxhdHRlbiA9IDA7XG4gICAgaWYgKHBvcyA9PSAwICYmIHNpZGUgPCAwIHx8IHBvcyA9PSBsZW5ndGggJiYgc2lkZSA+PSAwKSB7XG4gICAgICAgIGlmICghKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZ2Vja28pKSB7IC8vIFRoZXNlIGJyb3dzZXJzIHJlbGlhYmx5IHJldHVybiB2YWxpZCByZWN0YW5nbGVzIGZvciBlbXB0eSByYW5nZXNcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBmcm9tLS07XG4gICAgICAgICAgICAgICAgZmxhdHRlbiA9IDE7XG4gICAgICAgICAgICB9IC8vIEZJWE1FIHRoaXMgaXMgd3JvbmcgaW4gUlRMIHRleHRcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICBmbGF0dGVuID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChzaWRlIDwgMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBsZW5ndGgpXG4gICAgICAgICAgICB0bysrO1xuICAgIH1cbiAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UodGV4dCwgZnJvbSwgdG8pLmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCByZWN0ID0gcmVjdHNbKGZsYXR0ZW4gPyBmbGF0dGVuIDwgMCA6IHNpZGUgPj0gMCkgPyAwIDogcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFmbGF0dGVuICYmIHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmVjdCA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwocmVjdHMsIHIgPT4gci53aWR0aCkgfHwgcmVjdDtcbiAgICByZXR1cm4gZmxhdHRlbiA/IGZsYXR0ZW5SZWN0KHJlY3QsIGZsYXR0ZW4gPCAwKSA6IHJlY3QgfHwgbnVsbDtcbn1cbi8vIEFsc28gdXNlZCBmb3IgY29sbGFwc2VkIHJhbmdlcyB0aGF0IGRvbid0IGhhdmUgYSBwbGFjZWhvbGRlciB3aWRnZXQhXG5jbGFzcyBXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIHN0YXRpYyBjcmVhdGUod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRWaWV3KHdpZGdldCwgbGVuZ3RoLCBzaWRlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBXaWRnZXRWaWV3LmNyZWF0ZSh0aGlzLndpZGdldCwgdGhpcy5sZW5ndGggLSBmcm9tLCB0aGlzLnNpZGUpO1xuICAgICAgICB0aGlzLmxlbmd0aCAtPSBmcm9tO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzeW5jKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tLCB2aWV3KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmIHRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00odmlldykpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLndpZGdldC5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIHRoaXMuc2lkZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBXaWRnZXRWaWV3KSB8fCAhdGhpcy53aWRnZXQuY29tcGFyZShzb3VyY2Uud2lkZ2V0KSB8fFxuICAgICAgICAgICAgZnJvbSA+IDAgJiYgb3BlblN0YXJ0IDw9IDAgfHwgdG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb20gKyAoc291cmNlID8gc291cmNlLmxlbmd0aCA6IDApICsgKHRoaXMubGVuZ3RoIC0gdG8pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGUgJiZcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmNvbnN0cnVjdG9yID09IG90aGVyLndpZGdldC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLndpZGdldC5jb21wYXJlKG90aGVyLndpZGdldCkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkodHJ1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgIXRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSB0aGlzLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0ID0gb3RoZXIud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBvdGhlci5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5UZXh0LmVtcHR5O1xuICAgICAgICBsZXQgdG9wID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHRvcC5wYXJlbnQpXG4gICAgICAgICAgICB0b3AgPSB0b3AucGFyZW50O1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0b3AsIHRleHQgPSB2aWV3ICYmIHZpZXcuc3RhdGUuZG9jLCBzdGFydCA9IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgcmV0dXJuIHRleHQgPyB0ZXh0LnNsaWNlKHN0YXJ0LCBzdGFydCArIHRoaXMubGVuZ3RoKSA6IHN0YXRlLlRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gKHRoaXMubGVuZ3RoID8gcG9zID09IDAgOiB0aGlzLnNpZGUgPiAwKVxuICAgICAgICAgICAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKVxuICAgICAgICAgICAgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHRoaXMud2lkZ2V0LmNvb3Jkc0F0KHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgbGV0IHJlY3RzID0gdGhpcy5kb20uZ2V0Q2xpZW50UmVjdHMoKSwgcmVjdCA9IG51bGw7XG4gICAgICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBmcm9tQmFjayA9IHRoaXMuc2lkZSA/IHRoaXMuc2lkZSA8IDAgOiBwb3MgPiAwO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbUJhY2sgPyByZWN0cy5sZW5ndGggLSAxIDogMDs7IGkgKz0gKGZyb21CYWNrID8gLTEgOiAxKSkge1xuICAgICAgICAgICAgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKHBvcyA+IDAgPyBpID09IDAgOiBpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhdHRlblJlY3QocmVjdCwgIWZyb21CYWNrKTtcbiAgICB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpc1dpZGdldCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0aGlzLndpZGdldC5pc0hpZGRlbjsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgfVxufVxuLy8gVGhlc2UgYXJlIGRyYXduIGFyb3VuZCB1bmVkaXRhYmxlIHdpZGdldHMgdG8gYXZvaWQgYSBudW1iZXIgb2Zcbi8vIGJyb3dzZXIgYnVncyB0aGF0IHNob3cgdXAgd2hlbiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IG5leHQgdG9cbi8vIHVuZWRpdGFibGUgaW5saW5lIGNvbnRlbnQuXG5jbGFzcyBXaWRnZXRCdWZmZXJWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbiAgICBtZXJnZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFdpZGdldEJ1ZmZlclZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGU7XG4gICAgfVxuICAgIHNwbGl0KCkgeyByZXR1cm4gbmV3IFdpZGdldEJ1ZmZlclZpZXcodGhpcy5zaWRlKTsgfVxuICAgIHN5bmMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiY20td2lkZ2V0QnVmZmVyXCI7XG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiB0aGlzLnNpZGUgPiAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20pOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKCkgeyByZXR1cm4gMDsgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb29yZHNBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICByZXR1cm4gc3RhdGUuVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuVGV4dFZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gV2lkZ2V0Vmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBXaWRnZXRCdWZmZXJWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IG5vQ2hpbGRyZW47XG5mdW5jdGlvbiBpbmxpbmVET01BdFBvcyhwYXJlbnQsIHBvcykge1xuICAgIGxldCBkb20gPSBwYXJlbnQuZG9tLCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQsIGkgPSAwO1xuICAgIGZvciAobGV0IG9mZiA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID09IG9mZiAmJiBjaGlsZC5nZXRTaWRlKCkgPD0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAocG9zID4gb2ZmICYmIHBvcyA8IGVuZCAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuZG9tQXRQb3MocG9zIC0gb2ZmKTtcbiAgICAgICAgaWYgKHBvcyA8PSBvZmYpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgb2ZmID0gZW5kO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICBsZXQgcHJldiA9IGNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgaWYgKHByZXYuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIHByZXYuZG9tQXRQb3MocHJldi5sZW5ndGgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5bal07XG4gICAgICAgIGlmIChuZXh0LmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUF0UG9zKDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERPTVBvcyhkb20sIDApO1xufVxuLy8gQXNzdW1lcyBgdmlld2AsIGlmIGEgbWFyayB2aWV3LCBoYXMgcHJlY2lzZWx5IDEgY2hpbGQuXG5mdW5jdGlvbiBqb2luSW5saW5lSW50byhwYXJlbnQsIHZpZXcsIG9wZW4pIHtcbiAgICBsZXQgbGFzdCwgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGlmIChvcGVuID4gMCAmJiB2aWV3IGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIChsYXN0ID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgbGFzdC5tYXJrLmVxKHZpZXcubWFyaykpIHtcbiAgICAgICAgam9pbklubGluZUludG8obGFzdCwgdmlldy5jaGlsZHJlblswXSwgb3BlbiAtIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaCh2aWV3KTtcbiAgICAgICAgdmlldy5zZXRQYXJlbnQocGFyZW50KTtcbiAgICB9XG4gICAgcGFyZW50Lmxlbmd0aCArPSB2aWV3Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNvb3Jkc0luQ2hpbGRyZW4odmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGJlZm9yZSA9IG51bGwsIGJlZm9yZVBvcyA9IC0xLCBhZnRlciA9IG51bGwsIGFmdGVyUG9zID0gLTE7XG4gICAgZnVuY3Rpb24gc2Nhbih2aWV3LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCB2aWV3LmNoaWxkcmVuLmxlbmd0aCAmJiBvZmYgPD0gcG9zOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FuKGNoaWxkLCBwb3MgLSBvZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoIWFmdGVyIHx8IGFmdGVyLmlzSGlkZGVuICYmIHNpZGUgPiAwKSAmJlxuICAgICAgICAgICAgICAgICAgICAoZW5kID4gcG9zIHx8IG9mZiA9PSBlbmQgJiYgY2hpbGQuZ2V0U2lkZSgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJQb3MgPSBwb3MgLSBvZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9mZiA8IHBvcyB8fCAob2ZmID09IGVuZCAmJiBjaGlsZC5nZXRTaWRlKCkgPCAwKSAmJiAhY2hpbGQuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVBvcyA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nhbih2aWV3LCBwb3MpO1xuICAgIGxldCB0YXJnZXQgPSAoc2lkZSA8IDAgPyBiZWZvcmUgOiBhZnRlcikgfHwgYmVmb3JlIHx8IGFmdGVyO1xuICAgIGlmICh0YXJnZXQpXG4gICAgICAgIHJldHVybiB0YXJnZXQuY29vcmRzQXQoTWF0aC5tYXgoMCwgdGFyZ2V0ID09IGJlZm9yZSA/IGJlZm9yZVBvcyA6IGFmdGVyUG9zKSwgc2lkZSk7XG4gICAgcmV0dXJuIGZhbGxiYWNrUmVjdCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGZhbGxiYWNrUmVjdCh2aWV3KSB7XG4gICAgbGV0IGxhc3QgPSB2aWV3LmRvbS5sYXN0Q2hpbGQ7XG4gICAgaWYgKCFsYXN0KVxuICAgICAgICByZXR1cm4gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IobGFzdCk7XG4gICAgcmV0dXJuIHJlY3RzW3JlY3RzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBdHRycyhzb3VyY2UsIHRhcmdldCkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIiAmJiB0YXJnZXQuY2xhc3MpXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3MgKz0gXCIgXCIgKyBzb3VyY2UuY2xhc3M7XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiICYmIHRhcmdldC5zdHlsZSlcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZSArPSBcIjtcIiArIHNvdXJjZS5zdHlsZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3Qgbm9BdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBhdHRyc0VxKGEsIGIsIGlnbm9yZSkge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghYSlcbiAgICAgICAgYSA9IG5vQXR0cnM7XG4gICAgaWYgKCFiKVxuICAgICAgICBiID0gbm9BdHRycztcbiAgICBsZXQga2V5c0EgPSBPYmplY3Qua2V5cyhhKSwga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoa2V5c0EubGVuZ3RoIC0gKGlnbm9yZSAmJiBrZXlzQS5pbmRleE9mKGlnbm9yZSkgPiAtMSA/IDEgOiAwKSAhPVxuICAgICAgICBrZXlzQi5sZW5ndGggLSAoaWdub3JlICYmIGtleXNCLmluZGV4T2YoaWdub3JlKSA+IC0xID8gMSA6IDApKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXNBKSB7XG4gICAgICAgIGlmIChrZXkgIT0gaWdub3JlICYmIChrZXlzQi5pbmRleE9mKGtleSkgPT0gLTEgfHwgYVtrZXldICE9PSBiW2tleV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKGRvbSwgcHJldiwgYXR0cnMpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGlmIChwcmV2KVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICBpZiAoIShhdHRycyAmJiBuYW1lIGluIGF0dHJzKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICBpZiAoIShwcmV2ICYmIHByZXZbbmFtZV0gPT0gYXR0cnNbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBnZXRBdHRycyhkb20pIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHIgPSBkb20uYXR0cmlidXRlc1tpXTtcbiAgICAgICAgYXR0cnNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbn1cblxuLyoqXG5XaWRnZXRzIGFkZGVkIHRvIHRoZSBjb250ZW50IGFyZSBkZXNjcmliZWQgYnkgc3ViY2xhc3NlcyBvZiB0aGlzXG5jbGFzcy4gVXNpbmcgYSBkZXNjcmlwdGlvbiBvYmplY3QgbGlrZSB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvXG5kZWxheSBjcmVhdGluZyBvZiB0aGUgRE9NIHN0cnVjdHVyZSBmb3IgYSB3aWRnZXQgdW50aWwgaXQgaXNcbm5lZWRlZCwgYW5kIHRvIGF2b2lkIHJlZHJhd2luZyB3aWRnZXRzIGV2ZW4gaWYgdGhlIGRlY29yYXRpb25zXG50aGF0IGRlZmluZSB0aGVtIGFyZSByZWNyZWF0ZWQuXG4qL1xuY2xhc3MgV2lkZ2V0VHlwZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGluc3RhbmNlIHRvIGFub3RoZXIgaW5zdGFuY2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAoVHlwZVNjcmlwdCBjYW4ndCBleHByZXNzIHRoaXMsIGJ1dCBvbmx5IGluc3RhbmNlcyBvZiB0aGUgc2FtZVxuICAgIHNwZWNpZmljIGNsYXNzIHdpbGwgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kLikgVGhpcyBpcyB1c2VkIHRvXG4gICAgYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgd2hlbiB0aGV5IGFyZSByZXBsYWNlZCBieSBhIG5ld1xuICAgIGRlY29yYXRpb24gb2YgdGhlIHNhbWUgdHlwZS4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdFxuICAgIHJldHVybnMgYGZhbHNlYCwgd2hpY2ggd2lsbCBjYXVzZSBuZXcgaW5zdGFuY2VzIG9mIHRoZSB3aWRnZXQgdG9cbiAgICBhbHdheXMgYmUgcmVkcmF3bi5cbiAgICAqL1xuICAgIGVxKHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBET00gZWxlbWVudCBjcmVhdGVkIGJ5IGEgd2lkZ2V0IG9mIHRoZSBzYW1lIHR5cGUgKGJ1dFxuICAgIGRpZmZlcmVudCwgbm9uLWBlcWAgY29udGVudCkgdG8gcmVmbGVjdCB0aGlzIHdpZGdldC4gTWF5IHJldHVyblxuICAgIHRydWUgdG8gaW5kaWNhdGUgdGhhdCBpdCBjb3VsZCB1cGRhdGUsIGZhbHNlIHRvIGluZGljYXRlIGl0XG4gICAgY291bGRuJ3QgKGluIHdoaWNoIGNhc2UgdGhlIHdpZGdldCB3aWxsIGJlIHJlZHJhd24pLiBUaGUgZGVmYXVsdFxuICAgIGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJucyBmYWxzZS5cbiAgICAqL1xuICAgIHVwZGF0ZURPTShkb20sIHZpZXcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlc3RpbWF0ZWQgaGVpZ2h0IHRoaXMgd2lkZ2V0IHdpbGwgaGF2ZSwgdG8gYmUgdXNlZCB3aGVuXG4gICAgZXN0aW1hdGluZyB0aGUgaGVpZ2h0IG9mIGNvbnRlbnQgdGhhdCBoYXNuJ3QgYmVlbiBkcmF3bi4gTWF5XG4gICAgcmV0dXJuIC0xIHRvIGluZGljYXRlIHlvdSBkb24ndCBrbm93LiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgIHJldHVybnMgLTEuXG4gICAgKi9cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gLTE7IH1cbiAgICAvKipcbiAgICBGb3IgaW5saW5lIHdpZGdldHMgdGhhdCBhcmUgZGlzcGxheWVkIGlubGluZSAoYXMgb3Bwb3NlZCB0b1xuICAgIGBpbmxpbmUtYmxvY2tgKSBhbmQgaW50cm9kdWNlIGxpbmUgYnJlYWtzICh0aHJvdWdoIGA8YnI+YCB0YWdzXG4gICAgb3IgdGV4dHVhbCBuZXdsaW5lcyksIHRoaXMgbXVzdCBpbmRpY2F0ZSB0aGUgYW1vdW50IG9mIGxpbmVcbiAgICBicmVha3MgdGhleSBpbnRyb2R1Y2UuIERlZmF1bHRzIHRvIDAuXG4gICAgKi9cbiAgICBnZXQgbGluZUJyZWFrcygpIHsgcmV0dXJuIDA7IH1cbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBjb25maWd1cmUgd2hpY2gga2luZHMgb2YgZXZlbnRzIGluc2lkZSB0aGUgd2lkZ2V0XG4gICAgc2hvdWxkIGJlIGlnbm9yZWQgYnkgdGhlIGVkaXRvci4gVGhlIGRlZmF1bHQgaXMgdG8gaWdub3JlIGFsbFxuICAgIGV2ZW50cy5cbiAgICAqL1xuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0cnVlOyB9XG4gICAgLyoqXG4gICAgT3ZlcnJpZGUgdGhlIHdheSBzY3JlZW4gY29vcmRpbmF0ZXMgZm9yIHBvc2l0aW9ucyBhdC9pbiB0aGVcbiAgICB3aWRnZXQgYXJlIGZvdW5kLiBgcG9zYCB3aWxsIGJlIHRoZSBvZmZzZXQgaW50byB0aGUgd2lkZ2V0LCBhbmRcbiAgICBgc2lkZWAgdGhlIHNpZGUgb2YgdGhlIHBvc2l0aW9uIHRoYXQgaXMgYmVpbmcgcXVlcmllZOKAlGxlc3MgdGhhblxuICAgIHplcm8gZm9yIGJlZm9yZSwgZ3JlYXRlciB0aGFuIHplcm8gZm9yIGFmdGVyLCBhbmQgemVybyBmb3JcbiAgICBkaXJlY3RseSBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICovXG4gICAgY29vcmRzQXQoZG9tLCBwb3MsIHNpZGUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGFuIGluc3RhbmNlIG9mIHRoZSB3aWRnZXQgaXMgcmVtb3ZlZFxuICAgIGZyb20gdGhlIGVkaXRvciB2aWV3LlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuLyoqXG5UaGUgZGlmZmVyZW50IHR5cGVzIG9mIGJsb2NrcyB0aGF0IGNhbiBvY2N1ciBpbiBhbiBlZGl0b3Igdmlldy5cbiovXG5leHBvcnRzLkJsb2NrVHlwZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoQmxvY2tUeXBlKSB7XG4gICAgLyoqXG4gICAgQSBsaW5lIG9mIHRleHQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBhZnRlciBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRCZWZvcmVcIl0gPSAxXSA9IFwiV2lkZ2V0QmVmb3JlXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBiZWZvcmUgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QWZ0ZXJcIl0gPSAyXSA9IFwiV2lkZ2V0QWZ0ZXJcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBbcmVwbGFjaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBhIHJhbmdlIG9mIGNvbnRlbnQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0UmFuZ2VcIl0gPSAzXSA9IFwiV2lkZ2V0UmFuZ2VcIjtcbn0pKGV4cG9ydHMuQmxvY2tUeXBlIHx8IChleHBvcnRzLkJsb2NrVHlwZSA9IHt9KSk7XG4vKipcbkEgZGVjb3JhdGlvbiBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZHJhdyBvciBzdHlsZSBhIHBpZWNlXG5vZiBjb250ZW50LiBZb3UnbGwgdXN1YWxseSB1c2UgaXQgd3JhcHBlZCBpbiBhXG5bYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSksIHdoaWNoIGFkZHMgYSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uLlxuQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgRGVjb3JhdGlvbiBleHRlbmRzIHN0YXRlLlJhbmdlVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhcnRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVuZFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd2lkZ2V0LCBcbiAgICAvKipcbiAgICBUaGUgY29uZmlnIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGlzIGRlY29yYXRpb24uIFlvdSBjYW5cbiAgICBpbmNsdWRlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbiB0aGVyZSB0byBzdG9yZSBtZXRhZGF0YSBhYm91dFxuICAgIHlvdXIgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFNpZGUgPSBzdGFydFNpZGU7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IGVuZFNpZGU7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBkZWNvcmF0aW9uLCB3aGljaCBpbmZsdWVuY2VzIHRoZSBzdHlsaW5nIG9mIHRoZVxuICAgIGNvbnRlbnQgaW4gaXRzIHJhbmdlLiBOZXN0ZWQgbWFyayBkZWNvcmF0aW9ucyB3aWxsIGNhdXNlIG5lc3RlZFxuICAgIERPTSBlbGVtZW50cyB0byBiZSBjcmVhdGVkLiBOZXN0aW5nIG9yZGVyIGlzIGRldGVybWluZWQgYnlcbiAgICBwcmVjZWRlbmNlIG9mIHRoZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgd2l0aFxuICAgIHRoZSBoaWdoZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucyBjcmVhdGluZyB0aGUgaW5uZXIgRE9NIG5vZGVzLlxuICAgIFN1Y2ggZWxlbWVudHMgYXJlIHNwbGl0IG9uIGxpbmUgYm91bmRhcmllcyBhbmQgb24gdGhlIGJvdW5kYXJpZXNcbiAgICBvZiBsb3dlci1wcmVjZWRlbmNlIGRlY29yYXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIG1hcmsoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtEZWNvcmF0aW9uKHNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggZGlzcGxheXMgYSBET00gZWxlbWVudCBhdCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQoc3BlYykge1xuICAgICAgICBsZXQgc2lkZSA9IE1hdGgubWF4KC0xMDAwMCwgTWF0aC5taW4oMTAwMDAsIHNwZWMuc2lkZSB8fCAwKSksIGJsb2NrID0gISFzcGVjLmJsb2NrO1xuICAgICAgICBzaWRlICs9IChibG9jayAmJiAhc3BlYy5pbmxpbmVPcmRlcilcbiAgICAgICAgICAgID8gKHNpZGUgPiAwID8gMzAwMDAwMDAwIC8qIFNpZGUuQmxvY2tBZnRlciAqLyA6IC00MDAwMDAwMDAgLyogU2lkZS5CbG9ja0JlZm9yZSAqLylcbiAgICAgICAgICAgIDogKHNpZGUgPiAwID8gMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQWZ0ZXIgKi8gOiAtMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQmVmb3JlICovKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc2lkZSwgc2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmVwbGFjZSBkZWNvcmF0aW9uIHdoaWNoIHJlcGxhY2VzIHRoZSBnaXZlbiByYW5nZSB3aXRoXG4gICAgYSB3aWRnZXQsIG9yIHNpbXBseSBoaWRlcyBpdC5cbiAgICAqL1xuICAgIHN0YXRpYyByZXBsYWNlKHNwZWMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gISFzcGVjLmJsb2NrLCBzdGFydFNpZGUsIGVuZFNpZGU7XG4gICAgICAgIGlmIChzcGVjLmlzQmxvY2tHYXApIHtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IC01MDAwMDAwMDAgLyogU2lkZS5HYXBTdGFydCAqLztcbiAgICAgICAgICAgIGVuZFNpZGUgPSA0MDAwMDAwMDAgLyogU2lkZS5HYXBFbmQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2spO1xuICAgICAgICAgICAgc3RhcnRTaWRlID0gKHN0YXJ0ID8gKGJsb2NrID8gLTMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jU3RhcnQgKi8gOiAtMSAvKiBTaWRlLklubGluZUluY1N0YXJ0ICovKSA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovKSAtIDE7XG4gICAgICAgICAgICBlbmRTaWRlID0gKGVuZCA/IChibG9jayA/IDIwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jRW5kICovIDogMSAvKiBTaWRlLklubGluZUluY0VuZCAqLykgOiAtNjAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jRW5kICovKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggY2FuIGFkZCBET00gYXR0cmlidXRlcyB0byB0aGVcbiAgICBsaW5lIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBsaW5lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBbYERlY29yYXRpb25TZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkgZnJvbSB0aGUgZ2l2ZW5cbiAgICBkZWNvcmF0ZWQgcmFuZ2Ugb3IgcmFuZ2VzLiBJZiB0aGUgcmFuZ2VzIGFyZW4ndCBhbHJlYWR5IHNvcnRlZCxcbiAgICBwYXNzIGB0cnVlYCBmb3IgYHNvcnRgIHRvIG1ha2UgdGhlIGxpYnJhcnkgc29ydCB0aGVtIGZvciB5b3UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0KG9mLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLlJhbmdlU2V0Lm9mKG9mLCBzb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNIZWlnaHQoKSB7IHJldHVybiB0aGlzLndpZGdldCA/IHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+IC0xIDogZmFsc2U7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uLm5vbmUgPSBzdGF0ZS5SYW5nZVNldC5lbXB0eTtcbmNsYXNzIE1hcmtEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYyk7XG4gICAgICAgIHN1cGVyKHN0YXJ0ID8gLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLyA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovLCBlbmQgPyAxIC8qIFNpZGUuSW5saW5lSW5jRW5kICovIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLywgbnVsbCwgc3BlYyk7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHNwZWMudGFnTmFtZSB8fCBcInNwYW5cIjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IHNwZWMuY2xhc3MgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5hdHRycyA9IHNwZWMuYXR0cmlidXRlcyB8fCBudWxsO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgb3RoZXIgaW5zdGFuY2VvZiBNYXJrRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9PSBvdGhlci50YWdOYW1lICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuY2xhc3MgfHwgKChfYSA9IHRoaXMuYXR0cnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzcykpID09IChvdGhlci5jbGFzcyB8fCAoKF9iID0gb3RoZXIuYXR0cnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGFzcykpICYmXG4gICAgICAgICAgICAgICAgYXR0cnNFcSh0aGlzLmF0dHJzLCBvdGhlci5hdHRycywgXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tID49IHRvKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXJrIGRlY29yYXRpb25zIG1heSBub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTWFya0RlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gZmFsc2U7XG5jbGFzcyBMaW5lRGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIC0yMDAwMDAwMDAgLyogU2lkZS5MaW5lICovLCBudWxsLCBzcGVjKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTGluZURlY29yYXRpb24gJiZcbiAgICAgICAgICAgIHRoaXMuc3BlYy5jbGFzcyA9PSBvdGhlci5zcGVjLmNsYXNzICYmXG4gICAgICAgICAgICBhdHRyc0VxKHRoaXMuc3BlYy5hdHRyaWJ1dGVzLCBvdGhlci5zcGVjLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKHRvICE9IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkxpbmUgZGVjb3JhdGlvbiByYW5nZXMgbXVzdCBiZSB6ZXJvLWxlbmd0aFwiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5MaW5lRGVjb3JhdGlvbi5wcm90b3R5cGUubWFwTW9kZSA9IHN0YXRlLk1hcE1vZGUuVHJhY2tCZWZvcmU7XG5MaW5lRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuY2xhc3MgUG9pbnREZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgd2lkZ2V0LCBpc1JlcGxhY2UpIHtcbiAgICAgICAgc3VwZXIoc3RhcnRTaWRlLCBlbmRTaWRlLCB3aWRnZXQsIHNwZWMpO1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIHRoaXMuaXNSZXBsYWNlID0gaXNSZXBsYWNlO1xuICAgICAgICB0aGlzLm1hcE1vZGUgPSAhYmxvY2sgPyBzdGF0ZS5NYXBNb2RlLlRyYWNrRGVsIDogc3RhcnRTaWRlIDw9IDAgPyBzdGF0ZS5NYXBNb2RlLlRyYWNrQmVmb3JlIDogc3RhdGUuTWFwTW9kZS5UcmFja0FmdGVyO1xuICAgIH1cbiAgICAvLyBPbmx5IHJlbGV2YW50IHdoZW4gdGhpcy5ibG9jayA9PSB0cnVlXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2lkZSAhPSB0aGlzLmVuZFNpZGUgPyBleHBvcnRzLkJsb2NrVHlwZS5XaWRnZXRSYW5nZVxuICAgICAgICAgICAgOiB0aGlzLnN0YXJ0U2lkZSA8PSAwID8gZXhwb3J0cy5CbG9ja1R5cGUuV2lkZ2V0QmVmb3JlIDogZXhwb3J0cy5CbG9ja1R5cGUuV2lkZ2V0QWZ0ZXI7XG4gICAgfVxuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgfHwgISF0aGlzLndpZGdldCAmJiAodGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID49IDUgfHwgdGhpcy53aWRnZXQubGluZUJyZWFrcyA+IDApO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gJiZcbiAgICAgICAgICAgIHdpZGdldHNFcSh0aGlzLndpZGdldCwgb3RoZXIud2lkZ2V0KSAmJlxuICAgICAgICAgICAgdGhpcy5ibG9jayA9PSBvdGhlci5ibG9jayAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydFNpZGUgPT0gb3RoZXIuc3RhcnRTaWRlICYmIHRoaXMuZW5kU2lkZSA9PSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXBsYWNlICYmIChmcm9tID4gdG8gfHwgKGZyb20gPT0gdG8gJiYgdGhpcy5zdGFydFNpZGUgPiAwICYmIHRoaXMuZW5kU2lkZSA8PSAwKSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcmFuZ2UgZm9yIHJlcGxhY2VtZW50IGRlY29yYXRpb25cIik7XG4gICAgICAgIGlmICghdGhpcy5pc1JlcGxhY2UgJiYgdG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV2lkZ2V0IGRlY29yYXRpb25zIGNhbiBvbmx5IGhhdmUgemVyby1sZW5ndGggcmFuZ2VzXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cblBvaW50RGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuZnVuY3Rpb24gZ2V0SW5jbHVzaXZlKHNwZWMsIGJsb2NrID0gZmFsc2UpIHtcbiAgICBsZXQgeyBpbmNsdXNpdmVTdGFydDogc3RhcnQsIGluY2x1c2l2ZUVuZDogZW5kIH0gPSBzcGVjO1xuICAgIGlmIChzdGFydCA9PSBudWxsKVxuICAgICAgICBzdGFydCA9IHNwZWMuaW5jbHVzaXZlO1xuICAgIGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0ICE9PSBudWxsICYmIHN0YXJ0ICE9PSB2b2lkIDAgPyBzdGFydCA6IGJsb2NrLCBlbmQ6IGVuZCAhPT0gbnVsbCAmJiBlbmQgIT09IHZvaWQgMCA/IGVuZCA6IGJsb2NrIH07XG59XG5mdW5jdGlvbiB3aWRnZXRzRXEoYSwgYikge1xuICAgIHJldHVybiBhID09IGIgfHwgISEoYSAmJiBiICYmIGEuY29tcGFyZShiKSk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZShmcm9tLCB0bywgcmFuZ2VzLCBtYXJnaW4gPSAwKSB7XG4gICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XSArIG1hcmdpbiA+PSBmcm9tKVxuICAgICAgICByYW5nZXNbbGFzdF0gPSBNYXRoLm1heChyYW5nZXNbbGFzdF0sIHRvKTtcbiAgICBlbHNlXG4gICAgICAgIHJhbmdlcy5wdXNoKGZyb20sIHRvKTtcbn1cblxuY2xhc3MgTGluZVZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hdHRycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IDA7XG4gICAgfVxuICAgIC8vIENvbnN1bWVzIHNvdXJjZVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgTGluZVZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgc291cmNlLnRyYW5zZmVyRE9NKHRoaXMpOyAvLyBSZXVzZSBzb3VyY2UuZG9tIHdoZW4gYXBwcm9wcmlhdGVcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzU3RhcnQpXG4gICAgICAgICAgICB0aGlzLnNldERlY28oc291cmNlID8gc291cmNlLmF0dHJzIDogbnVsbCk7XG4gICAgICAgIG1lcmdlQ2hpbGRyZW5JbnRvKHRoaXMsIGZyb20sIHRvLCBzb3VyY2UgPyBzb3VyY2UuY2hpbGRyZW4uc2xpY2UoKSA6IFtdLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoYXQpIHtcbiAgICAgICAgbGV0IGVuZCA9IG5ldyBMaW5lVmlldztcbiAgICAgICAgZW5kLmJyZWFrQWZ0ZXIgPSB0aGlzLmJyZWFrQWZ0ZXI7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkUG9zKGF0KTtcbiAgICAgICAgaWYgKG9mZikge1xuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2ldLnNwbGl0KG9mZiksIDApO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5tZXJnZShvZmYsIHRoaXMuY2hpbGRyZW5baV0ubGVuZ3RoLCBudWxsLCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2pdLCAwKTtcbiAgICAgICAgd2hpbGUgKGkgPiAwICYmIHRoaXMuY2hpbGRyZW5baSAtIDFdLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblstLWldLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSBpO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICB0cmFuc2ZlckRPTShvdGhlcikge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICBvdGhlci5zZXRET00odGhpcy5kb20pO1xuICAgICAgICBvdGhlci5wcmV2QXR0cnMgPSB0aGlzLnByZXZBdHRycyA9PT0gdW5kZWZpbmVkID8gdGhpcy5hdHRycyA6IHRoaXMucHJldkF0dHJzO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgIH1cbiAgICBzZXREZWNvKGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnNFcSh0aGlzLmF0dHJzLCBhdHRycykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGVuZChjaGlsZCwgb3BlblN0YXJ0KSB7XG4gICAgICAgIGpvaW5JbmxpbmVJbnRvKHRoaXMsIGNoaWxkLCBvcGVuU3RhcnQpO1xuICAgIH1cbiAgICAvLyBPbmx5IGNhbGxlZCB3aGVuIGJ1aWxkaW5nIGEgbGluZSB2aWV3IGluIENvbnRlbnRCdWlsZGVyXG4gICAgYWRkTGluZURlY28oZGVjbykge1xuICAgICAgICBsZXQgYXR0cnMgPSBkZWNvLnNwZWMuYXR0cmlidXRlcywgY2xzID0gZGVjby5zcGVjLmNsYXNzO1xuICAgICAgICBpZiAoYXR0cnMpXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gY29tYmluZUF0dHJzKGF0dHJzLCB0aGlzLmF0dHJzIHx8IHt9KTtcbiAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBjb21iaW5lQXR0cnMoeyBjbGFzczogY2xzIH0sIHRoaXMuYXR0cnMgfHwge30pO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIGlubGluZURPTUF0UG9zKHRoaXMsIHBvcyk7XG4gICAgfVxuICAgIHJldXNlRE9NKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJESVZcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRET00obm9kZSk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLyB8IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZsYWdzICYgNCAvKiBWaWV3RmxhZy5BdHRyc0RpcnR5ICovKSB7XG4gICAgICAgICAgICBjbGVhckF0dHJpYnV0ZXModGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnMgPyBudWxsIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZBdHRycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1cGRhdGVBdHRycyh0aGlzLmRvbSwgdGhpcy5wcmV2QXR0cnMsIHRoaXMuYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxpbmVcIik7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbS5sYXN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChsYXN0ICYmIENvbnRlbnRWaWV3LmdldChsYXN0KSBpbnN0YW5jZW9mIE1hcmtWaWV3KVxuICAgICAgICAgICAgbGFzdCA9IGxhc3QubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgIXRoaXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBsYXN0Lm5vZGVOYW1lICE9IFwiQlJcIiAmJiAoKF9hID0gQ29udGVudFZpZXcuZ2V0KGxhc3QpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFZGl0YWJsZSkgPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAoIWJyb3dzZXIuaW9zIHx8ICF0aGlzLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUZXh0VmlldykpKSB7XG4gICAgICAgICAgICBsZXQgaGFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJCUlwiKTtcbiAgICAgICAgICAgIGhhY2suY21JZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoaGFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVRleHRTaXplKCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCB0aGlzLmxlbmd0aCA+IDIwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0b3RhbFdpZHRoID0gMCwgdGV4dEhlaWdodDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBUZXh0VmlldykgfHwgL1teIC1+XS8udGVzdChjaGlsZC50ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkLmRvbSk7XG4gICAgICAgICAgICBpZiAocmVjdHMubGVuZ3RoICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0b3RhbFdpZHRoICs9IHJlY3RzWzBdLndpZHRoO1xuICAgICAgICAgICAgdGV4dEhlaWdodCA9IHJlY3RzWzBdLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRvdGFsV2lkdGggPyBudWxsIDoge1xuICAgICAgICAgICAgbGluZUhlaWdodDogdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LFxuICAgICAgICAgICAgY2hhcldpZHRoOiB0b3RhbFdpZHRoIC8gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICB0ZXh0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgcmVjdCA9IGNvb3Jkc0luQ2hpbGRyZW4odGhpcywgcG9zLCBzaWRlKTtcbiAgICAgICAgLy8gQ29ycmVjdCByZWN0YW5nbGUgaGVpZ2h0IGZvciBlbXB0eSBsaW5lcyB3aGVuIHRoZSByZXR1cm5lZFxuICAgICAgICAvLyBoZWlnaHQgaXMgbGFyZ2VyIHRoYW4gdGhlIHRleHQgaGVpZ2h0LlxuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHJlY3QgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGxldCB7IGhlaWdodE9yYWNsZSB9ID0gdGhpcy5wYXJlbnQudmlldy52aWV3U3RhdGUsIGhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQpIDwgMiAmJiBoZWlnaHRPcmFjbGUudGV4dEhlaWdodCA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gKGhlaWdodCAtIGhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiByZWN0LnRvcCArIGRpc3QsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBkaXN0LCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIExpbmVWaWV3ICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDAgJiYgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgIGF0dHJzRXEodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmIHRoaXMuYnJlYWtBZnRlciA9PSBvdGhlci5icmVha0FmdGVyO1xuICAgIH1cbiAgICBjb3ZlcnMoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgc3RhdGljIGZpbmQoZG9jVmlldywgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgZG9jVmlldy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gZG9jVmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgYmxvY2subGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gZW5kICsgYmxvY2suYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBCbG9ja1dpZGdldFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIGRlY28pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmRlY28gPSBkZWNvO1xuICAgICAgICB0aGlzLmJyZWFrQWZ0ZXIgPSAwO1xuICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBfdGFrZURlY28sIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldykgfHwgIXRoaXMud2lkZ2V0LmNvbXBhcmUoc291cmNlLndpZGdldCkgfHxcbiAgICAgICAgICAgIGZyb20gPiAwICYmIG9wZW5TdGFydCA8PSAwIHx8IHRvIDwgdGhpcy5sZW5ndGggJiYgb3BlbkVuZCA8PSAwKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tICsgKHNvdXJjZSA/IHNvdXJjZS5sZW5ndGggOiAwKSArICh0aGlzLmxlbmd0aCAtIHRvKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID09IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgc3BsaXQoYXQpIHtcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMubGVuZ3RoIC0gYXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXQ7XG4gICAgICAgIGxldCBlbmQgPSBuZXcgQmxvY2tXaWRnZXRWaWV3KHRoaXMud2lkZ2V0LCBsZW4sIHRoaXMuZGVjbyk7XG4gICAgICAgIGVuZC5icmVha0FmdGVyID0gdGhpcy5icmVha0FmdGVyO1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBub0NoaWxkcmVuOyB9XG4gICAgc3luYyh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy5kb20gfHwgIXRoaXMud2lkZ2V0LnVwZGF0ZURPTSh0aGlzLmRvbSwgdmlldykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiB0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMud2lkZ2V0LnRvRE9NKHZpZXcpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy53aWRnZXQuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnZpZXcuc3RhdGUuZG9jLnNsaWNlKHRoaXMucG9zQXRTdGFydCwgdGhpcy5wb3NBdEVuZCkgOiBzdGF0ZS5UZXh0LmVtcHR5O1xuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJlxuICAgICAgICAgICAgb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yID09IHRoaXMud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIW90aGVyLndpZGdldC5jb21wYXJlKHRoaXMud2lkZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG90aGVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZGVjbyA9IG90aGVyLmRlY287XG4gICAgICAgICAgICB0aGlzLmJyZWFrQWZ0ZXIgPSBvdGhlci5icmVha0FmdGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBpZ25vcmVFdmVudChldmVudCkgeyByZXR1cm4gdGhpcy53aWRnZXQuaWdub3JlRXZlbnQoZXZlbnQpOyB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpc1dpZGdldCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHRoaXMud2lkZ2V0LmNvb3Jkc0F0KHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgaWYgKHRoaXMud2lkZ2V0IGluc3RhbmNlb2YgQmxvY2tHYXBXaWRnZXQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0aGlzLmxlbmd0aCA/IHBvcyA9PSAwIDogc2lkZSA8PSAwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICB9XG4gICAgY292ZXJzKHNpZGUpIHtcbiAgICAgICAgbGV0IHsgc3RhcnRTaWRlLCBlbmRTaWRlIH0gPSB0aGlzLmRlY287XG4gICAgICAgIHJldHVybiBzdGFydFNpZGUgPT0gZW5kU2lkZSA/IGZhbHNlIDogc2lkZSA8IDAgPyBzdGFydFNpZGUgPCAwIDogZW5kU2lkZSA+IDA7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tHYXBXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IFwiY20tZ2FwXCI7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5oZWlnaHQgPT0gdGhpcy5oZWlnaHQ7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBlZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5oZWlnaHQ7IH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbmNsYXNzIENvbnRlbnRCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2MsIHBvcywgZW5kLCBkaXNhbGxvd0Jsb2NrRWZmZWN0c0Zvcikge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmRpc2FsbG93QmxvY2tFZmZlY3RzRm9yID0gZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3I7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLmJyZWFrQXRTdGFydCA9IDA7XG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICB0aGlzLmJ1ZmZlck1hcmtzID0gW107XG4gICAgICAgIC8vIFNldCB0byBmYWxzZSBkaXJlY3RseSBhZnRlciBhIHdpZGdldCB0aGF0IGNvdmVycyB0aGUgcG9zaXRpb24gYWZ0ZXIgaXRcbiAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMub3BlbkVuZCA9IC0xO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgICAgIHRoaXMuc2tpcCA9IHBvcztcbiAgICB9XG4gICAgcG9zQ292ZXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5icmVha0F0U3RhcnQgJiYgdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tICE9IHRoaXMucG9zO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiAhKGxhc3QuYnJlYWtBZnRlciB8fCBsYXN0IGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIGxhc3QuZGVjby5lbmRTaWRlIDwgMCk7XG4gICAgfVxuICAgIGdldExpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh0aGlzLmN1ckxpbmUgPSBuZXcgTGluZVZpZXcpO1xuICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyTGluZTtcbiAgICB9XG4gICAgZmx1c2hCdWZmZXIoYWN0aXZlID0gdGhpcy5idWZmZXJNYXJrcykge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUuYXBwZW5kKHdyYXBNYXJrcyhuZXcgV2lkZ2V0QnVmZmVyVmlldygtMSksIGFjdGl2ZSksIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQmxvY2tXaWRnZXQodmlldykge1xuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGVudC5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICBmaW5pc2gob3BlbkVuZCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyICYmIG9wZW5FbmQgPD0gdGhpcy5idWZmZXJNYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICBpZiAoIXRoaXMucG9zQ292ZXJlZCgpICYmXG4gICAgICAgICAgICAhKG9wZW5FbmQgJiYgdGhpcy5jb250ZW50Lmxlbmd0aCAmJiB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3KSlcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgIH1cbiAgICBidWlsZFRleHQobGVuZ3RoLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiA9PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdmFsdWUsIGxpbmVCcmVhaywgZG9uZSB9ID0gdGhpcy5jdXJzb3IubmV4dCh0aGlzLnNraXApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbiBvdXQgb2YgdGV4dCBjb250ZW50IHdoZW4gZHJhd2luZyBpbmxpbmUgdmlld3NcIik7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXS5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFrZSA9IE1hdGgubWluKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYsIGxlbmd0aCwgNTEyIC8qIFQuQ2h1bmsgKi8pO1xuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcihhY3RpdmUuc2xpY2UoYWN0aXZlLmxlbmd0aCAtIG9wZW5TdGFydCkpO1xuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYXBwZW5kKHdyYXBNYXJrcyhuZXcgVGV4dFZpZXcodGhpcy50ZXh0LnNsaWNlKHRoaXMudGV4dE9mZiwgdGhpcy50ZXh0T2ZmICsgdGFrZSkpLCBhY3RpdmUpLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gdGFrZTtcbiAgICAgICAgICAgIGxlbmd0aCAtPSB0YWtlO1xuICAgICAgICAgICAgb3BlblN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzcGFuKGZyb20sIHRvLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB0aGlzLmJ1aWxkVGV4dCh0byAtIGZyb20sIGFjdGl2ZSwgb3BlblN0YXJ0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgIH1cbiAgICBwb2ludChmcm9tLCB0bywgZGVjbywgYWN0aXZlLCBvcGVuU3RhcnQsIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FsbG93QmxvY2tFZmZlY3RzRm9yW2luZGV4XSAmJiBkZWNvIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJsb2NrIGRlY29yYXRpb25zIG1heSBub3QgYmUgc3BlY2lmaWVkIHZpYSBwbHVnaW5zXCIpO1xuICAgICAgICAgICAgaWYgKHRvID4gdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS50bylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRlY29yYXRpb25zIHRoYXQgcmVwbGFjZSBsaW5lIGJyZWFrcyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoZGVjbyBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjby5zdGFydFNpZGUgPiAwICYmICF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9ja1dpZGdldChuZXcgQmxvY2tXaWRnZXRWaWV3KGRlY28ud2lkZ2V0IHx8IE51bGxXaWRnZXQuYmxvY2ssIGxlbiwgZGVjbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXcgPSBXaWRnZXRWaWV3LmNyZWF0ZShkZWNvLndpZGdldCB8fCBOdWxsV2lkZ2V0LmlubGluZSwgbGVuLCBsZW4gPyAwIDogZGVjby5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JCZWZvcmUgPSB0aGlzLmF0Q3Vyc29yUG9zICYmICF2aWV3LmlzRWRpdGFibGUgJiYgb3BlblN0YXJ0IDw9IGFjdGl2ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKGZyb20gPCB0byB8fCBkZWNvLnN0YXJ0U2lkZSA+IDApO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JBZnRlciA9ICF2aWV3LmlzRWRpdGFibGUgJiYgKGZyb20gPCB0byB8fCBvcGVuU3RhcnQgPiBhY3RpdmUubGVuZ3RoIHx8IGRlY28uc3RhcnRTaWRlIDw9IDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciA9PSAyIC8qIEJ1Zi5JZkN1cnNvciAqLyAmJiAhY3Vyc29yQmVmb3JlICYmICF2aWV3LmlzRWRpdGFibGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUuYXBwZW5kKHdyYXBNYXJrcyhuZXcgV2lkZ2V0QnVmZmVyVmlldygxKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYWN0aXZlLmxlbmd0aCArIE1hdGgubWF4KDAsIG9wZW5TdGFydCAtIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3ModmlldywgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gY3Vyc29yQWZ0ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gIWN1cnNvckFmdGVyID8gMCAvKiBCdWYuTm8gKi8gOiBmcm9tIDwgdG8gfHwgb3BlblN0YXJ0ID4gYWN0aXZlLmxlbmd0aCA/IDEgLyogQnVmLlllcyAqLyA6IDIgLyogQnVmLklmQ3Vyc29yICovO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyTWFya3MgPSBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gPT0gdGhpcy5wb3MpIHsgLy8gTGluZSBkZWNvcmF0aW9uXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKS5hZGRMaW5lRGVjbyhkZWNvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBpdGVyYXRvciBwYXN0IHRoZSByZXBsYWNlZCBjb250ZW50XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmICsgbGVuIDw9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwICs9IGxlbiAtICh0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKHRleHQsIGZyb20sIHRvLCBkZWNvcmF0aW9ucywgZHluYW1pY0RlY29yYXRpb25NYXApIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgQ29udGVudEJ1aWxkZXIodGV4dCwgZnJvbSwgdG8sIGR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgYnVpbGRlci5vcGVuRW5kID0gc3RhdGUuUmFuZ2VTZXQuc3BhbnMoZGVjb3JhdGlvbnMsIGZyb20sIHRvLCBidWlsZGVyKTtcbiAgICAgICAgaWYgKGJ1aWxkZXIub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIGJ1aWxkZXIub3BlblN0YXJ0ID0gYnVpbGRlci5vcGVuRW5kO1xuICAgICAgICBidWlsZGVyLmZpbmlzaChidWlsZGVyLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwTWFya3ModmlldywgYWN0aXZlKSB7XG4gICAgZm9yIChsZXQgbWFyayBvZiBhY3RpdmUpXG4gICAgICAgIHZpZXcgPSBuZXcgTWFya1ZpZXcobWFyaywgW3ZpZXddLCB2aWV3Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZpZXc7XG59XG5jbGFzcyBOdWxsV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodGFnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIudGFnID09IHRoaXMudGFnOyB9XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnKTsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHsgcmV0dXJuIGVsdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IHRoaXMudGFnOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuTnVsbFdpZGdldC5pbmxpbmUgPSBuZXcgTnVsbFdpZGdldChcInNwYW5cIik7XG5OdWxsV2lkZ2V0LmJsb2NrID0gbmV3IE51bGxXaWRnZXQoXCJkaXZcIik7XG5cbi8qKlxuVXNlZCB0byBpbmRpY2F0ZSBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuKi9cbmV4cG9ydHMuRGlyZWN0aW9uID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICAvLyAoVGhlc2UgYXJlIGNob3NlbiB0byBtYXRjaCB0aGUgYmFzZSBsZXZlbHMsIGluIGJpZGkgYWxnb3JpdGhtXG4gICAgLy8gdGVybXMsIG9mIHNwYW5zIGluIHRoYXQgZGlyZWN0aW9uLilcbiAgICAvKipcbiAgICBMZWZ0LXRvLXJpZ2h0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcbiAgICAvKipcbiAgICBSaWdodC10by1sZWZ0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbn0pKGV4cG9ydHMuRGlyZWN0aW9uIHx8IChleHBvcnRzLkRpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBMVFIgPSBleHBvcnRzLkRpcmVjdGlvbi5MVFIsIFJUTCA9IGV4cG9ydHMuRGlyZWN0aW9uLlJUTDtcbi8vIERlY29kZSBhIHN0cmluZyB3aXRoIGVhY2ggdHlwZSBlbmNvZGVkIGFzIGxvZzIodHlwZSlcbmZ1bmN0aW9uIGRlYyhzdHIpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdC5wdXNoKDEgPDwgK3N0cltpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAwIHRvIDB4ZjhcbmNvbnN0IExvd1R5cGVzID0gZGVjKFwiODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg2NjY4ODg4ODg3ODc4MzMzMzMzMzMzMzc4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODc4NjY2Njg4ODgwODg4ODg2NjMzODA4ODgzMDg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDhcIik7XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbmNvbnN0IEFyYWJpY1R5cGVzID0gZGVjKFwiNDQ0NDQ0ODgyNjYyNzI4ODk5OTk5OTk5OTk5MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyOTk5OTk5OTk5OTk5OTk5OTk5OTk5NDQ0NDQ0NDQ0NDY0NDIyMjgyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk0OTk5OTk5OTIyOTk4OTk5OTIyMzMzMzMzMzMzM1wiKTtcbmNvbnN0IEJyYWNrZXRzID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgQnJhY2tldFN0YWNrID0gW107XG4vLyBUaGVyZSdzIGEgbG90IG1vcmUgaW5cbi8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9CaWRpQnJhY2tldHMudHh0LFxuLy8gd2hpY2ggYXJlIGxlZnQgb3V0IHRvIGtlZXAgY29kZSBzaXplIGRvd24uXG5mb3IgKGxldCBwIG9mIFtcIigpXCIsIFwiW11cIiwgXCJ7fVwiXSkge1xuICAgIGxldCBsID0gcC5jaGFyQ29kZUF0KDApLCByID0gcC5jaGFyQ29kZUF0KDEpO1xuICAgIEJyYWNrZXRzW2xdID0gcjtcbiAgICBCcmFja2V0c1tyXSA9IC1sO1xufVxuZnVuY3Rpb24gY2hhclR5cGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPD0gMHhmNyA/IExvd1R5cGVzW2NoXSA6XG4gICAgICAgIDB4NTkwIDw9IGNoICYmIGNoIDw9IDB4NWY0ID8gMiAvKiBULlIgKi8gOlxuICAgICAgICAgICAgMHg2MDAgPD0gY2ggJiYgY2ggPD0gMHg2ZjkgPyBBcmFiaWNUeXBlc1tjaCAtIDB4NjAwXSA6XG4gICAgICAgICAgICAgICAgMHg2ZWUgPD0gY2ggJiYgY2ggPD0gMHg4YWMgPyA0IC8qIFQuQUwgKi8gOlxuICAgICAgICAgICAgICAgICAgICAweDIwMDAgPD0gY2ggJiYgY2ggPD0gMHgyMDBjID8gMjU2IC8qIFQuTkkgKi8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgMHhmYjUwIDw9IGNoICYmIGNoIDw9IDB4ZmRmZiA/IDQgLyogVC5BTCAqLyA6IDEgLyogVC5MICovO1xufVxuY29uc3QgQmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNcXHVmYjUwLVxcdWZkZmZdLztcbi8qKlxuUmVwcmVzZW50cyBhIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgdGV4dCB0aGF0IGhhcyBhIHNpbmdsZSBkaXJlY3Rpb25cbihhcyBpbiBsZWZ0LXRvLXJpZ2h0IG9yIHJpZ2h0LXRvLWxlZnQpLlxuKi9cbmNsYXNzIEJpZGlTcGFuIHtcbiAgICAvKipcbiAgICBUaGUgZGlyZWN0aW9uIG9mIHRoaXMgc3Bhbi5cbiAgICAqL1xuICAgIGdldCBkaXIoKSB7IHJldHVybiB0aGlzLmxldmVsICUgMiA/IFJUTCA6IExUUjsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBzcGFuIChyZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgc3Bhbi5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgW1wiYmlkaVxuICAgIGxldmVsXCJdKGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvI0Jhc2ljX0Rpc3BsYXlfQWxnb3JpdGhtKVxuICAgIG9mIHRoZSBzcGFuIChpbiB0aGlzIGNvbnRleHQsIDAgbWVhbnNcbiAgICBsZWZ0LXRvLXJpZ2h0LCAxIG1lYW5zIHJpZ2h0LXRvLWxlZnQsIDIgbWVhbnMgbGVmdC10by1yaWdodFxuICAgIG51bWJlciBpbnNpZGUgcmlnaHQtdG8tbGVmdCB0ZXh0KS5cbiAgICAqL1xuICAgIGxldmVsKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNpZGUoZW5kLCBkaXIpIHsgcmV0dXJuICh0aGlzLmRpciA9PSBkaXIpID09IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcndhcmQoZm9yd2FyZCwgZGlyKSB7IHJldHVybiBmb3J3YXJkID09ICh0aGlzLmRpciA9PSBkaXIpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZChvcmRlciwgaW5kZXgsIGxldmVsLCBhc3NvYykge1xuICAgICAgICBsZXQgbWF5YmUgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltpXTtcbiAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPD0gaW5kZXggJiYgc3Bhbi50byA+PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGFuLmxldmVsID09IGxldmVsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIG11bHRpcGxlIHNwYW5zIG1hdGNoLCBpZiBhc3NvYyAhPSAwLCB0YWtlIHRoZSBvbmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGNvdmVycyB0aGF0IHNpZGUsIG90aGVyd2lzZSB0YWtlIHRoZSBvbmUgd2l0aCB0aGUgbWluaW11bVxuICAgICAgICAgICAgICAgIC8vIGxldmVsLlxuICAgICAgICAgICAgICAgIGlmIChtYXliZSA8IDAgfHwgKGFzc29jICE9IDAgPyAoYXNzb2MgPCAwID8gc3Bhbi5mcm9tIDwgaW5kZXggOiBzcGFuLnRvID4gaW5kZXgpIDogb3JkZXJbbWF5YmVdLmxldmVsID4gc3Bhbi5sZXZlbCkpXG4gICAgICAgICAgICAgICAgICAgIG1heWJlID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBtYXliZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc29sYXRlc0VxKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGlBID0gYVtpXSwgaUIgPSBiW2ldO1xuICAgICAgICBpZiAoaUEuZnJvbSAhPSBpQi5mcm9tIHx8IGlBLnRvICE9IGlCLnRvIHx8IGlBLmRpcmVjdGlvbiAhPSBpQi5kaXJlY3Rpb24gfHwgIWlzb2xhdGVzRXEoaUEuaW5uZXIsIGlCLmlubmVyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBSZXVzZWQgYXJyYXkgb2YgY2hhcmFjdGVyIHR5cGVzXG5jb25zdCB0eXBlcyA9IFtdO1xuLy8gRmlsbCBpbiB0aGUgY2hhcmFjdGVyIHR5cGVzIChpbiBgdHlwZXNgKSBmcm9tIGBmcm9tYCB0byBgdG9gIGFuZFxuLy8gYXBwbHkgVyBub3JtYWxpemF0aW9uIHJ1bGVzLlxuZnVuY3Rpb24gY29tcHV0ZUNoYXJUeXBlcyhsaW5lLCByRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgZm9yIChsZXQgaUkgPSAwOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICBsZXQgcHJldlR5cGUgPSBpSSA/IDI1NiAvKiBULk5JICovIDogb3V0ZXJUeXBlO1xuICAgICAgICAvLyBXMS4gRXhhbWluZSBlYWNoIG5vbi1zcGFjaW5nIG1hcmsgKE5TTSkgaW4gdGhlIGxldmVsIHJ1biwgYW5kXG4gICAgICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAgICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHNvci5cbiAgICAgICAgLy8gVzIuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcbiAgICAgICAgLy8gbnVtYmVyLlxuICAgICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAgICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4sIEFOLCBFVCwgQ1MsIE5JKVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbSwgcHJldiA9IHByZXZUeXBlLCBwcmV2U3Ryb25nID0gcHJldlR5cGU7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IGNoYXJUeXBlKGxpbmUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSA1MTIgLyogVC5OU00gKi8pXG4gICAgICAgICAgICAgICAgdHlwZSA9IHByZXY7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDQgLyogVC5BTCAqLylcbiAgICAgICAgICAgICAgICB0eXBlID0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZSA9PSA0IC8qIFQuQUwgKi8gPyAyIC8qIFQuUiAqLyA6IHR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSAmIDcgLyogVC5TdHJvbmcgKi8pXG4gICAgICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgICAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlclxuICAgICAgICAvLyBOZXV0cmFsLlxuICAgICAgICAvLyBXNy4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOLCBOSSlcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIHByZXYgPSBwcmV2VHlwZSwgcHJldlN0cm9uZyA9IHByZXZUeXBlOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IDEyOCAvKiBULkNTICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0byAtIDEgJiYgcHJldiA9PSB0eXBlc1tpICsgMV0gJiYgKHByZXYgJiAyNCAvKiBULk51bSAqLykpXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlc1tpXSA9IHByZXY7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IDI1NiAvKiBULk5JICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA2NCAvKiBULkVUICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbmQgPCB0byAmJiB0eXBlc1tlbmRdID09IDY0IC8qIFQuRVQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlID0gKGkgJiYgcHJldiA9PSA4IC8qIFQuRU4gKi8pIHx8IChlbmQgPCByVG8gJiYgdHlwZXNbZW5kXSA9PSA4IC8qIFQuRU4gKi8pID8gKHByZXZTdHJvbmcgPT0gMSAvKiBULkwgKi8gPyAxIC8qIFQuTCAqLyA6IDggLyogVC5FTiAqLykgOiAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGVuZDsgaisrKVxuICAgICAgICAgICAgICAgICAgICB0eXBlc1tqXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICAgICAgaSA9IGVuZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gUHJvY2VzcyBicmFja2V0cyB0aHJvdWdob3V0IGEgcnVuIHNlcXVlbmNlLlxuZnVuY3Rpb24gcHJvY2Vzc0JyYWNrZXRQYWlycyhsaW5lLCByRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgbGV0IG9wcG9zaXRlVHlwZSA9IG91dGVyVHlwZSA9PSAxIC8qIFQuTCAqLyA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XG4gICAgZm9yIChsZXQgaUkgPSAwLCBzSSA9IDAsIGNvbnRleHQgPSAwOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAvLyBOMC4gUHJvY2VzcyBicmFja2V0IHBhaXJzIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2VcbiAgICAgICAgLy8gc2VxdWVudGlhbGx5IGluIHRoZSBsb2dpY2FsIG9yZGVyIG9mIHRoZSB0ZXh0IHBvc2l0aW9ucyBvZiB0aGVcbiAgICAgICAgLy8gb3BlbmluZyBwYWlyZWQgYnJhY2tldHMgdXNpbmcgdGhlIGxvZ2ljIGdpdmVuIGJlbG93LiBXaXRoaW4gdGhpc1xuICAgICAgICAvLyBzY29wZSwgYmlkaXJlY3Rpb25hbCB0eXBlcyBFTiBhbmQgQU4gYXJlIHRyZWF0ZWQgYXMgUi5cbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIGNoLCBiciwgdHlwZTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEtlZXBzIFtzdGFydEluZGV4LCB0eXBlLCBzdHJvbmdTZWVuXSB0cmlwbGVzIGZvciBlYWNoIG9wZW5cbiAgICAgICAgICAgIC8vIGJyYWNrZXQgb24gQnJhY2tldFN0YWNrLlxuICAgICAgICAgICAgaWYgKGJyID0gQnJhY2tldHNbY2ggPSBsaW5lLmNoYXJDb2RlQXQoaSldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyIDwgMCkgeyAvLyBDbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCcmFja2V0U3RhY2tbc0ogKyAxXSA9PSAtYnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IChmbGFncyAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKSA/IG91dGVyVHlwZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoZmxhZ3MgJiA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLykgPyAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbGFncyAmIDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovKSA/IG9wcG9zaXRlVHlwZSA6IG91dGVyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXNbaV0gPSB0eXBlc1tCcmFja2V0U3RhY2tbc0pdXSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc0kgPSBzSjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCcmFja2V0U3RhY2subGVuZ3RoID09IDE4OSAvKiBCcmFja2V0ZWQuTWF4RGVwdGggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBpO1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZSA9IHR5cGVzW2ldKSA9PSAyIC8qIFQuUiAqLyB8fCB0eXBlID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVtYmVkID0gdHlwZSA9PSBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGVtYmVkID8gMCA6IDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXIgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NOZXV0cmFscyhyRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgZm9yIChsZXQgaUkgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgICAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgICAgICAvLyBkaXJlY3Rpb24uIEV1cm9wZWFuIGFuZCBBcmFiaWMgbnVtYmVycyBhY3QgYXMgaWYgdGhleSB3ZXJlIFIgaW5cbiAgICAgICAgLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcbiAgICAgICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgICAgIC8vIE4yLiBBbnkgcmVtYWluaW5nIG5ldXRyYWxzIHRha2UgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOKVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IDI1NiAvKiBULk5JICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA9PSB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlJID09IGlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlzb2xhdGVzW2lJKytdLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzW2VuZF0gPT0gMjU2IC8qIFQuTkkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZUwgPSBwcmV2ID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgICAgIGxldCBhZnRlckwgPSAoZW5kIDwgclRvID8gdHlwZXNbZW5kXSA6IG91dGVyVHlwZSkgPT0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSBiZWZvcmVMID09IGFmdGVyTCA/IChiZWZvcmVMID8gMSAvKiBULkwgKi8gOiAyIC8qIFQuUiAqLykgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGVuZCwgakkgPSBpSSwgZnJvbUogPSBqSSA/IGlzb2xhdGVzW2pJIC0gMV0udG8gOiByRnJvbTsgaiA+IGk7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09IGZyb21KKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gaXNvbGF0ZXNbLS1qSV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21KID0gakkgPyBpc29sYXRlc1tqSSAtIDFdLnRvIDogckZyb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbLS1qXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBGaW5kIHRoZSBjb250aWd1b3VzIHJhbmdlcyBvZiBjaGFyYWN0ZXIgdHlwZXMgaW4gYSBnaXZlbiByYW5nZSwgYW5kXG4vLyBlbWl0IHNwYW5zIGZvciB0aGVtLiBGbGlwIHRoZSBvcmRlciBvZiB0aGUgc3BhbnMgYXMgYXBwcm9wcmlhdGVcbi8vIGJhc2VkIG9uIHRoZSBsZXZlbCwgYW5kIGNhbGwgdGhyb3VnaCB0byBjb21wdXRlIHRoZSBzcGFucyBmb3Jcbi8vIGlzb2xhdGVzIGF0IHRoZSBwcm9wZXIgcG9pbnQuXG5mdW5jdGlvbiBlbWl0U3BhbnMobGluZSwgZnJvbSwgdG8sIGxldmVsLCBiYXNlTGV2ZWwsIGlzb2xhdGVzLCBvcmRlcikge1xuICAgIGxldCBvdXJUeXBlID0gbGV2ZWwgJSAyID8gMiAvKiBULlIgKi8gOiAxIC8qIFQuTCAqLztcbiAgICBpZiAoKGxldmVsICUgMikgPT0gKGJhc2VMZXZlbCAlIDIpKSB7IC8vIFNhbWUgZGlyIGFzIGJhc2UgZGlyZWN0aW9uLCBkb24ndCBmbGlwXG4gICAgICAgIGZvciAobGV0IGlDaCA9IGZyb20sIGlJID0gMDsgaUNoIDwgdG87KSB7XG4gICAgICAgICAgICAvLyBTY2FuIGEgc2VjdGlvbiBvZiBjaGFyYWN0ZXJzIGluIGRpcmVjdGlvbiBvdXJUeXBlLCB1bmxlc3NcbiAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW5vdGhlciB0eXBlIG9mIGNoYXIgcmlnaHQgYWZ0ZXIgaUNoLCBpbiB3aGljaCBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBzY2FuIGEgc2VjdGlvbiBvZiBvdGhlciBjaGFyYWN0ZXJzICh3aGljaCwgaWYgb3VyVHlwZSA9PVxuICAgICAgICAgICAgLy8gVC5MLCBtYXkgY29udGFpbiBib3RoIFQuUiBhbmQgVC5BTiBjaGFycykuXG4gICAgICAgICAgICBsZXQgc2FtZURpciA9IHRydWUsIGlzTnVtID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaUkgPT0gaXNvbGF0ZXMubGVuZ3RoIHx8IGlDaCA8IGlzb2xhdGVzW2lJXS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0eXBlc1tpQ2hdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IG91clR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZURpciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpc051bSA9IG5leHQgPT0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIb2xkcyBhbiBhcnJheSBvZiBpc29sYXRlcyB0byBwYXNzIHRvIGEgcmVjdXJzaXZlIGNhbGwgaWYgd2VcbiAgICAgICAgICAgIC8vIG11c3QgcmVjdXJzZSAodG8gZGlzdGluZ3Vpc2ggVC5BTiBpbnNpZGUgYW4gUlRMIHNlY3Rpb24gaW5cbiAgICAgICAgICAgIC8vIExUUiB0ZXh0KSwgbnVsbCBpZiB3ZSBjYW4gZW1pdCBkaXJlY3RseVxuICAgICAgICAgICAgbGV0IHJlY3Vyc2UgPSAhc2FtZURpciAmJiBvdXJUeXBlID09IDEgLyogVC5MICovID8gW10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGxvY2FsTGV2ZWwgPSBzYW1lRGlyID8gbGV2ZWwgOiBsZXZlbCArIDE7XG4gICAgICAgICAgICBsZXQgaVNjYW4gPSBpQ2g7XG4gICAgICAgICAgICBydW46IGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoaUkgPCBpc29sYXRlcy5sZW5ndGggJiYgaVNjYW4gPT0gaXNvbGF0ZXNbaUldLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNvID0gaXNvbGF0ZXNbaUldO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FuIGFoZWFkIHRvIHZlcmlmeSB0aGF0IHRoZXJlIGlzIGFub3RoZXIgY2hhciBpbiB0aGlzIGRpciBhZnRlciB0aGUgaXNvbGF0ZShzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEaXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1cHRvID0gaXNvLnRvLCBqSSA9IGlJICsgMTs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwdG8gPT0gdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoakkgPCBpc29sYXRlcy5sZW5ndGggJiYgaXNvbGF0ZXNbakldLmZyb20gPT0gdXB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0byA9IGlzb2xhdGVzW2pJKytdLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzW3VwdG9dID09IG91clR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpSSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZS5wdXNoKGlzbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvLmZyb20gPiBpQ2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaUNoLCBpc28uZnJvbSwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpclN3YXAgPSAoaXNvLmRpcmVjdGlvbiA9PSBMVFIpICE9ICEobG9jYWxMZXZlbCAlIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBkaXJTd2FwID8gbGV2ZWwgKyAxIDogbGV2ZWwsIGJhc2VMZXZlbCwgaXNvLmlubmVyLCBpc28uZnJvbSwgaXNvLnRvLCBvcmRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpQ2ggPSBpc28udG87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaVNjYW4gPSBpc28udG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuID09IHRvIHx8IChzYW1lRGlyID8gdHlwZXNbaVNjYW5dICE9IG91clR5cGUgOiB0eXBlc1tpU2Nhbl0gPT0gb3VyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpU2NhbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN1cnNlKVxuICAgICAgICAgICAgICAgIGVtaXRTcGFucyhsaW5lLCBpQ2gsIGlTY2FuLCBsZXZlbCArIDEsIGJhc2VMZXZlbCwgcmVjdXJzZSwgb3JkZXIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaUNoIDwgaVNjYW4pXG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaUNoLCBpU2NhbiwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgaUNoID0gaVNjYW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEl0ZXJhdGUgaW4gcmV2ZXJzZSB0byBmbGlwIHRoZSBzcGFuIG9yZGVyLiBTYW1lIGNvZGUgYWdhaW4sIGJ1dFxuICAgICAgICAvLyBnb2luZyBmcm9tIHRoZSBiYWNrIG9mIHRoZSBzZWN0aW9uIHRvIHRoZSBmcm9udFxuICAgICAgICBmb3IgKGxldCBpQ2ggPSB0bywgaUkgPSBpc29sYXRlcy5sZW5ndGg7IGlDaCA+IGZyb207KSB7XG4gICAgICAgICAgICBsZXQgc2FtZURpciA9IHRydWUsIGlzTnVtID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWlJIHx8IGlDaCA+IGlzb2xhdGVzW2lJIC0gMV0udG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHR5cGVzW2lDaCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IG91clR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZURpciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpc051bSA9IG5leHQgPT0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVjdXJzZSA9ICFzYW1lRGlyICYmIG91clR5cGUgPT0gMSAvKiBULkwgKi8gPyBbXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbG9jYWxMZXZlbCA9IHNhbWVEaXIgPyBsZXZlbCA6IGxldmVsICsgMTtcbiAgICAgICAgICAgIGxldCBpU2NhbiA9IGlDaDtcbiAgICAgICAgICAgIHJ1bjogZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChpSSAmJiBpU2NhbiA9PSBpc29sYXRlc1tpSSAtIDFdLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzbyA9IGlzb2xhdGVzWy0taUldO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FuIGFoZWFkIHRvIHZlcmlmeSB0aGF0IHRoZXJlIGlzIGFub3RoZXIgY2hhciBpbiB0aGlzIGRpciBhZnRlciB0aGUgaXNvbGF0ZShzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEaXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1cHRvID0gaXNvLmZyb20sIGpJID0gaUk7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHRvID09IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoakkgJiYgaXNvbGF0ZXNbakkgLSAxXS50byA9PSB1cHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHRvID0gaXNvbGF0ZXNbLS1qSV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1t1cHRvIC0gMV0gPT0gb3VyVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNlLnB1c2goaXNvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc28udG8gPCBpQ2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaXNvLnRvLCBpQ2gsIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXJTd2FwID0gKGlzby5kaXJlY3Rpb24gPT0gTFRSKSAhPSAhKGxvY2FsTGV2ZWwgJSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgZGlyU3dhcCA/IGxldmVsICsgMSA6IGxldmVsLCBiYXNlTGV2ZWwsIGlzby5pbm5lciwgaXNvLmZyb20sIGlzby50bywgb3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaUNoID0gaXNvLmZyb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaVNjYW4gPSBpc28uZnJvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaVNjYW4gPT0gZnJvbSB8fCAoc2FtZURpciA/IHR5cGVzW2lTY2FuIC0gMV0gIT0gb3VyVHlwZSA6IHR5cGVzW2lTY2FuIC0gMV0gPT0gb3VyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpU2Nhbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN1cnNlKVxuICAgICAgICAgICAgICAgIGVtaXRTcGFucyhsaW5lLCBpU2NhbiwgaUNoLCBsZXZlbCArIDEsIGJhc2VMZXZlbCwgcmVjdXJzZSwgb3JkZXIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaVNjYW4gPCBpQ2gpXG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaVNjYW4sIGlDaCwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgaUNoID0gaVNjYW47XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGxldmVsLCBiYXNlTGV2ZWwsIGlzb2xhdGVzLCBmcm9tLCB0bywgb3JkZXIpIHtcbiAgICBsZXQgb3V0ZXJUeXBlID0gKGxldmVsICUgMiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi8pO1xuICAgIGNvbXB1dGVDaGFyVHlwZXMobGluZSwgZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIHByb2Nlc3NCcmFja2V0UGFpcnMobGluZSwgZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIHByb2Nlc3NOZXV0cmFscyhmcm9tLCB0bywgaXNvbGF0ZXMsIG91dGVyVHlwZSk7XG4gICAgZW1pdFNwYW5zKGxpbmUsIGZyb20sIHRvLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgb3JkZXIpO1xufVxuZnVuY3Rpb24gY29tcHV0ZU9yZGVyKGxpbmUsIGRpcmVjdGlvbiwgaXNvbGF0ZXMpIHtcbiAgICBpZiAoIWxpbmUpXG4gICAgICAgIHJldHVybiBbbmV3IEJpZGlTcGFuKDAsIDAsIGRpcmVjdGlvbiA9PSBSVEwgPyAxIDogMCldO1xuICAgIGlmIChkaXJlY3Rpb24gPT0gTFRSICYmICFpc29sYXRlcy5sZW5ndGggJiYgIUJpZGlSRS50ZXN0KGxpbmUpKVxuICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxpbmUubGVuZ3RoKTtcbiAgICBpZiAoaXNvbGF0ZXMubGVuZ3RoKVxuICAgICAgICB3aGlsZSAobGluZS5sZW5ndGggPiB0eXBlcy5sZW5ndGgpXG4gICAgICAgICAgICB0eXBlc1t0eXBlcy5sZW5ndGhdID0gMjU2IC8qIFQuTkkgKi87IC8vIE1ha2Ugc3VyZSB0eXBlcyBhcnJheSBoYXMgbm8gZ2Fwc1xuICAgIGxldCBvcmRlciA9IFtdLCBsZXZlbCA9IGRpcmVjdGlvbiA9PSBMVFIgPyAwIDogMTtcbiAgICBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGxldmVsLCBsZXZlbCwgaXNvbGF0ZXMsIDAsIGxpbmUubGVuZ3RoLCBvcmRlcik7XG4gICAgcmV0dXJuIG9yZGVyO1xufVxuZnVuY3Rpb24gdHJpdmlhbE9yZGVyKGxlbmd0aCkge1xuICAgIHJldHVybiBbbmV3IEJpZGlTcGFuKDAsIGxlbmd0aCwgMCldO1xufVxubGV0IG1vdmVkT3ZlciA9IFwiXCI7XG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIG1vdmVzIHN0cmljdGx5IHZpc3VhbGx5LCB3aXRob3V0IGNvbmNlcm4gZm9yIGFcbi8vIHRyYXZlcnNhbCB2aXNpdGluZyBldmVyeSBsb2dpY2FsIHBvc2l0aW9uIGluIHRoZSBzdHJpbmcuIEl0IHdpbGxcbi8vIHN0aWxsIGRvIHNvIGZvciBzaW1wbGUgaW5wdXQsIGJ1dCBzaXR1YXRpb25zIGxpa2UgbXVsdGlwbGUgaXNvbGF0ZXNcbi8vIHdpdGggdGhlIHNhbWUgbGV2ZWwgbmV4dCB0byBlYWNoIG90aGVyLCBvciB0ZXh0IGdvaW5nIGFnYWluc3QgdGhlXG4vLyBtYWluIGRpciBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLCB3aWxsIG1ha2Ugc29tZSBwb3NpdGlvbnNcbi8vIHVucmVhY2hhYmxlIHdpdGggdGhpcyBtb3Rpb24uIEVhY2ggdmlzaWJsZSBjdXJzb3IgcG9zaXRpb24gd2lsbFxuLy8gY29ycmVzcG9uZCB0byB0aGUgbG93ZXItbGV2ZWwgYmlkaSBzcGFuIHRoYXQgdG91Y2hlcyBpdC5cbi8vXG4vLyBUaGUgYWx0ZXJuYXRpdmUgd291bGQgYmUgdG8gc29sdmUgYW4gb3JkZXIgZ2xvYmFsbHkgZm9yIGEgZ2l2ZW5cbi8vIGxpbmUsIG1ha2luZyBzdXJlIHRoYXQgaXQgaW5jbHVkZXMgZXZlcnkgcG9zaXRpb24sIGJ1dCB0aGF0IHdvdWxkXG4vLyByZXF1aXJlIGFzc29jaWF0aW5nIG5vbi1jYW5vbmljYWwgKGhpZ2hlciBiaWRpIHNwYW4gbGV2ZWwpXG4vLyBwb3NpdGlvbnMgd2l0aCBhIGdpdmVuIHZpc3VhbCBwb3NpdGlvbiwgd2hpY2ggaXMgbGlrZWx5IHRvIGNvbmZ1c2Vcbi8vIHBlb3BsZS4gKEFuZCB3b3VsZCBnZW5lcmFsbHkgYmUgYSBsb3QgbW9yZSBjb21wbGljYXRlZC4pXG5mdW5jdGlvbiBtb3ZlVmlzdWFsbHkobGluZSwgb3JkZXIsIGRpciwgc3RhcnQsIGZvcndhcmQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydC5oZWFkIC0gbGluZS5mcm9tO1xuICAgIGxldCBzcGFuSSA9IEJpZGlTcGFuLmZpbmQob3JkZXIsIHN0YXJ0SW5kZXgsIChfYSA9IHN0YXJ0LmJpZGlMZXZlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTEsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgc3BhbiA9IG9yZGVyW3NwYW5JXSwgc3BhbkVuZCA9IHNwYW4uc2lkZShmb3J3YXJkLCBkaXIpO1xuICAgIC8vIEVuZCBvZiBzcGFuXG4gICAgaWYgKHN0YXJ0SW5kZXggPT0gc3BhbkVuZCkge1xuICAgICAgICBsZXQgbmV4dEkgPSBzcGFuSSArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICBpZiAobmV4dEkgPCAwIHx8IG5leHRJID49IG9yZGVyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBzcGFuID0gb3JkZXJbc3BhbkkgPSBuZXh0SV07XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzcGFuLnNpZGUoIWZvcndhcmQsIGRpcik7XG4gICAgICAgIHNwYW5FbmQgPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKTtcbiAgICB9XG4gICAgbGV0IG5leHRJbmRleCA9IHN0YXRlLmZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBzdGFydEluZGV4LCBzcGFuLmZvcndhcmQoZm9yd2FyZCwgZGlyKSk7XG4gICAgaWYgKG5leHRJbmRleCA8IHNwYW4uZnJvbSB8fCBuZXh0SW5kZXggPiBzcGFuLnRvKVxuICAgICAgICBuZXh0SW5kZXggPSBzcGFuRW5kO1xuICAgIG1vdmVkT3ZlciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihzdGFydEluZGV4LCBuZXh0SW5kZXgpLCBNYXRoLm1heChzdGFydEluZGV4LCBuZXh0SW5kZXgpKTtcbiAgICBsZXQgbmV4dFNwYW4gPSBzcGFuSSA9PSAoZm9yd2FyZCA/IG9yZGVyLmxlbmd0aCAtIDEgOiAwKSA/IG51bGwgOiBvcmRlcltzcGFuSSArIChmb3J3YXJkID8gMSA6IC0xKV07XG4gICAgaWYgKG5leHRTcGFuICYmIG5leHRJbmRleCA9PSBzcGFuRW5kICYmIG5leHRTcGFuLmxldmVsICsgKGZvcndhcmQgPyAwIDogMSkgPCBzcGFuLmxldmVsKVxuICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0U3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpICsgbGluZS5mcm9tLCBuZXh0U3Bhbi5mb3J3YXJkKGZvcndhcmQsIGRpcikgPyAxIDogLTEsIG5leHRTcGFuLmxldmVsKTtcbiAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0SW5kZXggKyBsaW5lLmZyb20sIHNwYW4uZm9yd2FyZChmb3J3YXJkLCBkaXIpID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcbn1cbmZ1bmN0aW9uIGF1dG9EaXJlY3Rpb24odGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgbGV0IHR5cGUgPSBjaGFyVHlwZSh0ZXh0LmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICBpZiAodHlwZSA9PSAxIC8qIFQuTCAqLylcbiAgICAgICAgICAgIHJldHVybiBMVFI7XG4gICAgICAgIGlmICh0eXBlID09IDIgLyogVC5SICovIHx8IHR5cGUgPT0gNCAvKiBULkFMICovKVxuICAgICAgICAgICAgcmV0dXJuIFJUTDtcbiAgICB9XG4gICAgcmV0dXJuIExUUjtcbn1cblxuY29uc3QgY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UgPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRyYWdNb3Zlc1NlbGVjdGlvbiQxID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBtb3VzZVNlbGVjdGlvblN0eWxlID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBleGNlcHRpb25TaW5rID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB1cGRhdGVMaXN0ZW5lciA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuY29uc3QgaW5wdXRIYW5kbGVyID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBmb2N1c0NoYW5nZUVmZmVjdCA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuY29uc3QgY2xpcGJvYXJkSW5wdXRGaWx0ZXIgPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGNsaXBib2FyZE91dHB1dEZpbHRlciA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuY29uc3QgcGVyTGluZVRleHREaXJlY3Rpb24gPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpXG59KTtcbmNvbnN0IG5hdGl2ZVNlbGVjdGlvbkhpZGRlbiA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuY29uc3Qgc2Nyb2xsSGFuZGxlciA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuY2xhc3MgU2Nyb2xsVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgeSA9IFwibmVhcmVzdFwiLCB4ID0gXCJuZWFyZXN0XCIsIHlNYXJnaW4gPSA1LCB4TWFyZ2luID0gNSwgXG4gICAgLy8gVGhpcyBkYXRhIHN0cnVjdHVyZSBpcyBhYnVzZWQgdG8gYWxzbyBzdG9yZSBwcmVjaXNlIHNjcm9sbFxuICAgIC8vIHNuYXBzaG90cywgaW5zdGVhZCBvZiBhIGBzY3JvbGxJbnRvVmlld2AgcmVxdWVzdC4gV2hlbiB0aGlzXG4gICAgLy8gZmxhZyBpcyBgdHJ1ZWAsIGByYW5nZWAgcG9pbnRzIGF0IGEgcG9zaXRpb24gaW4gdGhlIHJlZmVyZW5jZVxuICAgIC8vIGxpbmUsIGB5TWFyZ2luYCBob2xkcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhhdFxuICAgIC8vIGxpbmUgYW5kIHRoZSB0b3Agb2YgdGhlIGVkaXRvciwgYW5kIGB4TWFyZ2luYCBob2xkcyB0aGVcbiAgICAvLyBlZGl0b3IncyBgc2Nyb2xsTGVmdGAuXG4gICAgaXNTbmFwc2hvdCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55TWFyZ2luID0geU1hcmdpbjtcbiAgICAgICAgdGhpcy54TWFyZ2luID0geE1hcmdpbjtcbiAgICAgICAgdGhpcy5pc1NuYXBzaG90ID0gaXNTbmFwc2hvdDtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZW1wdHkgPyB0aGlzIDpcbiAgICAgICAgICAgIG5ldyBTY3JvbGxUYXJnZXQodGhpcy5yYW5nZS5tYXAoY2hhbmdlcyksIHRoaXMueSwgdGhpcy54LCB0aGlzLnlNYXJnaW4sIHRoaXMueE1hcmdpbiwgdGhpcy5pc1NuYXBzaG90KTtcbiAgICB9XG4gICAgY2xpcChzdGF0ZSQxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlLnRvIDw9IHN0YXRlJDEuZG9jLmxlbmd0aCA/IHRoaXMgOlxuICAgICAgICAgICAgbmV3IFNjcm9sbFRhcmdldChzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXRlJDEuZG9jLmxlbmd0aCksIHRoaXMueSwgdGhpcy54LCB0aGlzLnlNYXJnaW4sIHRoaXMueE1hcmdpbiwgdGhpcy5pc1NuYXBzaG90KTtcbiAgICB9XG59XG5jb25zdCBzY3JvbGxJbnRvVmlldyA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogKHQsIGNoKSA9PiB0Lm1hcChjaCkgfSk7XG5jb25zdCBzZXRFZGl0Q29udGV4dEZvcm1hdHRpbmcgPSBzdGF0ZS5TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuTG9nIG9yIHJlcG9ydCBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIGluIGNsaWVudCBjb2RlLiBTaG91bGRcbnByb2JhYmx5IG9ubHkgYmUgdXNlZCBieSBleHRlbnNpb24gY29kZSB0aGF0IGFsbG93cyBjbGllbnQgY29kZSB0b1xucHJvdmlkZSBmdW5jdGlvbnMsIGFuZCBjYWxscyB0aG9zZSBmdW5jdGlvbnMgaW4gYSBjb250ZXh0IHdoZXJlIGFuXG5leGNlcHRpb24gY2FuJ3QgYmUgcHJvcGFnYXRlZCB0byBjYWxsaW5nIGNvZGUgaW4gYSByZWFzb25hYmxlIHdheVxuKGZvciBleGFtcGxlIHdoZW4gaW4gYW4gZXZlbnQgaGFuZGxlcikuXG5cbkVpdGhlciBjYWxscyBhIGhhbmRsZXIgcmVnaXN0ZXJlZCB3aXRoXG5bYEVkaXRvclZpZXcuZXhjZXB0aW9uU2lua2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmV4Y2VwdGlvblNpbmspLFxuYHdpbmRvdy5vbmVycm9yYCwgaWYgZGVmaW5lZCwgb3IgYGNvbnNvbGUuZXJyb3JgIChpbiB3aGljaCBjYXNlXG5pdCdsbCBwYXNzIGBjb250ZXh0YCwgd2hlbiBnaXZlbiwgYXMgZmlyc3QgYXJndW1lbnQpLlxuKi9cbmZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbihzdGF0ZSwgZXhjZXB0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IGhhbmRsZXIgPSBzdGF0ZS5mYWNldChleGNlcHRpb25TaW5rKTtcbiAgICBpZiAoaGFuZGxlci5sZW5ndGgpXG4gICAgICAgIGhhbmRsZXJbMF0oZXhjZXB0aW9uKTtcbiAgICBlbHNlIGlmICh3aW5kb3cub25lcnJvcilcbiAgICAgICAgd2luZG93Lm9uZXJyb3IoU3RyaW5nKGV4Y2VwdGlvbiksIGNvbnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBleGNlcHRpb24pO1xuICAgIGVsc2UgaWYgKGNvbnRleHQpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY29udGV4dCArIFwiOlwiLCBleGNlcHRpb24pO1xuICAgIGVsc2VcbiAgICAgICAgY29uc29sZS5lcnJvcihleGNlcHRpb24pO1xufVxuY29uc3QgZWRpdGFibGUgPSBzdGF0ZS5GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IHRydWUgfSk7XG5sZXQgbmV4dFBsdWdpbklEID0gMDtcbmNvbnN0IHZpZXdQbHVnaW4gPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbi8qKlxuVmlldyBwbHVnaW5zIGFzc29jaWF0ZSBzdGF0ZWZ1bCB2YWx1ZXMgd2l0aCBhIHZpZXcuIFRoZXkgY2FuXG5pbmZsdWVuY2UgdGhlIHdheSB0aGUgY29udGVudCBpcyBkcmF3biwgYW5kIGFyZSBub3RpZmllZCBvZiB0aGluZ3NcbnRoYXQgaGFwcGVuIGluIHRoZSB2aWV3LlxuKi9cbmNsYXNzIFZpZXdQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbUV2ZW50SGFuZGxlcnMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tRXZlbnRPYnNlcnZlcnMsIGJ1aWxkRXh0ZW5zaW9ucykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICB0aGlzLmRvbUV2ZW50SGFuZGxlcnMgPSBkb21FdmVudEhhbmRsZXJzO1xuICAgICAgICB0aGlzLmRvbUV2ZW50T2JzZXJ2ZXJzID0gZG9tRXZlbnRPYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gYnVpbGRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBwbHVnaW4gZnJvbSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGVcbiAgICBwbHVnaW4ncyB2YWx1ZSwgZ2l2ZW4gYW4gZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNyZWF0ZSwgc3BlYykge1xuICAgICAgICBjb25zdCB7IGV2ZW50SGFuZGxlcnMsIGV2ZW50T2JzZXJ2ZXJzLCBwcm92aWRlLCBkZWNvcmF0aW9uczogZGVjbyB9ID0gc3BlYyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3UGx1Z2luKG5leHRQbHVnaW5JRCsrLCBjcmVhdGUsIGV2ZW50SGFuZGxlcnMsIGV2ZW50T2JzZXJ2ZXJzLCBwbHVnaW4gPT4ge1xuICAgICAgICAgICAgbGV0IGV4dCA9IFt2aWV3UGx1Z2luLm9mKHBsdWdpbildO1xuICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgZXh0LnB1c2goZGVjb3JhdGlvbnMub2YodmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW5JbnN0ID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkluc3QgPyBkZWNvKHBsdWdpbkluc3QpIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlKVxuICAgICAgICAgICAgICAgIGV4dC5wdXNoKHByb3ZpZGUocGx1Z2luKSk7XG4gICAgICAgICAgICByZXR1cm4gZXh0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGZvciBhIGNsYXNzIHdob3NlIGNvbnN0cnVjdG9yIHRha2VzIGEgc2luZ2xlXG4gICAgZWRpdG9yIHZpZXcgYXMgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUNsYXNzKGNscywgc3BlYykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgY2xzKHZpZXcpLCBzcGVjKTtcbiAgICB9XG59XG5jbGFzcyBQbHVnaW5JbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvLyBXaGVuIHN0YXJ0aW5nIGFuIHVwZGF0ZSwgYWxsIHBsdWdpbnMgaGF2ZSB0aGlzIGZpZWxkIHNldCB0byB0aGVcbiAgICAgICAgLy8gdXBkYXRlIG9iamVjdCwgaW5kaWNhdGluZyB0aGV5IG5lZWQgdG8gYmUgdXBkYXRlZC4gV2hlbiBmaW5pc2hlZFxuICAgICAgICAvLyB1cGRhdGluZywgaXQgaXMgc2V0IHRvIGBmYWxzZWAuIFJldHJpZXZpbmcgYSBwbHVnaW4gdGhhdCBuZWVkcyB0b1xuICAgICAgICAvLyBiZSB1cGRhdGVkIHdpdGggYHZpZXcucGx1Z2luYCBmb3JjZXMgYW4gZWFnZXIgdXBkYXRlLlxuICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGlzIG51bGwgd2hlbiB0aGUgcGx1Z2luIGlzIGluaXRpYWxseSBjcmVhdGVkLCBidXRcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgb24gdGhlIGZpcnN0IHVwZGF0ZS5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BlYykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNwZWMuY3JlYXRlKHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tdXN0VXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gdGhpcy5tdXN0VXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih1cGRhdGUuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuZGVzdHJveSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSh2aWV3KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbn1cbmNvbnN0IGVkaXRvckF0dHJpYnV0ZXMgPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGNvbnRlbnRBdHRyaWJ1dGVzID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG4vLyBQcm92aWRlIGRlY29yYXRpb25zXG5jb25zdCBkZWNvcmF0aW9ucyA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuY29uc3Qgb3V0ZXJEZWNvcmF0aW9ucyA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuY29uc3QgYXRvbWljUmFuZ2VzID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBiaWRpSXNvbGF0ZWRSYW5nZXMgPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbmZ1bmN0aW9uIGdldElzb2xhdGVkUmFuZ2VzKHZpZXcsIGxpbmUpIHtcbiAgICBsZXQgaXNvbGF0ZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGJpZGlJc29sYXRlZFJhbmdlcyk7XG4gICAgaWYgKCFpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBpc29sYXRlcztcbiAgICBsZXQgc2V0cyA9IGlzb2xhdGVzLm1hcChpID0+IGkgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGkodmlldykgOiBpKTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgc3RhdGUuUmFuZ2VTZXQuc3BhbnMoc2V0cywgbGluZS5mcm9tLCBsaW5lLnRvLCB7XG4gICAgICAgIHBvaW50KCkgeyB9LFxuICAgICAgICBzcGFuKGZyb21Eb2MsIHRvRG9jLCBhY3RpdmUsIG9wZW4pIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZnJvbURvYyAtIGxpbmUuZnJvbSwgdG8gPSB0b0RvYyAtIGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IHJlc3VsdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBhY3RpdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0sIG9wZW4tLSkge1xuICAgICAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBhY3RpdmVbaV0uc3BlYy5iaWRpSXNvbGF0ZSwgdXBkYXRlO1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gYXV0b0RpcmVjdGlvbihsaW5lLnRleHQsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICBpZiAob3BlbiA+IDAgJiYgbGV2ZWwubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICh1cGRhdGUgPSBsZXZlbFtsZXZlbC5sZW5ndGggLSAxXSkudG8gPT0gZnJvbSAmJiB1cGRhdGUuZGlyZWN0aW9uID09IGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUudG8gPSB0bztcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSB1cGRhdGUuaW5uZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkID0geyBmcm9tLCB0bywgZGlyZWN0aW9uLCBpbm5lcjogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwucHVzaChhZGQpO1xuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IGFkZC5pbm5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgc2Nyb2xsTWFyZ2lucyA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsTWFyZ2lucyh2aWV3KSB7XG4gICAgbGV0IGxlZnQgPSAwLCByaWdodCA9IDAsIHRvcCA9IDAsIGJvdHRvbSA9IDA7XG4gICAgZm9yIChsZXQgc291cmNlIG9mIHZpZXcuc3RhdGUuZmFjZXQoc2Nyb2xsTWFyZ2lucykpIHtcbiAgICAgICAgbGV0IG0gPSBzb3VyY2Uodmlldyk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBpZiAobS5sZWZ0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIG0ubGVmdCk7XG4gICAgICAgICAgICBpZiAobS5yaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIG0ucmlnaHQpO1xuICAgICAgICAgICAgaWYgKG0udG9wICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBtLnRvcCk7XG4gICAgICAgICAgICBpZiAobS5ib3R0b20gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChib3R0b20sIG0uYm90dG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfTtcbn1cbmNvbnN0IHN0eWxlTW9kdWxlID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG5jbGFzcyBDaGFuZ2VkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpIHtcbiAgICAgICAgdGhpcy5mcm9tQSA9IGZyb21BO1xuICAgICAgICB0aGlzLnRvQSA9IHRvQTtcbiAgICAgICAgdGhpcy5mcm9tQiA9IGZyb21CO1xuICAgICAgICB0aGlzLnRvQiA9IHRvQjtcbiAgICB9XG4gICAgam9pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZWRSYW5nZShNYXRoLm1pbih0aGlzLmZyb21BLCBvdGhlci5mcm9tQSksIE1hdGgubWF4KHRoaXMudG9BLCBvdGhlci50b0EpLCBNYXRoLm1pbih0aGlzLmZyb21CLCBvdGhlci5mcm9tQiksIE1hdGgubWF4KHRoaXMudG9CLCBvdGhlci50b0IpKTtcbiAgICB9XG4gICAgYWRkVG9TZXQoc2V0KSB7XG4gICAgICAgIGxldCBpID0gc2V0Lmxlbmd0aCwgbWUgPSB0aGlzO1xuICAgICAgICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2V0W2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tQSA+IG1lLnRvQSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50b0EgPCBtZS5mcm9tQSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG1lID0gbWUuam9pbihyYW5nZSk7XG4gICAgICAgICAgICBzZXQuc3BsaWNlKGkgLSAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuc3BsaWNlKGksIDAsIG1lKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgc3RhdGljIGV4dGVuZFdpdGhSYW5nZXMoZGlmZiwgcmFuZ2VzKSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkSSA9IDAsIHJJID0gMCwgcG9zQSA9IDAsIHBvc0IgPSAwOzsgZEkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBkSSA9PSBkaWZmLmxlbmd0aCA/IG51bGwgOiBkaWZmW2RJXSwgb2ZmID0gcG9zQSAtIHBvc0I7XG4gICAgICAgICAgICBsZXQgZW5kID0gbmV4dCA/IG5leHQuZnJvbUIgOiAxZTk7XG4gICAgICAgICAgICB3aGlsZSAockkgPCByYW5nZXMubGVuZ3RoICYmIHJhbmdlc1tySV0gPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tySV0sIHRvID0gcmFuZ2VzW3JJICsgMV07XG4gICAgICAgICAgICAgICAgbGV0IGZyb21CID0gTWF0aC5tYXgocG9zQiwgZnJvbSksIHRvQiA9IE1hdGgubWluKGVuZCwgdG8pO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQiA8PSB0b0IpXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUIgKyBvZmYsIHRvQiArIG9mZiwgZnJvbUIsIHRvQikuYWRkVG9TZXQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAodG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgckkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgbmV3IENoYW5nZWRSYW5nZShuZXh0LmZyb21BLCBuZXh0LnRvQSwgbmV4dC5mcm9tQiwgbmV4dC50b0IpLmFkZFRvU2V0KHJlc3VsdCk7XG4gICAgICAgICAgICBwb3NBID0gbmV4dC50b0E7XG4gICAgICAgICAgICBwb3NCID0gbmV4dC50b0I7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblZpZXcgW3BsdWdpbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKSBhcmUgZ2l2ZW4gaW5zdGFuY2VzIG9mIHRoaXNcbmNsYXNzLCB3aGljaCBkZXNjcmliZSB3aGF0IGhhcHBlbmVkLCB3aGVuZXZlciB0aGUgdmlldyBpcyB1cGRhdGVkLlxuKi9cbmNsYXNzIFZpZXdVcGRhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3IgdmlldyB0aGF0IHRoZSB1cGRhdGUgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgICovXG4gICAgdmlldywgXG4gICAgLyoqXG4gICAgVGhlIG5ldyBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSQxLCBcbiAgICAvKipcbiAgICBUaGUgdHJhbnNhY3Rpb25zIGludm9sdmVkIGluIHRoZSB1cGRhdGUuIE1heSBiZSBlbXB0eS5cbiAgICAqL1xuICAgIHRyYW5zYWN0aW9ucykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGUkMTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IHN0YXRlLkNoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5jb21wb3NlKHRyLmNoYW5nZXMpO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IGNoYW5nZWRSYW5nZXMucHVzaChuZXcgQ2hhbmdlZFJhbmdlKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZFJhbmdlcyA9IGNoYW5nZWRSYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1VwZGF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIFt2aWV3cG9ydF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlld3BvcnQpIG9yXG4gICAgW3Zpc2libGUgcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aXNpYmxlUmFuZ2VzKSBjaGFuZ2VkIGluIHRoaXNcbiAgICB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGhlaWdodCBvZiBhIGJsb2NrIGVsZW1lbnQgaW4gdGhlIGVkaXRvclxuICAgIGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZG9jdW1lbnQgd2FzIG1vZGlmaWVkIG9yIHRoZSBzaXplIG9mIHRoZVxuICAgIGVkaXRvciwgb3IgZWxlbWVudHMgd2l0aGluIHRoZSBlZGl0b3IsIGNoYW5nZWQuXG4gICAgKi9cbiAgICBnZXQgZ2VvbWV0cnlDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NDaGFuZ2VkIHx8ICh0aGlzLmZsYWdzICYgKDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLyB8IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIHVwZGF0ZSBpbmRpY2F0ZXMgYSBmb2N1cyBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZm9jdXNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZG9jdW1lbnQgY2hhbmdlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2hhbmdlcy5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHNldCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLnNlbGVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mbGFncyA9PSAwICYmIHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCA9PSAwOyB9XG59XG5cbmNsYXNzIERvY1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoOyB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXAgPSBbZmFsc2VdO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZWQgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc0NvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbiA9IG5ldyBTZXQ7XG4gICAgICAgIHRoaXMuZWRpdENvbnRleHRGb3JtYXR0aW5nID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB0aGlzLmxhc3RDb21wb3NpdGlvbkFmdGVyQ3Vyc29yID0gZmFsc2U7XG4gICAgICAgIC8vIFRyYWNrIGEgbWluaW11bSB3aWR0aCBmb3IgdGhlIGVkaXRvci4gV2hlbiBtZWFzdXJpbmcgc2l6ZXMgaW5cbiAgICAgICAgLy8gbWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cywgdGhpcyBpcyB1cGRhdGVkIHRvIHBvaW50IGF0IHRoZSB3aWR0aFxuICAgICAgICAvLyBvZiBhIGdpdmVuIGVsZW1lbnQgYW5kIGl0cyBleHRlbnQgaW4gdGhlIGRvY3VtZW50LiBXaGVuIGEgY2hhbmdlXG4gICAgICAgIC8vIGhhcHBlbnMgaW4gdGhhdCByYW5nZSwgdGhlc2UgYXJlIHJlc2V0LiBUaGF0IHdheSwgb25jZSB3ZSd2ZSBzZWVuXG4gICAgICAgIC8vIGEgbGluZS9lbGVtZW50IG9mIGEgZ2l2ZW4gbGVuZ3RoLCB3ZSBrZWVwIHRoZSBlZGl0b3Igd2lkZSBlbm91Z2hcbiAgICAgICAgLy8gdG8gZml0IGF0IGxlYXN0IHRoYXQgZWxlbWVudCwgdW50aWwgaXQgaXMgY2hhbmdlZCwgYXQgd2hpY2ggcG9pbnRcbiAgICAgICAgLy8gd2UgZm9yZ2V0IGl0IGFnYWluLlxuICAgICAgICB0aGlzLm1pbldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAvLyBUcmFjayB3aGV0aGVyIHRoZSBET00gc2VsZWN0aW9uIHdhcyBzZXQgaW4gYSBsb3NzeSB3YXksIHNvIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgbWVzcyBpdCB1cCB3aGVuIHJlYWRpbmcgaXQgYmFjayBpdFxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlSGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgcmVzaXplIG9ic2VydmVyIHRvIGlnbm9yZSByZXNpemVzIHRoYXQgd2UgY2F1c2VkXG4gICAgICAgIC8vIG91cnNlbHZlc1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnNldERPTSh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMaW5lVmlld107XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0uc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vIFVwZGF0ZSB0aGUgZG9jdW1lbnQgdmlldyB0byBhIGdpdmVuIHN0YXRlLlxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xuICAgICAgICBpZiAodGhpcy5taW5XaWR0aCA+IDAgJiYgY2hhbmdlZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghY2hhbmdlZFJhbmdlcy5ldmVyeSgoeyBmcm9tQSwgdG9BIH0pID0+IHRvQSA8IHRoaXMubWluV2lkdGhGcm9tIHx8IGZyb21BID4gdGhpcy5taW5XaWR0aFRvKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSB0aGlzLm1pbldpZHRoRnJvbSA9IHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoRnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhUbywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVFZGl0Q29udGV4dEZvcm1hdHRpbmcodXBkYXRlKTtcbiAgICAgICAgbGV0IHJlYWRDb21wb3NpdGlvbkF0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJiAhdGhpcy52aWV3Lm9ic2VydmVyLmVkaXRDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5kb21DaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV3U2VsKVxuICAgICAgICAgICAgICAgIHJlYWRDb21wb3NpdGlvbkF0ID0gdGhpcy5kb21DaGFuZ2VkLm5ld1NlbC5oZWFkO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXRvdWNoZXNDb21wb3NpdGlvbih1cGRhdGUuY2hhbmdlcywgdGhpcy5oYXNDb21wb3NpdGlvbikgJiYgIXVwZGF0ZS5zZWxlY3Rpb25TZXQpXG4gICAgICAgICAgICAgICAgcmVhZENvbXBvc2l0aW9uQXQgPSB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSByZWFkQ29tcG9zaXRpb25BdCA+IC0xID8gZmluZENvbXBvc2l0aW9uUmFuZ2UodGhpcy52aWV3LCB1cGRhdGUuY2hhbmdlcywgcmVhZENvbXBvc2l0aW9uQXQpIDogbnVsbDtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24uY2xlYXIoKTtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLmhhc0NvbXBvc2l0aW9uO1xuICAgICAgICAgICAgY2hhbmdlZFJhbmdlcyA9IG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbSwgdG8sIHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyhmcm9tLCAtMSksIHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0bywgMSkpXG4gICAgICAgICAgICAgICAgLmFkZFRvU2V0KGNoYW5nZWRSYW5nZXMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNDb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uID8geyBmcm9tOiBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiwgdG86IGNvbXBvc2l0aW9uLnJhbmdlLnRvQiB9IDogbnVsbDtcbiAgICAgICAgLy8gV2hlbiB0aGUgRE9NIG5vZGVzIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGFyZSBtb3ZlZCB0byBhbm90aGVyXG4gICAgICAgIC8vIHBhcmVudCwgQ2hyb21lIHNvbWV0aW1lcyByZXBvcnRzIGEgZGlmZmVyZW50IHNlbGVjdGlvbiB0aHJvdWdoXG4gICAgICAgIC8vIGdldFNlbGVjdGlvbiB0aGFuIHRoZSBvbmUgdGhhdCBpdCBhY3R1YWxseSBzaG93cyB0byB0aGUgdXNlci5cbiAgICAgICAgLy8gVGhpcyBmb3JjZXMgYSBzZWxlY3Rpb24gdXBkYXRlIHdoZW4gbGluZXMgYXJlIGpvaW5lZCB0byB3b3JrXG4gICAgICAgIC8vIGFyb3VuZCB0aGF0LiBJc3N1ZSAjNTRcbiAgICAgICAgaWYgKChicm93c2VyLmllIHx8IGJyb3dzZXIuY2hyb21lKSAmJiAhY29tcG9zaXRpb24gJiYgdXBkYXRlICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuZG9jLmxpbmVzICE9IHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lcylcbiAgICAgICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBsZXQgcHJldkRlY28gPSB0aGlzLmRlY29yYXRpb25zLCBkZWNvID0gdGhpcy51cGRhdGVEZWNvKCk7XG4gICAgICAgIGxldCBkZWNvRGlmZiA9IGZpbmRDaGFuZ2VkRGVjbyhwcmV2RGVjbywgZGVjbywgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBjaGFuZ2VkUmFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY2hhbmdlZFJhbmdlcywgZGVjb0RpZmYpO1xuICAgICAgICBpZiAoISh0aGlzLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLykgJiYgY2hhbmdlZFJhbmdlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbm5lcihjaGFuZ2VkUmFuZ2VzLCB1cGRhdGUuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoLCBjb21wb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgYnkgdXBkYXRlIGFuZCB0aGUgY29uc3RydWN0b3IgZG8gcGVyZm9ybSB0aGUgYWN0dWFsIERPTVxuICAgIC8vIHVwZGF0ZVxuICAgIHVwZGF0ZUlubmVyKGNoYW5nZXMsIG9sZExlbmd0aCwgY29tcG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKGNoYW5nZXMsIG9sZExlbmd0aCwgY29tcG9zaXRpb24pO1xuICAgICAgICBsZXQgeyBvYnNlcnZlciB9ID0gdGhpcy52aWV3O1xuICAgICAgICBvYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gTG9jayB0aGUgaGVpZ2h0IGR1cmluZyByZWRyYXdpbmcsIHNpbmNlIENocm9tZSBzb21ldGltZXNcbiAgICAgICAgICAgIC8vIG1lc3NlcyB3aXRoIHRoZSBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIERPTSBtdXRhdGlvbiAodGhvdWdoXG4gICAgICAgICAgICAvLyBubyByZWxheW91dCBpcyB0cmlnZ2VyZWQgYW5kIEkgY2Fubm90IGltYWdpbmUgaG93IGl0IGNhblxuICAgICAgICAgICAgLy8gcmVjb21wdXRlIHRoZSBzY3JvbGwgcG9zaXRpb24gd2l0aG91dCBhIGxheW91dClcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IHRoaXMudmlldy52aWV3U3RhdGUuY29udGVudEhlaWdodCAvIHRoaXMudmlldy5zY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5mbGV4QmFzaXMgPSB0aGlzLm1pbldpZHRoID8gdGhpcy5taW5XaWR0aCArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMsIHdoZW4gRE9NIG11dGF0aW9ucyBvY2N1ciBkaXJlY3RseVxuICAgICAgICAgICAgLy8gYXJvdW5kIHRoZSBzZWxlY3Rpb24sIGdldCBjb25mdXNlZCBhbmQgcmVwb3J0IGEgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gZnJvbSB0aGUgb25lIGl0IGRpc3BsYXlzIChpc3N1ZSAjMjE4KS4gVGhpcyB0cmllc1xuICAgICAgICAgICAgLy8gdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgICAgICAgICAgbGV0IHRyYWNrID0gYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5pb3MgPyB7IG5vZGU6IG9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSwgd3JpdHRlbjogZmFsc2UgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3luYyh0aGlzLnZpZXcsIHRyYWNrKTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgJj0gfjcgLyogVmlld0ZsYWcuRGlydHkgKi87XG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgKHRyYWNrLndyaXR0ZW4gfHwgb2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlICE9IHRyYWNrLm5vZGUpKVxuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24uZm9yRWFjaChjVmlldyA9PiBjVmlldy5mbGFncyAmPSB+OCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLyk7XG4gICAgICAgIGxldCBnYXBzID0gW107XG4gICAgICAgIGlmICh0aGlzLnZpZXcudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXcudmlld3BvcnQudG8gPCB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIGNoaWxkLndpZGdldCBpbnN0YW5jZW9mIEJsb2NrR2FwV2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICBnYXBzLnB1c2goY2hpbGQuZG9tKTtcbiAgICAgICAgb2JzZXJ2ZXIudXBkYXRlR2FwcyhnYXBzKTtcbiAgICB9XG4gICAgdXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoLCBjb21wb3NpdGlvbikge1xuICAgICAgICBsZXQgcmFuZ2VzID0gY29tcG9zaXRpb24gPyBjb21wb3NpdGlvbi5yYW5nZS5hZGRUb1NldChjaGFuZ2VzLnNsaWNlKCkpIDogY2hhbmdlcztcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY2hpbGRDdXJzb3Iob2xkTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlcy5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPj0gMCA/IHJhbmdlc1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBuZXh0LCBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZDtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiA8IHRvQiAmJiBjb21wb3NpdGlvbi5yYW5nZS50b0IgPiBmcm9tQikge1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBDb250ZW50QnVpbGRlci5idWlsZCh0aGlzLnZpZXcuc3RhdGUuZG9jLCBmcm9tQiwgY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXApO1xuICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IENvbnRlbnRCdWlsZGVyLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIGNvbXBvc2l0aW9uLnJhbmdlLnRvQiwgdG9CLCB0aGlzLmRlY29yYXRpb25zLCB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgICAgICAgICBicmVha0F0U3RhcnQgPSBiZWZvcmUuYnJlYWtBdFN0YXJ0O1xuICAgICAgICAgICAgICAgIG9wZW5TdGFydCA9IGJlZm9yZS5vcGVuU3RhcnQ7XG4gICAgICAgICAgICAgICAgb3BlbkVuZCA9IGFmdGVyLm9wZW5FbmQ7XG4gICAgICAgICAgICAgICAgbGV0IGNvbXBMaW5lID0gdGhpcy5jb21wb3NpdGlvblZpZXcoY29tcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlci5icmVha0F0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcExpbmUuYnJlYWtBZnRlciA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyLmNvbnRlbnQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLm1lcmdlKGNvbXBMaW5lLmxlbmd0aCwgY29tcExpbmUubGVuZ3RoLCBhZnRlci5jb250ZW50WzBdLCBmYWxzZSwgYWZ0ZXIub3BlblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5icmVha0FmdGVyID0gYWZ0ZXIuY29udGVudFswXS5icmVha0FmdGVyO1xuICAgICAgICAgICAgICAgICAgICBhZnRlci5jb250ZW50LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUuY29udGVudC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcExpbmUubWVyZ2UoMCwgMCwgYmVmb3JlLmNvbnRlbnRbYmVmb3JlLmNvbnRlbnQubGVuZ3RoIC0gMV0sIHRydWUsIDAsIGJlZm9yZS5vcGVuRW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUuY29udGVudC5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGJlZm9yZS5jb250ZW50LmNvbmNhdChjb21wTGluZSkuY29uY2F0KGFmdGVyLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKHsgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9XG4gICAgICAgICAgICAgICAgICAgIENvbnRlbnRCdWlsZGVyLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIGZyb21CLCB0b0IsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB7IGk6IHRvSSwgb2ZmOiB0b09mZiB9ID0gY3Vyc29yLmZpbmRQb3ModG9BLCAxKTtcbiAgICAgICAgICAgIGxldCB7IGk6IGZyb21JLCBvZmY6IGZyb21PZmYgfSA9IGN1cnNvci5maW5kUG9zKGZyb21BLCAtMSk7XG4gICAgICAgICAgICByZXBsYWNlUmFuZ2UodGhpcywgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGNvbnRlbnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9zaXRpb24pXG4gICAgICAgICAgICB0aGlzLmZpeENvbXBvc2l0aW9uRE9NKGNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgdXBkYXRlRWRpdENvbnRleHRGb3JtYXR0aW5nKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZyA9IHRoaXMuZWRpdENvbnRleHRGb3JtYXR0aW5nLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHVwZGF0ZS50cmFuc2FjdGlvbnMpXG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEVkaXRDb250ZXh0Rm9ybWF0dGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dEZvcm1hdHRpbmcgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb3NpdGlvblZpZXcoY29tcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGN1ciA9IG5ldyBUZXh0Vmlldyhjb21wb3NpdGlvbi50ZXh0Lm5vZGVWYWx1ZSk7XG4gICAgICAgIGN1ci5mbGFncyB8PSA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovO1xuICAgICAgICBmb3IgKGxldCB7IGRlY28gfSBvZiBjb21wb3NpdGlvbi5tYXJrcylcbiAgICAgICAgICAgIGN1ciA9IG5ldyBNYXJrVmlldyhkZWNvLCBbY3VyXSwgY3VyLmxlbmd0aCk7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IExpbmVWaWV3O1xuICAgICAgICBsaW5lLmFwcGVuZChjdXIsIDApO1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgZml4Q29tcG9zaXRpb25ET00oY29tcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGZpeCA9IChkb20sIGNWaWV3KSA9PiB7XG4gICAgICAgICAgICBjVmlldy5mbGFncyB8PSA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovIHwgKGNWaWV3LmNoaWxkcmVuLnNvbWUoYyA9PiBjLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLykgPyAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi8gOiAwKTtcbiAgICAgICAgICAgIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24uYWRkKGNWaWV3KTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2ICE9IGNWaWV3KVxuICAgICAgICAgICAgICAgIHByZXYuZG9tID0gbnVsbDtcbiAgICAgICAgICAgIGNWaWV3LnNldERPTShkb20pO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5jaGlsZFBvcyhjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiwgMSk7XG4gICAgICAgIGxldCBjVmlldyA9IHRoaXMuY2hpbGRyZW5bcG9zLmldO1xuICAgICAgICBmaXgoY29tcG9zaXRpb24ubGluZSwgY1ZpZXcpO1xuICAgICAgICBmb3IgKGxldCBpID0gY29tcG9zaXRpb24ubWFya3MubGVuZ3RoIC0gMTsgaSA+PSAtMTsgaS0tKSB7XG4gICAgICAgICAgICBwb3MgPSBjVmlldy5jaGlsZFBvcyhwb3Mub2ZmLCAxKTtcbiAgICAgICAgICAgIGNWaWV3ID0gY1ZpZXcuY2hpbGRyZW5bcG9zLmldO1xuICAgICAgICAgICAgZml4KGkgPj0gMCA/IGNvbXBvc2l0aW9uLm1hcmtzW2ldLm5vZGUgOiBjb21wb3NpdGlvbi50ZXh0LCBjVmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3luYyB0aGUgRE9NIHNlbGVjdGlvbiB0byB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgIHVwZGF0ZVNlbGVjdGlvbihtdXN0UmVhZCA9IGZhbHNlLCBmcm9tUG9pbnRlciA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChtdXN0UmVhZCB8fCAhdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSlcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IGFjdGl2ZUVsdCA9IHRoaXMudmlldy5yb290LmFjdGl2ZUVsZW1lbnQsIGZvY3VzZWQgPSBhY3RpdmVFbHQgPT0gdGhpcy5kb207XG4gICAgICAgIGxldCBzZWxlY3Rpb25Ob3RGb2N1cyA9ICFmb2N1c2VkICYmXG4gICAgICAgICAgICBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZSkgJiYgIShhY3RpdmVFbHQgJiYgdGhpcy5kb20uY29udGFpbnMoYWN0aXZlRWx0KSk7XG4gICAgICAgIGlmICghKGZvY3VzZWQgfHwgZnJvbVBvaW50ZXIgfHwgc2VsZWN0aW9uTm90Rm9jdXMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLmZvcmNlU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBtYWluID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgYW5jaG9yID0gdGhpcy5tb3ZlVG9MaW5lKHRoaXMuZG9tQXRQb3MobWFpbi5hbmNob3IpKTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYWluLmVtcHR5ID8gYW5jaG9yIDogdGhpcy5tb3ZlVG9MaW5lKHRoaXMuZG9tQXRQb3MobWFpbi5oZWFkKSk7XG4gICAgICAgIC8vIEFsd2F5cyByZXNldCBvbiBGaXJlZm94IHdoZW4gbmV4dCB0byBhbiB1bmVkaXRhYmxlIG5vZGUgdG9cbiAgICAgICAgLy8gYXZvaWQgaW52aXNpYmxlIGN1cnNvciBidWdzICgjMTExKVxuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbyAmJiBtYWluLmVtcHR5ICYmICF0aGlzLmhhc0NvbXBvc2l0aW9uICYmIGJldHdlZW5VbmVkaXRhYmxlKGFuY2hvcikpIHtcbiAgICAgICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBhbmNob3Iubm9kZS5pbnNlcnRCZWZvcmUoZHVtbXksIGFuY2hvci5ub2RlLmNoaWxkTm9kZXNbYW5jaG9yLm9mZnNldF0gfHwgbnVsbCkpO1xuICAgICAgICAgICAgYW5jaG9yID0gaGVhZCA9IG5ldyBET01Qb3MoZHVtbXksIDApO1xuICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb21TZWwgPSB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSBoZXJlLCBvciBpbiBhbiBlcXVpdmFsZW50IHBvc2l0aW9uLCBkb24ndCB0b3VjaCBpdFxuICAgICAgICBpZiAoZm9yY2UgfHwgIWRvbVNlbC5mb2N1c05vZGUgfHwgKCFpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpIHx8XG4gICAgICAgICAgICAhaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZC5ub2RlLCBoZWFkLm9mZnNldCwgZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSkgJiYgIXRoaXMuc3VwcHJlc3NXaWRnZXRDdXJzb3JDaGFuZ2UoZG9tU2VsLCBtYWluKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBoaWRlIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHdoZW4gdGFwcGluZ1xuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiB1bmVkaXRhYmxlIG5vZGUsIGFuZCBub3QgYnJpbmcgaXQgYmFjayB3aGVuIHdlXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIHRvIGl0cyBwcm9wZXIgcG9zaXRpb24uIFRoaXMgdHJpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBrZXlib2FyZCBieSBjeWNsaW5nIGZvY3VzLlxuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgdGhpcy5kb20uY29udGFpbnMoZG9tU2VsLmZvY3VzTm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5VbmVkaXRhYmxlKGRvbVNlbC5mb2N1c05vZGUsIHRoaXMuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhd1NlbCA9IGdldFNlbGVjdGlvbih0aGlzLnZpZXcucm9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYXdTZWwpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYWluLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MTIwNzZcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0VG8gPSBuZXh0VG9VbmVkaXRhYmxlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VG8gJiYgbmV4dFRvICE9ICgxIC8qIE5leHRUby5CZWZvcmUgKi8gfCAyIC8qIE5leHRUby5BZnRlciAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IChuZXh0VG8gPT0gMSAvKiBOZXh0VG8uQmVmb3JlICovID8gdGV4dE5vZGVCZWZvcmUgOiB0ZXh0Tm9kZUFmdGVyKShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IG5ldyBET01Qb3ModGV4dC5ub2RlLCB0ZXh0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNvbGxhcHNlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW4uYmlkaUxldmVsICE9IG51bGwgJiYgcmF3U2VsLmNhcmV0QmlkaUxldmVsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdTZWwuY2FyZXRCaWRpTGV2ZWwgPSBtYWluLmJpZGlMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmF3U2VsLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgd2lsbCBpZ25vcmUgdGhlIGNhbGwgYWJvdmUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZGRlbiwgYW5kIHRoZW4gcmFpc2UgYW4gZXJyb3Igb24gdGhlIGNhbGwgdG8gZXh0ZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vICgjOTQwKS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1NlbC5leHRlbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlIChJRSkgd2F5XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmFuY2hvciA+IG1haW4uaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgIFthbmNob3IsIGhlYWRdID0gW2hlYWQsIGFuY2hvcl07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Ob3RGb2N1cyAmJiB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVsdC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBhbmNob3IucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gaGVhZC5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gSWYgYSB6ZXJvLWxlbmd0aCB3aWRnZXQgaXMgaW5zZXJ0ZWQgbmV4dCB0byB0aGUgY3Vyc29yIGR1cmluZ1xuICAgIC8vIGNvbXBvc2l0aW9uLCBhdm9pZCBtb3ZpbmcgaXQgYWNyb3NzIGl0IGFuZCBkaXNydXB0aW5nIHRoZVxuICAgIC8vIGNvbXBvc2l0aW9uLlxuICAgIHN1cHByZXNzV2lkZ2V0Q3Vyc29yQ2hhbmdlKHNlbCwgY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NvbXBvc2l0aW9uICYmIGN1cnNvci5lbXB0eSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkgJiZcbiAgICAgICAgICAgIHRoaXMucG9zRnJvbURPTShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpID09IGN1cnNvci5oZWFkO1xuICAgIH1cbiAgICBlbmZvcmNlQ3Vyc29yQXNzb2MoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBvc2l0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBjdXJzb3IgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIWN1cnNvci5lbXB0eSB8fCAhY3Vyc29yLmFzc29jIHx8ICFzZWwubW9kaWZ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodGhpcywgY3Vyc29yLmhlYWQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgICAgIGlmIChjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgfHwgY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAtMSksIGFmdGVyID0gdGhpcy5jb29yZHNBdChjdXJzb3IuaGVhZCwgMSk7XG4gICAgICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCBiZWZvcmUuYm90dG9tID4gYWZ0ZXIudG9wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb21BdFBvcyhjdXJzb3IuaGVhZCArIGN1cnNvci5hc3NvYyk7XG4gICAgICAgIHNlbC5jb2xsYXBzZShkb20ubm9kZSwgZG9tLm9mZnNldCk7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGN1cnNvci5hc3NvYyA8IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgICAgIC8vIFRoaXMgY2FuIGdvIHdyb25nIGluIGNvcm5lciBjYXNlcyBsaWtlIHNpbmdsZS1jaGFyYWN0ZXIgbGluZXMsXG4gICAgICAgIC8vIHNvIGNoZWNrIGFuZCByZXNldCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBuZXdSYW5nZSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShuZXdSYW5nZS5hbmNob3JOb2RlLCBuZXdSYW5nZS5hbmNob3JPZmZzZXQpICE9IGN1cnNvci5mcm9tKVxuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgfVxuICAgIC8vIElmIGEgcG9zaXRpb24gaXMgaW4vbmVhciBhIGJsb2NrIHdpZGdldCwgbW92ZSBpdCB0byBhIG5lYXJieSB0ZXh0XG4gICAgLy8gbGluZSwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0aGUgY3Vyc29yIGluc2lkZSBhIGJsb2NrIHdpZGdldC5cbiAgICBtb3ZlVG9MaW5lKHBvcykge1xuICAgICAgICAvLyBCbG9jayB3aWRnZXRzIHdpbGwgcmV0dXJuIHBvc2l0aW9ucyBiZWZvcmUvYWZ0ZXIgdGhlbSwgd2hpY2hcbiAgICAgICAgLy8gYXJlIHRodXMgZGlyZWN0bHkgaW4gdGhlIGRvY3VtZW50IERPTSBlbGVtZW50LlxuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb20sIG5ld1BvcztcbiAgICAgICAgaWYgKHBvcy5ub2RlICE9IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3Mub2Zmc2V0OyAhbmV3UG9zICYmIGkgPCBkb20uY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB2aWV3LmRvbUF0UG9zKDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3Mub2Zmc2V0IC0gMTsgIW5ld1BvcyAmJiBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB2aWV3LmRvbUF0UG9zKHZpZXcubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UG9zID8gbmV3IERPTVBvcyhuZXdQb3Mubm9kZSwgbmV3UG9zLm9mZnNldCwgdHJ1ZSkgOiBwb3M7XG4gICAgfVxuICAgIG5lYXJlc3QoZG9tKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOykge1xuICAgICAgICAgICAgbGV0IGRvbVZpZXcgPSBDb250ZW50Vmlldy5nZXQoY3VyKTtcbiAgICAgICAgICAgIGlmIChkb21WaWV3ICYmIGRvbVZpZXcucm9vdFZpZXcgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tVmlldztcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgdmlldyA9IHRoaXMubmVhcmVzdChub2RlKTtcbiAgICAgICAgaWYgKCF2aWV3KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gZmluZCBwb3NpdGlvbiBmb3IgYSBET00gcG9zaXRpb24gb3V0c2lkZSBvZiB0aGUgZG9jdW1lbnRcIik7XG4gICAgICAgIHJldHVybiB2aWV3LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgdmlldy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIC0xKTtcbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG9mZiA8IGNoaWxkLmxlbmd0aCB8fCBjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21BdFBvcyhvZmYpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGJlc3QgPSBudWxsLCBiZXN0UG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdGhpcy5sZW5ndGgsIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgLSBjaGlsZC5icmVha0FmdGVyLCBzdGFydCA9IGVuZCAtIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPCBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPD0gcG9zICYmIChzdGFydCA8IHBvcyB8fCBjaGlsZC5jb3ZlcnMoLTEpKSAmJiAoZW5kID4gcG9zIHx8IGNoaWxkLmNvdmVycygxKSkgJiZcbiAgICAgICAgICAgICAgICAoIWJlc3QgfHwgY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldyAmJiAhKGJlc3QgaW5zdGFuY2VvZiBMaW5lVmlldyAmJiBzaWRlID49IDApKSkge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBiZXN0UG9zID0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZXN0ICYmIHN0YXJ0ID09IHBvcyAmJiBlbmQgPT0gcG9zICYmIGNoaWxkIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIE1hdGguYWJzKHNpZGUpIDwgMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kZWNvLnN0YXJ0U2lkZSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgIGJlc3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3QgPyBiZXN0LmNvb3Jkc0F0KHBvcyAtIGJlc3RQb3MsIHNpZGUpIDogbnVsbDtcbiAgICB9XG4gICAgY29vcmRzRm9yQ2hhcihwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkUG9zKHBvcywgMSksIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgaSwgb2ZmOiBjaGlsZE9mZiB9ID0gY2hpbGQuY2hpbGRQb3Mob2ZmLCAxKTtcbiAgICAgICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoKGNoaWxkID0gY2hpbGQuY2hpbGRyZW5baV0pLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBjaGlsZE9mZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZW5kID0gc3RhdGUuZmluZENsdXN0ZXJCcmVhayhjaGlsZC50ZXh0LCBvZmYpO1xuICAgICAgICBpZiAoZW5kID09IG9mZilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQuZG9tLCBvZmYsIGVuZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSAmJiByZWN0LmxlZnQgPCByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZpZXdwb3J0KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgeyBmcm9tLCB0byB9ID0gdmlld3BvcnQ7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSB0aGlzLnZpZXcuY29udGVudERPTS5jbGllbnRXaWR0aDtcbiAgICAgICAgbGV0IGlzV2lkZXIgPSBjb250ZW50V2lkdGggPiBNYXRoLm1heCh0aGlzLnZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB0aGlzLm1pbldpZHRoKSArIDE7XG4gICAgICAgIGxldCB3aWRlc3QgPSAtMSwgbHRyID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gZXhwb3J0cy5EaXJlY3Rpb24uTFRSO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZFJlY3QgPSBjaGlsZC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGRSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2lkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBjaGlsZC5kb20ubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBsYXN0ID8gY2xpZW50UmVjdHNGb3IobGFzdCkgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IGx0ciA/IHJlY3QucmlnaHQgLSBjaGlsZFJlY3QubGVmdCA6IGNoaWxkUmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IHdpZGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSBjb250ZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCB7IGkgfSA9IHRoaXMuY2hpbGRQb3MocG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUodGhpcy5jaGlsZHJlbltpXS5kb20pLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gZXhwb3J0cy5EaXJlY3Rpb24uUlRMIDogZXhwb3J0cy5EaXJlY3Rpb24uTFRSO1xuICAgIH1cbiAgICBtZWFzdXJlVGV4dFNpemUoKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmUgPSBjaGlsZC5tZWFzdXJlVGV4dFNpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVhc3VyZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gd29ya2FibGUgbGluZSBleGlzdHMsIGZvcmNlIGEgbGF5b3V0IG9mIGEgbWVhc3VyYWJsZSBlbGVtZW50XG4gICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodDtcbiAgICAgICAgZHVtbXkuY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgIGR1bW15LnN0eWxlLndpZHRoID0gXCI5OTk5OXB4XCI7XG4gICAgICAgIGR1bW15LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBkdW1teS50ZXh0Q29udGVudCA9IFwiYWJjIGRlZiBnaGkgamtsIG1ubyBwcXIgc3R1XCI7XG4gICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZHVtbXkpO1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBjbGllbnRSZWN0c0ZvcihkdW1teS5maXJzdENoaWxkKVswXTtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBkdW1teS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICBjaGFyV2lkdGggPSByZWN0ID8gcmVjdC53aWR0aCAvIDI3IDogNztcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSByZWN0ID8gcmVjdC5oZWlnaHQgOiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgZHVtbXkucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQgfTtcbiAgICB9XG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTW92ZSBiYWNrIHRvIHN0YXJ0IG9mIGxhc3QgZWxlbWVudCB3aGVuIHBvc3NpYmxlLCBzbyB0aGF0XG4gICAgICAgIC8vIGBDaGlsZEN1cnNvci5maW5kUG9zYCBkb2Vzbid0IGhhdmUgdG8gZGVhbCB3aXRoIHRoZSBlZGdlIGNhc2VcbiAgICAgICAgLy8gb2YgYmVpbmcgYWZ0ZXIgdGhlIGxhc3QgZWxlbWVudC5cbiAgICAgICAgbGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICBwb3MgLT0gdGhpcy5jaGlsZHJlblstLWldLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZEN1cnNvcih0aGlzLmNoaWxkcmVuLCBwb3MsIGkpO1xuICAgIH1cbiAgICBjb21wdXRlQmxvY2tHYXBEZWNvKCkge1xuICAgICAgICBsZXQgZGVjbyA9IFtdLCB2cyA9IHRoaXMudmlldy52aWV3U3RhdGU7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gdnMudmlld3BvcnRzLmxlbmd0aCA/IG51bGwgOiB2cy52aWV3cG9ydHNbaV07XG4gICAgICAgICAgICBsZXQgZW5kID0gbmV4dCA/IG5leHQuZnJvbSAtIDEgOiB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gKHZzLmxpbmVCbG9ja0F0KGVuZCkuYm90dG9tIC0gdnMubGluZUJsb2NrQXQocG9zKS50b3ApIC8gdGhpcy52aWV3LnNjYWxlWTtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2goRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgQmxvY2tHYXBXaWRnZXQoaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9ja0dhcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShwb3MsIGVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dC50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbiAgICB1cGRhdGVEZWNvKCkge1xuICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgIGxldCBhbGxEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5tYXAoZCA9PiB7XG4gICAgICAgICAgICBsZXQgZHluYW1pYyA9IHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljID8gZCh0aGlzLnZpZXcpIDogZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkeW5hbWljT3V0ZXIgPSBmYWxzZSwgb3V0ZXJEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KG91dGVyRGVjb3JhdGlvbnMpLm1hcCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGR5bmFtaWMgPSB0eXBlb2YgZCA9PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICBpZiAoZHluYW1pYylcbiAgICAgICAgICAgICAgICBkeW5hbWljT3V0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWMgPyBkKHRoaXMudmlldykgOiBkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dGVyRGVjby5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IGR5bmFtaWNPdXRlcjtcbiAgICAgICAgICAgIGFsbERlY28ucHVzaChzdGF0ZS5SYW5nZVNldC5qb2luKG91dGVyRGVjbykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBbXG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZyxcbiAgICAgICAgICAgIC4uLmFsbERlY28sXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCbG9ja0dhcERlY28oKSxcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUubGluZUdhcERlY29cbiAgICAgICAgXTtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9ucztcbiAgICB9XG4gICAgc2Nyb2xsSW50b1ZpZXcodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQuaXNTbmFwc2hvdCkge1xuICAgICAgICAgICAgbGV0IHJlZiA9IHRoaXMudmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQodGFyZ2V0LnJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgPSByZWYudG9wIC0gdGFyZ2V0LnlNYXJnaW47XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB0YXJnZXQueE1hcmdpbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIHRoaXMudmlldy5zdGF0ZS5mYWNldChzY3JvbGxIYW5kbGVyKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcih0aGlzLnZpZXcsIHRhcmdldC5yYW5nZSwgdGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUsIFwic2Nyb2xsIGhhbmRsZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmFuZ2UgfSA9IHRhcmdldDtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmhlYWQsIHJhbmdlLmVtcHR5ID8gcmFuZ2UuYXNzb2MgOiByYW5nZS5oZWFkID4gcmFuZ2UuYW5jaG9yID8gLTEgOiAxKSwgb3RoZXI7XG4gICAgICAgIGlmICghcmVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiAob3RoZXIgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmFuY2hvciwgcmFuZ2UuYW5jaG9yID4gcmFuZ2UuaGVhZCA/IC0xIDogMSkpKVxuICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogTWF0aC5taW4ocmVjdC5sZWZ0LCBvdGhlci5sZWZ0KSwgdG9wOiBNYXRoLm1pbihyZWN0LnRvcCwgb3RoZXIudG9wKSxcbiAgICAgICAgICAgICAgICByaWdodDogTWF0aC5tYXgocmVjdC5yaWdodCwgb3RoZXIucmlnaHQpLCBib3R0b206IE1hdGgubWF4KHJlY3QuYm90dG9tLCBvdGhlci5ib3R0b20pIH07XG4gICAgICAgIGxldCBtYXJnaW5zID0gZ2V0U2Nyb2xsTWFyZ2lucyh0aGlzLnZpZXcpO1xuICAgICAgICBsZXQgdGFyZ2V0UmVjdCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG1hcmdpbnMubGVmdCwgdG9wOiByZWN0LnRvcCAtIG1hcmdpbnMudG9wLFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBtYXJnaW5zLnJpZ2h0LCBib3R0b206IHJlY3QuYm90dG9tICsgbWFyZ2lucy5ib3R0b21cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgb2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCB9ID0gdGhpcy52aWV3LnNjcm9sbERPTTtcbiAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMudmlldy5zY3JvbGxET00sIHRhcmdldFJlY3QsIHJhbmdlLmhlYWQgPCByYW5nZS5hbmNob3IgPyAtMSA6IDEsIHRhcmdldC54LCB0YXJnZXQueSwgTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0LnhNYXJnaW4sIG9mZnNldFdpZHRoKSwgLW9mZnNldFdpZHRoKSwgTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0LnlNYXJnaW4sIG9mZnNldEhlaWdodCksIC1vZmZzZXRIZWlnaHQpLCB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBleHBvcnRzLkRpcmVjdGlvbi5MVFIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJldHdlZW5VbmVkaXRhYmxlKHBvcykge1xuICAgIHJldHVybiBwb3Mubm9kZS5ub2RlVHlwZSA9PSAxICYmIHBvcy5ub2RlLmZpcnN0Q2hpbGQgJiZcbiAgICAgICAgKHBvcy5vZmZzZXQgPT0gMCB8fCBwb3Mubm9kZS5jaGlsZE5vZGVzW3Bvcy5vZmZzZXQgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSBwb3Mubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCB8fCBwb3Mubm9kZS5jaGlsZE5vZGVzW3Bvcy5vZmZzZXRdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpO1xufVxuZnVuY3Rpb24gZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBoZWFkUG9zKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKCFzZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHRleHROb2RlQmVmb3JlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgbGV0IHRleHRBZnRlciA9IHRleHROb2RlQWZ0ZXIoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBsZXQgdGV4dE5vZGUgPSB0ZXh0QmVmb3JlIHx8IHRleHRBZnRlcjtcbiAgICBpZiAodGV4dEFmdGVyICYmIHRleHRCZWZvcmUgJiYgdGV4dEFmdGVyLm5vZGUgIT0gdGV4dEJlZm9yZS5ub2RlKSB7XG4gICAgICAgIGxldCBkZXNjQWZ0ZXIgPSBDb250ZW50Vmlldy5nZXQodGV4dEFmdGVyLm5vZGUpO1xuICAgICAgICBpZiAoIWRlc2NBZnRlciB8fCBkZXNjQWZ0ZXIgaW5zdGFuY2VvZiBUZXh0VmlldyAmJiBkZXNjQWZ0ZXIudGV4dCAhPSB0ZXh0QWZ0ZXIubm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRleHROb2RlID0gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuZG9jVmlldy5sYXN0Q29tcG9zaXRpb25BZnRlckN1cnNvcikge1xuICAgICAgICAgICAgbGV0IGRlc2NCZWZvcmUgPSBDb250ZW50Vmlldy5nZXQodGV4dEJlZm9yZS5ub2RlKTtcbiAgICAgICAgICAgIGlmICghKCFkZXNjQmVmb3JlIHx8IGRlc2NCZWZvcmUgaW5zdGFuY2VvZiBUZXh0VmlldyAmJiBkZXNjQmVmb3JlLnRleHQgIT0gdGV4dEJlZm9yZS5ub2RlLm5vZGVWYWx1ZSkpXG4gICAgICAgICAgICAgICAgdGV4dE5vZGUgPSB0ZXh0QWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb2NWaWV3Lmxhc3RDb21wb3NpdGlvbkFmdGVyQ3Vyc29yID0gdGV4dE5vZGUgIT0gdGV4dEJlZm9yZTtcbiAgICBpZiAoIXRleHROb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZnJvbSA9IGhlYWRQb3MgLSB0ZXh0Tm9kZS5vZmZzZXQ7XG4gICAgcmV0dXJuIHsgZnJvbSwgdG86IGZyb20gKyB0ZXh0Tm9kZS5ub2RlLm5vZGVWYWx1ZS5sZW5ndGgsIG5vZGU6IHRleHROb2RlLm5vZGUgfTtcbn1cbmZ1bmN0aW9uIGZpbmRDb21wb3NpdGlvblJhbmdlKHZpZXcsIGNoYW5nZXMsIGhlYWRQb3MpIHtcbiAgICBsZXQgZm91bmQgPSBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcsIGhlYWRQb3MpO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB7IG5vZGU6IHRleHROb2RlLCBmcm9tLCB0byB9ID0gZm91bmQsIHRleHQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgLy8gRG9uJ3QgdHJ5IHRvIHByZXNlcnZlIG11bHRpLWxpbmUgY29tcG9zaXRpb25zXG4gICAgaWYgKC9bXFxuXFxyXS8udGVzdCh0ZXh0KSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHZpZXcuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGZvdW5kLmZyb20sIGZvdW5kLnRvKSAhPSB0ZXh0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaW52ID0gY2hhbmdlcy5pbnZlcnRlZERlc2M7XG4gICAgbGV0IHJhbmdlID0gbmV3IENoYW5nZWRSYW5nZShpbnYubWFwUG9zKGZyb20pLCBpbnYubWFwUG9zKHRvKSwgZnJvbSwgdG8pO1xuICAgIGxldCBtYXJrcyA9IFtdO1xuICAgIGZvciAobGV0IHBhcmVudCA9IHRleHROb2RlLnBhcmVudE5vZGU7OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBsZXQgcGFyZW50VmlldyA9IENvbnRlbnRWaWV3LmdldChwYXJlbnQpO1xuICAgICAgICBpZiAocGFyZW50VmlldyBpbnN0YW5jZW9mIE1hcmtWaWV3KVxuICAgICAgICAgICAgbWFya3MucHVzaCh7IG5vZGU6IHBhcmVudCwgZGVjbzogcGFyZW50Vmlldy5tYXJrIH0pO1xuICAgICAgICBlbHNlIGlmIChwYXJlbnRWaWV3IGluc3RhbmNlb2YgTGluZVZpZXcgfHwgcGFyZW50Lm5vZGVOYW1lID09IFwiRElWXCIgJiYgcGFyZW50LnBhcmVudE5vZGUgPT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIHRleHQ6IHRleHROb2RlLCBtYXJrcywgbGluZTogcGFyZW50IH07XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudCAhPSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICBtYXJrcy5wdXNoKHsgbm9kZTogcGFyZW50LCBkZWNvOiBuZXcgTWFya0RlY29yYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGdldEF0dHJzKHBhcmVudCksXG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6IHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV4dFRvVW5lZGl0YWJsZShub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA6IDApIHxcbiAgICAgICAgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDIgLyogTmV4dFRvLkFmdGVyICovIDogMCk7XG59XG5sZXQgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMSA9IGNsYXNzIERlY29yYXRpb25Db21wYXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG4gICAgfVxuICAgIGNvbXBhcmVSYW5nZShmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxuICAgIGNvbXBhcmVQb2ludChmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxufTtcbmZ1bmN0aW9uIGZpbmRDaGFuZ2VkRGVjbyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMTtcbiAgICBzdGF0ZS5SYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXApO1xuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XG59XG5mdW5jdGlvbiBpblVuZWRpdGFibGUobm9kZSwgaW5zaWRlKSB7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTsgY3VyICYmIGN1ciAhPSBpbnNpZGU7IGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxICYmIGN1ci5jb250ZW50RWRpdGFibGUgPT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdG91Y2hlc0NvbXBvc2l0aW9uKGNoYW5nZXMsIGNvbXBvc2l0aW9uKSB7XG4gICAgbGV0IHRvdWNoZWQgPSBmYWxzZTtcbiAgICBpZiAoY29tcG9zaXRpb24pXG4gICAgICAgIGNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IGNvbXBvc2l0aW9uLnRvICYmIHRvID4gY29tcG9zaXRpb24uZnJvbSlcbiAgICAgICAgICAgICAgICB0b3VjaGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIHRvdWNoZWQ7XG59XG5cbmZ1bmN0aW9uIGdyb3VwQXQoc3RhdGUkMSwgcG9zLCBiaWFzID0gMSkge1xuICAgIGxldCBjYXRlZ29yaXplID0gc3RhdGUkMS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgbGluZSA9IHN0YXRlJDEuZG9jLmxpbmVBdChwb3MpLCBsaW5lUG9zID0gcG9zIC0gbGluZS5mcm9tO1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgIGlmIChsaW5lUG9zID09IDApXG4gICAgICAgIGJpYXMgPSAxO1xuICAgIGVsc2UgaWYgKGxpbmVQb3MgPT0gbGluZS5sZW5ndGgpXG4gICAgICAgIGJpYXMgPSAtMTtcbiAgICBsZXQgZnJvbSA9IGxpbmVQb3MsIHRvID0gbGluZVBvcztcbiAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgIGZyb20gPSBzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcywgZmFsc2UpO1xuICAgIGVsc2VcbiAgICAgICAgdG8gPSBzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcyk7XG4gICAgbGV0IGNhdCA9IGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgd2hpbGUgKGZyb20gPiAwKSB7XG4gICAgICAgIGxldCBwcmV2ID0gc3RhdGUuZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGZyb20sIGZhbHNlKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKHByZXYsIGZyb20pKSAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZnJvbSA9IHByZXY7XG4gICAgfVxuICAgIHdoaWxlICh0byA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gc3RhdGUuZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHRvKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKHRvLCBuZXh0KSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHRvID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLkVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tICsgbGluZS5mcm9tLCB0byArIGxpbmUuZnJvbSk7XG59XG4vLyBTZWFyY2ggdGhlIERPTSBmb3IgdGhlIHtub2RlLCBvZmZzZXR9IHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuXG4vLyBjb29yZGluYXRlcy4gVmVyeSBpbmVmZmljaWVudCBhbmQgY3J1ZGUsIGJ1dCBjYW4gdXN1YWxseSBiZSBhdm9pZGVkXG4vLyBieSBjYWxsaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBpbnN0ZWFkLlxuZnVuY3Rpb24gZ2V0ZHgoeCwgcmVjdCkge1xuICAgIHJldHVybiByZWN0LmxlZnQgPiB4ID8gcmVjdC5sZWZ0IC0geCA6IE1hdGgubWF4KDAsIHggLSByZWN0LnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIGdldGR5KHksIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPiB5ID8gcmVjdC50b3AgLSB5IDogTWF0aC5tYXgoMCwgeSAtIHJlY3QuYm90dG9tKTtcbn1cbmZ1bmN0aW9uIHlPdmVybGFwKGEsIGIpIHtcbiAgICByZXR1cm4gYS50b3AgPCBiLmJvdHRvbSAtIDEgJiYgYS5ib3R0b20gPiBiLnRvcCArIDE7XG59XG5mdW5jdGlvbiB1cFRvcChyZWN0LCB0b3ApIHtcbiAgICByZXR1cm4gdG9wIDwgcmVjdC50b3AgPyB7IHRvcCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgYm90dG9tOiByZWN0LmJvdHRvbSB9IDogcmVjdDtcbn1cbmZ1bmN0aW9uIHVwQm90KHJlY3QsIGJvdHRvbSkge1xuICAgIHJldHVybiBib3R0b20gPiByZWN0LmJvdHRvbSA/IHsgdG9wOiByZWN0LnRvcCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgYm90dG9tIH0gOiByZWN0O1xufVxuZnVuY3Rpb24gZG9tUG9zQXRDb29yZHMocGFyZW50LCB4LCB5KSB7XG4gICAgbGV0IGNsb3Nlc3QsIGNsb3Nlc3RSZWN0LCBjbG9zZXN0WCwgY2xvc2VzdFksIGNsb3Nlc3RPdmVybGFwID0gZmFsc2U7XG4gICAgbGV0IGFib3ZlLCBiZWxvdywgYWJvdmVSZWN0LCBiZWxvd1JlY3Q7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBwYXJlbnQuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IoY2hpbGQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RSZWN0ICYmIHlPdmVybGFwKGNsb3Nlc3RSZWN0LCByZWN0KSlcbiAgICAgICAgICAgICAgICByZWN0ID0gdXBUb3AodXBCb3QocmVjdCwgY2xvc2VzdFJlY3QuYm90dG9tKSwgY2xvc2VzdFJlY3QudG9wKTtcbiAgICAgICAgICAgIGxldCBkeCA9IGdldGR4KHgsIHJlY3QpLCBkeSA9IGdldGR5KHksIHJlY3QpO1xuICAgICAgICAgICAgaWYgKGR4ID09IDAgJiYgZHkgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubm9kZVR5cGUgPT0gMyA/IGRvbVBvc0luVGV4dChjaGlsZCwgeCwgeSkgOiBkb21Qb3NBdENvb3JkcyhjaGlsZCwgeCwgeSk7XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QgfHwgY2xvc2VzdFkgPiBkeSB8fCBjbG9zZXN0WSA9PSBkeSAmJiBjbG9zZXN0WCA+IGR4KSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0WCA9IGR4O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RZID0gZHk7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSBkeSA/ICh5IDwgcmVjdC50b3AgPyAtMSA6IDEpIDogZHggPyAoeCA8IHJlY3QubGVmdCA/IC0xIDogMSkgOiAwO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RPdmVybGFwID0gIXNpZGUgfHwgKHNpZGUgPiAwID8gaSA8IHJlY3RzLmxlbmd0aCAtIDEgOiBpID4gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHggPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh5ID4gcmVjdC5ib3R0b20gJiYgKCFhYm92ZVJlY3QgfHwgYWJvdmVSZWN0LmJvdHRvbSA8IHJlY3QuYm90dG9tKSkge1xuICAgICAgICAgICAgICAgICAgICBhYm92ZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBhYm92ZVJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5IDwgcmVjdC50b3AgJiYgKCFiZWxvd1JlY3QgfHwgYmVsb3dSZWN0LnRvcCA+IHJlY3QudG9wKSkge1xuICAgICAgICAgICAgICAgICAgICBiZWxvdyA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBiZWxvd1JlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFib3ZlUmVjdCAmJiB5T3ZlcmxhcChhYm92ZVJlY3QsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gdXBCb3QoYWJvdmVSZWN0LCByZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgeU92ZXJsYXAoYmVsb3dSZWN0LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIGJlbG93UmVjdCA9IHVwVG9wKGJlbG93UmVjdCwgcmVjdC50b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhYm92ZVJlY3QgJiYgYWJvdmVSZWN0LmJvdHRvbSA+PSB5KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBhYm92ZTtcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBhYm92ZVJlY3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJlbG93UmVjdCAmJiBiZWxvd1JlY3QudG9wIDw9IHkpIHtcbiAgICAgICAgY2xvc2VzdCA9IGJlbG93O1xuICAgICAgICBjbG9zZXN0UmVjdCA9IGJlbG93UmVjdDtcbiAgICB9XG4gICAgaWYgKCFjbG9zZXN0KVxuICAgICAgICByZXR1cm4geyBub2RlOiBwYXJlbnQsIG9mZnNldDogMCB9O1xuICAgIGxldCBjbGlwWCA9IE1hdGgubWF4KGNsb3Nlc3RSZWN0LmxlZnQsIE1hdGgubWluKGNsb3Nlc3RSZWN0LnJpZ2h0LCB4KSk7XG4gICAgaWYgKGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIGRvbVBvc0luVGV4dChjbG9zZXN0LCBjbGlwWCwgeSk7XG4gICAgaWYgKGNsb3Nlc3RPdmVybGFwICYmIGNsb3Nlc3QuY29udGVudEVkaXRhYmxlICE9IFwiZmFsc2VcIilcbiAgICAgICAgcmV0dXJuIGRvbVBvc0F0Q29vcmRzKGNsb3Nlc3QsIGNsaXBYLCB5KTtcbiAgICBsZXQgb2Zmc2V0ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChwYXJlbnQuY2hpbGROb2RlcywgY2xvc2VzdCkgK1xuICAgICAgICAoeCA+PSAoY2xvc2VzdFJlY3QubGVmdCArIGNsb3Nlc3RSZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7XG4gICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQgfTtcbn1cbmZ1bmN0aW9uIGRvbVBvc0luVGV4dChub2RlLCB4LCB5KSB7XG4gICAgbGV0IGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VzdE9mZnNldCA9IC0xLCBjbG9zZXN0RFkgPSAxZTksIGdlbmVyYWxTaWRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCByZWN0cyA9IHRleHRSYW5nZShub2RlLCBpLCBpICsgMSkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghZ2VuZXJhbFNpZGUpXG4gICAgICAgICAgICAgICAgZ2VuZXJhbFNpZGUgPSB4IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgbGV0IGR5ID0gKHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IHkgLSByZWN0LmJvdHRvbSkgLSAxO1xuICAgICAgICAgICAgaWYgKHJlY3QubGVmdCAtIDEgPD0geCAmJiByZWN0LnJpZ2h0ICsgMSA+PSB4ICYmIGR5IDwgY2xvc2VzdERZKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0geCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCBhZnRlciA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBSVEwgb24gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGdldHRpbmcgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY3RzIGZvciBlbXB0eSByYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QmVmb3JlID0gdGV4dFJhbmdlKG5vZGUsIGkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdEJlZm9yZS5sZWZ0ID09IHJlY3QucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9ICFyaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGR5IDw9IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogaSArIChhZnRlciA/IDEgOiAwKSB9O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RPZmZzZXQgPSBpICsgKGFmdGVyID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3REWSA9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogY2xvc2VzdE9mZnNldCA+IC0xID8gY2xvc2VzdE9mZnNldCA6IGdlbmVyYWxTaWRlID4gMCA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IDAgfTtcbn1cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzKHZpZXcsIGNvb3JkcywgcHJlY2lzZSwgYmlhcyA9IC0xKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgY29udGVudCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9jVG9wID0gY29udGVudC50b3AgKyB2aWV3LnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xuICAgIGxldCBibG9jaywgeyBkb2NIZWlnaHQgfSA9IHZpZXcudmlld1N0YXRlO1xuICAgIGxldCB7IHgsIHkgfSA9IGNvb3JkcywgeU9mZnNldCA9IHkgLSBkb2NUb3A7XG4gICAgaWYgKHlPZmZzZXQgPCAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAoeU9mZnNldCA+IGRvY0hlaWdodClcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAvLyBTY2FuIGZvciBhIHRleHQgYmxvY2sgbmVhciB0aGUgcXVlcmllZCB5IHBvc2l0aW9uXG4gICAgZm9yIChsZXQgaGFsZkxpbmUgPSB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUudGV4dEhlaWdodCAvIDIsIGJvdW5jZWQgPSBmYWxzZTs7KSB7XG4gICAgICAgIGJsb2NrID0gdmlldy5lbGVtZW50QXRIZWlnaHQoeU9mZnNldCk7XG4gICAgICAgIGlmIChibG9jay50eXBlID09IGV4cG9ydHMuQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgLy8gTW92ZSB0aGUgeSBwb3NpdGlvbiBvdXQgb2YgdGhpcyBibG9ja1xuICAgICAgICAgICAgeU9mZnNldCA9IGJpYXMgPiAwID8gYmxvY2suYm90dG9tICsgaGFsZkxpbmUgOiBibG9jay50b3AgLSBoYWxmTGluZTtcbiAgICAgICAgICAgIGlmICh5T2Zmc2V0ID49IDAgJiYgeU9mZnNldCA8PSBkb2NIZWlnaHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG9jdW1lbnQgY29uc2lzdHMgZW50aXJlbHkgb2YgcmVwbGFjZWQgd2lkZ2V0cywgd2VcbiAgICAgICAgICAgIC8vIHdvbid0IGZpbmQgYSB0ZXh0IGJsb2NrLCBzbyByZXR1cm4gMFxuICAgICAgICAgICAgaWYgKGJvdW5jZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNpc2UgPyBudWxsIDogMDtcbiAgICAgICAgICAgIGJvdW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgYmlhcyA9IC1iaWFzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHkgPSBkb2NUb3AgKyB5T2Zmc2V0O1xuICAgIGxldCBsaW5lU3RhcnQgPSBibG9jay5mcm9tO1xuICAgIC8vIElmIHRoaXMgaXMgb3V0c2lkZSBvZiB0aGUgcmVuZGVyZWQgdmlld3BvcnQsIHdlIGNhbid0IGRldGVybWluZSBhIHBvc2l0aW9uXG4gICAgaWYgKGxpbmVTdGFydCA8IHZpZXcudmlld3BvcnQuZnJvbSlcbiAgICAgICAgcmV0dXJuIHZpZXcudmlld3BvcnQuZnJvbSA9PSAwID8gMCA6IHByZWNpc2UgPyBudWxsIDogcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudCwgYmxvY2ssIHgsIHkpO1xuICAgIGlmIChsaW5lU3RhcnQgPiB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC50byA9PSB2aWV3LnN0YXRlLmRvYy5sZW5ndGggPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOlxuICAgICAgICAgICAgcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgLy8gUHJlZmVyIFNoYWRvd1Jvb3RPckRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQgaWYgcHJlc2VudCwgZmFsbCBiYWNrIHRvIGRvY3VtZW50IGlmIG5vdFxuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGxldCByb290ID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2M7XG4gICAgbGV0IGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgdW5leHBlY3RlZCwgY2xpcCB4IGF0IHRoZSBzaWRlcyBvZiB0aGUgY29udGVudCBhcmVhIGFuZCB0cnkgYWdhaW5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgeCA9IE1hdGgubWF4KGNvbnRlbnQubGVmdCArIDEsIE1hdGgubWluKGNvbnRlbnQucmlnaHQgLSAxLCB4KSk7XG4gICAgICAgIGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmICF2aWV3LmNvbnRlbnRET00uY29udGFpbnMoZWxlbWVudCkpXG4gICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlcmUncyB2aXNpYmxlIGVkaXRvciBjb250ZW50IHVuZGVyIHRoZSBwb2ludCwgc28gd2UgY2FuIHRyeVxuICAgIC8vIHVzaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBhcyBhIHNob3J0Y3V0XG4gICAgbGV0IG5vZGUsIG9mZnNldCA9IC0xO1xuICAgIGlmIChlbGVtZW50ICYmICgoX2EgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChlbGVtZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpICE9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICAoeyBvZmZzZXROb2RlOiBub2RlLCBvZmZzZXQgfSA9IHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgKHsgc3RhcnRDb250YWluZXI6IG5vZGUsIHN0YXJ0T2Zmc2V0OiBvZmZzZXQgfSA9IHJhbmdlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcuY29udGVudERPTS5jb250YWlucyhub2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICBicm93c2VyLnNhZmFyaSAmJiBpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuY2hyb21lICYmIGlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hyb21lIHdpbGwgcmV0dXJuIG9mZnNldHMgaW50byA8aW5wdXQ+IGVsZW1lbnRzIHdpdGhvdXQgY2hpbGRcbiAgICAgICAgLy8gbm9kZXMsIHdoaWNoIHdpbGwgbGVhZCB0byBhIG51bGwgZGVyZWYgYmVsb3csIHNvIGNsaXAgdGhlXG4gICAgICAgIC8vIG9mZnNldCB0byB0aGUgbm9kZSBzaXplLlxuICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKG1heE9mZnNldChub2RlKSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gTm8gbHVjaywgZG8gb3VyIG93biAocG90ZW50aWFsbHkgZXhwZW5zaXZlKSBzZWFyY2hcbiAgICBpZiAoIW5vZGUgfHwgIXZpZXcuZG9jVmlldy5kb20uY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgbGluZVN0YXJ0KTtcbiAgICAgICAgaWYgKCFsaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHlPZmZzZXQgPiBibG9jay50b3AgKyBibG9jay5oZWlnaHQgLyAyID8gYmxvY2sudG8gOiBibG9jay5mcm9tO1xuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGRvbVBvc0F0Q29vcmRzKGxpbmUuZG9tLCB4LCB5KSk7XG4gICAgfVxuICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3Qobm9kZSk7XG4gICAgaWYgKCFuZWFyZXN0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAobmVhcmVzdC5pc1dpZGdldCAmJiAoKF9iID0gbmVhcmVzdC5kb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ub2RlVHlwZSkgPT0gMSkge1xuICAgICAgICBsZXQgcmVjdCA9IG5lYXJlc3QuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gY29vcmRzLnkgPCByZWN0LnRvcCB8fCBjb29yZHMueSA8PSByZWN0LmJvdHRvbSAmJiBjb29yZHMueCA8PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyXG4gICAgICAgICAgICA/IG5lYXJlc3QucG9zQXRTdGFydCA6IG5lYXJlc3QucG9zQXRFbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmVhcmVzdC5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSArIG5lYXJlc3QucG9zQXRTdGFydDtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50UmVjdCwgYmxvY2ssIHgsIHkpIHtcbiAgICBsZXQgaW50byA9IE1hdGgucm91bmQoKHggLSBjb250ZW50UmVjdC5sZWZ0KSAqIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKTtcbiAgICBpZiAodmlldy5saW5lV3JhcHBpbmcgJiYgYmxvY2suaGVpZ2h0ID4gdmlldy5kZWZhdWx0TGluZUhlaWdodCAqIDEuNSkge1xuICAgICAgICBsZXQgdGV4dEhlaWdodCA9IHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0O1xuICAgICAgICBsZXQgbGluZSA9IE1hdGguZmxvb3IoKHkgLSBibG9jay50b3AgLSAodmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHRleHRIZWlnaHQpICogMC41KSAvIHRleHRIZWlnaHQpO1xuICAgICAgICBpbnRvICs9IGxpbmUgKiB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUxlbmd0aDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGJsb2NrLmZyb20sIGJsb2NrLnRvKTtcbiAgICByZXR1cm4gYmxvY2suZnJvbSArIHN0YXRlLmZpbmRDb2x1bW4oY29udGVudCwgaW50bywgdmlldy5zdGF0ZS50YWJTaXplKTtcbn1cbi8vIEluIGNhc2Ugb2YgYSBoaWdoIGxpbmUgaGVpZ2h0LCBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHRyZWF0c1xuLy8gdGhlIHNwYWNlIGJldHdlZW4gbGluZXMgYXMgYmVsb25naW5nIHRvIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGVcbi8vIGxpbmUgYmVmb3JlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZWN0IHN1Y2ggYSByZXN1bHQgc28gdGhhdCBpdCBjYW4gYmVcbi8vIGlnbm9yZWQgKGlzc3VlICM0MDEpLlxuZnVuY3Rpb24gaXNTdXNwaWNpb3VzU2FmYXJpQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSB7XG4gICAgbGV0IGxlbjtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAzIHx8IG9mZnNldCAhPSAobGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nOyBuZXh0OyBuZXh0ID0gbmV4dC5uZXh0U2libGluZylcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgIT0gMSB8fCBuZXh0Lm5vZGVOYW1lICE9IFwiQlJcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGV4dFJhbmdlKG5vZGUsIGxlbiAtIDEsIGxlbikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IHg7XG59XG4vLyBDaHJvbWUgd2lsbCBtb3ZlIHBvc2l0aW9ucyBiZXR3ZWVuIGxpbmVzIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBsaW5lXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNDaHJvbWVDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcbiAgICBpZiAob2Zmc2V0ICE9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOzspIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSB8fCBwYXJlbnQuZmlyc3RDaGlsZCAhPSBjdXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tbGluZVwiKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjdXIgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGxldCByZWN0ID0gbm9kZS5ub2RlVHlwZSA9PSAxID8gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICA6IHRleHRSYW5nZShub2RlLCAwLCBNYXRoLm1heChub2RlLm5vZGVWYWx1ZS5sZW5ndGgsIDEpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4geCAtIHJlY3QubGVmdCA+IDU7XG59XG5mdW5jdGlvbiBibG9ja0F0KHZpZXcsIHBvcykge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpXG4gICAgICAgIGZvciAobGV0IGwgb2YgbGluZS50eXBlKSB7XG4gICAgICAgICAgICBpZiAobC50byA+IHBvcyB8fCBsLnRvID09IHBvcyAmJiAobC50byA9PSBsaW5lLnRvIHx8IGwudHlwZSA9PSBleHBvcnRzLkJsb2NrVHlwZS5UZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBsaW5lO1xufVxuZnVuY3Rpb24gbW92ZVRvTGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCkge1xuICAgIGxldCBsaW5lID0gYmxvY2tBdCh2aWV3LCBzdGFydC5oZWFkKTtcbiAgICBsZXQgY29vcmRzID0gIWluY2x1ZGVXcmFwIHx8IGxpbmUudHlwZSAhPSBleHBvcnRzLkJsb2NrVHlwZS5UZXh0IHx8ICEodmlldy5saW5lV3JhcHBpbmcgfHwgbGluZS53aWRnZXRMaW5lQnJlYWtzKSA/IG51bGxcbiAgICAgICAgOiB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0LmFzc29jIDwgMCAmJiBzdGFydC5oZWFkID4gbGluZS5mcm9tID8gc3RhcnQuaGVhZCAtIDEgOiBzdGFydC5oZWFkKTtcbiAgICBpZiAoY29vcmRzKSB7XG4gICAgICAgIGxldCBlZGl0b3JSZWN0ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSB2aWV3LnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pO1xuICAgICAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGZvcndhcmQgPT0gKGRpcmVjdGlvbiA9PSBleHBvcnRzLkRpcmVjdGlvbi5MVFIpID8gZWRpdG9yUmVjdC5yaWdodCAtIDEgOiBlZGl0b3JSZWN0LmxlZnQgKyAxLFxuICAgICAgICAgICAgeTogKGNvb3Jkcy50b3AgKyBjb29yZHMuYm90dG9tKSAvIDIgfSk7XG4gICAgICAgIGlmIChwb3MgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgZm9yd2FyZCA/IC0xIDogMSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbmZ1bmN0aW9uIG1vdmVCeUNoYXIodmlldywgc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhcnQuaGVhZCksIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgbGV0IGRpcmVjdGlvbiA9IHZpZXcudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgZm9yIChsZXQgY3VyID0gc3RhcnQsIGNoZWNrID0gbnVsbDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVZpc3VhbGx5KGxpbmUsIHNwYW5zLCBkaXJlY3Rpb24sIGN1ciwgZm9yd2FyZCksIGNoYXIgPSBtb3ZlZE92ZXI7XG4gICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgY2hhciA9IFwiXFxuXCI7XG4gICAgICAgICAgICBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZShsaW5lLm51bWJlciArIChmb3J3YXJkID8gMSA6IC0xKSk7XG4gICAgICAgICAgICBzcGFucyA9IHZpZXcuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICAgICAgbmV4dCA9IHZpZXcudmlzdWFsTGluZVNpZGUobGluZSwgIWZvcndhcmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgICAgIGlmICghYnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICBjaGVjayA9IGJ5KGNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaGVjayhjaGFyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBuZXh0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ5R3JvdXAodmlldywgcG9zLCBzdGFydCkge1xuICAgIGxldCBjYXRlZ29yaXplID0gdmlldy5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShzdGFydCk7XG4gICAgcmV0dXJuIChuZXh0KSA9PiB7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KTtcbiAgICAgICAgaWYgKGNhdCA9PSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICByZXR1cm4gY2F0ID09IG5leHRDYXQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVWZXJ0aWNhbGx5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkge1xuICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0LmhlYWQsIGRpciA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgaWYgKHN0YXJ0UG9zID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGVuZ3RoIDogMCkpXG4gICAgICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXJ0UG9zLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IGdvYWwgPSBzdGFydC5nb2FsQ29sdW1uLCBzdGFydFk7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHN0YXJ0Q29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhzdGFydFBvcywgc3RhcnQuYXNzb2MgfHwgLTEpLCBkb2NUb3AgPSB2aWV3LmRvY3VtZW50VG9wO1xuICAgIGlmIChzdGFydENvb3Jkcykge1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IHN0YXJ0Q29vcmRzLmxlZnQgLSByZWN0LmxlZnQ7XG4gICAgICAgIHN0YXJ0WSA9IGRpciA8IDAgPyBzdGFydENvb3Jkcy50b3AgOiBzdGFydENvb3Jkcy5ib3R0b207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcudmlld1N0YXRlLmxpbmVCbG9ja0F0KHN0YXJ0UG9zKTtcbiAgICAgICAgaWYgKGdvYWwgPT0gbnVsbClcbiAgICAgICAgICAgIGdvYWwgPSBNYXRoLm1pbihyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LCB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAqIChzdGFydFBvcyAtIGxpbmUuZnJvbSkpO1xuICAgICAgICBzdGFydFkgPSAoZGlyIDwgMCA/IGxpbmUudG9wIDogbGluZS5ib3R0b20pICsgZG9jVG9wO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZWRHb2FsID0gcmVjdC5sZWZ0ICsgZ29hbDtcbiAgICBsZXQgZGlzdCA9IGRpc3RhbmNlICE9PSBudWxsICYmIGRpc3RhbmNlICE9PSB2b2lkIDAgPyBkaXN0YW5jZSA6ICh2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUudGV4dEhlaWdodCA+PiAxKTtcbiAgICBmb3IgKGxldCBleHRyYSA9IDA7OyBleHRyYSArPSAxMCkge1xuICAgICAgICBsZXQgY3VyWSA9IHN0YXJ0WSArIChkaXN0ICsgZXh0cmEpICogZGlyO1xuICAgICAgICBsZXQgcG9zID0gcG9zQXRDb29yZHModmlldywgeyB4OiByZXNvbHZlZEdvYWwsIHk6IGN1clkgfSwgZmFsc2UsIGRpcik7XG4gICAgICAgIGlmIChjdXJZIDwgcmVjdC50b3AgfHwgY3VyWSA+IHJlY3QuYm90dG9tIHx8IChkaXIgPCAwID8gcG9zIDwgc3RhcnRQb3MgOiBwb3MgPiBzdGFydFBvcykpIHtcbiAgICAgICAgICAgIGxldCBjaGFyUmVjdCA9IHZpZXcuZG9jVmlldy5jb29yZHNGb3JDaGFyKHBvcyk7XG4gICAgICAgICAgICBsZXQgYXNzb2MgPSAhY2hhclJlY3QgfHwgY3VyWSA8IGNoYXJSZWN0LnRvcCA/IC0xIDogMTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgYXNzb2MsIHVuZGVmaW5lZCwgZ29hbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBza2lwQXRvbWljUmFuZ2VzKGF0b21zLCBwb3MsIGJpYXMpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBtb3ZlZCA9IDA7XG4gICAgICAgIGZvciAobGV0IHNldCBvZiBhdG9tcykge1xuICAgICAgICAgICAgc2V0LmJldHdlZW4ocG9zIC0gMSwgcG9zICsgMSwgKGZyb20sIHRvLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIHBvcyA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaWRlID0gbW92ZWQgfHwgYmlhcyB8fCAocG9zIC0gZnJvbSA8IHRvIC0gcG9zID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gc2lkZSA8IDAgPyBmcm9tIDogdG87XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkID0gc2lkZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vdmVkKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG59XG5mdW5jdGlvbiBza2lwQXRvbXModmlldywgb2xkUG9zLCBwb3MpIHtcbiAgICBsZXQgbmV3UG9zID0gc2tpcEF0b21pY1Jhbmdlcyh2aWV3LnN0YXRlLmZhY2V0KGF0b21pY1JhbmdlcykubWFwKGYgPT4gZih2aWV3KSksIHBvcy5mcm9tLCBvbGRQb3MuaGVhZCA+IHBvcy5mcm9tID8gLTEgOiAxKTtcbiAgICByZXR1cm4gbmV3UG9zID09IHBvcy5mcm9tID8gcG9zIDogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXdQb3MsIG5ld1BvcyA8IHBvcy5mcm9tID8gMSA6IC0xKTtcbn1cblxuY29uc3QgTGluZUJyZWFrUGxhY2Vob2xkZXIgPSBcIlxcdWZmZmZcIjtcbmNsYXNzIERPTVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRzLCBzdGF0ZSQxKSB7XG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmxpbmVTZXBhcmF0b3IgPSBzdGF0ZSQxLmZhY2V0KHN0YXRlLkVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBhcHBlbmQodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgKz0gdGV4dDtcbiAgICB9XG4gICAgbGluZUJyZWFrKCkge1xuICAgICAgICB0aGlzLnRleHQgKz0gTGluZUJyZWFrUGxhY2Vob2xkZXI7XG4gICAgfVxuICAgIHJlYWRSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICghc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHN0YXJ0LnBhcmVudE5vZGU7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHBhcmVudCwgY3VyKTtcbiAgICAgICAgICAgIGxldCBvbGRMZW4gPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5yZWFkTm9kZShjdXIpO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBjdXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSBlbmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChjdXIpLCBuZXh0VmlldyA9IENvbnRlbnRWaWV3LmdldChuZXh0KTtcbiAgICAgICAgICAgIGlmICh2aWV3ICYmIG5leHRWaWV3ID8gdmlldy5icmVha0FmdGVyIDpcbiAgICAgICAgICAgICAgICAodmlldyA/IHZpZXcuYnJlYWtBZnRlciA6IGlzQmxvY2tFbGVtZW50KGN1cikpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc0Jsb2NrRWxlbWVudChuZXh0KSAmJiAoY3VyLm5vZGVOYW1lICE9IFwiQlJcIiB8fCBjdXIuY21JZ25vcmUpICYmIHRoaXMudGV4dC5sZW5ndGggPiBvbGRMZW4pKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHBhcmVudCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlYWRUZXh0Tm9kZShub2RlKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgTWF0aC5taW4ocG9pbnQub2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IDAsIHJlID0gdGhpcy5saW5lU2VwYXJhdG9yID8gbnVsbCA6IC9cXHJcXG4/fFxcbi9nOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QnJlYWsgPSAtMSwgYnJlYWtTaXplID0gMSwgbTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSB0ZXh0LmluZGV4T2YodGhpcy5saW5lU2VwYXJhdG9yLCBvZmYpO1xuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtID0gcmUuZXhlYyh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIG5leHRCcmVhayA9IG0uaW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWtTaXplID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGVuZCh0ZXh0LnNsaWNlKG9mZiwgbmV4dEJyZWFrIDwgMCA/IHRleHQubGVuZ3RoIDogbmV4dEJyZWFrKSk7XG4gICAgICAgICAgICBpZiAobmV4dEJyZWFrIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICBpZiAoYnJlYWtTaXplID4gMSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSAmJiBwb2ludC5wb3MgPiB0aGlzLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQucG9zIC09IGJyZWFrU2l6ZSAtIDE7XG4gICAgICAgICAgICBvZmYgPSBuZXh0QnJlYWsgKyBicmVha1NpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5jbUlnbm9yZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSk7XG4gICAgICAgIGxldCBmcm9tVmlldyA9IHZpZXcgJiYgdmlldy5vdmVycmlkZURPTVRleHQ7XG4gICAgICAgIGlmIChmcm9tVmlldyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRQb2ludEluc2lkZShub2RlLCBmcm9tVmlldy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZyb21WaWV3Lml0ZXIoKTsgIWkubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGkubGluZUJyZWFrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoaS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRUZXh0Tm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIikge1xuICAgICAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFJhbmdlKG5vZGUuZmlyc3RDaGlsZCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZFBvaW50QmVmb3JlKG5vZGUsIG5leHQpIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlICYmIG5vZGUuY2hpbGROb2Rlc1twb2ludC5vZmZzZXRdID09IG5leHQpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgZmluZFBvaW50SW5zaWRlKG5vZGUsIGxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgPyBwb2ludC5ub2RlID09IG5vZGUgOiBub2RlLmNvbnRhaW5zKHBvaW50Lm5vZGUpKVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGggKyAoaXNBdEVuZChub2RlLCBwb2ludC5ub2RlLCBwb2ludC5vZmZzZXQpID8gbGVuZ3RoIDogMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNBdEVuZChwYXJlbnQsIG5vZGUsIG9mZnNldCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCFub2RlIHx8IG9mZnNldCA8IG1heE9mZnNldChub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG59XG5jbGFzcyBET01Qb2ludCB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnBvcyA9IC0xO1xuICAgIH1cbn1cblxuY2xhc3MgRE9NQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydCwgZW5kLCB0eXBlT3Zlcikge1xuICAgICAgICB0aGlzLnR5cGVPdmVyID0gdHlwZU92ZXI7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VkID0gc3RhcnQgPiAtMTtcbiAgICAgICAgbGV0IHsgaW1wcmVjaXNlSGVhZDogaUhlYWQsIGltcHJlY2lzZUFuY2hvcjogaUFuY2hvciB9ID0gdmlldy5kb2NWaWV3O1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSAmJiBzdGFydCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgY2hhbmdlcyB3aGVuIHRoZSBlZGl0b3IgaXMgcmVhZC1vbmx5XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnQgPiAtMSAmJiAodGhpcy5ib3VuZHMgPSB2aWV3LmRvY1ZpZXcuZG9tQm91bmRzQXJvdW5kKHN0YXJ0LCBlbmQsIDApKSkge1xuICAgICAgICAgICAgbGV0IHNlbFBvaW50cyA9IGlIZWFkIHx8IGlBbmNob3IgPyBbXSA6IHNlbGVjdGlvblBvaW50cyh2aWV3KTtcbiAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRE9NUmVhZGVyKHNlbFBvaW50cywgdmlldy5zdGF0ZSk7XG4gICAgICAgICAgICByZWFkZXIucmVhZFJhbmdlKHRoaXMuYm91bmRzLnN0YXJ0RE9NLCB0aGlzLmJvdW5kcy5lbmRET00pO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gcmVhZGVyLnRleHQ7XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IHNlbGVjdGlvbkZyb21Qb2ludHMoc2VsUG9pbnRzLCB0aGlzLmJvdW5kcy5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkb21TZWwgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICAgICAgbGV0IGhlYWQgPSBpSGVhZCAmJiBpSGVhZC5ub2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgaUhlYWQub2Zmc2V0ID09IGRvbVNlbC5mb2N1c09mZnNldCB8fFxuICAgICAgICAgICAgICAgICFjb250YWlucyh2aWV3LmNvbnRlbnRET00sIGRvbVNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICAgICAgPyB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWRcbiAgICAgICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgICAgICBsZXQgYW5jaG9yID0gaUFuY2hvciAmJiBpQW5jaG9yLm5vZGUgPT0gZG9tU2VsLmFuY2hvck5vZGUgJiYgaUFuY2hvci5vZmZzZXQgPT0gZG9tU2VsLmFuY2hvck9mZnNldCB8fFxuICAgICAgICAgICAgICAgICFjb250YWlucyh2aWV3LmNvbnRlbnRET00sIGRvbVNlbC5hbmNob3JOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3JcbiAgICAgICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIGlPUyB3aWxsIHJlZnVzZSB0byBzZWxlY3QgdGhlIGJsb2NrIGdhcHMgd2hlbiBkb2luZ1xuICAgICAgICAgICAgLy8gc2VsZWN0LWFsbC5cbiAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHB1dCB0aGUgc2VsZWN0aW9uICppbnNpZGUqIHRoZW0sIGNvbmZ1c2luZ1xuICAgICAgICAgICAgLy8gcG9zRnJvbURPTVxuICAgICAgICAgICAgbGV0IHZwID0gdmlldy52aWV3cG9ydDtcbiAgICAgICAgICAgIGlmICgoYnJvd3Nlci5pb3MgfHwgYnJvd3Nlci5jaHJvbWUpICYmIHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiYgaGVhZCAhPSBhbmNob3IgJiZcbiAgICAgICAgICAgICAgICAodnAuZnJvbSA+IDAgfHwgdnAudG8gPCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihoZWFkLCBhbmNob3IpLCB0byA9IE1hdGgubWF4KGhlYWQsIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgbGV0IG9mZkZyb20gPSB2cC5mcm9tIC0gZnJvbSwgb2ZmVG8gPSB2cC50byAtIHRvO1xuICAgICAgICAgICAgICAgIGlmICgob2ZmRnJvbSA9PSAwIHx8IG9mZkZyb20gPT0gMSB8fCBmcm9tID09IDApICYmIChvZmZUbyA9PSAwIHx8IG9mZlRvID09IC0xIHx8IHRvID09IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IHZpZXcuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RE9NQ2hhbmdlKHZpZXcsIGRvbUNoYW5nZSkge1xuICAgIGxldCBjaGFuZ2U7XG4gICAgbGV0IHsgbmV3U2VsIH0gPSBkb21DaGFuZ2UsIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IGxhc3RLZXkgPSB2aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPiBEYXRlLm5vdygpIC0gMTAwID8gdmlldy5pbnB1dFN0YXRlLmxhc3RLZXlDb2RlIDogLTE7XG4gICAgaWYgKGRvbUNoYW5nZS5ib3VuZHMpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGRvbUNoYW5nZS5ib3VuZHM7XG4gICAgICAgIGxldCBwcmVmZXJyZWRQb3MgPSBzZWwuZnJvbSwgcHJlZmVycmVkU2lkZSA9IG51bGw7XG4gICAgICAgIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWQgKG9yLCBvblxuICAgICAgICAvLyBBbmRyb2lkLCB3aGVuIHNvbWV0aGluZyB3YXMgZGVsZXRlZClcbiAgICAgICAgaWYgKGxhc3RLZXkgPT09IDggfHwgYnJvd3Nlci5hbmRyb2lkICYmIGRvbUNoYW5nZS50ZXh0Lmxlbmd0aCA8IHRvIC0gZnJvbSkge1xuICAgICAgICAgICAgcHJlZmVycmVkUG9zID0gc2VsLnRvO1xuICAgICAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwiZW5kXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZmYgPSBmaW5kRGlmZih2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0bywgTGluZUJyZWFrUGxhY2Vob2xkZXIpLCBkb21DaGFuZ2UudGV4dCwgcHJlZmVycmVkUG9zIC0gZnJvbSwgcHJlZmVycmVkU2lkZSk7XG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgaW5zZXJ0cyB0d28gbmV3bGluZXMgd2hlbiBwcmVzc2luZyBzaGlmdC1lbnRlciBhdCB0aGVcbiAgICAgICAgICAgIC8vIGVuZCBvZiBhIGxpbmUuIERvbUNoYW5nZSBkcm9wcyBvbmUgb2YgdGhvc2UuXG4gICAgICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgbGFzdEtleSA9PSAxMyAmJlxuICAgICAgICAgICAgICAgIGRpZmYudG9CID09IGRpZmYuZnJvbSArIDIgJiYgZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikgPT0gTGluZUJyZWFrUGxhY2Vob2xkZXIgKyBMaW5lQnJlYWtQbGFjZWhvbGRlcilcbiAgICAgICAgICAgICAgICBkaWZmLnRvQi0tO1xuICAgICAgICAgICAgY2hhbmdlID0geyBmcm9tOiBmcm9tICsgZGlmZi5mcm9tLCB0bzogZnJvbSArIGRpZmYudG9BLFxuICAgICAgICAgICAgICAgIGluc2VydDogc3RhdGUuVGV4dC5vZihkb21DaGFuZ2UudGV4dC5zbGljZShkaWZmLmZyb20sIGRpZmYudG9CKS5zcGxpdChMaW5lQnJlYWtQbGFjZWhvbGRlcikpIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICghdmlldy5oYXNGb2N1cyAmJiB2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSB8fCBuZXdTZWwubWFpbi5lcShzZWwpKSkge1xuICAgICAgICBuZXdTZWwgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZSAmJiAhbmV3U2VsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFjaGFuZ2UgJiYgZG9tQ2hhbmdlLnR5cGVPdmVyICYmICFzZWwuZW1wdHkgJiYgbmV3U2VsICYmIG5ld1NlbC5tYWluLmVtcHR5KSB7XG4gICAgICAgIC8vIEhldXJpc3RpYyB0byBub3RpY2UgdHlwaW5nIG92ZXIgYSBzZWxlY3RlZCBjaGFyYWN0ZXJcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgc2VsLnRvKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPj0gc2VsLmZyb20gJiYgY2hhbmdlLnRvIDw9IHNlbC50byAmJlxuICAgICAgICAoY2hhbmdlLmZyb20gIT0gc2VsLmZyb20gfHwgY2hhbmdlLnRvICE9IHNlbC50bykgJiZcbiAgICAgICAgKHNlbC50byAtIHNlbC5mcm9tKSAtIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSkgPD0gNCkge1xuICAgICAgICAvLyBJZiB0aGUgY2hhbmdlIGlzIGluc2lkZSB0aGUgc2VsZWN0aW9uIGFuZCBjb3ZlcnMgbW9zdCBvZiBpdCxcbiAgICAgICAgLy8gYXNzdW1lIGl0IGlzIGEgc2VsZWN0aW9uIHJlcGxhY2UgKHdpdGggaWRlbnRpY2FsIGNoYXJhY3RlcnMgYXRcbiAgICAgICAgLy8gdGhlIHN0YXJ0L2VuZCBub3QgaW5jbHVkZWQgaW4gdGhlIGRpZmYpXG4gICAgICAgIGNoYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLFxuICAgICAgICAgICAgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgY2hhbmdlLmZyb20pLmFwcGVuZChjaGFuZ2UuaW5zZXJ0KS5hcHBlbmQodmlldy5zdGF0ZS5kb2Muc2xpY2UoY2hhbmdlLnRvLCBzZWwudG8pKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgoYnJvd3Nlci5tYWMgfHwgYnJvd3Nlci5hbmRyb2lkKSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tID09IHNlbC5oZWFkIC0gMSAmJlxuICAgICAgICAvXlxcLiA/JC8udGVzdChjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkpICYmIHZpZXcuY29udGVudERPTS5nZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiKSA9PSBcIm9mZlwiKSB7XG4gICAgICAgIC8vIERldGVjdCBpbnNlcnQtcGVyaW9kLW9uLWRvdWJsZS1zcGFjZSBNYWMgYW5kIEFuZHJvaWQgYmVoYXZpb3IsXG4gICAgICAgIC8vIGFuZCB0cmFuc2Zvcm0gaXQgaW50byBhIHJlZ3VsYXIgc3BhY2UgaW5zZXJ0LlxuICAgICAgICBpZiAobmV3U2VsICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDIpXG4gICAgICAgICAgICBuZXdTZWwgPSBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiBzdGF0ZS5UZXh0Lm9mKFtcIiBcIl0pIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXIuY2hyb21lICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgY2hhbmdlLmZyb20gPT0gc2VsLmhlYWQgJiZcbiAgICAgICAgY2hhbmdlLmluc2VydC50b1N0cmluZygpID09IFwiXFxuIFwiICYmIHZpZXcubGluZVdyYXBwaW5nKSB7XG4gICAgICAgIC8vIEluIENocm9tZSwgaWYgeW91IGluc2VydCBhIHNwYWNlIGF0IHRoZSBzdGFydCBvZiBhIHdyYXBwZWRcbiAgICAgICAgLy8gbGluZSwgaXQgd2lsbCBhY3R1YWxseSBpbnNlcnQgYSBuZXdsaW5lIGFuZCBhIHNwYWNlLCBjYXVzaW5nIGFcbiAgICAgICAgLy8gYm9ndXMgbmV3IGxpbmUgdG8gYmUgY3JlYXRlZCBpbiBDb2RlTWlycm9yICgjOTY4KVxuICAgICAgICBpZiAobmV3U2VsKVxuICAgICAgICAgICAgbmV3U2VsID0gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXdTZWwubWFpbi5hbmNob3IgLSAxLCBuZXdTZWwubWFpbi5oZWFkIC0gMSk7XG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogc3RhdGUuVGV4dC5vZihbXCIgXCJdKSB9O1xuICAgIH1cbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBhcHBseURPTUNoYW5nZUlubmVyKHZpZXcsIGNoYW5nZSwgbmV3U2VsLCBsYXN0S2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICFuZXdTZWwubWFpbi5lcShzZWwpKSB7XG4gICAgICAgIGxldCBzY3JvbGxJbnRvVmlldyA9IGZhbHNlLCB1c2VyRXZlbnQgPSBcInNlbGVjdFwiO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwKSB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW4gPT0gXCJzZWxlY3RcIilcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldyA9IHRydWU7XG4gICAgICAgICAgICB1c2VyRXZlbnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiBuZXdTZWwsIHNjcm9sbEludG9WaWV3LCB1c2VyRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RE9NQ2hhbmdlSW5uZXIodmlldywgY2hhbmdlLCBuZXdTZWwsIGxhc3RLZXkgPSAtMSkge1xuICAgIGlmIChicm93c2VyLmlvcyAmJiB2aWV3LmlucHV0U3RhdGUuZmx1c2hJT1NLZXkoY2hhbmdlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgLy8gQW5kcm9pZCBicm93c2VycyBkb24ndCBmaXJlIHJlYXNvbmFibGUga2V5IGV2ZW50cyBmb3IgZW50ZXIsXG4gICAgLy8gYmFja3NwYWNlLCBvciBkZWxldGUuIFNvIHRoaXMgZGV0ZWN0cyBjaGFuZ2VzIHRoYXQgbG9vayBsaWtlXG4gICAgLy8gdGhleSdyZSBjYXVzZWQgYnkgdGhvc2Uga2V5cywgYW5kIHJlaW50ZXJwcmV0cyB0aGVtIGFzIGtleVxuICAgIC8vIGV2ZW50cy4gKFNvbWUgb2YgdGhlc2Uga2V5cyBhcmUgYWxzbyBoYW5kbGVkIGJ5IGJlZm9yZWlucHV0XG4gICAgLy8gZXZlbnRzIGFuZCB0aGUgcGVuZGluZ0FuZHJvaWRLZXkgbWVjaGFuaXNtLCBidXQgdGhhdCdzIG5vdFxuICAgIC8vIHJlbGlhYmxlIGluIGFsbCBzaXR1YXRpb25zLilcbiAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmXG4gICAgICAgICgoY2hhbmdlLnRvID09IHNlbC50byAmJlxuICAgICAgICAgICAgLy8gR0JvYXJkIHdpbGwgc29tZXRpbWVzIHJlbW92ZSBhIHNwYWNlIGl0IGp1c3QgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGFmdGVyIGEgY29tcGxldGlvbiB3aGVuIHlvdSBwcmVzcyBlbnRlclxuICAgICAgICAgICAgKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tIHx8IGNoYW5nZS5mcm9tID09IHNlbC5mcm9tIC0gMSAmJiB2aWV3LnN0YXRlLnNsaWNlRG9jKGNoYW5nZS5mcm9tLCBzZWwuZnJvbSkgPT0gXCIgXCIpICYmXG4gICAgICAgICAgICBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS5pbnNlcnQubGluZXMgPT0gMiAmJlxuICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkVudGVyXCIsIDEzKSkgfHxcbiAgICAgICAgICAgICgoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gLSAxICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCB8fFxuICAgICAgICAgICAgICAgIGxhc3RLZXkgPT0gOCAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA8IGNoYW5nZS50byAtIGNoYW5nZS5mcm9tICYmIGNoYW5nZS50byA+IHNlbC5oZWFkKSAmJlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJCYWNrc3BhY2VcIiwgOCkpIHx8XG4gICAgICAgICAgICAoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgY2hhbmdlLnRvID09IHNlbC50byArIDEgJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJEZWxldGVcIiwgNDYpKSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCB0ZXh0ID0gY2hhbmdlLmluc2VydC50b1N0cmluZygpO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcrKztcbiAgICBsZXQgZGVmYXVsdFRyO1xuICAgIGxldCBkZWZhdWx0SW5zZXJ0ID0gKCkgPT4gZGVmYXVsdFRyIHx8IChkZWZhdWx0VHIgPSBhcHBseURlZmF1bHRJbnNlcnQodmlldywgY2hhbmdlLCBuZXdTZWwpKTtcbiAgICBpZiAoIXZpZXcuc3RhdGUuZmFjZXQoaW5wdXRIYW5kbGVyKS5zb21lKGggPT4gaCh2aWV3LCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvLCB0ZXh0LCBkZWZhdWx0SW5zZXJ0KSkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goZGVmYXVsdEluc2VydCgpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdEluc2VydCh2aWV3LCBjaGFuZ2UsIG5ld1NlbCkge1xuICAgIGxldCB0ciwgc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGUsIHNlbCA9IHN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gPj0gKHNlbC50byAtIHNlbC5mcm9tKSAvIDMgJiZcbiAgICAgICAgKCFuZXdTZWwgfHwgbmV3U2VsLm1haW4uZW1wdHkgJiYgbmV3U2VsLm1haW4uZnJvbSA9PSBjaGFuZ2UuZnJvbSArIGNoYW5nZS5pbnNlcnQubGVuZ3RoKSAmJlxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICBsZXQgYmVmb3JlID0gc2VsLmZyb20gPCBjaGFuZ2UuZnJvbSA/IHN0YXJ0U3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIGNoYW5nZS5mcm9tKSA6IFwiXCI7XG4gICAgICAgIGxldCBhZnRlciA9IHNlbC50byA+IGNoYW5nZS50byA/IHN0YXJ0U3RhdGUuc2xpY2VEb2MoY2hhbmdlLnRvLCBzZWwudG8pIDogXCJcIjtcbiAgICAgICAgdHIgPSBzdGFydFN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odmlldy5zdGF0ZS50b1RleHQoYmVmb3JlICsgY2hhbmdlLmluc2VydC5zbGljZVN0cmluZygwLCB1bmRlZmluZWQsIHZpZXcuc3RhdGUubGluZUJyZWFrKSArIGFmdGVyKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyhjaGFuZ2UpO1xuICAgICAgICBsZXQgbWFpblNlbCA9IG5ld1NlbCAmJiBuZXdTZWwubWFpbi50byA8PSBjaGFuZ2VzLm5ld0xlbmd0aCA/IG5ld1NlbC5tYWluIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBUcnkgdG8gYXBwbHkgYSBjb21wb3NpdGlvbiBjaGFuZ2UgdG8gYWxsIGN1cnNvcnNcbiAgICAgICAgaWYgKHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggPiAxICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJlxuICAgICAgICAgICAgY2hhbmdlLnRvIDw9IHNlbC50byAmJiBjaGFuZ2UudG8gPj0gc2VsLnRvIC0gMTApIHtcbiAgICAgICAgICAgIGxldCByZXBsYWNlZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgICAgICAgICBsZXQgY29tcG9zaXRpb25SYW5nZSwgY29tcG9zaXRpb24gPSBuZXdTZWwgJiYgZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBuZXdTZWwubWFpbi5oZWFkKTtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBkTGVuID0gY2hhbmdlLmluc2VydC5sZW5ndGggLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pO1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB7IGZyb206IGNvbXBvc2l0aW9uLmZyb20sIHRvOiBjb21wb3NpdGlvbi50byAtIGRMZW4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc2VsLmhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHNlbC50byAtIGNoYW5nZS50bywgc2l6ZSA9IHNlbC50byAtIHNlbC5mcm9tO1xuICAgICAgICAgICAgdHIgPSBzdGFydFN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIHJhbmdlLnRvID09IHNlbC50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlcywgcmFuZ2U6IG1haW5TZWwgfHwgcmFuZ2UubWFwKGNoYW5nZXMpIH07XG4gICAgICAgICAgICAgICAgbGV0IHRvID0gcmFuZ2UudG8gLSBvZmZzZXQsIGZyb20gPSB0byAtIHJlcGxhY2VkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UudG8gLSByYW5nZS5mcm9tICE9IHNpemUgfHwgdmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0bykgIT0gcmVwbGFjZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlcmUncyBubyB3YXkgdG8gbWFrZSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIGluIHRoZSBzYW1lIG5vZGUgd29yayB3aXRob3V0IGFib3J0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0aW9uLCBzbyBjdXJzb3JzIGluIHRoZSBjb21wb3NpdGlvbiByYW5nZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UudG8gPj0gY29tcG9zaXRpb25SYW5nZS5mcm9tICYmIHJhbmdlLmZyb20gPD0gY29tcG9zaXRpb25SYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VDaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKHsgZnJvbSwgdG8sIGluc2VydDogY2hhbmdlLmluc2VydCB9KSwgc2VsT2ZmID0gcmFuZ2UudG8gLSBzZWwudG87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VDaGFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogIW1haW5TZWwgPyByYW5nZS5tYXAocmFuZ2VDaGFuZ2VzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UoTWF0aC5tYXgoMCwgbWFpblNlbC5hbmNob3IgKyBzZWxPZmYpLCBNYXRoLm1heCgwLCBtYWluU2VsLmhlYWQgKyBzZWxPZmYpKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyID0ge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBtYWluU2VsICYmIHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJlcGxhY2VSYW5nZShtYWluU2VsKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdXNlckV2ZW50ID0gXCJpbnB1dC50eXBlXCI7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nIHx8XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHVzZXJFdmVudCArPSBcIi5jb21wb3NlXCI7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdXNlckV2ZW50ICs9IFwiLnN0YXJ0XCI7XG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydFN0YXRlLnVwZGF0ZSh0ciwgeyB1c2VyRXZlbnQsIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IG1pbkxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgbGV0IGZyb20gPSAwO1xuICAgIHdoaWxlIChmcm9tIDwgbWluTGVuICYmIGEuY2hhckNvZGVBdChmcm9tKSA9PSBiLmNoYXJDb2RlQXQoZnJvbSkpXG4gICAgICAgIGZyb20rKztcbiAgICBpZiAoZnJvbSA9PSBtaW5MZW4gJiYgYS5sZW5ndGggPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0b0EgPSBhLmxlbmd0aCwgdG9CID0gYi5sZW5ndGg7XG4gICAgd2hpbGUgKHRvQSA+IDAgJiYgdG9CID4gMCAmJiBhLmNoYXJDb2RlQXQodG9BIC0gMSkgPT0gYi5jaGFyQ29kZUF0KHRvQiAtIDEpKSB7XG4gICAgICAgIHRvQS0tO1xuICAgICAgICB0b0ItLTtcbiAgICB9XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgZnJvbSAtIE1hdGgubWluKHRvQSwgdG9CKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSB0b0EgKyBhZGp1c3QgLSBmcm9tO1xuICAgIH1cbiAgICBpZiAodG9BIDwgZnJvbSAmJiBhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQSA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQiA9IGZyb20gKyAodG9CIC0gdG9BKTtcbiAgICAgICAgdG9BID0gZnJvbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9CIDwgZnJvbSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0IgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0EgPSBmcm9tICsgKHRvQSAtIHRvQik7XG4gICAgICAgIHRvQiA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiB7IGZyb20sIHRvQSwgdG9CIH07XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Qb2ludHModmlldykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZiAodmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoYW5jaG9yTm9kZSkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSk7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT0gYW5jaG9yTm9kZSB8fCBmb2N1c09mZnNldCAhPSBhbmNob3JPZmZzZXQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbVBvaW50cyhwb2ludHMsIGJhc2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yID0gcG9pbnRzWzBdLnBvcywgaGVhZCA9IHBvaW50cy5sZW5ndGggPT0gMiA/IHBvaW50c1sxXS5wb3MgOiBhbmNob3I7XG4gICAgcmV0dXJuIGFuY2hvciA+IC0xICYmIGhlYWQgPiAtMSA/IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yICsgYmFzZSwgaGVhZCArIGJhc2UpIDogbnVsbDtcbn1cblxuY2xhc3MgSW5wdXRTdGF0ZSB7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKG9yaWdpbikge1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLZXlUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIC8vIE9uIGlPUywgc29tZSBrZXlzIG5lZWQgdG8gaGF2ZSB0aGVpciBkZWZhdWx0IGJlaGF2aW9yIGhhcHBlblxuICAgICAgICAvLyAoYWZ0ZXIgd2hpY2ggd2UgcmV0cm9hY3RpdmVseSBoYW5kbGUgdGhlbSBhbmQgcmVzZXQgdGhlIERPTSkgdG9cbiAgICAgICAgLy8gYXZvaWQgbWVzc2luZyB1cCB0aGUgdmlydHVhbCBrZXlib2FyZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgV2hlbiBlbmFibGVkICg+LTEpLCB0YWIgcHJlc3NlcyBhcmUgbm90IGdpdmVuIHRvIGtleSBoYW5kbGVycyxcbiAgICAgICAgbGVhdmluZyB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IuIElmID4wLCB0aGUgbW9kZSBleHBpcmVzXG4gICAgICAgIGF0IHRoYXQgdGltZXN0YW1wLCBhbmQgYW55IG90aGVyIGtleXByZXNzIGNsZWFycyBpdC5cbiAgICAgICAgRXNjIGVuYWJsZXMgdGVtcG9yYXJ5IHRhYiBmb2N1cyBtb2RlIGZvciB0d28gc2Vjb25kcyB3aGVuIG5vdFxuICAgICAgICBvdGhlcndpc2UgaGFuZGxlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJGb2N1c01vZGUgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbnRleHRNZW51ID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxIYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLy8gLTEgbWVhbnMgbm90IGluIGEgY29tcG9zaXRpb24uIE90aGVyd2lzZSwgdGhpcyBjb3VudHMgdGhlIG51bWJlclxuICAgICAgICAvLyBvZiBjaGFuZ2VzIG1hZGUgZHVyaW5nIHRoZSBjb21wb3NpdGlvbi4gVGhlIGNvdW50IGlzIHVzZWQgdG9cbiAgICAgICAgLy8gYXZvaWQgdHJlYXRpbmcgdGhlIHN0YXJ0IHN0YXRlIG9mIHRoZSBjb21wb3NpdGlvbiwgYmVmb3JlIGFueVxuICAgICAgICAvLyBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlLCBhcyBwYXJ0IG9mIHRoZSBjb21wb3NpdGlvbi5cbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAtMTtcbiAgICAgICAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlIG5leHQgY2hhbmdlIHNob3VsZCBiZSBtYXJrZWQgYXMgc3RhcnRpbmcgdGhlXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIChudWxsIG1lYW5zIG5vIGNvbXBvc2l0aW9uLCB0cnVlIG1lYW5zIG5leHQgaXMgdGhlXG4gICAgICAgIC8vIGZpcnN0LCBmYWxzZSBtZWFucyBmaXJzdCBoYXMgYWxyZWFkeSBiZWVuIG1hcmtlZCBmb3IgdGhpc1xuICAgICAgICAvLyBjb21wb3NpdGlvbilcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgLy8gRW5kIHRpbWUgb2YgdGhlIHByZXZpb3VzIGNvbXBvc2l0aW9uXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gMDtcbiAgICAgICAgLy8gVXNlZCBpbiBhIGtsdWRnZSB0byBkZXRlY3Qgd2hlbiBhbiBFbnRlciBrZXlwcmVzcyBzaG91bGQgYmVcbiAgICAgICAgLy8gY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBjb21wb3NpdGlvbiBvbiBTYWZhcmksIHdoaWNoIGZpcmVzIGV2ZW50c1xuICAgICAgICAvLyBpbiB0aGUgd3Jvbmcgb3JkZXJcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSBmYWxzZTtcbiAgICAgICAgLy8gVXNlZCB0byBjYXRlZ29yaXplIGNoYW5nZXMgYXMgcGFydCBvZiBhIGNvbXBvc2l0aW9uLCBldmVuIHdoZW5cbiAgICAgICAgLy8gdGhlIG11dGF0aW9uIGV2ZW50cyBmaXJlIHNob3J0bHkgYWZ0ZXIgdGhlIGNvbXBvc2l0aW9uZW5kIGV2ZW50XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAvLyBXaGVuIGEgZHJhZyBmcm9tIHRoZSBlZGl0b3IgaXMgYWN0aXZlLCB0aGlzIHBvaW50cyBhdCB0aGUgcmFuZ2VcbiAgICAgICAgLy8gYmVpbmcgZHJhZ2dlZC5cbiAgICAgICAgdGhpcy5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubm90aWZpZWRGb2N1c2VkID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgLy8gT24gU2FmYXJpIGFkZGluZyBhbiBpbnB1dCBldmVudCBoYW5kbGVyIHNvbWVob3cgcHJldmVudHMgYW5cbiAgICAgICAgLy8gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW4geW91IHByZXNzIGVudGVyLlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkpXG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbylcbiAgICAgICAgICAgIGZpcmVmb3hDb3B5Q3V0SGFjayh2aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudCk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnRCZWxvbmdzVG9FZGl0b3IodGhpcy52aWV3LCBldmVudCkgfHwgdGhpcy5pZ25vcmVEdXJpbmdDb21wb3NpdGlvbihldmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChldmVudC50eXBlID09IFwia2V5ZG93blwiICYmIHRoaXMua2V5ZG93bihldmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucnVuSGFuZGxlcnMoZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIH1cbiAgICBydW5IYW5kbGVycyh0eXBlLCBldmVudCkge1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG9ic2VydmVyIG9mIGhhbmRsZXJzLm9ic2VydmVycylcbiAgICAgICAgICAgICAgICBvYnNlcnZlcih0aGlzLnZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgaGFuZGxlcnMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIodGhpcy52aWV3LCBldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVuc3VyZUhhbmRsZXJzKHBsdWdpbnMpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0gY29tcHV0ZUhhbmRsZXJzKHBsdWdpbnMpLCBwcmV2ID0gdGhpcy5oYW5kbGVycywgZG9tID0gdGhpcy52aWV3LmNvbnRlbnRET007XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpXG4gICAgICAgICAgICBpZiAodHlwZSAhPSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhc3NpdmUgPSAhaGFuZGxlcnNbdHlwZV0uaGFuZGxlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBleGlzdHMgPSBwcmV2W3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdHMgJiYgcGFzc2l2ZSAhPSAhZXhpc3RzLmhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpXG4gICAgICAgICAgICAgICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuaGFuZGxlRXZlbnQsIHsgcGFzc2l2ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBwcmV2KVxuICAgICAgICAgICAgaWYgKHR5cGUgIT0gXCJzY3JvbGxcIiAmJiAhaGFuZGxlcnNbdHlwZV0pXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5oYW5kbGVFdmVudCk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICB9XG4gICAga2V5ZG93bihldmVudCkge1xuICAgICAgICAvLyBNdXN0IGFsd2F5cyBydW4sIGV2ZW4gaWYgYSBjdXN0b20gaGFuZGxlciBoYW5kbGVkIHRoZSBldmVudFxuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDkgJiYgdGhpcy50YWJGb2N1c01vZGUgPiAtMSAmJiAoIXRoaXMudGFiRm9jdXNNb2RlIHx8IERhdGUubm93KCkgPD0gdGhpcy50YWJGb2N1c01vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLnRhYkZvY3VzTW9kZSA+IDAgJiYgZXZlbnQua2V5Q29kZSAhPSAyNyAmJiBtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy50YWJGb2N1c01vZGUgPSAtMTtcbiAgICAgICAgLy8gQ2hyb21lIGZvciBBbmRyb2lkIHVzdWFsbHkgZG9lc24ndCBmaXJlIHByb3BlciBrZXkgZXZlbnRzLCBidXRcbiAgICAgICAgLy8gb2NjYXNpb25hbGx5IGRvZXMsIHVzdWFsbHkgc3Vycm91bmRlZCBieSBhIGJ1bmNoIG9mIGNvbXBsaWNhdGVkXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIGNoYW5nZXMuIFdoZW4gYW4gZW50ZXIgb3IgYmFja3NwYWNlIGtleSBldmVudCBpc1xuICAgICAgICAvLyBzZWVuLCBob2xkIG9mZiBvbiBoYW5kbGluZyBET00gZXZlbnRzIGZvciBhIGJpdCwgYW5kIHRoZW5cbiAgICAgICAgLy8gZGlzcGF0Y2ggaXQuXG4gICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJlxuICAgICAgICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PSA4KSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShldmVudC5rZXksIGV2ZW50LmtleUNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudGluZyB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBFbnRlciBvbiBpT1MgbWFrZXMgdGhlXG4gICAgICAgIC8vIHZpcnR1YWwga2V5Ym9hcmQgZ2V0IHN0dWNrIGluIHRoZSB3cm9uZyAobG93ZXJjYXNlKVxuICAgICAgICAvLyBzdGF0ZS4gU28gd2UgbGV0IGl0IGdvIHRocm91Z2gsIGFuZCB0aGVuLCBpblxuICAgICAgICAvLyBhcHBseURPTUNoYW5nZSwgbm90aWZ5IGtleSBoYW5kbGVycyBvZiBpdCBhbmQgcmVzZXQgdG9cbiAgICAgICAgLy8gdGhlIHN0YXRlIHRoZXkgcHJvZHVjZS5cbiAgICAgICAgbGV0IHBlbmRpbmc7XG4gICAgICAgIGlmIChicm93c2VyLmlvcyAmJiAhZXZlbnQuc3ludGhldGljICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgJiZcbiAgICAgICAgICAgICgocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5rZXlDb2RlID09IGV2ZW50LmtleUNvZGUpKSAmJiAhZXZlbnQuY3RybEtleSB8fFxuICAgICAgICAgICAgICAgIEVtYWNzeVBlbmRpbmdLZXlzLmluZGV4T2YoZXZlbnQua2V5KSA+IC0xICYmIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LnNoaWZ0S2V5KSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gcGVuZGluZyB8fCBldmVudDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaElPU0tleSgpLCAyNTApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT0gMjI5KVxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmbHVzaElPU0tleShjaGFuZ2UpIHtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMucGVuZGluZ0lPU0tleTtcbiAgICAgICAgaWYgKCFrZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSBhbiBhdXRvY29ycmVjdGlvbiBiZWZvcmUgRW50ZXJcbiAgICAgICAgaWYgKGtleS5rZXkgPT0gXCJFbnRlclwiICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA8IGNoYW5nZS50byAmJiAvXlxcUyskLy50ZXN0KGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KHRoaXMudmlldy5jb250ZW50RE9NLCBrZXkua2V5LCBrZXkua2V5Q29kZSwga2V5IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCA/IGtleSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghL15rZXkvLnRlc3QoZXZlbnQudHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyA+IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0dW0uZGUvMjAxNi8wNi8yNC9oYW5kbGluZy1pbWUtZXZlbnRzLWluLWphdmFzY3JpcHQvLlxuICAgICAgICAvLyBPbiBzb21lIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGNvbmZpcm0gY2hhcmFjdGVyIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmUgc29tZXRpbWVzIGVtaXR0ZWQgaW4gdGhlXG4gICAgICAgIC8vIHdyb25nIG9yZGVyLiBUaGUga2V5IGV2ZW50IHNob3VsZCBzdGlsbCBiZSBpZ25vcmVkLCBldmVuIHdoZW5cbiAgICAgICAgLy8gaXQgaGFwcGVucyBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnQuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiAhYnJvd3Nlci5pb3MgJiYgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdLZXkgJiYgRGF0ZS5ub3coKSAtIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0IDwgMTAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGFydE1vdXNlU2VsZWN0aW9uKG1vdXNlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBtb3VzZVNlbGVjdGlvbjtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dlZENvbnRlbnQgJiYgdXBkYXRlLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRyYWdnZWRDb250ZW50ID0gdGhpcy5kcmFnZ2VkQ29udGVudC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmluZEhhbmRsZXIocGx1Z2luLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChwbHVnaW4sIGV2ZW50LCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIYW5kbGVycyhwbHVnaW5zKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gcmVjb3JkKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFt0eXBlXSB8fCAocmVzdWx0W3R5cGVdID0geyBvYnNlcnZlcnM6IFtdLCBoYW5kbGVyczogW10gfSk7XG4gICAgfVxuICAgIGZvciAobGV0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgIGxldCBzcGVjID0gcGx1Z2luLnNwZWM7XG4gICAgICAgIGlmIChzcGVjICYmIHNwZWMuZG9tRXZlbnRIYW5kbGVycylcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gc3BlYy5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGYgPSBzcGVjLmRvbUV2ZW50SGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCh0eXBlKS5oYW5kbGVycy5wdXNoKGJpbmRIYW5kbGVyKHBsdWdpbi52YWx1ZSwgZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYyAmJiBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzKVxuICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGYgPSBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgICAgICByZWNvcmQodHlwZSkub2JzZXJ2ZXJzLnB1c2goYmluZEhhbmRsZXIocGx1Z2luLnZhbHVlLCBmKSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpXG4gICAgICAgIHJlY29yZCh0eXBlKS5oYW5kbGVycy5wdXNoKGhhbmRsZXJzW3R5cGVdKTtcbiAgICBmb3IgKGxldCB0eXBlIGluIG9ic2VydmVycylcbiAgICAgICAgcmVjb3JkKHR5cGUpLm9ic2VydmVycy5wdXNoKG9ic2VydmVyc1t0eXBlXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IFBlbmRpbmdLZXlzID0gW1xuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBrZXlDb2RlOiA4LCBpbnB1dFR5cGU6IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBrZXlDb2RlOiAxMywgaW5wdXRUeXBlOiBcImluc2VydFBhcmFncmFwaFwiIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRMaW5lQnJlYWtcIiB9LFxuICAgIHsga2V5OiBcIkRlbGV0ZVwiLCBrZXlDb2RlOiA0NiwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCIgfVxuXTtcbmNvbnN0IEVtYWNzeVBlbmRpbmdLZXlzID0gXCJkdGhrb1wiO1xuLy8gS2V5IGNvZGVzIGZvciBtb2RpZmllciBrZXlzXG5jb25zdCBtb2RpZmllckNvZGVzID0gWzE2LCAxNywgMTgsIDIwLCA5MSwgOTIsIDIyNCwgMjI1XTtcbmNvbnN0IGRyYWdTY3JvbGxNYXJnaW4gPSA2O1xuZnVuY3Rpb24gZHJhZ1Njcm9sbFNwZWVkKGRpc3QpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgZGlzdCkgKiAwLjcgKyA4O1xufVxuZnVuY3Rpb24gZGlzdChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKGEuY2xpZW50WCAtIGIuY2xpZW50WCksIE1hdGguYWJzKGEuY2xpZW50WSAtIGIuY2xpZW50WSkpO1xufVxuY2xhc3MgTW91c2VTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXJ0RXZlbnQsIHN0eWxlLCBtdXN0U2VsZWN0KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgdGhpcy5tdXN0U2VsZWN0ID0gbXVzdFNlbGVjdDtcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB0aGlzLnNjcm9sbGluZyA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50cyA9IHNjcm9sbGFibGVQYXJlbnRzKHZpZXcuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMuYXRvbXMgPSB2aWV3LnN0YXRlLmZhY2V0KGF0b21pY1JhbmdlcykubWFwKGYgPT4gZih2aWV3KSk7XG4gICAgICAgIGxldCBkb2MgPSB2aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gc3RhcnRFdmVudC5zaGlmdEtleTtcbiAgICAgICAgdGhpcy5tdWx0aXBsZSA9IHZpZXcuc3RhdGUuZmFjZXQoc3RhdGUuRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpICYmIGFkZHNTZWxlY3Rpb25SYW5nZSh2aWV3LCBzdGFydEV2ZW50KTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGlzSW5QcmltYXJ5U2VsZWN0aW9uKHZpZXcsIHN0YXJ0RXZlbnQpICYmIGdldENsaWNrVHlwZShzdGFydEV2ZW50KSA9PSAxID8gbnVsbCA6IGZhbHNlO1xuICAgIH1cbiAgICBzdGFydChldmVudCkge1xuICAgICAgICAvLyBXaGVuIGNsaWNraW5nIG91dHNpZGUgb2YgdGhlIHNlbGVjdGlvbiwgaW1tZWRpYXRlbHkgYXBwbHkgdGhlXG4gICAgICAgIC8vIGVmZmVjdCBvZiBzdGFydGluZyB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KGV2ZW50KTtcbiAgICB9XG4gICAgbW92ZShldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyB8fCB0aGlzLmRyYWdnaW5nID09IG51bGwgJiYgZGlzdCh0aGlzLnN0YXJ0RXZlbnQsIGV2ZW50KSA8IDEwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCA9IGV2ZW50KTtcbiAgICAgICAgbGV0IHN4ID0gMCwgc3kgPSAwO1xuICAgICAgICBsZXQgbGVmdCA9IDAsIHRvcCA9IDAsIHJpZ2h0ID0gdGhpcy52aWV3Lndpbi5pbm5lcldpZHRoLCBib3R0b20gPSB0aGlzLnZpZXcud2luLmlubmVySGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxQYXJlbnRzLngpXG4gICAgICAgICAgICAoeyBsZWZ0LCByaWdodCB9ID0gdGhpcy5zY3JvbGxQYXJlbnRzLnguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxQYXJlbnRzLnkpXG4gICAgICAgICAgICAoeyB0b3AsIGJvdHRvbSB9ID0gdGhpcy5zY3JvbGxQYXJlbnRzLnkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICBsZXQgbWFyZ2lucyA9IGdldFNjcm9sbE1hcmdpbnModGhpcy52aWV3KTtcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFggLSBtYXJnaW5zLmxlZnQgPD0gbGVmdCArIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeCA9IC1kcmFnU2Nyb2xsU3BlZWQobGVmdCAtIGV2ZW50LmNsaWVudFgpO1xuICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRYICsgbWFyZ2lucy5yaWdodCA+PSByaWdodCAtIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeCA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRYIC0gcmlnaHQpO1xuICAgICAgICBpZiAoZXZlbnQuY2xpZW50WSAtIG1hcmdpbnMudG9wIDw9IHRvcCArIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeSA9IC1kcmFnU2Nyb2xsU3BlZWQodG9wIC0gZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFkgKyBtYXJnaW5zLmJvdHRvbSA+PSBib3R0b20gLSBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3kgPSBkcmFnU2Nyb2xsU3BlZWQoZXZlbnQuY2xpZW50WSAtIGJvdHRvbSk7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsU3BlZWQoc3gsIHN5KTtcbiAgICB9XG4gICAgdXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KTtcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nKVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsU3BlZWQoMCwgMCk7XG4gICAgICAgIGxldCBkb2MgPSB0aGlzLnZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50O1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uID0gdGhpcy52aWV3LmlucHV0U3RhdGUuZHJhZ2dlZENvbnRlbnQgPSBudWxsO1xuICAgIH1cbiAgICBzZXRTY3JvbGxTcGVlZChzeCwgc3kpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IHsgeDogc3gsIHk6IHN5IH07XG4gICAgICAgIGlmIChzeCB8fCBzeSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsaW5nIDwgMClcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IHNldEludGVydmFsKCgpID0+IHRoaXMuc2Nyb2xsKCksIDUwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjcm9sbGluZyA+IC0xKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc2Nyb2xsaW5nKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nyb2xsKCkge1xuICAgICAgICBsZXQgeyB4LCB5IH0gPSB0aGlzLnNjcm9sbFNwZWVkO1xuICAgICAgICBpZiAoeCAmJiB0aGlzLnNjcm9sbFBhcmVudHMueCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRzLnguc2Nyb2xsTGVmdCArPSB4O1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgJiYgdGhpcy5zY3JvbGxQYXJlbnRzLnkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50cy55LnNjcm9sbFRvcCArPSB5O1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggfHwgeSlcbiAgICAgICAgICAgIHRoaXMudmlldy53aW4uc2Nyb2xsQnkoeCwgeSk7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KTtcbiAgICB9XG4gICAgc2tpcEF0b21zKHNlbCkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldLCB1cGRhdGVkID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIGxldCBwb3MgPSBza2lwQXRvbWljUmFuZ2VzKHRoaXMuYXRvbXMsIHJhbmdlLmZyb20sIDApO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgIT0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHNraXBBdG9taWNSYW5nZXModGhpcy5hdG9tcywgcmFuZ2UuZnJvbSwgLTEpO1xuICAgICAgICAgICAgICAgIGxldCB0byA9IHNraXBBdG9taWNSYW5nZXModGhpcy5hdG9tcywgcmFuZ2UudG8sIDEpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tICE9IHJhbmdlLmZyb20gfHwgdG8gIT0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuZnJvbSA9PSByYW5nZS5hbmNob3IgPyBmcm9tIDogdG8sIHJhbmdlLmZyb20gPT0gcmFuZ2UuaGVhZCA/IGZyb20gOiB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIGlmICghcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICByYW5nZXMgPSBzZWwucmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzW2ldID0gdXBkYXRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzID8gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHNlbC5tYWluSW5kZXgpIDogc2VsO1xuICAgIH1cbiAgICBzZWxlY3QoZXZlbnQpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgc2VsZWN0aW9uID0gdGhpcy5za2lwQXRvbXModGhpcy5zdHlsZS5nZXQoZXZlbnQsIHRoaXMuZXh0ZW5kLCB0aGlzLm11bHRpcGxlKSk7XG4gICAgICAgIGlmICh0aGlzLm11c3RTZWxlY3QgfHwgIXNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbiwgdGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5wb2ludGVyXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSkpXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdHlsZS51cGRhdGUodXBkYXRlKSlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpLCAyMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGZhY2V0ID0gdmlldy5zdGF0ZS5mYWNldChjbGlja0FkZHNTZWxlY3Rpb25SYW5nZSk7XG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7XG59XG5mdW5jdGlvbiBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGRyYWdNb3Zlc1NlbGVjdGlvbiQxKTtcbiAgICByZXR1cm4gZmFjZXQubGVuZ3RoID8gZmFjZXRbMF0oZXZlbnQpIDogYnJvd3Nlci5tYWMgPyAhZXZlbnQuYWx0S2V5IDogIWV2ZW50LmN0cmxLZXk7XG59XG5mdW5jdGlvbiBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCB7IG1haW4gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChtYWluLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gT24gYm91bmRhcnkgY2xpY2tzLCBjaGVjayB3aGV0aGVyIHRoZSBjb29yZGluYXRlcyBhcmUgaW5zaWRlIHRoZVxuICAgIC8vIHNlbGVjdGlvbidzIGNsaWVudCByZWN0YW5nbGVzXG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgIGlmICghc2VsIHx8IHNlbC5yYW5nZUNvdW50ID09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCByZWN0cyA9IHNlbC5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDw9IGV2ZW50LmNsaWVudFggJiYgcmVjdC5yaWdodCA+PSBldmVudC5jbGllbnRYICYmXG4gICAgICAgICAgICByZWN0LnRvcCA8PSBldmVudC5jbGllbnRZICYmIHJlY3QuYm90dG9tID49IGV2ZW50LmNsaWVudFkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmJ1YmJsZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbm9kZSA9IGV2ZW50LnRhcmdldCwgY1ZpZXc7IG5vZGUgIT0gdmlldy5jb250ZW50RE9NOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fCAoKGNWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpKSAmJiBjVmlldy5pZ25vcmVFdmVudChldmVudCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3Qgb2JzZXJ2ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChicm93c2VyLmlvcyAmJiBicm93c2VyLndlYmtpdF92ZXJzaW9uIDwgNjA0KTtcbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3KSB7XG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIHRleHRGaWx0ZXIoc3RhdGUsIGZhY2V0LCB0ZXh0KSB7XG4gICAgZm9yIChsZXQgZmlsdGVyIG9mIHN0YXRlLmZhY2V0KGZhY2V0KSlcbiAgICAgICAgdGV4dCA9IGZpbHRlcih0ZXh0LCBzdGF0ZSk7XG4gICAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIGlucHV0KSB7XG4gICAgaW5wdXQgPSB0ZXh0RmlsdGVyKHZpZXcuc3RhdGUsIGNsaXBib2FyZElucHV0RmlsdGVyLCBpbnB1dCk7XG4gICAgbGV0IHsgc3RhdGU6IHN0YXRlJDEgfSA9IHZpZXcsIGNoYW5nZXMsIGkgPSAxLCB0ZXh0ID0gc3RhdGUkMS50b1RleHQoaW5wdXQpO1xuICAgIGxldCBieUxpbmUgPSB0ZXh0LmxpbmVzID09IHN0YXRlJDEuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7XG4gICAgbGV0IGxpbmV3aXNlID0gbGFzdExpbmV3aXNlQ29weSAhPSBudWxsICYmIHN0YXRlJDEuc2VsZWN0aW9uLnJhbmdlcy5ldmVyeShyID0+IHIuZW1wdHkpICYmIGxhc3RMaW5ld2lzZUNvcHkgPT0gdGV4dC50b1N0cmluZygpO1xuICAgIGlmIChsaW5ld2lzZSkge1xuICAgICAgICBsZXQgbGFzdExpbmUgPSAtMTtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlJDEuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlJDEuZG9jLmxpbmVBdChyYW5nZS5mcm9tKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdExpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgIGxhc3RMaW5lID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IHN0YXRlJDEudG9UZXh0KChieUxpbmUgPyB0ZXh0LmxpbmUoaSsrKS50ZXh0IDogaW5wdXQpICsgc3RhdGUkMS5saW5lQnJlYWspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBpbnNlcnQubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnlMaW5lKSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZSQxLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0ZXh0LmxpbmUoaSsrKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IGxpbmUudGV4dCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBsaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUkMS5yZXBsYWNlU2VsZWN0aW9uKHRleHQpO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKGNoYW5nZXMsIHtcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnBhc3RlXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgfSk7XG59XG5vYnNlcnZlcnMuc2Nyb2xsID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3AgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3A7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0ID0gdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdDtcbn07XG5oYW5kbGVycy5rZXlkb3duID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdFwiKTtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNyAmJiB2aWV3LmlucHV0U3RhdGUudGFiRm9jdXNNb2RlICE9IDApXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgPSBEYXRlLm5vdygpICsgMjAwMDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xub2JzZXJ2ZXJzLnRvdWNoc3RhcnQgPSAodmlldywgZSkgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG59O1xub2JzZXJ2ZXJzLnRvdWNobW92ZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID4gRGF0ZS5ub3coKSAtIDIwMDApXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gSWdub3JlIHRvdWNoIGludGVyYWN0aW9uXG4gICAgbGV0IHN0eWxlID0gbnVsbDtcbiAgICBmb3IgKGxldCBtYWtlU3R5bGUgb2Ygdmlldy5zdGF0ZS5mYWNldChtb3VzZVNlbGVjdGlvblN0eWxlKSkge1xuICAgICAgICBzdHlsZSA9IG1ha2VTdHlsZSh2aWV3LCBldmVudCk7XG4gICAgICAgIGlmIChzdHlsZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIXN0eWxlICYmIGV2ZW50LmJ1dHRvbiA9PSAwKVxuICAgICAgICBzdHlsZSA9IGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBsZXQgbXVzdEZvY3VzID0gIXZpZXcuaGFzRm9jdXM7XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5zdGFydE1vdXNlU2VsZWN0aW9uKG5ldyBNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCwgc3R5bGUsIG11c3RGb2N1cykpO1xuICAgICAgICBpZiAobXVzdEZvY3VzKVxuICAgICAgICAgICAgdmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlICYmICFhY3RpdmUuY29udGFpbnModmlldy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLmJsdXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBsZXQgbW91c2VTZWwgPSB2aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb247XG4gICAgICAgIGlmIChtb3VzZVNlbCkge1xuICAgICAgICAgICAgbW91c2VTZWwuc3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIG1vdXNlU2VsLmRyYWdnaW5nID09PSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZnVuY3Rpb24gcmFuZ2VGb3JDbGljayh2aWV3LCBwb3MsIGJpYXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSAxKSB7IC8vIFNpbmdsZSBjbGlja1xuICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGJpYXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09IDIpIHsgLy8gRG91YmxlIGNsaWNrXG4gICAgICAgIHJldHVybiBncm91cEF0KHZpZXcuc3RhdGUsIHBvcywgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBUcmlwbGUgY2xpY2tcbiAgICAgICAgbGV0IHZpc3VhbCA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpLCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0U3RhcnQgOiBsaW5lLmZyb20sIHRvID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogbGluZS50bztcbiAgICAgICAgaWYgKHRvIDwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoICYmIHRvID09IGxpbmUudG8pXG4gICAgICAgICAgICB0bysrO1xuICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5sZXQgaW5zaWRlID0gKHgsIHksIHJlY3QpID0+IHkgPj0gcmVjdC50b3AgJiYgeSA8PSByZWN0LmJvdHRvbSAmJiB4ID49IHJlY3QubGVmdCAmJiB4IDw9IHJlY3QucmlnaHQ7XG4vLyBUcnkgdG8gZGV0ZXJtaW5lLCBmb3IgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLCBhc3NvY2lhdGVkIHdpdGggdGhlXG4vLyBnaXZlbiBwb3NpdGlvbiwgd2hldGhlciB0aGV5IGFyZSByZWxhdGVkIHRvIHRoZSBlbGVtZW50IGJlZm9yZSBvclxuLy8gdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLlxuZnVuY3Rpb24gZmluZFBvc2l0aW9uU2lkZSh2aWV3LCBwb3MsIHgsIHkpIHtcbiAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpO1xuICAgIGlmICghbGluZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IG9mZiA9IHBvcyAtIGxpbmUucG9zQXRTdGFydDtcbiAgICAvLyBMaW5lIGJvdW5kYXJpZXMgcG9pbnQgaW50byB0aGUgbGluZVxuICAgIGlmIChvZmYgPT0gMClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKG9mZiA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIC8vIFBvc2l0aW9ucyBvbiB0b3Agb2YgYW4gZWxlbWVudCBwb2ludCBhdCB0aGF0IGVsZW1lbnRcbiAgICBsZXQgYmVmb3JlID0gbGluZS5jb29yZHNBdChvZmYsIC0xKTtcbiAgICBpZiAoYmVmb3JlICYmIGluc2lkZSh4LCB5LCBiZWZvcmUpKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IGFmdGVyID0gbGluZS5jb29yZHNBdChvZmYsIDEpO1xuICAgIGlmIChhZnRlciAmJiBpbnNpZGUoeCwgeSwgYWZ0ZXIpKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbGluZSB3cmFwIHBvaW50LiBQaWNrIGJlZm9yZSBpZiB0aGUgcG9pbnQgaXNcbiAgICAvLyBhYm92ZSBpdHMgYm90dG9tLlxuICAgIHJldHVybiBiZWZvcmUgJiYgYmVmb3JlLmJvdHRvbSA+PSB5ID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gcXVlcnlQb3ModmlldywgZXZlbnQpIHtcbiAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIHJldHVybiB7IHBvcywgYmlhczogZmluZFBvc2l0aW9uU2lkZSh2aWV3LCBwb3MsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpIH07XG59XG5jb25zdCBCYWRNb3VzZURldGFpbCA9IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExO1xubGV0IGxhc3RNb3VzZURvd24gPSBudWxsLCBsYXN0TW91c2VEb3duQ291bnQgPSAwLCBsYXN0TW91c2VEb3duVGltZSA9IDA7XG5mdW5jdGlvbiBnZXRDbGlja1R5cGUoZXZlbnQpIHtcbiAgICBpZiAoIUJhZE1vdXNlRGV0YWlsKVxuICAgICAgICByZXR1cm4gZXZlbnQuZGV0YWlsO1xuICAgIGxldCBsYXN0ID0gbGFzdE1vdXNlRG93biwgbGFzdFRpbWUgPSBsYXN0TW91c2VEb3duVGltZTtcbiAgICBsYXN0TW91c2VEb3duID0gZXZlbnQ7XG4gICAgbGFzdE1vdXNlRG93blRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBsYXN0TW91c2VEb3duQ291bnQgPSAhbGFzdCB8fCAobGFzdFRpbWUgPiBEYXRlLm5vdygpIC0gNDAwICYmIE1hdGguYWJzKGxhc3QuY2xpZW50WCAtIGV2ZW50LmNsaWVudFgpIDwgMiAmJlxuICAgICAgICBNYXRoLmFicyhsYXN0LmNsaWVudFkgLSBldmVudC5jbGllbnRZKSA8IDIpID8gKGxhc3RNb3VzZURvd25Db3VudCArIDEpICUgMyA6IDE7XG59XG5mdW5jdGlvbiBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gcXVlcnlQb3ModmlldywgZXZlbnQpLCB0eXBlID0gZ2V0Q2xpY2tUeXBlKGV2ZW50KTtcbiAgICBsZXQgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydC5wb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc3RhcnQucG9zKTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgZXh0ZW5kLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSwgcmVtb3ZlZDtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgY3VyLnBvcywgY3VyLmJpYXMsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnBvcyAhPSBjdXIucG9zICYmICFleHRlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRSYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgc3RhcnQucG9zLCBzdGFydC5iaWFzLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHN0YXJ0UmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSksIHRvID0gTWF0aC5tYXgoc3RhcnRSYW5nZS50bywgcmFuZ2UudG8pO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gZnJvbSA8IHJhbmdlLmZyb20gPyBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pIDogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLnJlcGxhY2VSYW5nZShzdGFydFNlbC5tYWluLmV4dGVuZChyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUgJiYgdHlwZSA9PSAxICYmIHN0YXJ0U2VsLnJhbmdlcy5sZW5ndGggPiAxICYmIChyZW1vdmVkID0gcmVtb3ZlUmFuZ2VBcm91bmQoc3RhcnRTZWwsIGN1ci5wb3MpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUmFuZ2VBcm91bmQoc2VsLCBwb3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICAgIGlmIChmcm9tIDw9IHBvcyAmJiB0byA+PSBwb3MpXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWwucmFuZ2VzLnNsaWNlKDAsIGkpLmNvbmNhdChzZWwucmFuZ2VzLnNsaWNlKGkgKyAxKSksIHNlbC5tYWluSW5kZXggPT0gaSA/IDAgOiBzZWwubWFpbkluZGV4IC0gKHNlbC5tYWluSW5kZXggPiBpID8gMSA6IDApKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyBzZWxlY3Rpb246IHsgbWFpbjogcmFuZ2UgfSB9ID0gdmlldy5zdGF0ZTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgICBsZXQgY1ZpZXcgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChldmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoY1ZpZXcgJiYgY1ZpZXcuaXNXaWRnZXQpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gY1ZpZXcucG9zQXRTdGFydCwgdG8gPSBmcm9tICsgY1ZpZXcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGZyb20gPj0gcmFuZ2UudG8gfHwgdG8gPD0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHsgaW5wdXRTdGF0ZSB9ID0gdmlldztcbiAgICBpZiAoaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbi5kcmFnZ2luZyA9IHRydWU7XG4gICAgaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IHJhbmdlO1xuICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIHRleHRGaWx0ZXIodmlldy5zdGF0ZSwgY2xpcGJvYXJkT3V0cHV0RmlsdGVyLCB2aWV3LnN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKSkpO1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuZHJhZ2dlZENvbnRlbnQgPSBudWxsO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5mdW5jdGlvbiBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dCwgZGlyZWN0KSB7XG4gICAgdGV4dCA9IHRleHRGaWx0ZXIodmlldy5zdGF0ZSwgY2xpcGJvYXJkSW5wdXRGaWx0ZXIsIHRleHQpO1xuICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBkcm9wUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGxldCB7IGRyYWdnZWRDb250ZW50IH0gPSB2aWV3LmlucHV0U3RhdGU7XG4gICAgbGV0IGRlbCA9IGRpcmVjdCAmJiBkcmFnZ2VkQ29udGVudCAmJiBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgZXZlbnQpXG4gICAgICAgID8geyBmcm9tOiBkcmFnZ2VkQ29udGVudC5mcm9tLCB0bzogZHJhZ2dlZENvbnRlbnQudG8gfSA6IG51bGw7XG4gICAgbGV0IGlucyA9IHsgZnJvbTogZHJvcFBvcywgaW5zZXJ0OiB0ZXh0IH07XG4gICAgbGV0IGNoYW5nZXMgPSB2aWV3LnN0YXRlLmNoYW5nZXMoZGVsID8gW2RlbCwgaW5zXSA6IGlucyk7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAtMSksIGhlYWQ6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIDEpIH0sXG4gICAgICAgIHVzZXJFdmVudDogZGVsID8gXCJtb3ZlLmRyb3BcIiA6IFwiaW5wdXQuZHJvcFwiXG4gICAgfSk7XG4gICAgdmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbn1cbmhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkgeyAvLyBGb3IgYSBmaWxlIGRyb3AsIHJlYWQgdGhlIGZpbGUncyB0ZXh0LlxuICAgICAgICBsZXQgdGV4dCA9IEFycmF5KGZpbGVzLmxlbmd0aCksIHJlYWQgPSAwO1xuICAgICAgICBsZXQgZmluaXNoRmlsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgrK3JlYWQgPT0gZmlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LmZpbHRlcihzID0+IHMgIT0gbnVsbCkuam9pbih2aWV3LnN0YXRlLmxpbmVCcmVhayksIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmaW5pc2hGaWxlO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIS9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QocmVhZGVyLnJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRleHRbaV0gPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgIGZpbmlzaEZpbGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdGV4dCA9IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5oYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikgfHwgZGF0YS5nZXREYXRhKFwidGV4dC91cmktbGlzdFwiKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZVBhc3RlKHZpZXcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpIHtcbiAgICAvLyBUaGUgZXh0cmEgd3JhcHBlciBpcyBzb21laG93IG5lY2Vzc2FyeSBvbiBJRS9FZGdlIHRvIHByZXZlbnQgdGhlXG4gICAgLy8gY29udGVudCBmcm9tIGJlaW5nIG1hbmdsZWQgd2hlbiBpdCBpcyBwdXQgb250byB0aGUgY2xpcGJvYXJkXG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC52YWx1ZSA9IHRleHQ7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgdGFyZ2V0LnNlbGVjdGlvbkVuZCA9IHRleHQubGVuZ3RoO1xuICAgIHRhcmdldC5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGNvcGllZFJhbmdlKHN0YXRlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXSwgcmFuZ2VzID0gW10sIGxpbmV3aXNlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICBpZiAoIWNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgc2VsZWN0ZWQsIGRvIGEgbGluZS13aXNlIGNvcHlcbiAgICAgICAgbGV0IHVwdG8gPSAtMTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tIH0gb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZyb20pO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gdXB0bykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChsaW5lLnRleHQpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgbGluZS50byArIDEpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXB0byA9IGxpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxpbmV3aXNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGV4dDogdGV4dEZpbHRlcihzdGF0ZSwgY2xpcGJvYXJkT3V0cHV0RmlsdGVyLCBjb250ZW50LmpvaW4oc3RhdGUubGluZUJyZWFrKSksIHJhbmdlcywgbGluZXdpc2UgfTtcbn1cbmxldCBsYXN0TGluZXdpc2VDb3B5ID0gbnVsbDtcbmhhbmRsZXJzLmNvcHkgPSBoYW5kbGVycy5jdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyB0ZXh0LCByYW5nZXMsIGxpbmV3aXNlIH0gPSBjb3BpZWRSYW5nZSh2aWV3LnN0YXRlKTtcbiAgICBpZiAoIXRleHQgJiYgIWxpbmV3aXNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGFzdExpbmV3aXNlQ29weSA9IGxpbmV3aXNlID8gdGV4dCA6IG51bGw7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJjdXRcIiAmJiAhdmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBjaGFuZ2VzOiByYW5nZXMsXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIHVzZXJFdmVudDogXCJkZWxldGUuY3V0XCJcbiAgICAgICAgfSk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmNsZWFyRGF0YSgpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmNvbnN0IGlzRm9jdXNDaGFuZ2UgPSBzdGF0ZS5Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbihzdGF0ZSwgZm9jdXMpIHtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGdldEVmZmVjdCBvZiBzdGF0ZS5mYWNldChmb2N1c0NoYW5nZUVmZmVjdCkpIHtcbiAgICAgICAgbGV0IGVmZmVjdCA9IGdldEVmZmVjdChzdGF0ZSwgZm9jdXMpO1xuICAgICAgICBpZiAoZWZmZWN0KVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuICAgIHJldHVybiBlZmZlY3RzID8gc3RhdGUudXBkYXRlKHsgZWZmZWN0cywgYW5ub3RhdGlvbnM6IGlzRm9jdXNDaGFuZ2Uub2YodHJ1ZSkgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldykge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsZXQgZm9jdXMgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICBpZiAoZm9jdXMgIT0gdmlldy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCkge1xuICAgICAgICAgICAgbGV0IHRyID0gZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbih2aWV3LnN0YXRlLCBmb2N1cyk7XG4gICAgICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoW10pO1xuICAgICAgICB9XG4gICAgfSwgMTApO1xufVxub2JzZXJ2ZXJzLmZvY3VzID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFdoZW4gZm9jdXNpbmcgcmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiwgbW92ZSBpdCBiYWNrIHRvIHdoZXJlIGl0IHdhc1xuICAgIGlmICghdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICYmICh2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcCB8fCB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQpKSB7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wO1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0O1xuICAgIH1cbiAgICB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KTtcbn07XG5vYnNlcnZlcnMuYmx1ciA9IHZpZXcgPT4ge1xuICAgIHZpZXcub2JzZXJ2ZXIuY2xlYXJTZWxlY3Rpb25SYW5nZSgpO1xuICAgIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpO1xufTtcbm9ic2VydmVycy5jb21wb3NpdGlvbnN0YXJ0ID0gb2JzZXJ2ZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcub2JzZXJ2ZXIuZWRpdENvbnRleHQpXG4gICAgICAgIHJldHVybjsgLy8gQ29tcG9zaXRpb24gaGFuZGxlZCBieSBlZGl0IGNvbnRleHRcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPT0gbnVsbClcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSB0cnVlO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICAvLyBGSVhNRSBwb3NzaWJseSBzZXQgYSB0aW1lb3V0IHRvIGNsZWFyIGl0IGFnYWluIG9uIEFuZHJvaWRcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IDA7XG4gICAgfVxufTtcbm9ic2VydmVycy5jb21wb3NpdGlvbmVuZCA9IHZpZXcgPT4ge1xuICAgIGlmICh2aWV3Lm9ic2VydmVyLmVkaXRDb250ZXh0KVxuICAgICAgICByZXR1cm47IC8vIENvbXBvc2l0aW9uIGhhbmRsZWQgYnkgZWRpdCBjb250ZXh0XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IC0xO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSB0cnVlO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSB2aWV3Lm9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID4gMDtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGw7XG4gICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuYW5kcm9pZCkge1xuICAgICAgICAvLyBEZWxheSBmbHVzaGluZyBmb3IgYSBiaXQgb24gQW5kcm9pZCBiZWNhdXNlIGl0J2xsIG9mdGVuIGZpcmUgYVxuICAgICAgICAvLyBidW5jaCBvZiBjb250cmFkaWN0b3J5IGNoYW5nZXMgaW4gYSByb3cgYXQgZW5kIG9mIGNvbXBvc2l0b25cbiAgICAgICAgdmlldy5vYnNlcnZlci5mbHVzaFNvb24oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSkge1xuICAgICAgICAvLyBJZiB3ZSBmb3VuZCBwZW5kaW5nIHJlY29yZHMsIHNjaGVkdWxlIGEgZmx1c2guXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdmlldy5vYnNlcnZlci5mbHVzaCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgbWFrZSBzdXJlIHRoYXQsIGlmIG5vIGNoYW5nZXMgY29tZSBpbiBzb29uLCB0aGVcbiAgICAgICAgLy8gY29tcG9zaXRpb24gdmlldyBpcyBjbGVhcmVkLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCAmJiB2aWV3LmRvY1ZpZXcuaGFzQ29tcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoW10pO1xuICAgICAgICB9LCA1MCk7XG4gICAgfVxufTtcbm9ic2VydmVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Q29udGV4dE1lbnUgPSBEYXRlLm5vdygpO1xufTtcbmhhbmRsZXJzLmJlZm9yZWlucHV0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvLyBJbiBFZGl0Q29udGV4dCBtb2RlLCB3ZSBtdXN0IGhhbmRsZSBpbnNlcnRSZXBsYWNlbWVudFRleHQgZXZlbnRzXG4gICAgLy8gZGlyZWN0bHksIHRvIG1ha2Ugc3BlbGwgY2hlY2tpbmcgY29ycmVjdGlvbnMgd29ya1xuICAgIGlmIChldmVudC5pbnB1dFR5cGUgPT0gXCJpbnNlcnRSZXBsYWNlbWVudFRleHRcIiAmJiB2aWV3Lm9ic2VydmVyLmVkaXRDb250ZXh0KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gKF9hID0gZXZlbnQuZGF0YVRyYW5zZmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0RGF0YShcInRleHQvcGxhaW5cIiksIHJhbmdlcyA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpO1xuICAgICAgICBpZiAodGV4dCAmJiByYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgciA9IHJhbmdlc1swXTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gdmlldy5wb3NBdERPTShyLnN0YXJ0Q29udGFpbmVyLCByLnN0YXJ0T2Zmc2V0KSwgdG8gPSB2aWV3LnBvc0F0RE9NKHIuZW5kQ29udGFpbmVyLCByLmVuZE9mZnNldCk7XG4gICAgICAgICAgICBhcHBseURPTUNoYW5nZUlubmVyKHZpZXcsIHsgZnJvbSwgdG8sIGluc2VydDogdmlldy5zdGF0ZS50b1RleHQodGV4dCkgfSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCZWNhdXNlIENocm9tZSBBbmRyb2lkIGRvZXNuJ3QgZmlyZSB1c2VmdWwga2V5IGV2ZW50cywgdXNlXG4gICAgLy8gYmVmb3JlaW5wdXQgdG8gZGV0ZWN0IGJhY2tzcGFjZSAoYW5kIHBvc3NpYmx5IGVudGVyIGFuZCBkZWxldGUsXG4gICAgLy8gYnV0IHRob3NlIHVzdWFsbHkgZG9uJ3QgZXZlbiBzZWVtIHRvIGZpcmUgYmVmb3JlaW5wdXQgZXZlbnRzIGF0XG4gICAgLy8gdGhlIG1vbWVudCkgYW5kIGZha2UgYSBrZXkgZXZlbnQgZm9yIGl0LlxuICAgIC8vXG4gICAgLy8gKHByZXZlbnREZWZhdWx0IG9uIGJlZm9yZWlucHV0LCB0aG91Z2ggc3VwcG9ydGVkIGluIHRoZSBzcGVjLFxuICAgIC8vIHNlZW1zIHRvIGRvIG5vdGhpbmcgYXQgYWxsIG9uIENocm9tZSkuXG4gICAgbGV0IHBlbmRpbmc7XG4gICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuYW5kcm9pZCAmJiAocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5pbnB1dFR5cGUgPT0gZXZlbnQuaW5wdXRUeXBlKSkpIHtcbiAgICAgICAgdmlldy5vYnNlcnZlci5kZWxheUFuZHJvaWRLZXkocGVuZGluZy5rZXksIHBlbmRpbmcua2V5Q29kZSk7XG4gICAgICAgIGlmIChwZW5kaW5nLmtleSA9PSBcIkJhY2tzcGFjZVwiIHx8IHBlbmRpbmcua2V5ID09IFwiRGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydFZpZXdIZWlnaHQgPSAoKF9iID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSB8fCAwO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIEJhY2tzcGFjaW5nIG5lYXIgdW5lZGl0YWJsZSBub2RlcyBvbiBDaHJvbWUgQW5kcm9pZCBzb21ldGltZXNcbiAgICAgICAgICAgICAgICAvLyBjbG9zZXMgdGhlIHZpcnR1YWwga2V5Ym9hcmQuIFRoaXMgdHJpZXMgdG8gY3J1ZGVseSBkZXRlY3RcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFuZCByZWZvY3VzIHRvIGdldCBpdCBiYWNrLlxuICAgICAgICAgICAgICAgIGlmICgoKChfYSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlaWdodCkgfHwgMCkgPiBzdGFydFZpZXdIZWlnaHQgKyAxMCAmJiB2aWV3Lmhhc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChicm93c2VyLmlvcyAmJiBldmVudC5pbnB1dFR5cGUgPT0gXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiKSB7XG4gICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgRE9NIGNoYW5nZXMgKGFuZCBiZWZvcmVpbnB1dCkgaGFwcGVuIF9iZWZvcmVfXG4gICAgICAgIC8vIHRoZSBrZXkgZXZlbnQgZm9yIGN0cmwtZCBvbiBpT1Mgd2hlbiB1c2luZyBhbiBleHRlcm5hbFxuICAgICAgICAvLyBrZXlib2FyZC5cbiAgICAgICAgdmlldy5vYnNlcnZlci5mbHVzaFNvb24oKTtcbiAgICB9XG4gICAgLy8gU2FmYXJpIHdpbGwgb2NjYXNpb25hbGx5IGZvcmdldCB0byBmaXJlIGNvbXBvc2l0aW9uZW5kIGF0IHRoZSBlbmQgb2YgYSBkZWFkLWtleSBjb21wb3NpdGlvblxuICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiBldmVudC5pbnB1dFR5cGUgPT0gXCJpbnNlcnRUZXh0XCIgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gb2JzZXJ2ZXJzLmNvbXBvc2l0aW9uZW5kKHZpZXcsIGV2ZW50KSwgMjApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgYXBwbGllZEZpcmVmb3hIYWNrID0gbmV3IFNldDtcbi8vIEluIEZpcmVmb3gsIHdoZW4gY3V0L2NvcHkgaGFuZGxlcnMgYXJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudCwgdGhhdFxuLy8gc29tZWhvdyBhdm9pZHMgYSBidWcgd2hlcmUgdGhvc2UgZXZlbnRzIGFyZW4ndCBmaXJlZCB3aGVuIHRoZVxuLy8gc2VsZWN0aW9uIGlzIGVtcHR5LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy8xMDgyXG4vLyBhbmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTk1OTYxXG5mdW5jdGlvbiBmaXJlZm94Q29weUN1dEhhY2soZG9jKSB7XG4gICAgaWYgKCFhcHBsaWVkRmlyZWZveEhhY2suaGFzKGRvYykpIHtcbiAgICAgICAgYXBwbGllZEZpcmVmb3hIYWNrLmFkZChkb2MpO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgKCkgPT4geyB9KTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJjdXRcIiwgKCkgPT4geyB9KTtcbiAgICB9XG59XG5cbmNvbnN0IHdyYXBwaW5nV2hpdGVTcGFjZSA9IFtcInByZS13cmFwXCIsIFwibm9ybWFsXCIsIFwicHJlLWxpbmVcIiwgXCJicmVhay1zcGFjZXNcIl07XG4vLyBVc2VkIHRvIHRyYWNrLCBkdXJpbmcgdXBkYXRlSGVpZ2h0LCBpZiBhbnkgYWN0dWFsIGhlaWdodHMgY2hhbmdlZFxubGV0IGhlaWdodENoYW5nZUZsYWcgPSBmYWxzZTtcbmZ1bmN0aW9uIGNsZWFySGVpZ2h0Q2hhbmdlRmxhZygpIHsgaGVpZ2h0Q2hhbmdlRmxhZyA9IGZhbHNlOyB9XG5jbGFzcyBIZWlnaHRPcmFjbGUge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVXcmFwcGluZykge1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5kb2MgPSBzdGF0ZS5UZXh0LmVtcHR5O1xuICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gMTQ7IC8vIFRoZSBoZWlnaHQgb2YgYW4gZW50aXJlIGxpbmUgKGxpbmUtaGVpZ2h0KVxuICAgICAgICB0aGlzLmNoYXJXaWR0aCA9IDc7XG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IDE0OyAvLyBUaGUgaGVpZ2h0IG9mIHRoZSBhY3R1YWwgZm9udCAoZm9udC1zaXplKVxuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSAzMDtcbiAgICB9XG4gICAgaGVpZ2h0Rm9yR2FwKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHRoaXMuZG9jLmxpbmVBdCh0bykubnVtYmVyIC0gdGhpcy5kb2MubGluZUF0KGZyb20pLm51bWJlciArIDE7XG4gICAgICAgIGlmICh0aGlzLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgIGxpbmVzICs9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoKHRvIC0gZnJvbSkgLSAobGluZXMgKiB0aGlzLmxpbmVMZW5ndGggKiAwLjUpKSAvIHRoaXMubGluZUxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0ICogbGluZXM7XG4gICAgfVxuICAgIGhlaWdodEZvckxpbmUobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBsZXQgbGluZXMgPSAxICsgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChsZW5ndGggLSB0aGlzLmxpbmVMZW5ndGgpIC8gKHRoaXMubGluZUxlbmd0aCAtIDUpKSk7XG4gICAgICAgIHJldHVybiBsaW5lcyAqIHRoaXMubGluZUhlaWdodDtcbiAgICB9XG4gICAgc2V0RG9jKGRvYykgeyB0aGlzLmRvYyA9IGRvYzsgcmV0dXJuIHRoaXM7IH1cbiAgICBtdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpIHtcbiAgICAgICAgcmV0dXJuICh3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xKSAhPSB0aGlzLmxpbmVXcmFwcGluZztcbiAgICB9XG4gICAgbXVzdFJlZnJlc2hGb3JIZWlnaHRzKGxpbmVIZWlnaHRzKSB7XG4gICAgICAgIGxldCBuZXdIZWlnaHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGggPSBsaW5lSGVpZ2h0c1tpXTtcbiAgICAgICAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSkgeyAvLyBSb3VuZCB0byAuMSBwaXhlbHNcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SGVpZ2h0O1xuICAgIH1cbiAgICByZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCwgbGluZUxlbmd0aCwga25vd25IZWlnaHRzKSB7XG4gICAgICAgIGxldCBsaW5lV3JhcHBpbmcgPSB3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IE1hdGgucm91bmQobGluZUhlaWdodCkgIT0gTWF0aC5yb3VuZCh0aGlzLmxpbmVIZWlnaHQpIHx8IHRoaXMubGluZVdyYXBwaW5nICE9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5saW5lV3JhcHBpbmcgPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gY2hhcldpZHRoO1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSB0ZXh0SGVpZ2h0O1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtub3duSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBoID0ga25vd25IZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoIDwgMClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn1cbi8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYnkgYHVwZGF0ZUhlaWdodGAgdG8gbWFrZSBET00gbWVhc3VyZW1lbnRzXG4vLyBhcnJpdmUgYXQgdGhlIHJpZ2h0IG5pZGVzLiBUaGUgYGhlaWdodHNgIGFycmF5IGlzIGEgc2VxdWVuY2Ugb2Zcbi8vIGJsb2NrIGhlaWdodHMsIHN0YXJ0aW5nIGZyb20gcG9zaXRpb24gYGZyb21gLlxuY2xhc3MgTWVhc3VyZWRIZWlnaHRzIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCBoZWlnaHRzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaGVpZ2h0cyA9IGhlaWdodHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBnZXQgbW9yZSgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPCB0aGlzLmhlaWdodHMubGVuZ3RoOyB9XG59XG4vKipcblJlY29yZCB1c2VkIHRvIHJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIGJsb2NrLWxldmVsIGVsZW1lbnRcbmluIHRoZSBlZGl0b3Igdmlldy5cbiovXG5jbGFzcyBCbG9ja0luZm8ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBlbGVtZW50IGluIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnQpLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBJdHMgaGVpZ2h0LlxuICAgICovXG4gICAgaGVpZ2h0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWwgV2VpcmQgcGFja2VkIGZpZWxkIHRoYXQgaG9sZHMgYW4gYXJyYXkgb2YgY2hpbGRyZW5cbiAgICBmb3IgY29tcG9zaXRlIGJsb2NrcywgYSBkZWNvcmF0aW9uIGZvciBibG9jayB3aWRnZXRzLCBhbmQgYVxuICAgIG51bWJlciBpbmRpY2F0aW5nIHRoZSBhbW91bnQgb2Ygd2lkZ2V0LWNyZWF0ZSBsaW5lIGJyZWFrcyBmb3JcbiAgICB0ZXh0IGJsb2Nrcy5cbiAgICAqL1xuICAgIF9jb250ZW50KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBfY29udGVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgZWxlbWVudCB0aGlzIGlzLiBXaGVuIHF1ZXJ5aW5nIGxpbmVzLCB0aGlzIG1heSBiZVxuICAgIGFuIGFycmF5IG9mIGFsbCB0aGUgYmxvY2tzIHRoYXQgbWFrZSB1cCB0aGUgbGluZS5cbiAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2NvbnRlbnQgPT0gXCJudW1iZXJcIiA/IGV4cG9ydHMuQmxvY2tUeXBlLlRleHQgOlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLl9jb250ZW50KSA/IHRoaXMuX2NvbnRlbnQgOiB0aGlzLl9jb250ZW50LnR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIGVsZW1lbnQgYXMgYSBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCBib3R0b20oKSB7IHJldHVybiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0OyB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIHdpZGdldCBibG9jaywgdGhpcyB3aWxsIHJldHVybiB0aGUgd2lkZ2V0XG4gICAgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICovXG4gICAgZ2V0IHdpZGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gPyB0aGlzLl9jb250ZW50LndpZGdldCA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSB0ZXh0YmxvY2ssIHRoaXMgaG9sZHMgdGhlIG51bWJlciBvZiBsaW5lIGJyZWFrc1xuICAgIHRoYXQgYXBwZWFyIGluIHdpZGdldHMgaW5zaWRlIHRoZSBibG9jay5cbiAgICAqL1xuICAgIGdldCB3aWRnZXRMaW5lQnJlYWtzKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2NvbnRlbnQgPT0gXCJudW1iZXJcIiA/IHRoaXMuX2NvbnRlbnQgOiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAoQXJyYXkuaXNBcnJheSh0aGlzLl9jb250ZW50KSA/IHRoaXMuX2NvbnRlbnQgOiBbdGhpc10pXG4gICAgICAgICAgICAuY29uY2F0KEFycmF5LmlzQXJyYXkob3RoZXIuX2NvbnRlbnQpID8gb3RoZXIuX2NvbnRlbnQgOiBbb3RoZXJdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8odGhpcy5mcm9tLCB0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCwgdGhpcy50b3AsIHRoaXMuaGVpZ2h0ICsgb3RoZXIuaGVpZ2h0LCBjb250ZW50KTtcbiAgICB9XG59XG52YXIgUXVlcnlUeXBlO1xuKGZ1bmN0aW9uIChRdWVyeVR5cGUpIHtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlQb3NcIl0gPSAwXSA9IFwiQnlQb3NcIjtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlIZWlnaHRcIl0gPSAxXSA9IFwiQnlIZWlnaHRcIjtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlQb3NOb0hlaWdodFwiXSA9IDJdID0gXCJCeVBvc05vSGVpZ2h0XCI7XG59KShRdWVyeVR5cGUgfHwgKFF1ZXJ5VHlwZSA9IHt9KSk7XG5jb25zdCBFcHNpbG9uID0gMWUtMztcbmNsYXNzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCAvLyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY292ZXJlZFxuICAgIGhlaWdodCwgLy8gSGVpZ2h0IG9mIHRoaXMgcGFydCBvZiB0aGUgZG9jdW1lbnRcbiAgICBmbGFncyA9IDIgLyogRmxhZy5PdXRkYXRlZCAqLykge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgZ2V0IG91dGRhdGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pID4gMDsgfVxuICAgIHNldCBvdXRkYXRlZCh2YWx1ZSkgeyB0aGlzLmZsYWdzID0gKHZhbHVlID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkgfCAodGhpcy5mbGFncyAmIH4yIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pOyB9XG4gICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5oZWlnaHQgLSBoZWlnaHQpID4gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2VGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJhc2UgY2FzZSBpcyB0byByZXBsYWNlIGEgbGVhZiBub2RlLCB3aGljaCBzaW1wbHkgYnVpbGRzIGEgdHJlZVxuICAgIC8vIGZyb20gdGhlIG5ldyBub2RlcyBhbmQgcmV0dXJucyB0aGF0IChIZWlnaHRNYXBCcmFuY2ggYW5kXG4gICAgLy8gSGVpZ2h0TWFwR2FwIG92ZXJyaWRlIHRoaXMgdG8gYWN0dWFsbHkgdXNlIGZyb20vdG8pXG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICB9XG4gICAgLy8gQWdhaW4sIHRoZXNlIGFyZSBiYXNlIGNhc2VzLCBhbmQgYXJlIG92ZXJyaWRkZW4gZm9yIGJyYW5jaCBhbmQgZ2FwIG5vZGVzLlxuICAgIGRlY29tcG9zZUxlZnQoX3RvLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBkZWNvbXBvc2VSaWdodChfZnJvbSwgcmVzdWx0KSB7IHJlc3VsdC5wdXNoKHRoaXMpOyB9XG4gICAgYXBwbHlDaGFuZ2VzKGRlY29yYXRpb25zLCBvbGREb2MsIG9yYWNsZSwgY2hhbmdlcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLCBkb2MgPSBvcmFjbGUuZG9jO1xuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9ID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG1lLmxpbmVBdChmcm9tQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9yYWNsZS5zZXREb2Mob2xkRG9jKSwgMCwgMCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQudG8gPj0gdG9BID8gc3RhcnQgOiBtZS5saW5lQXQodG9BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIHRvQiArPSBlbmQudG8gLSB0b0E7XG4gICAgICAgICAgICB0b0EgPSBlbmQudG87XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgc3RhcnQuZnJvbSA8PSBjaGFuZ2VzW2kgLSAxXS50b0EpIHtcbiAgICAgICAgICAgICAgICBmcm9tQSA9IGNoYW5nZXNbaSAtIDFdLmZyb21BO1xuICAgICAgICAgICAgICAgIGZyb21CID0gY2hhbmdlc1tpIC0gMV0uZnJvbUI7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQSA8IHN0YXJ0LmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21CICs9IHN0YXJ0LmZyb20gLSBmcm9tQTtcbiAgICAgICAgICAgIGZyb21BID0gc3RhcnQuZnJvbTtcbiAgICAgICAgICAgIGxldCBub2RlcyA9IE5vZGVCdWlsZGVyLmJ1aWxkKG9yYWNsZS5zZXREb2MoZG9jKSwgZGVjb3JhdGlvbnMsIGZyb21CLCB0b0IpO1xuICAgICAgICAgICAgbWUgPSByZXBsYWNlKG1lLCBtZS5yZXBsYWNlKGZyb21BLCB0b0EsIG5vZGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lLnVwZGF0ZUhlaWdodChvcmFjbGUsIDApO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7IHJldHVybiBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAwKTsgfVxuICAgIC8vIG5vZGVzIHVzZXMgbnVsbCB2YWx1ZXMgdG8gaW5kaWNhdGUgdGhlIHBvc2l0aW9uIG9mIGxpbmUgYnJlYWtzLlxuICAgIC8vIFRoZXJlIGFyZSBuZXZlciBsaW5lIGJyZWFrcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBhcnJheSwgb3JcbiAgICAvLyB0d28gbGluZSBicmVha3MgbmV4dCB0byBlYWNoIG90aGVyLCBhbmQgdGhlIGFycmF5IGlzbid0IGFsbG93ZWRcbiAgICAvLyB0byBiZSBlbXB0eSAoc2FtZSByZXN0cmljdGlvbnMgYXMgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGJ1aWxkZXIpLlxuICAgIHN0YXRpYyBvZihub2Rlcykge1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgICAgIGxldCBpID0gMCwgaiA9IG5vZGVzLmxlbmd0aCwgYmVmb3JlID0gMCwgYWZ0ZXIgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA+IGFmdGVyICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKC0taSwgMSwgc3BsaXQubGVmdCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBqICs9IDEgKyBzcGxpdC5icmVhaztcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyID4gYmVmb3JlICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0LmJyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAyICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUgPCBhZnRlcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbLS1qXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBicmsgPSAwO1xuICAgICAgICBpZiAobm9kZXNbaSAtIDFdID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZXNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJrID0gMTtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhlaWdodE1hcEJyYW5jaChIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoMCwgaSkpLCBicmssIEhlaWdodE1hcC5vZihub2Rlcy5zbGljZShqKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2Uob2xkLCB2YWwpIHtcbiAgICBpZiAob2xkID09IHZhbClcbiAgICAgICAgcmV0dXJuIG9sZDtcbiAgICBpZiAob2xkLmNvbnN0cnVjdG9yICE9IHZhbC5jb25zdHJ1Y3RvcilcbiAgICAgICAgaGVpZ2h0Q2hhbmdlRmxhZyA9IHRydWU7XG4gICAgcmV0dXJuIHZhbDtcbn1cbkhlaWdodE1hcC5wcm90b3R5cGUuc2l6ZSA9IDE7XG5jbGFzcyBIZWlnaHRNYXBCbG9jayBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQsIGRlY28pIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmRlY28gPSBkZWNvO1xuICAgIH1cbiAgICBibG9ja0F0KF9oZWlnaHQsIF9vcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCwgdGhpcy5oZWlnaHQsIHRoaXMuZGVjbyB8fCAwKTtcbiAgICB9XG4gICAgbGluZUF0KF92YWx1ZSwgX3R5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCgwLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgaWYgKGZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgdG8gPj0gb2Zmc2V0KVxuICAgICAgICAgICAgZih0aGlzLmJsb2NrQXQoMCwgb3JhY2xlLCB0b3AsIG9mZnNldCkpO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBfZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgYmxvY2soJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwVGV4dCBleHRlbmRzIEhlaWdodE1hcEJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGhlaWdodCwgbnVsbCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gMDsgLy8gQW1vdW50IG9mIGNvbGxhcHNlZCBjb250ZW50IGluIHRoZSBsaW5lXG4gICAgICAgIHRoaXMud2lkZ2V0SGVpZ2h0ID0gMDsgLy8gTWF4aW11bSBpbmxpbmUgd2lkZ2V0IGhlaWdodFxuICAgICAgICB0aGlzLmJyZWFrcyA9IDA7IC8vIE51bWJlciBvZiB3aWRnZXQtaW50cm9kdWNlZCBsaW5lIGJyZWFrcyBvbiB0aGUgbGluZVxuICAgIH1cbiAgICBibG9ja0F0KF9oZWlnaHQsIF9vcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCwgdGhpcy5oZWlnaHQsIHRoaXMuYnJlYWtzKTtcbiAgICB9XG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzWzBdO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEgJiYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0IHx8IG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiYgKG5vZGUuZmxhZ3MgJiA0IC8qIEZsYWcuU2luZ2xlTGluZSAqLykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmxlbmd0aCAtIG5vZGUubGVuZ3RoKSA8IDEwKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IEhlaWdodE1hcFRleHQobm9kZS5sZW5ndGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgICAgIG5vZGUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KE1hdGgubWF4KHRoaXMud2lkZ2V0SGVpZ2h0LCBvcmFjbGUuaGVpZ2h0Rm9yTGluZSh0aGlzLmxlbmd0aCAtIHRoaXMuY29sbGFwc2VkKSkgK1xuICAgICAgICAgICAgICAgIHRoaXMuYnJlYWtzICogb3JhY2xlLmxpbmVIZWlnaHQpO1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBsaW5lKCR7dGhpcy5sZW5ndGh9JHt0aGlzLmNvbGxhcHNlZCA/IC10aGlzLmNvbGxhcHNlZCA6IFwiXCJ9JHt0aGlzLndpZGdldEhlaWdodCA/IFwiOlwiICsgdGhpcy53aWRnZXRIZWlnaHQgOiBcIlwifSlgO1xuICAgIH1cbn1cbmNsYXNzIEhlaWdodE1hcEdhcCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7IHN1cGVyKGxlbmd0aCwgMCk7IH1cbiAgICBoZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBmaXJzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQpLm51bWJlciwgbGFzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQgKyB0aGlzLmxlbmd0aCkubnVtYmVyO1xuICAgICAgICBsZXQgbGluZXMgPSBsYXN0TGluZSAtIGZpcnN0TGluZSArIDE7XG4gICAgICAgIGxldCBwZXJMaW5lLCBwZXJDaGFyID0gMDtcbiAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbFBlckxpbmUgPSBNYXRoLm1pbih0aGlzLmhlaWdodCwgb3JhY2xlLmxpbmVIZWlnaHQgKiBsaW5lcyk7XG4gICAgICAgICAgICBwZXJMaW5lID0gdG90YWxQZXJMaW5lIC8gbGluZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiBsaW5lcyArIDEpXG4gICAgICAgICAgICAgICAgcGVyQ2hhciA9ICh0aGlzLmhlaWdodCAtIHRvdGFsUGVyTGluZSkgLyAodGhpcy5sZW5ndGggLSBsaW5lcyAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVyTGluZSA9IHRoaXMuaGVpZ2h0IC8gbGluZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmlyc3RMaW5lLCBsYXN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9O1xuICAgIH1cbiAgICBibG9ja0F0KGhlaWdodCwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxhc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH0gPSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpO1xuICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgbGV0IGd1ZXNzID0gb2Zmc2V0ICsgKGhlaWdodCA8IG9yYWNsZS5saW5lSGVpZ2h0ID8gMFxuICAgICAgICAgICAgICAgIDogTWF0aC5yb3VuZChNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoaGVpZ2h0IC0gdG9wKSAvIHRoaXMuaGVpZ2h0KSkgKiB0aGlzLmxlbmd0aCkpO1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChndWVzcyksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICAgICAgbGV0IGxpbmVUb3AgPSBNYXRoLm1heCh0b3AsIGhlaWdodCAtIGxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIGxpbmVUb3AsIGxpbmVIZWlnaHQsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsYXN0TGluZSAtIGZpcnN0TGluZSwgTWF0aC5mbG9vcigoaGVpZ2h0IC0gdG9wKSAvIHBlckxpbmUpKSk7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCBsZW5ndGggfSA9IG9yYWNsZS5kb2MubGluZShmaXJzdExpbmUgKyBsaW5lKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIGxlbmd0aCwgdG9wICsgcGVyTGluZSAqIGxpbmUsIHBlckxpbmUsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KHZhbHVlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCB0byAtIGZyb20sIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICBsZXQgbGluZXNBYm92ZSA9IGxpbmUubnVtYmVyIC0gZmlyc3RMaW5lO1xuICAgICAgICBsZXQgbGluZVRvcCA9IHRvcCArIHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChsaW5lLmZyb20gLSBvZmZzZXQgLSBsaW5lc0Fib3ZlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgTWF0aC5tYXgodG9wLCBNYXRoLm1pbihsaW5lVG9wLCB0b3AgKyB0aGlzLmhlaWdodCAtIGxpbmVIZWlnaHQpKSwgbGluZUhlaWdodCwgMCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGZyb20gPSBNYXRoLm1heChmcm9tLCBvZmZzZXQpO1xuICAgICAgICB0byA9IE1hdGgubWluKHRvLCBvZmZzZXQgKyB0aGlzLmxlbmd0aCk7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbSwgbGluZVRvcCA9IHRvcDsgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzQWJvdmUgPSBsaW5lLm51bWJlciAtIGZpcnN0TGluZTtcbiAgICAgICAgICAgICAgICBsaW5lVG9wICs9IHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChmcm9tIC0gb2Zmc2V0IC0gbGluZXNBYm92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGluZUhlaWdodCA9IHBlckxpbmUgKyBwZXJDaGFyICogbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBmKG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgbGluZVRvcCwgbGluZUhlaWdodCwgMCkpO1xuICAgICAgICAgICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5sZW5ndGggLSB0bztcbiAgICAgICAgaWYgKGFmdGVyID4gMCkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdID0gbmV3IEhlaWdodE1hcEdhcChsYXN0Lmxlbmd0aCArIGFmdGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoYWZ0ZXIgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiAwKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1swXSA9IG5ldyBIZWlnaHRNYXBHYXAoZnJvbSArIGZpcnN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMudW5zaGlmdChuZXcgSGVpZ2h0TWFwR2FwKGZyb20gLSAxKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gMSksIG51bGwpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcCh0aGlzLmxlbmd0aCAtIGZyb20gLSAxKSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiBwYXJ0IG9mIHRoaXMgZ2FwIHdpdGggbWVhc3VyZWQgbGluZXMuIFdlIGtub3cgdGhlcmVcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIHdpZGdldHMgb3IgY29sbGFwc2VkIHJhbmdlcyBpbiB0aG9zZSBsaW5lcywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhleSB3b3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaGVpZ2h0bWFwIChnYXBzXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnRhaW4gcGxhaW4gdGV4dCkuXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXSwgcG9zID0gTWF0aC5tYXgob2Zmc2V0LCBtZWFzdXJlZC5mcm9tKSwgc2luZ2xlSGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICBpZiAobWVhc3VyZWQuZnJvbSA+IG9mZnNldClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBHYXAobWVhc3VyZWQuZnJvbSAtIG9mZnNldCAtIDEpLnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCkpO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8PSBlbmQgJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhoZWlnaHQgLSBzaW5nbGVIZWlnaHQpID49IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IC0yO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQobGVuLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxpbmUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW4gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGVuZCAtIHBvcykudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcG9zKSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPCAwIHx8IE1hdGguYWJzKHJlc3VsdC5oZWlnaHQgLSB0aGlzLmhlaWdodCkgPj0gRXBzaWxvbiB8fFxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNpbmdsZUhlaWdodCAtIHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCkucGVyTGluZSkgPj0gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2VGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLmhlaWdodEZvckdhcChvZmZzZXQsIG9mZnNldCArIHRoaXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGdhcCgke3RoaXMubGVuZ3RofSlgOyB9XG59XG5jbGFzcyBIZWlnaHRNYXBCcmFuY2ggZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIGJyaywgcmlnaHQpIHtcbiAgICAgICAgc3VwZXIobGVmdC5sZW5ndGggKyBicmsgKyByaWdodC5sZW5ndGgsIGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0LCBicmsgfCAobGVmdC5vdXRkYXRlZCB8fCByaWdodC5vdXRkYXRlZCA/IDIgLyogRmxhZy5PdXRkYXRlZCAqLyA6IDApKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgIH1cbiAgICBnZXQgYnJlYWsoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMSAvKiBGbGFnLkJyZWFrICovOyB9XG4gICAgYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG1pZCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBoZWlnaHQgPCBtaWQgPyB0aGlzLmxlZnQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgbWlkLCBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhayk7XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBsZXQgbGVmdCA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0ID8gdmFsdWUgPCByaWdodFRvcCA6IHZhbHVlIDwgcmlnaHRPZmZzZXQ7XG4gICAgICAgIGxldCBiYXNlID0gbGVmdCA/IHRoaXMubGVmdC5saW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQubGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrIHx8IChsZWZ0ID8gYmFzZS50byA8IHJpZ2h0T2Zmc2V0IDogYmFzZS5mcm9tID4gcmlnaHRPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBzdWJRdWVyeSA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQgPyBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA6IFF1ZXJ5VHlwZS5CeVBvcztcbiAgICAgICAgaWYgKGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5qb2luKHRoaXMucmlnaHQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KS5qb2luKGJhc2UpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgaWYgKGZyb20gPCByaWdodE9mZnNldClcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpO1xuICAgICAgICAgICAgaWYgKHRvID49IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSB0aGlzLmxpbmVBdChyaWdodE9mZnNldCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgbWlkLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIG1pZC5mcm9tIC0gMSwgb3JhY2xlLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAobWlkLnRvID49IGZyb20gJiYgbWlkLmZyb20gPD0gdG8pXG4gICAgICAgICAgICAgICAgZihtaWQpO1xuICAgICAgICAgICAgaWYgKHRvID4gbWlkLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUobWlkLnRvICsgMSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgcmlnaHRTdGFydCA9IHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodG8gPCByaWdodFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LnJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSwgdGhpcy5yaWdodCk7XG4gICAgICAgIGlmIChmcm9tID4gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdCwgdGhpcy5yaWdodC5yZXBsYWNlKGZyb20gLSByaWdodFN0YXJ0LCB0byAtIHJpZ2h0U3RhcnQsIG5vZGVzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VMZWZ0KGZyb20sIHJlc3VsdCk7XG4gICAgICAgIGxldCBsZWZ0ID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBtZXJnZUdhcHMocmVzdWx0LCBsZWZ0IC0gMSk7XG4gICAgICAgIGlmICh0byA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VSaWdodCh0bywgcmVzdWx0KTtcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgICAgIGlmICh0byA8PSBsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5kZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxlZnQpO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgaWYgKHRvID49IGxlZnQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvID4gbGVmdClcbiAgICAgICAgICAgIHRoaXMucmlnaHQuZGVjb21wb3NlTGVmdCh0byAtIGxlZnQsIHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGgsIHJpZ2h0ID0gbGVmdCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmIChmcm9tID49IHJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuZGVjb21wb3NlUmlnaHQoZnJvbSAtIHJpZ2h0LCByZXN1bHQpO1xuICAgICAgICBpZiAoZnJvbSA8IGxlZnQpXG4gICAgICAgICAgICB0aGlzLmxlZnQuZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgJiYgZnJvbSA8IHJpZ2h0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmlnaHQpO1xuICAgIH1cbiAgICBiYWxhbmNlZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC5zaXplID4gMiAqIHJpZ2h0LnNpemUgfHwgcmlnaHQuc2l6ZSA+IDIgKiBsZWZ0LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHRoaXMuYnJlYWsgPyBbbGVmdCwgbnVsbCwgcmlnaHRdIDogW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgIHRoaXMubGVmdCA9IHJlcGxhY2UodGhpcy5sZWZ0LCBsZWZ0KTtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJlcGxhY2UodGhpcy5yaWdodCwgcmlnaHQpO1xuICAgICAgICB0aGlzLnNldEhlaWdodChsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodCk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkO1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgdGhpcy5icmVhayArIHJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCB7IGxlZnQsIHJpZ2h0IH0gPSB0aGlzLCByaWdodFN0YXJ0ID0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrLCByZWJhbGFuY2UgPSBudWxsO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgcmViYWxhbmNlID0gbGVmdCA9IGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSwgbWVhc3VyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZWZ0LnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCwgZm9yY2UpO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSByaWdodFN0YXJ0ICsgcmlnaHQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSByaWdodCA9IHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlKTtcbiAgICAgICAgaWYgKHJlYmFsYW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgdGhpcy5yaWdodC5oZWlnaHQ7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5sZWZ0ICsgKHRoaXMuYnJlYWsgPyBcIiBcIiA6IFwiLVwiKSArIHRoaXMucmlnaHQ7IH1cbn1cbmZ1bmN0aW9uIG1lcmdlR2Fwcyhub2RlcywgYXJvdW5kKSB7XG4gICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgaWYgKG5vZGVzW2Fyb3VuZF0gPT0gbnVsbCAmJlxuICAgICAgICAoYmVmb3JlID0gbm9kZXNbYXJvdW5kIC0gMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmXG4gICAgICAgIChhZnRlciA9IG5vZGVzW2Fyb3VuZCArIDFdKSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgbm9kZXMuc3BsaWNlKGFyb3VuZCAtIDEsIDMsIG5ldyBIZWlnaHRNYXBHYXAoYmVmb3JlLmxlbmd0aCArIDEgKyBhZnRlci5sZW5ndGgpKTtcbn1cbmNvbnN0IHJlbGV2YW50V2lkZ2V0SGVpZ2h0ID0gNTtcbmNsYXNzIE5vZGVCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIG9yYWNsZSkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5vcmFjbGUgPSBvcmFjbGU7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gLTE7XG4gICAgICAgIHRoaXMuY292ZXJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHBvcztcbiAgICB9XG4gICAgZ2V0IGlzQ292ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY292ZXJpbmcgJiYgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IHRoaXMuY292ZXJpbmc7XG4gICAgfVxuICAgIHNwYW4oX2Zyb20sIHRvKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4odG8sIHRoaXMubGluZUVuZCksIGxhc3QgPSB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbGFzdC5sZW5ndGggKz0gZW5kIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPiB0aGlzLnBvcyB8fCAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KGVuZCAtIHRoaXMucG9zLCAtMSkpO1xuICAgICAgICAgICAgdGhpcy53cml0dGVuVG8gPSBlbmQ7XG4gICAgICAgICAgICBpZiAodG8gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0dGVuVG8rKztcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgfVxuICAgIHBvaW50KGZyb20sIHRvLCBkZWNvKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgZGVjby5oZWlnaHRSZWxldmFudCkge1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0IDogMDtcbiAgICAgICAgICAgIGxldCBicmVha3MgPSBkZWNvLndpZGdldCA/IGRlY28ud2lkZ2V0LmxpbmVCcmVha3MgOiAwO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2sobmV3IEhlaWdodE1hcEJsb2NrKGxlbiwgaGVpZ2h0LCBkZWNvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gfHwgYnJlYWtzIHx8IGhlaWdodCA+PSByZWxldmFudFdpZGdldEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZURlY28oaGVpZ2h0LCBicmVha3MsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICB0aGlzLnNwYW4oZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVFbmQgPiAtMSAmJiB0aGlzLmxpbmVFbmQgPCB0aGlzLnBvcylcbiAgICAgICAgICAgIHRoaXMubGluZUVuZCA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvO1xuICAgIH1cbiAgICBlbnRlckxpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gdG87XG4gICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20gLSAxIHx8IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KHRoaXMucG9zIC0gZnJvbSwgLTEpKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcztcbiAgICB9XG4gICAgYmxhbmtDb250ZW50KGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBnYXAgPSBuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLm9yYWNsZS5kb2MubGluZUF0KGZyb20pLnRvID09IHRvKVxuICAgICAgICAgICAgZ2FwLmZsYWdzIHw9IDQgLyogRmxhZy5TaW5nbGVMaW5lICovO1xuICAgICAgICByZXR1cm4gZ2FwO1xuICAgIH1cbiAgICBlbnN1cmVMaW5lKCkge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID8gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQoMCwgLTEpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobGluZSk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBhZGRCbG9jayhibG9jaykge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgZGVjbyA9IGJsb2NrLmRlY287XG4gICAgICAgIGlmIChkZWNvICYmIGRlY28uc3RhcnRTaWRlID4gMCAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgYmxvY2subGVuZ3RoO1xuICAgICAgICBpZiAoZGVjbyAmJiBkZWNvLmVuZFNpZGUgPiAwKVxuICAgICAgICAgICAgdGhpcy5jb3ZlcmluZyA9IGJsb2NrO1xuICAgIH1cbiAgICBhZGRMaW5lRGVjbyhoZWlnaHQsIGJyZWFrcywgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5lbnN1cmVMaW5lKCk7XG4gICAgICAgIGxpbmUubGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgbGluZS5jb2xsYXBzZWQgKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLndpZGdldEhlaWdodCA9IE1hdGgubWF4KGxpbmUud2lkZ2V0SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICBsaW5lLmJyZWFrcyArPSBicmVha3M7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGxlbmd0aDtcbiAgICB9XG4gICAgZmluaXNoKGZyb20pIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA9PSAwID8gbnVsbCA6IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEgJiYgIShsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCkgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3JpdHRlblRvIDwgdGhpcy5wb3MgfHwgbGFzdCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCB0aGlzLnBvcykpO1xuICAgICAgICBsZXQgcG9zID0gZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQodGhpcy5vcmFjbGUsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gbm9kZSA/IG5vZGUubGVuZ3RoIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG4gICAgLy8gQWx3YXlzIGNhbGxlZCB3aXRoIGEgcmVnaW9uIHRoYXQgb24gYm90aCBzaWRlcyBlaXRoZXIgc3RyZXRjaGVzXG4gICAgLy8gdG8gYSBsaW5lIGJyZWFrIG9yIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgIC8vIFRoZSByZXR1cm5lZCBhcnJheSB1c2VzIG51bGwgdG8gaW5kaWNhdGUgbGluZSBicmVha3MsIGJ1dCBuZXZlclxuICAgIC8vIHN0YXJ0cyBvciBlbmRzIGluIGEgbGluZSBicmVhaywgb3IgaGFzIG11bHRpcGxlIGxpbmUgYnJlYWtzIG5leHRcbiAgICAvLyB0byBlYWNoIG90aGVyLlxuICAgIHN0YXRpYyBidWlsZChvcmFjbGUsIGRlY29yYXRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBOb2RlQnVpbGRlcihmcm9tLCBvcmFjbGUpO1xuICAgICAgICBzdGF0ZS5SYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIsIDApO1xuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goZnJvbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3I7XG4gICAgc3RhdGUuUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wLCAwKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKCkgeyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvLCBhLCBiKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgYSAmJiBhLmhlaWdodFJlbGV2YW50IHx8IGIgJiYgYi5oZWlnaHRSZWxldmFudClcbiAgICAgICAgICAgIGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMsIDUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmlzaWJsZVBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGxldCBsZWZ0ID0gTWF0aC5tYXgoMCwgcmVjdC5sZWZ0KSwgcmlnaHQgPSBNYXRoLm1pbih3aW4uaW5uZXJXaWR0aCwgcmVjdC5yaWdodCk7XG4gICAgbGV0IHRvcCA9IE1hdGgubWF4KDAsIHJlY3QudG9wKSwgYm90dG9tID0gTWF0aC5taW4od2luLmlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7IHBhcmVudCAmJiBwYXJlbnQgIT0gZG9jLmJvZHk7KSB7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsdCk7XG4gICAgICAgICAgICBpZiAoKGVsdC5zY3JvbGxIZWlnaHQgPiBlbHQuY2xpZW50SGVpZ2h0IHx8IGVsdC5zY3JvbGxXaWR0aCA+IGVsdC5jbGllbnRXaWR0aCkgJiZcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyAhPSBcInZpc2libGVcIikge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRSZWN0ID0gZWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBwYXJlbnRSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHBhcmVudFJlY3QucmlnaHQpO1xuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgcGFyZW50UmVjdC50b3ApO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWluKHBhcmVudCA9PSBkb20ucGFyZW50Tm9kZSA/IHdpbi5pbm5lckhlaWdodCA6IGJvdHRvbSwgcGFyZW50UmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gc3R5bGUucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiIHx8IHN0eWxlLnBvc2l0aW9uID09IFwiZml4ZWRcIiA/IGVsdC5vZmZzZXRQYXJlbnQgOiBlbHQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHJlY3QubGVmdCwgcmlnaHQ6IE1hdGgubWF4KGxlZnQsIHJpZ2h0KSAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiB0b3AgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSwgYm90dG9tOiBNYXRoLm1heCh0b3AsIGJvdHRvbSkgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xufVxuZnVuY3Rpb24gZnVsbFBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICAgIHRvcDogcGFkZGluZ1RvcCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG4vLyBMaW5lIGdhcHMgYXJlIHBsYWNlaG9sZGVyIHdpZGdldHMgdXNlZCB0byBoaWRlIHBpZWNlcyBvZiBvdmVybG9uZ1xuLy8gbGluZXMgd2l0aGluIHRoZSB2aWV3cG9ydCwgYXMgYSBrbHVkZ2UgdG8ga2VlcCB0aGUgZWRpdG9yXG4vLyByZXNwb25zaXZlIHdoZW4gYSByaWRpY3Vsb3VzbHkgbG9uZyBsaW5lIGlzIGxvYWRlZCBpbnRvIGl0LlxuY2xhc3MgTGluZUdhcCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHNpemUsIGRpc3BsYXlTaXplKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5kaXNwbGF5U2l6ZSA9IGRpc3BsYXlTaXplO1xuICAgIH1cbiAgICBzdGF0aWMgc2FtZShhLCBiKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZ0EgPSBhW2ldLCBnQiA9IGJbaV07XG4gICAgICAgICAgICBpZiAoZ0EuZnJvbSAhPSBnQi5mcm9tIHx8IGdBLnRvICE9IGdCLnRvIHx8IGdBLnNpemUgIT0gZ0Iuc2l6ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyYXcodmlld1N0YXRlLCB3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgIHdpZGdldDogbmV3IExpbmVHYXBXaWRnZXQodGhpcy5kaXNwbGF5U2l6ZSAqICh3cmFwcGluZyA/IHZpZXdTdGF0ZS5zY2FsZVkgOiB2aWV3U3RhdGUuc2NhbGVYKSwgd3JhcHBpbmcpXG4gICAgICAgIH0pLnJhbmdlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgTGluZUdhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHZlcnRpY2FsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMudmVydGljYWwgPSB2ZXJ0aWNhbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnNpemUgPT0gdGhpcy5zaXplICYmIG90aGVyLnZlcnRpY2FsID09IHRoaXMudmVydGljYWw7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IFwiMnB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmVydGljYWwgPyB0aGlzLnNpemUgOiAtMTsgfVxufVxuY2xhc3MgVmlld1N0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSQxKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZSQxO1xuICAgICAgICAvLyBUaGVzZSBhcmUgY29udGVudERPTS1sb2NhbCBjb29yZGluYXRlc1xuICAgICAgICB0aGlzLnBpeGVsVmlld3BvcnQgPSB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW5kb3cuaW5uZXJXaWR0aCwgdG9wOiAwLCBib3R0b206IDAgfTtcbiAgICAgICAgdGhpcy5pblZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSAwOyAvLyBQYWRkaW5nIGFib3ZlIHRoZSBkb2N1bWVudCwgc2NhbGVkXG4gICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7IC8vIFBhZGRpbmcgYmVsb3cgdGhlIGRvY3VtZW50LCBzY2FsZWRcbiAgICAgICAgdGhpcy5jb250ZW50RE9NV2lkdGggPSAwOyAvLyBjb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXG4gICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IDA7IC8vIGNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gMDsgLy8gc2Nyb2xsRE9NLmNsaWVudEhlaWdodCwgdW5zY2FsZWRcbiAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IDA7IC8vIHNjcm9sbERPTS5jbGllbnRXaWR0aCwgdW5zY2FsZWRcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSAwOyAvLyBMYXN0IHNlZW4gc2Nyb2xsRE9NLnNjcm9sbFRvcCwgc2NhbGVkXG4gICAgICAgIHRoaXMuc2Nyb2xsZWRUb0JvdHRvbSA9IGZhbHNlO1xuICAgICAgICAvLyBUaGUgQ1NTLXRyYW5zZm9ybWF0aW9uIHNjYWxlIG9mIHRoZSBlZGl0b3IgKHRyYW5zZm9ybWVkIHNpemUgL1xuICAgICAgICAvLyBjb25jcmV0ZSBzaXplKVxuICAgICAgICB0aGlzLnNjYWxlWCA9IDE7XG4gICAgICAgIHRoaXMuc2NhbGVZID0gMTtcbiAgICAgICAgLy8gVGhlIHZlcnRpY2FsIHBvc2l0aW9uIChkb2N1bWVudC1yZWxhdGl2ZSkgdG8gd2hpY2ggdG8gYW5jaG9yIHRoZVxuICAgICAgICAvLyBzY3JvbGwgcG9zaXRpb24uIC0xIG1lYW5zIGFuY2hvciB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JQb3MgPSAwO1xuICAgICAgICAvLyBUaGUgaGVpZ2h0IGF0IHRoZSBhbmNob3IgcG9zaXRpb24uIFNldCBieSB0aGUgRE9NIHVwZGF0ZSBwaGFzZS5cbiAgICAgICAgLy8gLTEgbWVhbnMgbm8gaGVpZ2h0IGF2YWlsYWJsZS5cbiAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgLy8gU2VlIFZQLk1heERPTUhlaWdodFxuICAgICAgICB0aGlzLnNjYWxlciA9IElkU2NhbGVyO1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IG51bGw7XG4gICAgICAgIC8vIEJyaWVmbHkgc2V0IHRvIHRydWUgd2hlbiBwcmludGluZywgdG8gZGlzYWJsZSB2aWV3cG9ydCBsaW1pdGluZ1xuICAgICAgICB0aGlzLnByaW50aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIEZsYWcgc2V0IHdoZW4gZWRpdG9yIGNvbnRlbnQgd2FzIHJlZHJhd24sIHNvIHRoYXQgdGhlIG5leHRcbiAgICAgICAgLy8gbWVhc3VyZSBzdGFnZSBrbm93cyBpdCBtdXN0IHJlYWQgRE9NIGxheW91dFxuICAgICAgICB0aGlzLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gPSBleHBvcnRzLkRpcmVjdGlvbi5MVFI7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IFtdO1xuICAgICAgICAvLyBDdXJzb3IgJ2Fzc29jJyBpcyBvbmx5IHNpZ25pZmljYW50IHdoZW4gdGhlIGN1cnNvciBpcyBvbiBhIGxpbmVcbiAgICAgICAgLy8gd3JhcCBwb2ludCwgd2hlcmUgaXQgbXVzdCBzdGljayB0byB0aGUgY2hhcmFjdGVyIHRoYXQgaXQgaXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoLiBTaW5jZSBicm93c2VycyBkb24ndCBwcm92aWRlIGEgcmVhc29uYWJsZVxuICAgICAgICAvLyBpbnRlcmZhY2UgdG8gc2V0IG9yIHF1ZXJ5IHRoaXMsIHdoZW4gYSBzZWxlY3Rpb24gaXMgc2V0IHRoYXRcbiAgICAgICAgLy8gbWlnaHQgY2F1c2UgdGhpcyB0byBiZSBzaWduaWZpY2FudCwgdGhpcyBmbGFnIGlzIHNldC4gVGhlIG5leHRcbiAgICAgICAgLy8gbWVhc3VyZSBwaGFzZSB3aWxsIGNoZWNrIHdoZXRoZXIgdGhlIGN1cnNvciBpcyBvbiBhIGxpbmUtd3JhcHBpbmdcbiAgICAgICAgLy8gYm91bmRhcnkgYW5kLCBpZiBzbywgcmVzZXQgaXQgdG8gbWFrZSBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgaW5cbiAgICAgICAgLy8gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcbiAgICAgICAgbGV0IGd1ZXNzV3JhcHBpbmcgPSBzdGF0ZSQxLmZhY2V0KGNvbnRlbnRBdHRyaWJ1dGVzKS5zb21lKHYgPT4gdHlwZW9mIHYgIT0gXCJmdW5jdGlvblwiICYmIHYuY2xhc3MgPT0gXCJjbS1saW5lV3JhcHBpbmdcIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0T3JhY2xlID0gbmV3IEhlaWdodE9yYWNsZShndWVzc1dyYXBwaW5nKTtcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSBzdGF0ZSQxLmZhY2V0KGRlY29yYXRpb25zKS5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IEhlaWdodE1hcC5lbXB0eSgpLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgc3RhdGUuVGV4dC5lbXB0eSwgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHN0YXRlJDEuZG9jKSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgc3RhdGUkMS5kb2MubGVuZ3RoKV0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXBkYXRlRm9yVmlld3BvcnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgdGhpcy5saW5lR2FwcyA9IHRoaXMuZW5zdXJlTGluZUdhcHMoW10pO1xuICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQodGhpcy5saW5lR2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KHRoaXMsIGZhbHNlKSkpO1xuICAgICAgICB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgfVxuICAgIHVwZGF0ZUZvclZpZXdwb3J0KCkge1xuICAgICAgICBsZXQgdmlld3BvcnRzID0gW3RoaXMudmlld3BvcnRdLCB7IG1haW4gfSA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBpID8gbWFpbi5oZWFkIDogbWFpbi5hbmNob3I7XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0cy5zb21lKCh7IGZyb20sIHRvIH0pID0+IHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5saW5lQmxvY2tBdChwb3MpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0cy5wdXNoKG5ldyBWaWV3cG9ydChmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVNjYWxlcigpO1xuICAgIH1cbiAgICB1cGRhdGVTY2FsZXIoKSB7XG4gICAgICAgIGxldCBzY2FsZXIgPSB0aGlzLnNjYWxlcjtcbiAgICAgICAgdGhpcy5zY2FsZXIgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQgPD0gNzAwMDAwMCAvKiBWUC5NYXhET01IZWlnaHQgKi8gPyBJZFNjYWxlciA6XG4gICAgICAgICAgICBuZXcgQmlnU2NhbGVyKHRoaXMuaGVpZ2h0T3JhY2xlLCB0aGlzLmhlaWdodE1hcCwgdGhpcy52aWV3cG9ydHMpO1xuICAgICAgICByZXR1cm4gc2NhbGVyLmVxKHRoaXMuc2NhbGVyKSA/IDAgOiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xuICAgIH1cbiAgICB1cGRhdGVWaWV3cG9ydExpbmVzKCkge1xuICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAuZm9yRWFjaExpbmUodGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCAwLCAwLCBibG9jayA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMucHVzaChzY2FsZUJsb2NrKGJsb2NrLCB0aGlzLnNjYWxlcikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0ID0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdXBkYXRlLnN0YXRlO1xuICAgICAgICBsZXQgcHJldkRlY28gPSB0aGlzLnN0YXRlRGVjbztcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSB0aGlzLnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICBsZXQgY29udGVudENoYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgbGV0IGhlaWdodENoYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjb250ZW50Q2hhbmdlcywgaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhwcmV2RGVjbywgdGhpcy5zdGF0ZURlY28sIHVwZGF0ZSA/IHVwZGF0ZS5jaGFuZ2VzIDogc3RhdGUuQ2hhbmdlU2V0LmVtcHR5KHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICAgICAgbGV0IHByZXZIZWlnaHQgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQ7XG4gICAgICAgIGxldCBzY3JvbGxBbmNob3IgPSB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPyBudWxsIDogdGhpcy5zY3JvbGxBbmNob3JBdCh0aGlzLnNjcm9sbFRvcCk7XG4gICAgICAgIGNsZWFySGVpZ2h0Q2hhbmdlRmxhZygpO1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IHRoaXMuaGVpZ2h0TWFwLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCBoZWlnaHRDaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCAhPSBwcmV2SGVpZ2h0IHx8IGhlaWdodENoYW5nZUZsYWcpXG4gICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgaWYgKHNjcm9sbEFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JQb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc2Nyb2xsQW5jaG9yLmZyb20sIC0xKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gc2Nyb2xsQW5jaG9yLnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gLTE7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IHRoaXMuaGVpZ2h0TWFwLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld3BvcnQgPSBoZWlnaHRDaGFuZ2VzLmxlbmd0aCA/IHRoaXMubWFwVmlld3BvcnQodGhpcy52aWV3cG9ydCwgdXBkYXRlLmNoYW5nZXMpIDogdGhpcy52aWV3cG9ydDtcbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldCAmJiAoc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPCB2aWV3cG9ydC5mcm9tIHx8IHNjcm9sbFRhcmdldC5yYW5nZS5oZWFkID4gdmlld3BvcnQudG8pIHx8XG4gICAgICAgICAgICAhdGhpcy52aWV3cG9ydElzQXBwcm9wcmlhdGUodmlld3BvcnQpKVxuICAgICAgICAgICAgdmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIHNjcm9sbFRhcmdldCk7XG4gICAgICAgIGxldCB2aWV3cG9ydENoYW5nZSA9IHZpZXdwb3J0LmZyb20gIT0gdGhpcy52aWV3cG9ydC5mcm9tIHx8IHZpZXdwb3J0LnRvICE9IHRoaXMudmlld3BvcnQudG87XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgdXBkYXRlLmZsYWdzIHw9IHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Q2hhbmdlIHx8ICF1cGRhdGUuY2hhbmdlcy5lbXB0eSB8fCAodXBkYXRlLmZsYWdzICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoIHx8IHRoaXMudmlld3BvcnQudG8gLSB0aGlzLnZpZXdwb3J0LmZyb20gPiAoMjAwMCAvKiBMRy5NYXJnaW4gKi8gPDwgMSkpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxpbmVHYXBzKHRoaXMuZW5zdXJlTGluZUdhcHModGhpcy5tYXBMaW5lR2Fwcyh0aGlzLmxpbmVHYXBzLCB1cGRhdGUuY2hhbmdlcykpKTtcbiAgICAgICAgdXBkYXRlLmZsYWdzIHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldClcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0O1xuICAgICAgICBpZiAoIXRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyAmJiB1cGRhdGUuc2VsZWN0aW9uU2V0ICYmIHVwZGF0ZS52aWV3LmxpbmVXcmFwcGluZyAmJlxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hc3NvYyAmJlxuICAgICAgICAgICAgIXVwZGF0ZS5zdGF0ZS5mYWNldChuYXRpdmVTZWxlY3Rpb25IaWRkZW4pKVxuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gdHJ1ZTtcbiAgICB9XG4gICAgbWVhc3VyZSh2aWV3KSB7XG4gICAgICAgIGxldCBkb20gPSB2aWV3LmNvbnRlbnRET00sIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKTtcbiAgICAgICAgbGV0IG9yYWNsZSA9IHRoaXMuaGVpZ2h0T3JhY2xlO1xuICAgICAgICBsZXQgd2hpdGVTcGFjZSA9IHN0eWxlLndoaXRlU3BhY2U7XG4gICAgICAgIHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gPSBzdHlsZS5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IGV4cG9ydHMuRGlyZWN0aW9uLlJUTCA6IGV4cG9ydHMuRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgbGV0IHJlZnJlc2ggPSB0aGlzLmhlaWdodE9yYWNsZS5tdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpO1xuICAgICAgICBsZXQgZG9tUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IG1lYXN1cmVDb250ZW50ID0gcmVmcmVzaCB8fCB0aGlzLm11c3RNZWFzdXJlQ29udGVudCB8fCB0aGlzLmNvbnRlbnRET01IZWlnaHQgIT0gZG9tUmVjdC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgICB0aGlzLm11c3RNZWFzdXJlQ29udGVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gMCwgYmlhcyA9IDA7XG4gICAgICAgIGlmIChkb21SZWN0LndpZHRoICYmIGRvbVJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgeyBzY2FsZVgsIHNjYWxlWSB9ID0gZ2V0U2NhbGUoZG9tLCBkb21SZWN0KTtcbiAgICAgICAgICAgIGlmIChzY2FsZVggPiAuMDA1ICYmIE1hdGguYWJzKHRoaXMuc2NhbGVYIC0gc2NhbGVYKSA+IC4wMDUgfHxcbiAgICAgICAgICAgICAgICBzY2FsZVkgPiAuMDA1ICYmIE1hdGguYWJzKHRoaXMuc2NhbGVZIC0gc2NhbGVZKSA+IC4wMDUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmVydGljYWwgcGFkZGluZ1xuICAgICAgICBsZXQgcGFkZGluZ1RvcCA9IChwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wKSB8fCAwKSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IChwYXJzZUludChzdHlsZS5wYWRkaW5nQm90dG9tKSB8fCAwKSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBpZiAodGhpcy5wYWRkaW5nVG9wICE9IHBhZGRpbmdUb3AgfHwgdGhpcy5wYWRkaW5nQm90dG9tICE9IHBhZGRpbmdCb3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3A7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLyB8IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yV2lkdGggIT0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgIGlmIChvcmFjbGUubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yV2lkdGggPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3AgIT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxlZFRvQm90dG9tID0gaXNTY3JvbGxlZFRvQm90dG9tKHZpZXcuc2Nyb2xsRE9NKTtcbiAgICAgICAgLy8gUGl4ZWwgdmlld3BvcnRcbiAgICAgICAgbGV0IHBpeGVsVmlld3BvcnQgPSAodGhpcy5wcmludGluZyA/IGZ1bGxQaXhlbFJhbmdlIDogdmlzaWJsZVBpeGVsUmFuZ2UpKGRvbSwgdGhpcy5wYWRkaW5nVG9wKTtcbiAgICAgICAgbGV0IGRUb3AgPSBwaXhlbFZpZXdwb3J0LnRvcCAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3AsIGRCb3R0b20gPSBwaXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b207XG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHBpeGVsVmlld3BvcnQ7XG4gICAgICAgIGxldCBpblZpZXcgPSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tID4gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCAmJiB0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgPiB0aGlzLnBpeGVsVmlld3BvcnQubGVmdDtcbiAgICAgICAgaWYgKGluVmlldyAhPSB0aGlzLmluVmlldykge1xuICAgICAgICAgICAgdGhpcy5pblZpZXcgPSBpblZpZXc7XG4gICAgICAgICAgICBpZiAoaW5WaWV3KVxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3ICYmICF0aGlzLnNjcm9sbFRhcmdldClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgY29udGVudFdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTVdpZHRoICE9IGNvbnRlbnRXaWR0aCB8fCB0aGlzLmVkaXRvckhlaWdodCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTVdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVhc3VyZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBsaW5lSGVpZ2h0cyA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHRoaXMudmlld3BvcnQpO1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5tdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpKVxuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHJlZnJlc2ggfHwgb3JhY2xlLmxpbmVXcmFwcGluZyAmJiBNYXRoLmFicyhjb250ZW50V2lkdGggLSB0aGlzLmNvbnRlbnRET01XaWR0aCkgPiBvcmFjbGUuY2hhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0IH0gPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IGxpbmVIZWlnaHQgPiAwICYmIG9yYWNsZS5yZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCwgY29udGVudFdpZHRoIC8gY2hhcldpZHRoLCBsaW5lSGVpZ2h0cyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1pbldpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFRvcCA+IDAgJiYgZEJvdHRvbSA+IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWF4KGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZFRvcCA8IDAgJiYgZEJvdHRvbSA8IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWluKGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgY2xlYXJIZWlnaHRDaGFuZ2VGbGFnKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB2cCBvZiB0aGlzLnZpZXdwb3J0cykge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHRzID0gdnAuZnJvbSA9PSB0aGlzLnZpZXdwb3J0LmZyb20gPyBsaW5lSGVpZ2h0cyA6IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodE1hcCA9IChyZWZyZXNoID8gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBzdGF0ZS5UZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0pIDogdGhpcy5oZWlnaHRNYXApLnVwZGF0ZUhlaWdodChvcmFjbGUsIDAsIHJlZnJlc2gsIG5ldyBNZWFzdXJlZEhlaWdodHModnAuZnJvbSwgaGVpZ2h0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodENoYW5nZUZsYWcpXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0Q2hhbmdlID0gIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHRoaXMudmlld3BvcnQsIGJpYXMpIHx8XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCAmJiAodGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHRoaXMudmlld3BvcnQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB0aGlzLnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Q2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLylcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gdGhpcy51cGRhdGVTY2FsZXIoKTtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KGJpYXMsIHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgIHJlc3VsdCB8PSB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChyZXN1bHQgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSB8fCB2aWV3cG9ydENoYW5nZSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2FwcyhyZWZyZXNoID8gW10gOiB0aGlzLmxpbmVHYXBzLCB2aWV3KSk7XG4gICAgICAgIHJlc3VsdCB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MpIHtcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIGluIHRoZSByZWFkIHN0YWdlLCBiZWNhdXNlIG1vdmluZyB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyB0byBhIGxpbmUgZW5kIGlzIGdvaW5nIHRvIHRyaWdnZXIgYSBsYXlvdXQgYW55d2F5LCBzbyBpdFxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgYSBwdXJlIHdyaXRlLiBJdCBzaG91bGQgYmUgcmFyZSB0aGF0IGl0IGRvZXMgYW55XG4gICAgICAgICAgICAvLyB3cml0aW5nLlxuICAgICAgICAgICAgdmlldy5kb2NWaWV3LmVuZm9yY2VDdXJzb3JBc3NvYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlVG9wKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQudG9wKTsgfVxuICAgIGdldCB2aXNpYmxlQm90dG9tKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tKTsgfVxuICAgIGdldFZpZXdwb3J0KGJpYXMsIHNjcm9sbFRhcmdldCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgZGl2aWRlIFZQLk1hcmdpbiBiZXR3ZWVuIHRoZSB0b3AgYW5kIHRoZVxuICAgICAgICAvLyBib3R0b20sIGRlcGVuZGluZyBvbiB0aGUgYmlhcyAodGhlIGNoYW5nZSBpbiB2aWV3cG9ydCBwb3NpdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUpLiBJdCdsbCBob2xkIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAgICBsZXQgbWFyZ2luVG9wID0gMC41IC0gTWF0aC5tYXgoLTAuNSwgTWF0aC5taW4oMC41LCBiaWFzIC8gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyKSk7XG4gICAgICAgIGxldCBtYXAgPSB0aGlzLmhlaWdodE1hcCwgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XG4gICAgICAgIGxldCB7IHZpc2libGVUb3AsIHZpc2libGVCb3R0b20gfSA9IHRoaXM7XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHZpc2libGVUb3AgLSBtYXJnaW5Ub3AgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodmlzaWJsZUJvdHRvbSArICgxIC0gbWFyZ2luVG9wKSAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkudG8pO1xuICAgICAgICAvLyBJZiBzY3JvbGxUYXJnZXQgaXMgZ2l2ZW4sIG1ha2Ugc3VyZSB0aGUgdmlld3BvcnQgaW5jbHVkZXMgdGhhdCBwb3NpdGlvblxuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICBsZXQgeyBoZWFkIH0gPSBzY3JvbGxUYXJnZXQucmFuZ2U7XG4gICAgICAgICAgICBpZiAoaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgaGVhZCA+IHZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXdIZWlnaHQgPSBNYXRoLm1pbih0aGlzLmVkaXRvckhlaWdodCwgdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApO1xuICAgICAgICAgICAgICAgIGxldCBibG9jayA9IG1hcC5saW5lQXQoaGVhZCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLCB0b3BQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldC55ID09IFwiY2VudGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IChibG9jay50b3AgKyBibG9jay5ib3R0b20pIC8gMiAtIHZpZXdIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFRhcmdldC55ID09IFwic3RhcnRcIiB8fCBzY3JvbGxUYXJnZXQueSA9PSBcIm5lYXJlc3RcIiAmJiBoZWFkIDwgdmlld3BvcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2sudG9wO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2suYm90dG9tIC0gdmlld0hlaWdodDtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHRvcFBvcyAtIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodG9wUG9zICsgdmlld0hlaWdodCArIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICAgIG1hcFZpZXdwb3J0KHZpZXdwb3J0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3cG9ydCh0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCkuZnJvbSwgdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS50byk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHZpZXdwb3J0IGNvdmVycyB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZVxuICAgIC8vIGRvY3VtZW50IGFuZCBub3QgdG9vIG11Y2ggYmV5b25kIHRoYXQuXG4gICAgdmlld3BvcnRJc0FwcHJvcHJpYXRlKHsgZnJvbSwgdG8gfSwgYmlhcyA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgeyB0b3AgfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgYm90dG9tIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApO1xuICAgICAgICBsZXQgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGZyb20gPT0gMCB8fCB0b3AgPD0gdmlzaWJsZVRvcCAtIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbigtYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG8gPT0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgYm90dG9tID49IHZpc2libGVCb3R0b20gKyBNYXRoLm1heCgxMCAvKiBWUC5NaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG9wID4gdmlzaWJsZVRvcCAtIDIgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLyAmJiBib3R0b20gPCB2aXNpYmxlQm90dG9tICsgMiAqIDEwMDAgLyogVlAuTWFyZ2luICovKTtcbiAgICB9XG4gICAgbWFwTGluZUdhcHMoZ2FwcywgY2hhbmdlcykge1xuICAgICAgICBpZiAoIWdhcHMubGVuZ3RoIHx8IGNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gZ2FwcztcbiAgICAgICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgIGlmICghY2hhbmdlcy50b3VjaGVzUmFuZ2UoZ2FwLmZyb20sIGdhcC50bykpXG4gICAgICAgICAgICAgICAgbWFwcGVkLnB1c2gobmV3IExpbmVHYXAoY2hhbmdlcy5tYXBQb3MoZ2FwLmZyb20pLCBjaGFuZ2VzLm1hcFBvcyhnYXAudG8pLCBnYXAuc2l6ZSwgZ2FwLmRpc3BsYXlTaXplKSk7XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHBvc2l0aW9ucyBpbiB0aGUgdmlld3BvcnQgd2hlcmUgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhXG4gICAgLy8gbGluZSBzaG91bGQgYmUgaGlkZGVuLCB0cnlpbmcgdG8gcmV1c2UgZXhpc3RpbmcgbGluZSBnYXBzIHdoZW5cbiAgICAvLyBhcHByb3ByaWF0ZSB0byBhdm9pZCB1bm5lY2Nlc2FyeSByZWRyYXdzLlxuICAgIC8vIFVzZXMgY3J1ZGUgY2hhcmFjdGVyLWNvdW50aW5nIGZvciB0aGUgcG9zaXRpb25pbmcgYW5kIHNpemluZyxcbiAgICAvLyBzaW5jZSBhY3R1YWwgRE9NIGNvb3JkaW5hdGVzIGFyZW4ndCBhbHdheXMgYXZhaWxhYmxlIGFuZFxuICAgIC8vIHByZWRpY3RhYmxlLiBSZWxpZXMgb24gZ2VuZXJvdXMgbWFyZ2lucyAoc2VlIExHLk1hcmdpbikgdG8gaGlkZVxuICAgIC8vIHRoZSBhcnRpZmFjdHMgdGhpcyBtaWdodCBwcm9kdWNlIGZyb20gdGhlIHVzZXIuXG4gICAgZW5zdXJlTGluZUdhcHMoY3VycmVudCwgbWF5TWVhc3VyZSkge1xuICAgICAgICBsZXQgd3JhcHBpbmcgPSB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7XG4gICAgICAgIGxldCBtYXJnaW4gPSB3cmFwcGluZyA/IDEwMDAwIC8qIExHLk1hcmdpbldyYXAgKi8gOiAyMDAwIC8qIExHLk1hcmdpbiAqLywgaGFsZk1hcmdpbiA9IG1hcmdpbiA+PiAxLCBkb3VibGVNYXJnaW4gPSBtYXJnaW4gPDwgMTtcbiAgICAgICAgLy8gVGhlIG5vbi13cmFwcGluZyBsb2dpYyB3b24ndCB3b3JrIGF0IGFsbCBpbiBwcmVkb21pbmFudGx5IHJpZ2h0LXRvLWxlZnQgdGV4dC5cbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gIT0gZXhwb3J0cy5EaXJlY3Rpb24uTFRSICYmICF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgbGV0IGFkZEdhcCA9IChmcm9tLCB0bywgbGluZSwgc3RydWN0dXJlKSA9PiB7XG4gICAgICAgICAgICBpZiAodG8gLSBmcm9tIDwgaGFsZk1hcmdpbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgYXZvaWQgPSBbc2VsLmZyb21dO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkpXG4gICAgICAgICAgICAgICAgYXZvaWQucHVzaChzZWwudG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIGF2b2lkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKGZyb20sIHBvcyAtIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKHBvcyArIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgdG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2FwID0gZmluZChjdXJyZW50LCBnYXAgPT4gZ2FwLmZyb20gPj0gbGluZS5mcm9tICYmIGdhcC50byA8PSBsaW5lLnRvICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FwLmZyb20gLSBmcm9tKSA8IGhhbGZNYXJnaW4gJiYgTWF0aC5hYnMoZ2FwLnRvIC0gdG8pIDwgaGFsZk1hcmdpbiAmJlxuICAgICAgICAgICAgICAgICFhdm9pZC5zb21lKHBvcyA9PiBnYXAuZnJvbSA8IHBvcyAmJiBnYXAudG8gPiBwb3MpKTtcbiAgICAgICAgICAgIGlmICghZ2FwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgZG93biwgc25hcCBnYXAgZW5kcyB0byBsaW5lIHN0YXJ0cyB0byBhdm9pZCBzaGlmdHMgaW4gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICBpZiAodG8gPCBsaW5lLnRvICYmIG1heU1lYXN1cmUgJiYgd3JhcHBpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5TWVhc3VyZS52aXNpYmxlUmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gdG8gJiYgci50byA+PSB0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVTdGFydCA9IG1heU1lYXN1cmUubW92ZVRvTGluZUJvdW5kYXJ5KHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pLCBmYWxzZSwgdHJ1ZSkuaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTdGFydCA+IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IGxpbmVTdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0aGlzLmdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3BsYXlTaXplID0gd3JhcHBpbmcgfHwgc2l6ZSA8IDIwMDAwMDAgLyogVlAuTWF4SG9yaXpHYXAgKi8gPyBzaXplIDogMjAwMDAwMCAvKiBWUC5NYXhIb3JpekdhcCAqLztcbiAgICAgICAgICAgICAgICBnYXAgPSBuZXcgTGluZUdhcChmcm9tLCB0bywgc2l6ZSwgZGlzcGxheVNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2Fwcy5wdXNoKGdhcCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjaGVja0xpbmUgPSAobGluZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgZG91YmxlTWFyZ2luIHx8IGxpbmUudHlwZSAhPSBleHBvcnRzLkJsb2NrVHlwZS5UZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBzdHJ1Y3R1cmUgPSBsaW5lU3RydWN0dXJlKGxpbmUuZnJvbSwgbGluZS50bywgdGhpcy5zdGF0ZURlY28pO1xuICAgICAgICAgICAgaWYgKHN0cnVjdHVyZS50b3RhbCA8IGRvdWJsZU1hcmdpbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zY3JvbGxUYXJnZXQgPyB0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDogbnVsbDtcbiAgICAgICAgICAgIGxldCB2aWV3RnJvbSwgdmlld1RvO1xuICAgICAgICAgICAgaWYgKHdyYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpbkhlaWdodCA9IChtYXJnaW4gLyB0aGlzLmhlaWdodE9yYWNsZS5saW5lTGVuZ3RoKSAqIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCwgYm90O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RnJhYyA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUZyYWMgPSAoKHRoaXMudmlzaWJsZUJvdHRvbSAtIHRoaXMudmlzaWJsZVRvcCkgLyAyICsgbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSB0YXJnZXRGcmFjIC0gc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgICAgICBib3QgPSB0YXJnZXRGcmFjICsgc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gKHRoaXMudmlzaWJsZVRvcCAtIGxpbmUudG9wIC0gbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBib3QgPSAodGhpcy52aXNpYmxlQm90dG9tIC0gbGluZS50b3AgKyBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgdG9wKTtcbiAgICAgICAgICAgICAgICB2aWV3VG8gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCBib3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsV2lkdGggPSBzdHJ1Y3R1cmUudG90YWwgKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpbldpZHRoID0gbWFyZ2luICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBob3Jpek9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsV2lkdGggPiAyMDAwMDAwIC8qIFZQLk1heEhvcml6R2FwICovKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBvbGQgb2YgY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZC5mcm9tID49IGxpbmUuZnJvbSAmJiBvbGQuZnJvbSA8IGxpbmUudG8gJiYgb2xkLnNpemUgIT0gb2xkLmRpc3BsYXlTaXplICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLmZyb20gKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGggKyBob3Jpek9mZnNldCA8IHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvcml6T2Zmc2V0ID0gb2xkLnNpemUgLSBvbGQuZGlzcGxheVNpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcHhMZWZ0ID0gdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQgKyBob3Jpek9mZnNldCwgcHhSaWdodCA9IHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCArIGhvcml6T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0LCByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldEZyYWMgPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VGcmFjID0gKChweFJpZ2h0IC0gcHhMZWZ0KSAvIDIgKyBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0RnJhYyAtIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0YXJnZXRGcmFjICsgc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChweExlZnQgLSBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IChweFJpZ2h0ICsgbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICB2aWV3VG8gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld0Zyb20gPiBsaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgYWRkR2FwKGxpbmUuZnJvbSwgdmlld0Zyb20sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICBpZiAodmlld1RvIDwgbGluZS50bylcbiAgICAgICAgICAgICAgICBhZGRHYXAodmlld1RvLCBsaW5lLnRvLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudmlld3BvcnRMaW5lcykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSlcbiAgICAgICAgICAgICAgICBsaW5lLnR5cGUuZm9yRWFjaChjaGVja0xpbmUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNoZWNrTGluZShsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2FwcztcbiAgICB9XG4gICAgZ2FwU2l6ZShsaW5lLCBmcm9tLCB0bywgc3RydWN0dXJlKSB7XG4gICAgICAgIGxldCBmcmFjdGlvbiA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRvKSAtIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIGZyb20pO1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5oZWlnaHQgKiBmcmFjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmUudG90YWwgKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGggKiBmcmFjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVMaW5lR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICghTGluZUdhcC5zYW1lKGdhcHMsIHRoaXMubGluZUdhcHMpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVHYXBzID0gZ2FwcztcbiAgICAgICAgICAgIHRoaXMubGluZUdhcERlY28gPSBEZWNvcmF0aW9uLnNldChnYXBzLm1hcChnYXAgPT4gZ2FwLmRyYXcodGhpcywgdGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVWaXNpYmxlUmFuZ2VzKCkge1xuICAgICAgICBsZXQgZGVjbyA9IHRoaXMuc3RhdGVEZWNvO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGgpXG4gICAgICAgICAgICBkZWNvID0gZGVjby5jb25jYXQodGhpcy5saW5lR2FwRGVjbyk7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgc3RhdGUuUmFuZ2VTZXQuc3BhbnMoZGVjbywgdGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB7XG4gICAgICAgICAgICBzcGFuKGZyb20sIHRvKSB7IHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7IH0sXG4gICAgICAgICAgICBwb2ludCgpIHsgfVxuICAgICAgICB9LCAyMCk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gcmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnZpc2libGVSYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLnZpc2libGVSYW5nZXMuc29tZSgociwgaSkgPT4gci5mcm9tICE9IHJhbmdlc1tpXS5mcm9tIHx8IHIudG8gIT0gcmFuZ2VzW2ldLnRvKTtcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICByZXR1cm4gY2hhbmdlZCA/IDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLyA6IDA7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gKHBvcyA+PSB0aGlzLnZpZXdwb3J0LmZyb20gJiYgcG9zIDw9IHRoaXMudmlld3BvcnQudG8gJiZcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRMaW5lcy5maW5kKGIgPT4gYi5mcm9tIDw9IHBvcyAmJiBiLnRvID49IHBvcykpIHx8XG4gICAgICAgICAgICBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChwb3MsIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICByZXR1cm4gKGhlaWdodCA+PSB0aGlzLnZpZXdwb3J0TGluZXNbMF0udG9wICYmIGhlaWdodCA8PSB0aGlzLnZpZXdwb3J0TGluZXNbdGhpcy52aWV3cG9ydExpbmVzLmxlbmd0aCAtIDFdLmJvdHRvbSAmJlxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLmZpbmQobCA9PiBsLnRvcCA8PSBoZWlnaHQgJiYgbC5ib3R0b20gPj0gaGVpZ2h0KSkgfHxcbiAgICAgICAgICAgIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKSB7XG4gICAgICAgIGxldCBibG9jayA9IHRoaXMubGluZUJsb2NrQXRIZWlnaHQoc2Nyb2xsVG9wICsgOCk7XG4gICAgICAgIHJldHVybiBibG9jay5mcm9tID49IHRoaXMudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXdwb3J0TGluZXNbMF0udG9wIC0gc2Nyb2xsVG9wID4gMjAwID8gYmxvY2sgOiB0aGlzLnZpZXdwb3J0TGluZXNbMF07XG4gICAgfVxuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAuYmxvY2tBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBnZXQgZG9jSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZXIudG9ET00odGhpcy5oZWlnaHRNYXAuaGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0hlaWdodCArIHRoaXMucGFkZGluZ1RvcCArIHRoaXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG59XG5jbGFzcyBWaWV3cG9ydCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpbmVTdHJ1Y3R1cmUoZnJvbSwgdG8sIHN0YXRlRGVjbykge1xuICAgIGxldCByYW5nZXMgPSBbXSwgcG9zID0gZnJvbSwgdG90YWwgPSAwO1xuICAgIHN0YXRlLlJhbmdlU2V0LnNwYW5zKHN0YXRlRGVjbywgZnJvbSwgdG8sIHtcbiAgICAgICAgc3BhbigpIHsgfSxcbiAgICAgICAgcG9pbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvOiBmcm9tIH0pO1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGZyb20gLSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgfVxuICAgIH0sIDIwKTsgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGNvbGxhcHNlZCByYW5nZXMgb2YgYSBzaWduaWZpY2FudCBzaXplXG4gICAgaWYgKHBvcyA8IHRvKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0byB9KTtcbiAgICAgICAgdG90YWwgKz0gdG8gLSBwb3M7XG4gICAgfVxuICAgIHJldHVybiB7IHRvdGFsLCByYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGZpbmRQb3NpdGlvbih7IHRvdGFsLCByYW5nZXMgfSwgcmF0aW8pIHtcbiAgICBpZiAocmF0aW8gPD0gMClcbiAgICAgICAgcmV0dXJuIHJhbmdlc1swXS5mcm9tO1xuICAgIGlmIChyYXRpbyA+PSAxKVxuICAgICAgICByZXR1cm4gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICBsZXQgZGlzdCA9IE1hdGguZmxvb3IodG90YWwgKiByYXRpbyk7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXSwgc2l6ZSA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRpc3QgPD0gc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tICsgZGlzdDtcbiAgICAgICAgZGlzdCAtPSBzaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHBvcykge1xuICAgIGxldCBjb3VudGVkID0gMDtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygc3RydWN0dXJlLnJhbmdlcykge1xuICAgICAgICBpZiAocG9zIDw9IHRvKSB7XG4gICAgICAgICAgICBjb3VudGVkICs9IHBvcyAtIGZyb207XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb3VudGVkICs9IHRvIC0gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZWQgLyBzdHJ1Y3R1cmUudG90YWw7XG59XG5mdW5jdGlvbiBmaW5kKGFycmF5LCBmKSB7XG4gICAgZm9yIChsZXQgdmFsIG9mIGFycmF5KVxuICAgICAgICBpZiAoZih2YWwpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8gRG9uJ3Qgc2NhbGUgd2hlbiB0aGUgZG9jdW1lbnQgaGVpZ2h0IGlzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Ygd2hhdFxuLy8gdGhlIERPTSBjYW4gaGFuZGxlLlxuY29uc3QgSWRTY2FsZXIgPSB7XG4gICAgdG9ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBmcm9tRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgc2NhbGU6IDEsXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyID09IHRoaXM7IH1cbn07XG4vLyBXaGVuIHRoZSBoZWlnaHQgaXMgdG9vIGJpZyAoPiBWUC5NYXhET01IZWlnaHQpLCBzY2FsZSBkb3duIHRoZVxuLy8gcmVnaW9ucyBvdXRzaWRlIHRoZSB2aWV3cG9ydHMgc28gdGhhdCB0aGUgdG90YWwgaGVpZ2h0IGlzXG4vLyBWUC5NYXhET01IZWlnaHQuXG5jbGFzcyBCaWdTY2FsZXIge1xuICAgIGNvbnN0cnVjdG9yKG9yYWNsZSwgaGVpZ2h0TWFwLCB2aWV3cG9ydHMpIHtcbiAgICAgICAgbGV0IHZwSGVpZ2h0ID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwO1xuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRvcCA9IGhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLnRvcDtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSBoZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCkuYm90dG9tO1xuICAgICAgICAgICAgdnBIZWlnaHQgKz0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHRvcCwgYm90dG9tLCBkb21Ub3A6IDAsIGRvbUJvdHRvbTogMCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2FsZSA9ICg3MDAwMDAwIC8qIFZQLk1heERPTUhlaWdodCAqLyAtIHZwSGVpZ2h0KSAvIChoZWlnaHRNYXAuaGVpZ2h0IC0gdnBIZWlnaHQpO1xuICAgICAgICBmb3IgKGxldCBvYmogb2YgdGhpcy52aWV3cG9ydHMpIHtcbiAgICAgICAgICAgIG9iai5kb21Ub3AgPSBkb21CYXNlICsgKG9iai50b3AgLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBkb21CYXNlID0gb2JqLmRvbUJvdHRvbSA9IG9iai5kb21Ub3AgKyAob2JqLmJvdHRvbSAtIG9iai50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IG9iai5ib3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAudG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb21CYXNlICsgKG4gLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5ib3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLmRvbVRvcCArIChuIC0gdnAudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAuZG9tVG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlICsgKG4gLSBkb21CYXNlKSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5kb21Cb3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLnRvcCArIChuIC0gdnAuZG9tVG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgQmlnU2NhbGVyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUgPT0gb3RoZXIuc2NhbGUgJiYgdGhpcy52aWV3cG9ydHMubGVuZ3RoID09IG90aGVyLnZpZXdwb3J0cy5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRzLmV2ZXJ5KCh2cCwgaSkgPT4gdnAuZnJvbSA9PSBvdGhlci52aWV3cG9ydHNbaV0uZnJvbSAmJiB2cC50byA9PSBvdGhlci52aWV3cG9ydHNbaV0udG8pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjYWxlQmxvY2soYmxvY2ssIHNjYWxlcikge1xuICAgIGlmIChzY2FsZXIuc2NhbGUgPT0gMSlcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIGxldCBiVG9wID0gc2NhbGVyLnRvRE9NKGJsb2NrLnRvcCksIGJCb3R0b20gPSBzY2FsZXIudG9ET00oYmxvY2suYm90dG9tKTtcbiAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhibG9jay5mcm9tLCBibG9jay5sZW5ndGgsIGJUb3AsIGJCb3R0b20gLSBiVG9wLCBBcnJheS5pc0FycmF5KGJsb2NrLl9jb250ZW50KSA/IGJsb2NrLl9jb250ZW50Lm1hcChiID0+IHNjYWxlQmxvY2soYiwgc2NhbGVyKSkgOiBibG9jay5fY29udGVudCk7XG59XG5cbmNvbnN0IHRoZW1lID0gc3RhdGUuRmFjZXQuZGVmaW5lKHsgY29tYmluZTogc3RycyA9PiBzdHJzLmpvaW4oXCIgXCIpIH0pO1xuY29uc3QgZGFya1RoZW1lID0gc3RhdGUuRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5pbmRleE9mKHRydWUpID4gLTEgfSk7XG5jb25zdCBiYXNlVGhlbWVJRCA9IHN0eWxlTW9kLlN0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZUxpZ2h0SUQgPSBzdHlsZU1vZC5TdHlsZU1vZHVsZS5uZXdOYW1lKCksIGJhc2VEYXJrSUQgPSBzdHlsZU1vZC5TdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG5jb25zdCBsaWdodERhcmtJRHMgPSB7IFwiJmxpZ2h0XCI6IFwiLlwiICsgYmFzZUxpZ2h0SUQsIFwiJmRhcmtcIjogXCIuXCIgKyBiYXNlRGFya0lEIH07XG5mdW5jdGlvbiBidWlsZFRoZW1lKG1haW4sIHNwZWMsIHNjb3Blcykge1xuICAgIHJldHVybiBuZXcgc3R5bGVNb2QuU3R5bGVNb2R1bGUoc3BlYywge1xuICAgICAgICBmaW5pc2goc2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gLyYvLnRlc3Qoc2VsKSA/IHNlbC5yZXBsYWNlKC8mXFx3Ki8sIG0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtID09IFwiJlwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFpbjtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlcyB8fCAhc2NvcGVzW21dKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5zdXBwb3J0ZWQgc2VsZWN0b3I6ICR7bX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVzW21dO1xuICAgICAgICAgICAgfSkgOiBtYWluICsgXCIgXCIgKyBzZWw7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGJhc2VUaGVtZSQxID0gYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCB7XG4gICAgXCImXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmUgIWltcG9ydGFudFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBcIiYuY20tZm9jdXNlZFwiOiB7XG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgc2ltcGxlIGRlZmF1bHQgb3V0bGluZSB0byBtYWtlIHN1cmUgYSBmb2N1c2VkXG4gICAgICAgICAgICAvLyBlZGl0b3IgaXMgdmlzdWFsbHkgZGlzdGluY3QuIENhbid0IGxlYXZlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd2lsbCBhcHBseSB0byB0aGUgY29udGVudCBlbGVtZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBhbmQgZG9lc24ndCBpbmNsdWRlIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVycy4gV2UgYWxzbyBjYW4ndCB1c2UgYW4gJ2F1dG8nIG91dGxpbmUsIHNpbmNlIHRob3NlXG4gICAgICAgICAgICAvLyBhcmUsIGZvciBzb21lIHJlYXNvbiwgZHJhd24gYmVoaW5kIHRoZSBlbGVtZW50IGNvbnRlbnQsIHdoaWNoXG4gICAgICAgICAgICAvLyB3aWxsIGNhdXNlIHRoaW5ncyBsaWtlIHRoZSBhY3RpdmUgbGluZSBiYWNrZ3JvdW5kIHRvIGNvdmVyXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGluZSAoIzI5NykuXG4gICAgICAgICAgICBvdXRsaW5lOiBcIjFweCBkb3R0ZWQgIzIxMjEyMVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCJcbiAgICB9LFxuICAgIFwiLmNtLXNjcm9sbGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgbGluZUhlaWdodDogMS40LFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvd1g6IFwiYXV0b1wiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICB6SW5kZXg6IDAsXG4gICAgICAgIG92ZXJmbG93QW5jaG9yOiBcIm5vbmVcIixcbiAgICB9LFxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGZsZXhHcm93OiAyLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCIsXG4gICAgICAgIHdvcmRXcmFwOiBcIm5vcm1hbFwiLCAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQ1NlxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjRweCAwXCIsXG4gICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICBcIiZbY29udGVudGVkaXRhYmxlPXRydWVdXCI6IHtcbiAgICAgICAgICAgIFdlYmtpdFVzZXJNb2RpZnk6IFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW5lV3JhcHBpbmdcIjoge1xuICAgICAgICB3aGl0ZVNwYWNlX2ZhbGxiYWNrOiBcInByZS13cmFwXCIsIC8vIEZvciBJRVxuICAgICAgICB3aGl0ZVNwYWNlOiBcImJyZWFrLXNwYWNlc1wiLFxuICAgICAgICB3b3JkQnJlYWs6IFwiYnJlYWstd29yZFwiLCAvLyBGb3IgU2FmYXJpLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgb3ZlcmZsb3ctd3JhcDogYW55d2hlcmVcbiAgICAgICAgb3ZlcmZsb3dXcmFwOiBcImFueXdoZXJlXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDFcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJibGFja1wiIH0sXG4gICAgXCImZGFyayAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwid2hpdGVcIiB9LFxuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAycHggMCA2cHhcIlxuICAgIH0sXG4gICAgXCIuY20tbGF5ZXJcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGNvbnRhaW46IFwic2l6ZSBzdHlsZVwiLFxuICAgICAgICBcIiYgPiAqXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkOWQ5ZDlcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIyMlwiXG4gICAgfSxcbiAgICBcIiZsaWdodC5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLXNlbGVjdGlvbkxheWVyIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDdkNGYwXCJcbiAgICB9LFxuICAgIFwiJmRhcmsuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1zZWxlY3Rpb25MYXllciAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIzM1wiXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiYuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIGFuaW1hdGlvbjogXCJzdGVwcygxKSBjbS1ibGluayAxLjJzIGluZmluaXRlXCJcbiAgICB9LFxuICAgIC8vIFR3byBhbmltYXRpb25zIGRlZmluZWQgc28gdGhhdCB3ZSBjYW4gc3dpdGNoIGJldHdlZW4gdGhlbSB0b1xuICAgIC8vIHJlc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRob3V0IGZvcmNpbmcgYW5vdGhlciBzdHlsZVxuICAgIC8vIHJlY29tcHV0YXRpb24uXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxuICAgIFwiQGtleWZyYW1lcyBjbS1ibGluazJcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIGJvcmRlckxlZnQ6IFwiMS4ycHggc29saWQgYmxhY2tcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMC42cHhcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdENvbG9yOiBcIiNkZGRcIlxuICAgIH0sXG4gICAgXCIuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLWN1cnNvckxheWVyIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICB9LFxuICAgIFwiLmNtLWlzb1wiOiB7XG4gICAgICAgIHVuaWNvZGVCaWRpOiBcImlzb2xhdGVcIlxuICAgIH0sXG4gICAgXCIuY20tYW5ub3VuY2VkXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgICAgICAgdG9wOiBcIi0xMDAwMHB4XCJcbiAgICB9LFxuICAgIFwiQG1lZGlhIHByaW50XCI6IHtcbiAgICAgICAgXCIuY20tYW5ub3VuY2VkXCI6IHsgZGlzcGxheTogXCJub25lXCIgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2NjZWVmZjQ0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWVlZmYzM1wiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwicmVkXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zcGVjaWFsQ2hhclwiOiB7IGNvbG9yOiBcIiNmNzhcIiB9LFxuICAgIFwiLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgaW5zZXRJbmxpbmVTdGFydDogMCxcbiAgICAgICAgekluZGV4OiAyMDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcbiAgICAgICAgY29sb3I6IFwiIzZjNmM2Y1wiLFxuICAgICAgICBib3JkZXJSaWdodDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwiI2NjY1wiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLCAvLyBOZWNlc3NhcnkgLS0gcHJldmVudHMgbWFyZ2luIGNvbGxhcHNpbmdcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgZmxleFNocmluazogMCxcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgbWluSGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG4gICAgfSxcbiAgICBcIi5jbS1saW5lTnVtYmVycyAuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMCAzcHggMCA1cHhcIixcbiAgICAgICAgbWluV2lkdGg6IFwiMjBweFwiLFxuICAgICAgICB0ZXh0QWxpZ246IFwicmlnaHRcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2UyZjJmZlwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMyMjIyMjdcIlxuICAgIH0sXG4gICAgXCIuY20tcGFuZWxzXCI6IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB6SW5kZXg6IDMwMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCIsXG4gICAgICAgIGNvbG9yOiBcImJsYWNrXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtdG9wXCI6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtYm90dG9tXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiLmNtLXRhYlwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcImJvdHRvbVwiXG4gICAgfSxcbiAgICBcIi5jbS13aWRnZXRCdWZmZXJcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRleHQtdG9wXCIsXG4gICAgICAgIGhlaWdodDogXCIxZW1cIixcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lXCJcbiAgICB9LFxuICAgIFwiLmNtLXBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRvcFwiLFxuICAgIH0sXG4gICAgXCIuY20taGlnaGxpZ2h0U3BhY2VcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwicmFkaWFsLWdyYWRpZW50KGNpcmNsZSBhdCA1MCUgNTUlLCAjYWFhIDIwJSwgdHJhbnNwYXJlbnQgNSUpXCIsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJjZW50ZXJcIixcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFRhYlwiOiB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgnZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjBcIj48cGF0aCBzdHJva2U9XCIlMjM4ODhcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIm5vbmVcIiBkPVwiTTEgMTBIMTk2TDE5MCA1TTE5MCAxNUwxOTYgMTBNMTk3IDRMMTk3IDE2XCIvPjwvc3ZnPicpYCxcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IFwiYXV0byAxMDAlXCIsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJyaWdodCA5MCVcIixcbiAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIlxuICAgIH0sXG4gICAgXCIuY20tdHJhaWxpbmdTcGFjZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmYzMzIyNTVcIlxuICAgIH0sXG4gICAgXCIuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIDFlbVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiMXB4XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNlZmYxZjUsICNkOWQ5ZGYpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2I0YjRiNCwgI2QwZDNkNilcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMzOTM5MzksICMxMTEpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoIzExMSwgIzMzMylcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yZW0gLjVlbVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzU1NVwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfVxufSwgbGlnaHREYXJrSURzKTtcblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG9cbi8vIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZCB0aGVyZVxuY29uc3QgdXNlQ2hhckRhdGEgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZWRpdENvbnRleHQgPSBudWxsO1xuICAgICAgICAvLyBUaGUga25vd24gc2VsZWN0aW9uLiBLZXB0IGluIG91ciBvd24gb2JqZWN0LCBhcyBvcHBvc2VkIHRvIGp1c3RcbiAgICAgICAgLy8gZGlyZWN0bHkgYWNjZXNzaW5nIHRoZSBzZWxlY3Rpb24gYmVjYXVzZTpcbiAgICAgICAgLy8gIC0gU2FmYXJpIGRvZXNuJ3QgcmVwb3J0IHRoZSByaWdodCBzZWxlY3Rpb24gaW4gc2hhZG93IERPTVxuICAgICAgICAvLyAgLSBSZWFkaW5nIGZyb20gdGhlIHNlbGVjdGlvbiBmb3JjZXMgYSBET00gbGF5b3V0XG4gICAgICAgIC8vICAtIFRoaXMgd2F5LCB3ZSBjYW4gaWdub3JlIHNlbGVjdGlvbmNoYW5nZSBldmVudHMgaWYgd2UgaGF2ZVxuICAgICAgICAvLyAgICBhbHJlYWR5IHNlZW4gdGhlICduZXcnIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlID0gbmV3IERPTVNlbGVjdGlvblN0YXRlO1xuICAgICAgICAvLyBTZXQgd2hlbiBhIHNlbGVjdGlvbiBjaGFuZ2UgaXMgZGV0ZWN0ZWQsIGNsZWFyZWQgb24gZmx1c2hcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XG4gICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5nYXBzID0gW107XG4gICAgICAgIHRoaXMucHJpbnRRdWVyeSA9IG51bGw7XG4gICAgICAgIC8vIFRpbWVvdXQgZm9yIHNjaGVkdWxpbmcgY2hlY2sgb2YgdGhlIHBhcmVudHMgdGhhdCBuZWVkIHNjcm9sbCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gLTE7XG4gICAgICAgIHRoaXMuZG9tID0gdmlldy5jb250ZW50RE9NO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IG11dCBvZiBtdXRhdGlvbnMpXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XG4gICAgICAgICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiB0eXBpbmcgb3ZlciBhIHNlbGVjdGlvbiBvclxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlciB0ZXh0IG5vZGUpIGNhbGwgdGhlXG4gICAgICAgICAgICAvLyBvYnNlcnZlciBjYWxsYmFjayBiZWZvcmUgYWN0dWFsbHkgdXBkYXRpbmcgdGhlIERPTS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBVbnJlbGF0ZWRseSwgaU9TIFNhZmFyaSB3aWxsLCB3aGVuIGVuZGluZyBhIGNvbXBvc2l0aW9uLFxuICAgICAgICAgICAgLy8gc29tZXRpbWVzIGZpcnN0IGNsZWFyIGl0LCBkZWxpdmVyIHRoZSBtdXRhdGlvbnMsIGFuZCB0aGVuXG4gICAgICAgICAgICAvLyByZWluc2VydCB0aGUgZmluaXNoZWQgdGV4dC4gQ29kZU1pcnJvcidzIGhhbmRsaW5nIG9mIHRoZVxuICAgICAgICAgICAgLy8gZGVsZXRpb24gd2lsbCBwcmV2ZW50IHRoZSByZWluc2VydGlvbiBmcm9tIGhhcHBlbmluZyxcbiAgICAgICAgICAgIC8vIGJyZWFraW5nIGNvbXBvc2l0aW9uLlxuICAgICAgICAgICAgaWYgKChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMSB8fCBicm93c2VyLmlvcyAmJiB2aWV3LmNvbXBvc2luZykgJiZcbiAgICAgICAgICAgICAgICBtdXRhdGlvbnMuc29tZShtID0+IG0udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG0ucmVtb3ZlZE5vZGVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbS5vbGRWYWx1ZS5sZW5ndGggPiBtLnRhcmdldC5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh3aW5kb3cuRWRpdENvbnRleHQgJiYgdmlldy5jb25zdHJ1Y3Rvci5FRElUX0NPTlRFWFQgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAvLyBDaHJvbWUgPDEyNiBkb2Vzbid0IHN1cHBvcnQgaW52ZXJ0ZWQgc2VsZWN0aW9ucyBpbiBlZGl0IGNvbnRleHQgKCMxMzkyKVxuICAgICAgICAgICAgIShicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmNocm9tZV92ZXJzaW9uIDwgMTI2KSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dCA9IG5ldyBFZGl0Q29udGV4dE1hbmFnZXIodmlldyk7XG4gICAgICAgICAgICBpZiAodmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkpXG4gICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmVkaXRDb250ZXh0ID0gdGhpcy5lZGl0Q29udGV4dC5lZGl0Q29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goeyB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBldmVudC5wcmV2VmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZXNpemUgPSB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25QcmludCA9IHRoaXMub25QcmludC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsID0gdGhpcy5vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEpXG4gICAgICAgICAgICB0aGlzLnByaW50UXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShcInByaW50XCIpO1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMudmlldy5kb2NWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdFVwZGF0ZSkgPCBEYXRlLm5vdygpIC0gNzUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwub2JzZXJ2ZSh2aWV3LnNjcm9sbERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4gPSB2aWV3Lndpbik7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudENoZWNrIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IHNldFRpbWVvdXQodGhpcy5saXN0ZW5Gb3JTY3JvbGwuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiAoZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMCkgIT0gdGhpcy5pbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSAhdGhpcy5pbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZyAhPSB0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IFswLCAuMDAxXSB9KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLm9ic2VydmUodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbkZvclNjcm9sbCgpO1xuICAgICAgICB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgIH1cbiAgICBvblNjcm9sbENoYW5nZWQoZSkge1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5ydW5IYW5kbGVycyhcInNjcm9sbFwiLCBlKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcbiAgICB9XG4gICAgb25TY3JvbGwoZSkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICB0aGlzLmZsdXNoKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdENvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5lZGl0Q29udGV4dC5tZWFzdXJlUmVxKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZSk7XG4gICAgfVxuICAgIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgIH1cbiAgICBvblByaW50KGV2ZW50KSB7XG4gICAgICAgIGlmICgoZXZlbnQudHlwZSA9PSBcImNoYW5nZVwiIHx8ICFldmVudC50eXBlKSAmJiAhZXZlbnQubWF0Y2hlcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmlldy5tZWFzdXJlKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIHVwZGF0ZUdhcHMoZ2Fwcykge1xuICAgICAgICBpZiAodGhpcy5nYXBJbnRlcnNlY3Rpb24gJiYgKGdhcHMubGVuZ3RoICE9IHRoaXMuZ2Fwcy5sZW5ndGggfHwgdGhpcy5nYXBzLnNvbWUoKGcsIGkpID0+IGcgIT0gZ2Fwc1tpXSkpKSB7XG4gICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5vYnNlcnZlKGdhcCk7XG4gICAgICAgICAgICB0aGlzLmdhcHMgPSBnYXBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGxldCB3YXNDaGFuZ2VkID0gdGhpcy5zZWxlY3Rpb25DaGFuZ2VkO1xuICAgICAgICBpZiAoIXRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCkgfHwgdGhpcy5kZWxheWVkQW5kcm9pZEtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgc2VsID0gdGhpcy5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5kb20gOiAhaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCBzZWwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29udGV4dCA9IHNlbC5hbmNob3JOb2RlICYmIHZpZXcuZG9jVmlldy5uZWFyZXN0KHNlbC5hbmNob3JOb2RlKTtcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5pZ25vcmVFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIGlmICghd2FzQ2hhbmdlZClcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIGhhcyBhIHNpbWlsYXIgaXNzdWUgd2hlbiBiYWNrc3BhY2luZyBvdXQgYVxuICAgICAgICAvLyBzZWxlY3Rpb24gKCM2NDUpLlxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSkgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiZcbiAgICAgICAgICAgIC8vIChTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUUpXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XG4gICAgfVxuICAgIHJlYWRTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgLy8gVGhlIFNlbGVjdGlvbiBvYmplY3QgaXMgYnJva2VuIGluIHNoYWRvdyByb290cyBpbiBTYWZhcmkuIFNlZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQxNFxuICAgICAgICBsZXQgc2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcmFuZ2UgPSBicm93c2VyLnNhZmFyaSAmJiB2aWV3LnJvb3Qubm9kZVR5cGUgPT0gMTEgJiZcbiAgICAgICAgICAgIHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tICYmXG4gICAgICAgICAgICBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodGhpcy52aWV3LCBzZWxlY3Rpb24pIHx8IHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCFyYW5nZSB8fCB0aGlzLnNlbGVjdGlvblJhbmdlLmVxKHJhbmdlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGxvY2FsID0gaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCByYW5nZSk7XG4gICAgICAgIC8vIERldGVjdCB0aGUgc2l0dWF0aW9uIHdoZXJlIHRoZSBicm93c2VyIGhhcywgb24gZm9jdXMsIG1vdmVkIHRoZVxuICAgICAgICAvLyBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50IGVsZW1lbnQuIFJlc2V0IGl0IHRvIHRoZVxuICAgICAgICAvLyBwb3NpdGlvbiBmcm9tIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAgICAgIGlmIChsb2NhbCAmJiAhdGhpcy5zZWxlY3Rpb25DaGFuZ2VkICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lIDwgRGF0ZS5ub3coKSAtIDMwMCAmJlxuICAgICAgICAgICAgYXRFbGVtZW50U3RhcnQodGhpcy5kb20sIHJhbmdlKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIGlmIChsb2NhbClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb25SYW5nZShhbmNob3IsIGhlYWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY2xlYXJTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQobnVsbCwgMCwgbnVsbCwgMCk7XG4gICAgfVxuICAgIGxpc3RlbkZvclNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICBsZXQgaSA9IDAsIGNoYW5nZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBkb20gPSB0aGlzLmRvbTsgZG9tOykge1xuICAgICAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmIGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmIHRoaXMuc2Nyb2xsVGFyZ2V0c1tpXSA9PSBkb20pXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmFzc2lnbmVkU2xvdCB8fCBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmICFjaGFuZ2VkKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzID0gY2hhbmdlZClcbiAgICAgICAgICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmUoZikge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy5kb20sIG9ic2VydmVPcHRpb25zKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgfVxuICAgIC8vIFRocm93IGF3YXkgYW55IHBlbmRpbmcgY2hhbmdlc1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIENocm9tZSBBbmRyb2lkLCBlc3BlY2lhbGx5IGluIGNvbWJpbmF0aW9uIHdpdGggR0JvYXJkLCBub3Qgb25seVxuICAgIC8vIGRvZXNuJ3QgcmVsaWFibHkgZmlyZSByZWd1bGFyIGtleSBldmVudHMsIGJ1dCBhbHNvIG9mdGVuXG4gICAgLy8gc3Vycm91bmRzIHRoZSBlZmZlY3Qgb2YgZW50ZXIgb3IgYmFja3NwYWNlIHdpdGggYSBidW5jaCBvZlxuICAgIC8vIGNvbXBvc2l0aW9uIGV2ZW50cyB0aGF0LCB3aGVuIGludGVycnVwdGVkLCBjYXVzZSB0ZXh0IGR1cGxpY2F0aW9uXG4gICAgLy8gb3Igb3RoZXIga2luZHMgb2YgY29ycnVwdGlvbi4gVGhpcyBoYWNrIG1ha2VzIHRoZSBlZGl0b3IgYmFjayBvZmZcbiAgICAvLyBmcm9tIGhhbmRsaW5nIERPTSBjaGFuZ2VzIGZvciBhIG1vbWVudCB3aGVuIHN1Y2ggYSBrZXkgaXNcbiAgICAvLyBkZXRlY3RlZCAodmlhIGJlZm9yZWlucHV0IG9yIGtleWRvd24pLCBhbmQgdGhlbiB0cmllcyB0byBmbHVzaFxuICAgIC8vIHRoZW0gb3IsIGlmIHRoYXQgaGFzIG5vIGVmZmVjdCwgZGlzcGF0Y2hlcyB0aGUgZ2l2ZW4ga2V5LlxuICAgIGRlbGF5QW5kcm9pZEtleShrZXksIGtleUNvZGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkpIHtcbiAgICAgICAgICAgIGxldCBmbHVzaCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9IGtleS5rZXlDb2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmbHVzaGVkID0gdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZsdXNoZWQgJiYga2V5LmZvcmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodGhpcy5kb20sIGtleS5rZXksIGtleS5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZShmbHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgYmFja3NwYWNlIGJlZm9yZWlucHV0IGlzIHNvbWV0aW1lcyBzaWduYWxsZWQgc3B1cmlvdXNseSxcbiAgICAgICAgLy8gRW50ZXIgYWx3YXlzIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICAgIGlmICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSB8fCBrZXkgPT0gXCJFbnRlclwiKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IHtcbiAgICAgICAgICAgICAgICBrZXksIGtleUNvZGUsXG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gdGhlIGtleSBoYW5kbGVyIHdoZW4gbm8gY2hhbmdlcyBhcmUgZGV0ZWN0ZWQgaWZcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGNvbWluZyByaWdodCBhZnRlciBhbm90aGVyIGNoYW5nZSwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHByb2JhYmx5IHBhcnQgb2YgYSB3ZWlyZCBjaGFpbiBvZiB1cGRhdGVzLCBhbmQgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gYmUgaWdub3JlZCBpZiBpdCByZXR1cm5zIHRoZSBET00gdG8gaXRzIHByZXZpb3VzIHN0YXRlLlxuICAgICAgICAgICAgICAgIGZvcmNlOiB0aGlzLmxhc3RDaGFuZ2UgPCBEYXRlLm5vdygpIC0gNTAgfHwgISEoKF9hID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcmNlKVxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpIHtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpO1xuICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgICB9XG4gICAgZmx1c2hTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHRoaXMuZGVsYXllZEZsdXNoID0gLTE7IHRoaXMuZmx1c2goKTsgfSk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICBwZW5kaW5nUmVjb3JkcygpIHtcbiAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgICB9XG4gICAgcHJvY2Vzc1JlY29yZHMoKSB7XG4gICAgICAgIGxldCByZWNvcmRzID0gdGhpcy5wZW5kaW5nUmVjb3JkcygpO1xuICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlYWRNdXRhdGlvbihyZWNvcmQpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICh7IGZyb20sIHRvIH0gPSByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gTWF0aC5taW4ocmFuZ2UuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heChyYW5nZS50bywgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0eXBlT3ZlciB9O1xuICAgIH1cbiAgICByZWFkQ2hhbmdlKCkge1xuICAgICAgICBsZXQgeyBmcm9tLCB0bywgdHlwZU92ZXIgfSA9IHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJiBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMuc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICBpZiAoZnJvbSA8IDAgJiYgIW5ld1NlbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZnJvbSA+IC0xKVxuICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlID0gbmV3IERPTUNoYW5nZSh0aGlzLnZpZXcsIGZyb20sIHRvLCB0eXBlT3Zlcik7XG4gICAgICAgIHRoaXMudmlldy5kb2NWaWV3LmRvbUNoYW5nZWQgPSB7IG5ld1NlbDogY2hhbmdlLm5ld1NlbCA/IGNoYW5nZS5uZXdTZWwubWFpbiA6IG51bGwgfTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgcGVuZGluZyBjaGFuZ2VzLCBpZiBhbnlcbiAgICBmbHVzaChyZWFkU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgICAgICAvLyBDb21wbGV0ZWx5IGhvbGQgb2ZmIGZsdXNoaW5nIHdoZW4gcGVuZGluZyBrZXlzIGFyZSBzZXTigJR0aGUgY29kZVxuICAgICAgICAvLyBtYW5hZ2luZyB0aG9zZSB3aWxsIG1ha2Ugc3VyZSBwcm9jZXNzUmVjb3JkcyBpcyBjYWxsZWQgYW5kIHRoZVxuICAgICAgICAvLyB2aWV3IGlzIHJlc3luY2hyb25pemVkIGFmdGVyXG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChyZWFkU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IGRvbUNoYW5nZSA9IHRoaXMucmVhZENoYW5nZSgpO1xuICAgICAgICBpZiAoIWRvbUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0U3RhdGUgPSB0aGlzLnZpZXcuc3RhdGU7XG4gICAgICAgIGxldCBoYW5kbGVkID0gYXBwbHlET01DaGFuZ2UodGhpcy52aWV3LCBkb21DaGFuZ2UpO1xuICAgICAgICAvLyBUaGUgdmlldyB3YXNuJ3QgdXBkYXRlZCBidXQgRE9NL3NlbGVjdGlvbiBjaGFuZ2VzIHdlcmUgc2Vlbi4gUmVzZXQgdGhlIHZpZXcuXG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUgPT0gc3RhcnRTdGF0ZSAmJlxuICAgICAgICAgICAgKGRvbUNoYW5nZS5kb21DaGFuZ2VkIHx8IGRvbUNoYW5nZS5uZXdTZWwgJiYgIWRvbUNoYW5nZS5uZXdTZWwubWFpbi5lcSh0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4pKSlcbiAgICAgICAgICAgIHRoaXMudmlldy51cGRhdGUoW10pO1xuICAgICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICB9XG4gICAgcmVhZE11dGF0aW9uKHJlYykge1xuICAgICAgICBsZXQgY1ZpZXcgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0KHJlYy50YXJnZXQpO1xuICAgICAgICBpZiAoIWNWaWV3IHx8IGNWaWV3Lmlnbm9yZU11dGF0aW9uKHJlYykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY1ZpZXcubWFya0RpcnR5KHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKTtcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKVxuICAgICAgICAgICAgY1ZpZXcuZmxhZ3MgfD0gNCAvKiBWaWV3RmxhZy5BdHRyc0RpcnR5ICovO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgbGV0IGNoaWxkQmVmb3JlID0gZmluZENoaWxkKGNWaWV3LCByZWMucHJldmlvdXNTaWJsaW5nIHx8IHJlYy50YXJnZXQucHJldmlvdXNTaWJsaW5nLCAtMSk7XG4gICAgICAgICAgICBsZXQgY2hpbGRBZnRlciA9IGZpbmRDaGlsZChjVmlldywgcmVjLm5leHRTaWJsaW5nIHx8IHJlYy50YXJnZXQubmV4dFNpYmxpbmcsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY2hpbGRCZWZvcmUgPyBjVmlldy5wb3NBZnRlcihjaGlsZEJlZm9yZSkgOiBjVmlldy5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBjaGlsZEFmdGVyID8gY1ZpZXcucG9zQmVmb3JlKGNoaWxkQWZ0ZXIpIDogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlYy50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBjVmlldy5wb3NBdFN0YXJ0LCB0bzogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiByZWMudGFyZ2V0Lm5vZGVWYWx1ZSA9PSByZWMub2xkVmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFdpbmRvdyh3aW4pIHtcbiAgICAgICAgaWYgKHdpbiAhPSB0aGlzLndpbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICAgICAgdGhpcy53aW4gPSB3aW47XG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkV2luZG93TGlzdGVuZXJzKHdpbikge1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgaWYgKHRoaXMucHJpbnRRdWVyeSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJpbnRRdWVyeS5hZGRFdmVudExpc3RlbmVyKVxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRRdWVyeS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMub25QcmludCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludFF1ZXJ5LmFkZExpc3RlbmVyKHRoaXMub25QcmludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVwcmludFwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgd2luLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIHJlbW92ZVdpbmRvd0xpc3RlbmVycyh3aW4pIHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICBpZiAodGhpcy5wcmludFF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmludFF1ZXJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludFF1ZXJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50UXVlcnkucmVtb3ZlTGlzdGVuZXIodGhpcy5vblByaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXByaW50XCIsIHRoaXMub25QcmludCk7XG4gICAgICAgIHdpbi5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGVkaXRhYmxlKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQoZWRpdGFibGUpKVxuICAgICAgICAgICAgICAgIHVwZGF0ZS52aWV3LmNvbnRlbnRET00uZWRpdENvbnRleHQgPSB1cGRhdGUuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gdGhpcy5lZGl0Q29udGV4dC5lZGl0Q29udGV4dCA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAoX2EgPSB0aGlzLmludGVyc2VjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9iID0gdGhpcy5nYXBJbnRlcnNlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYyA9IHRoaXMucmVzaXplU2Nyb2xsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzY29ubmVjdCgpO1xuICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGFyZW50Q2hlY2spO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kZWxheWVkRmx1c2gpO1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSk7XG4gICAgICAgIGlmICh0aGlzLmVkaXRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuY29udGVudERPTS5lZGl0Q29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDaGlsZChjVmlldywgZG9tLCBkaXIpIHtcbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICAgIGxldCBjdXJWaWV3ID0gQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgIGlmIChjdXJWaWV3ICYmIGN1clZpZXcucGFyZW50ID09IGNWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIGN1clZpZXc7XG4gICAgICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgZG9tID0gcGFyZW50ICE9IGNWaWV3LmRvbSA/IHBhcmVudCA6IGRpciA+IDAgPyBkb20ubmV4dFNpYmxpbmcgOiBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2VsZWN0aW9uUmFuZ2VGcm9tUmFuZ2UodmlldywgcmFuZ2UpIHtcbiAgICBsZXQgYW5jaG9yTm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBhbmNob3JPZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldDtcbiAgICBsZXQgZm9jdXNOb2RlID0gcmFuZ2UuZW5kQ29udGFpbmVyLCBmb2N1c09mZnNldCA9IHJhbmdlLmVuZE9mZnNldDtcbiAgICBsZXQgY3VyQW5jaG9yID0gdmlldy5kb2NWaWV3LmRvbUF0UG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yKTtcbiAgICAvLyBTaW5jZSBzdWNoIGEgcmFuZ2UgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuY2hvciBhbmQgaGVhZCxcbiAgICAvLyB1c2UgYSBoZXVyaXN0aWMgdGhhdCBmbGlwcyBpdCBhcm91bmQgaWYgaXRzIGVuZCBtYXRjaGVzIHRoZVxuICAgIC8vIGN1cnJlbnQgYW5jaG9yLlxuICAgIGlmIChpc0VxdWl2YWxlbnRQb3NpdGlvbihjdXJBbmNob3Iubm9kZSwgY3VyQW5jaG9yLm9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpXG4gICAgICAgIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdID0gW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXQsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldF07XG4gICAgcmV0dXJuIHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH07XG59XG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1ZyAoIzQxNClcbmZ1bmN0aW9uIHNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayh2aWV3LCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uLmdldENvbXBvc2VkUmFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcyh2aWV3LnJvb3QpWzBdO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRTZWxlY3Rpb25SYW5nZUZyb21SYW5nZSh2aWV3LCByYW5nZSk7XG4gICAgfVxuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgLy8gQmVjYXVzZSBTYWZhcmkgKGF0IGxlYXN0IGluIDIwMTgtMjAyMSkgZG9lc24ndCBwcm92aWRlIHJlZ3VsYXJcbiAgICAvLyBhY2Nlc3MgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgYSBzaGFkb3dyb290LCB3ZSBoYXZlIHRvIHBlcmZvcm0gYVxuICAgIC8vIHJpZGljdWxvdXMgaGFjayB0byBnZXQgYXQgaXTigJR1c2luZyBgZXhlY0NvbW1hbmRgIHRvIHRyaWdnZXIgYVxuICAgIC8vIGBiZWZvcmVJbnB1dGAgZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVhZCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gdGhlXG4gICAgLy8gZXZlbnQuXG4gICAgZnVuY3Rpb24gcmVhZChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZm91bmQgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKVswXTtcbiAgICB9XG4gICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICB2aWV3LmRvbS5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xuICAgIHZpZXcuY29udGVudERPTS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZvdW5kID8gYnVpbGRTZWxlY3Rpb25SYW5nZUZyb21SYW5nZSh2aWV3LCBmb3VuZCkgOiBudWxsO1xufVxuY2xhc3MgRWRpdENvbnRleHRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIC8vIFRoZSBkb2N1bWVudCB3aW5kb3cgZm9yIHdoaWNoIHRoZSB0ZXh0IGluIHRoZSBjb250ZXh0IGlzXG4gICAgICAgIC8vIG1haW50YWluZWQuIEZvciBsYXJnZSBkb2N1bWVudHMsIHRoaXMgbWF5IGJlIHNtYWxsZXIgdGhhbiB0aGVcbiAgICAgICAgLy8gZWRpdG9yIGRvY3VtZW50LiBUaGlzIHdpbmRvdyBhbHdheXMgaW5jbHVkZXMgdGhlIHNlbGVjdGlvbiBoZWFkLlxuICAgICAgICB0aGlzLmZyb20gPSAwO1xuICAgICAgICB0aGlzLnRvID0gMDtcbiAgICAgICAgLy8gV2hlbiBhcHBseWluZyBhIHRyYW5zYWN0aW9uLCB0aGlzIGlzIHVzZWQgdG8gY29tcGFyZSB0aGUgY2hhbmdlXG4gICAgICAgIC8vIG1hZGUgdG8gdGhlIGNvbnRleHQgY29udGVudCB0byB0aGUgY2hhbmdlIGluIHRoZSB0cmFuc2FjdGlvbiBpblxuICAgICAgICAvLyBvcmRlciB0byBtYWtlIHRoZSBtaW5pbWFsIGNoYW5nZXMgdG8gdGhlIGNvbnRleHQgKHNpbmNlIHRvdWNoaW5nXG4gICAgICAgIC8vIHRoYXQgc29tZXRpbWVzIGJyZWFrcyBzZXJpZXMgb2YgbXVsdGlwbGUgZWRpdHMgbWFkZSBmb3IgYSBzaW5nbGVcbiAgICAgICAgLy8gdXNlciBhY3Rpb24gb24gc29tZSBBbmRyb2lkIGtleWJvYXJkcylcbiAgICAgICAgdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgdGhlIGZhY3QgdGhhdCBFZGl0Q29udGV4dCBkb2VzIG5vdCByZXNwb25kXG4gICAgICAgIC8vIHdlbGwgdG8gaGF2aW5nIGl0cyBjb250ZW50IHVwZGF0ZWQgZHVyaW5nIGEgY29tcG9zaXRpb24gKHNlZSAjMTQ3MilcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2V0UmFuZ2Uodmlldy5zdGF0ZSk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5lZGl0Q29udGV4dCA9IG5ldyB3aW5kb3cuRWRpdENvbnRleHQoe1xuICAgICAgICAgICAgdGV4dDogdmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcodGhpcy5mcm9tLCB0aGlzLnRvKSxcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiB0aGlzLnRvQ29udGV4dFBvcyhNYXRoLm1heCh0aGlzLmZyb20sIE1hdGgubWluKHRoaXMudG8sIHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yKSkpLFxuICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiB0aGlzLnRvQ29udGV4dFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnRleHR1cGRhdGUgPSBlID0+IHtcbiAgICAgICAgICAgIGxldCB7IGFuY2hvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy50b0VkaXRvclBvcyhlLnVwZGF0ZVJhbmdlU3RhcnQpLCB0byA9IHRoaXMudG9FZGl0b3JQb3MoZS51cGRhdGVSYW5nZUVuZCk7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwICYmICF0aGlzLmNvbXBvc2luZylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IHsgY29udGV4dEJhc2U6IGUudXBkYXRlUmFuZ2VTdGFydCwgZWRpdG9yQmFzZTogZnJvbSwgZHJpZnRlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2UgPSB7IGZyb20sIHRvLCBpbnNlcnQ6IHN0YXRlLlRleHQub2YoZS50ZXh0LnNwbGl0KFwiXFxuXCIpKSB9O1xuICAgICAgICAgICAgLy8gSWYgdGhlIHdpbmRvdyBkb2Vzbid0IGluY2x1ZGUgdGhlIGFuY2hvciwgYXNzdW1lIGNoYW5nZXNcbiAgICAgICAgICAgIC8vIGFkamFjZW50IHRvIGEgc2lkZSBnbyB1cCB0byB0aGUgYW5jaG9yLlxuICAgICAgICAgICAgaWYgKGNoYW5nZS5mcm9tID09IHRoaXMuZnJvbSAmJiBhbmNob3IgPCB0aGlzLmZyb20pXG4gICAgICAgICAgICAgICAgY2hhbmdlLmZyb20gPSBhbmNob3I7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudG8gPT0gdGhpcy50byAmJiBhbmNob3IgPiB0aGlzLnRvKVxuICAgICAgICAgICAgICAgIGNoYW5nZS50byA9IGFuY2hvcjtcbiAgICAgICAgICAgIC8vIEVkaXQgY29udGV4dHMgc29tZXRpbWVzIGZpcmUgZW1wdHkgY2hhbmdlc1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiAhY2hhbmdlLmluc2VydC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZSA9IGNoYW5nZTtcbiAgICAgICAgICAgIGlmICghdmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgICAgICBhcHBseURPTUNoYW5nZUlubmVyKHZpZXcsIGNoYW5nZSwgc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnNpbmdsZSh0aGlzLnRvRWRpdG9yUG9zKGUuc2VsZWN0aW9uU3RhcnQpLCB0aGlzLnRvRWRpdG9yUG9zKGUuc2VsZWN0aW9uRW5kKSkpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRyYW5zYWN0aW9uIGRpZG4ndCBmbHVzaCBvdXIgY2hhbmdlLCByZXZlcnQgaXQgc29cbiAgICAgICAgICAgIC8vIHRoYXQgdGhlIGNvbnRleHQgaXMgaW4gc3luYyB3aXRoIHRoZSBlZGl0b3Igc3RhdGUgYWdhaW4uXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJ0UGVuZGluZyh2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbih2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5jaGFyYWN0ZXJib3VuZHN1cGRhdGUgPSBlID0+IHtcbiAgICAgICAgICAgIGxldCByZWN0cyA9IFtdLCBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnRvRWRpdG9yUG9zKGUucmFuZ2VTdGFydCksIGVuZCA9IHRoaXMudG9FZGl0b3JQb3MoZS5yYW5nZUVuZCk7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdmlldy5jb29yZHNGb3JDaGFyKGkpO1xuICAgICAgICAgICAgICAgIHByZXYgPSAocmVjdCAmJiBuZXcgRE9NUmVjdChyZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LCByZWN0LmJvdHRvbSAtIHJlY3QudG9wKSlcbiAgICAgICAgICAgICAgICAgICAgfHwgcHJldiB8fCBuZXcgRE9NUmVjdDtcbiAgICAgICAgICAgICAgICByZWN0cy5wdXNoKHByZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC51cGRhdGVDaGFyYWN0ZXJCb3VuZHMoZS5yYW5nZVN0YXJ0LCByZWN0cyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlcnMudGV4dGZvcm1hdHVwZGF0ZSA9IGUgPT4ge1xuICAgICAgICAgICAgbGV0IGRlY28gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGZvcm1hdCBvZiBlLmdldFRleHRGb3JtYXRzKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZVN0eWxlID0gZm9ybWF0LnVuZGVybGluZVN0eWxlLCB0aGlja25lc3MgPSBmb3JtYXQudW5kZXJsaW5lVGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lU3R5bGUgIT0gXCJOb25lXCIgJiYgdGhpY2tuZXNzICE9IFwiTm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IGB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSAke2xpbmVTdHlsZSA9PSBcIkRhc2hlZFwiID8gXCJkYXNoZWQgXCIgOiBsaW5lU3R5bGUgPT0gXCJTcXVpZ2dsZVwiID8gXCJ3YXZ5IFwiIDogXCJcIn0ke3RoaWNrbmVzcyA9PSBcIlRoaW5cIiA/IDEgOiAyfXB4YDtcbiAgICAgICAgICAgICAgICAgICAgZGVjby5wdXNoKERlY29yYXRpb24ubWFyayh7IGF0dHJpYnV0ZXM6IHsgc3R5bGUgfSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKHRoaXMudG9FZGl0b3JQb3MoZm9ybWF0LnJhbmdlU3RhcnQpLCB0aGlzLnRvRWRpdG9yUG9zKGZvcm1hdC5yYW5nZUVuZCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0RWRpdENvbnRleHRGb3JtYXR0aW5nLm9mKERlY29yYXRpb24uc2V0KGRlY28pKSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IDA7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IC0xO1xuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZHJpZnRlZCB9ID0gdGhpcy5jb21wb3Npbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChkcmlmdGVkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBldmVudCBpbiB0aGlzLmhhbmRsZXJzKVxuICAgICAgICAgICAgY29udGV4dC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZXJzW2V2ZW50XSk7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVDb250cm9sQm91bmRzKHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgICAgICAgICAgICAgIGlmIChzZWwgJiYgc2VsLnJhbmdlQ291bnQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlU2VsZWN0aW9uQm91bmRzKHNlbC5nZXRSYW5nZUF0KDApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgICAgIH0gfTtcbiAgICB9XG4gICAgYXBwbHlFZGl0cyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IG9mZiA9IDAsIGFib3J0ID0gZmFsc2UsIHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlO1xuICAgICAgICB1cGRhdGUuY2hhbmdlcy5pdGVyQ2hhbmdlcygoZnJvbUEsIHRvQSwgX2Zyb21CLCBfdG9CLCBpbnNlcnQpID0+IHtcbiAgICAgICAgICAgIGlmIChhYm9ydClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgZExlbiA9IGluc2VydC5sZW5ndGggLSAodG9BIC0gZnJvbUEpO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcgJiYgdG9BID49IHBlbmRpbmcudG8pIHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZy5mcm9tID09IGZyb21BICYmIHBlbmRpbmcudG8gPT0gdG9BICYmIHBlbmRpbmcuaW5zZXJ0LmVxKGluc2VydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZyA9IHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBudWxsOyAvLyBNYXRjaFxuICAgICAgICAgICAgICAgICAgICBvZmYgKz0gZExlbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byArPSBkTGVuO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBNaXNtYXRjaCwgcmV2ZXJ0XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldmVydFBlbmRpbmcodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tQSArPSBvZmY7XG4gICAgICAgICAgICB0b0EgKz0gb2ZmO1xuICAgICAgICAgICAgaWYgKHRvQSA8PSB0aGlzLmZyb20pIHsgLy8gQmVmb3JlIHRoZSB3aW5kb3dcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gKz0gZExlbjtcbiAgICAgICAgICAgICAgICB0aGlzLnRvICs9IGRMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tQSA8IHRoaXMudG8pIHsgLy8gT3ZlcmxhcHMgd2l0aCB3aW5kb3dcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUEgPCB0aGlzLmZyb20gfHwgdG9BID4gdGhpcy50byB8fCAodGhpcy50byAtIHRoaXMuZnJvbSkgKyBpbnNlcnQubGVuZ3RoID4gMzAwMDAgLyogQ3hWcC5NYXhTaXplICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZVRleHQodGhpcy50b0NvbnRleHRQb3MoZnJvbUEpLCB0aGlzLnRvQ29udGV4dFBvcyh0b0EpLCBpbnNlcnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy50byArPSBkTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmICs9IGRMZW47XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGVuZGluZyAmJiAhYWJvcnQpXG4gICAgICAgICAgICB0aGlzLnJldmVydFBlbmRpbmcodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgcmV0dXJuICFhYm9ydDtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcmV2ZXJ0ZWQgPSB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgJiYgKHRoaXMuY29tcG9zaW5nLmRyaWZ0ZWQgfHwgdXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+ICF0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikgJiYgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKSkpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZy5kcmlmdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nLmVkaXRvckJhc2UgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5jb21wb3NpbmcuZWRpdG9yQmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuYXBwbHlFZGl0cyh1cGRhdGUpIHx8ICF0aGlzLnJhbmdlSXNWYWxpZCh1cGRhdGUuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVzZXQodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHJldmVydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbih1cGRhdGUuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQpXG4gICAgICAgICAgICB1cGRhdGUudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgIH1cbiAgICByZXNldFJhbmdlKHN0YXRlKSB7XG4gICAgICAgIGxldCB7IGhlYWQgfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICB0aGlzLmZyb20gPSBNYXRoLm1heCgwLCBoZWFkIC0gMTAwMDAgLyogQ3hWcC5NYXJnaW4gKi8pO1xuICAgICAgICB0aGlzLnRvID0gTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgaGVhZCArIDEwMDAwIC8qIEN4VnAuTWFyZ2luICovKTtcbiAgICB9XG4gICAgcmVzZXQoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5yZXNldFJhbmdlKHN0YXRlKTtcbiAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVUZXh0KDAsIHRoaXMuZWRpdENvbnRleHQudGV4dC5sZW5ndGgsIHN0YXRlLmRvYy5zbGljZVN0cmluZyh0aGlzLmZyb20sIHRoaXMudG8pKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc3RhdGUpO1xuICAgIH1cbiAgICByZXZlcnRQZW5kaW5nKHN0YXRlKSB7XG4gICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlVGV4dCh0aGlzLnRvQ29udGV4dFBvcyhwZW5kaW5nLmZyb20pLCB0aGlzLnRvQ29udGV4dFBvcyhwZW5kaW5nLmZyb20gKyBwZW5kaW5nLmluc2VydC5sZW5ndGgpLCBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcocGVuZGluZy5mcm9tLCBwZW5kaW5nLnRvKSk7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbihzdGF0ZSkge1xuICAgICAgICBsZXQgeyBtYWluIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMudG9Db250ZXh0UG9zKE1hdGgubWF4KHRoaXMuZnJvbSwgTWF0aC5taW4odGhpcy50bywgbWFpbi5hbmNob3IpKSk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLnRvQ29udGV4dFBvcyhtYWluLmhlYWQpO1xuICAgICAgICBpZiAodGhpcy5lZGl0Q29udGV4dC5zZWxlY3Rpb25TdGFydCAhPSBzdGFydCB8fCB0aGlzLmVkaXRDb250ZXh0LnNlbGVjdGlvbkVuZCAhPSBlbmQpXG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZVNlbGVjdGlvbihzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgcmFuZ2VJc1ZhbGlkKHN0YXRlKSB7XG4gICAgICAgIGxldCB7IGhlYWQgfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICByZXR1cm4gISh0aGlzLmZyb20gPiAwICYmIGhlYWQgLSB0aGlzLmZyb20gPCA1MDAgLyogQ3hWcC5NaW5NYXJnaW4gKi8gfHxcbiAgICAgICAgICAgIHRoaXMudG8gPCBzdGF0ZS5kb2MubGVuZ3RoICYmIHRoaXMudG8gLSBoZWFkIDwgNTAwIC8qIEN4VnAuTWluTWFyZ2luICovIHx8XG4gICAgICAgICAgICB0aGlzLnRvIC0gdGhpcy5mcm9tID4gMTAwMDAgLyogQ3hWcC5NYXJnaW4gKi8gKiAzKTtcbiAgICB9XG4gICAgdG9FZGl0b3JQb3MoY29udGV4dFBvcykge1xuICAgICAgICBsZXQgYyA9IHRoaXMuY29tcG9zaW5nO1xuICAgICAgICByZXR1cm4gYyAmJiBjLmRyaWZ0ZWQgPyBjLmVkaXRvckJhc2UgKyAoY29udGV4dFBvcyAtIGMuY29udGV4dEJhc2UpIDogY29udGV4dFBvcyArIHRoaXMuZnJvbTtcbiAgICB9XG4gICAgdG9Db250ZXh0UG9zKGVkaXRvclBvcykge1xuICAgICAgICBsZXQgYyA9IHRoaXMuY29tcG9zaW5nO1xuICAgICAgICByZXR1cm4gYyAmJiBjLmRyaWZ0ZWQgPyBjLmNvbnRleHRCYXNlICsgKGVkaXRvclBvcyAtIGMuZWRpdG9yQmFzZSkgOiBlZGl0b3JQb3MgLSB0aGlzLmZyb207XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IGV2ZW50IGluIHRoaXMuaGFuZGxlcnMpXG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlcnNbZXZlbnRdKTtcbiAgICB9XG59XG5cbi8vIFRoZSBlZGl0b3IncyB1cGRhdGUgc3RhdGUgbWFjaGluZSBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuLy9cbi8vICAgICBJZGxlIOKGkiBVcGRhdGluZyDih4YgSWRsZSAodW5jaGVja2VkKSDihpIgTWVhc3VyaW5nIOKGkiBJZGxlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRICAgICAg4oaTXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRpbmcgKG1lYXN1cmUpXG4vL1xuLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAnSWRsZScgYW5kICdJZGxlICh1bmNoZWNrZWQpJyBsaWVzIGluXG4vLyB3aGV0aGVyIGEgbGF5b3V0IGNoZWNrIGhhcyBiZWVuIHNjaGVkdWxlZC4gQSByZWd1bGFyIHVwZGF0ZSB0aHJvdWdoXG4vLyB0aGUgYHVwZGF0ZWAgbWV0aG9kIHVwZGF0ZXMgdGhlIERPTSBpbiBhIHdyaXRlLW9ubHkgZmFzaGlvbiwgYW5kXG4vLyByZWxpZXMgb24gYSBjaGVjayAoc2NoZWR1bGVkIHdpdGggYHJlcXVlc3RBbmltYXRpb25GcmFtZWApIHRvIG1ha2Vcbi8vIHN1cmUgZXZlcnl0aGluZyBpcyB3aGVyZSBpdCBzaG91bGQgYmUgYW5kIHRoZSB2aWV3cG9ydCBjb3ZlcnMgdGhlXG4vLyB2aXNpYmxlIGNvZGUuIFRoYXQgY2hlY2sgY29udGludWVzIHRvIG1lYXN1cmUgYW5kIHRoZW4gb3B0aW9uYWxseVxuLy8gdXBkYXRlIHVudGlsIGl0IHJlYWNoZXMgYSBjb2hlcmVudCBzdGF0ZS5cbi8qKlxuQW4gZWRpdG9yIHZpZXcgcmVwcmVzZW50cyB0aGUgZWRpdG9yJ3MgdXNlciBpbnRlcmZhY2UuIEl0IGhvbGRzXG50aGUgZWRpdGFibGUgRE9NIHN1cmZhY2UsIGFuZCBwb3NzaWJseSBvdGhlciBlbGVtZW50cyBzdWNoIGFzIHRoZVxubGluZSBudW1iZXIgZ3V0dGVyLiBJdCBoYW5kbGVzIGV2ZW50cyBhbmQgZGlzcGF0Y2hlcyBzdGF0ZVxudHJhbnNhY3Rpb25zIGZvciBlZGl0aW5nIGFjdGlvbnMuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc3RhdGU7IH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIGRpc3BsYXkgbGFyZ2UgZG9jdW1lbnRzIHdpdGhvdXQgY29uc3VtaW5nIHRvbyBtdWNoXG4gICAgbWVtb3J5IG9yIG92ZXJsb2FkaW5nIHRoZSBicm93c2VyLCBDb2RlTWlycm9yIG9ubHkgZHJhd3MgdGhlXG4gICAgY29kZSB0aGF0IGlzIHZpc2libGUgKHBsdXMgYSBtYXJnaW4gYXJvdW5kIGl0KSB0byB0aGUgRE9NLiBUaGlzXG4gICAgcHJvcGVydHkgdGVsbHMgeW91IHRoZSBleHRlbnQgb2YgdGhlIGN1cnJlbnQgZHJhd24gdmlld3BvcnQsIGluXG4gICAgZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlld3BvcnQ7IH1cbiAgICAvKipcbiAgICBXaGVuIHRoZXJlIGFyZSwgZm9yIGV4YW1wbGUsIGxhcmdlIGNvbGxhcHNlZCByYW5nZXMgaW4gdGhlXG4gICAgdmlld3BvcnQsIGl0cyBzaXplIGNhbiBiZSBhIGxvdCBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIHZpc2libGVcbiAgICBjb250ZW50LiBUaHVzLCBpZiB5b3UgYXJlIGRvaW5nIHNvbWV0aGluZyBsaWtlIHN0eWxpbmcgdGhlXG4gICAgY29udGVudCBpbiB0aGUgdmlld3BvcnQsIGl0IGlzIHByZWZlcmFibGUgdG8gb25seSBkbyBzbyBmb3JcbiAgICB0aGVzZSByYW5nZXMsIHdoaWNoIGFyZSB0aGUgc3Vic2V0IG9mIHRoZSB2aWV3cG9ydCB0aGF0IGlzXG4gICAgYWN0dWFsbHkgZHJhd24uXG4gICAgKi9cbiAgICBnZXQgdmlzaWJsZVJhbmdlcygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpc2libGVSYW5nZXM7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIGVkaXRvciBpcyBlbnRpcmVseSBzY3JvbGxlZCBvdXQgb2Ygdmlld1xuICAgIG9yIG90aGVyd2lzZSBoaWRkZW4uXG4gICAgKi9cbiAgICBnZXQgaW5WaWV3KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaW5WaWV3OyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGNvbXBvc2luZyB0ZXh0IHZpYVxuICAgIFtJTUVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lucHV0X21ldGhvZCksIGFuZCBhdCBsZWFzdFxuICAgIG9uZSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSBpbiB0aGUgY3VycmVudCBjb21wb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBjb21wb3NpbmcoKSB7IHJldHVybiB0aGlzLmlucHV0U3RhdGUuY29tcG9zaW5nID4gMDsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBpbiBjb21wb3Npbmcgc3RhdGUuIE5vdGVcbiAgICB0aGF0IG9uIHNvbWUgcGxhdGZvcm1zLCBsaWtlIEFuZHJvaWQsIHRoaXMgd2lsbCBiZSB0aGUgY2FzZSBhXG4gICAgbG90LCBzaW5jZSBqdXN0IHB1dHRpbmcgdGhlIGN1cnNvciBvbiBhIHdvcmQgc3RhcnRzIGFcbiAgICBjb21wb3NpdGlvbiB0aGVyZS5cbiAgICAqL1xuICAgIGdldCBjb21wb3NpdGlvblN0YXJ0ZWQoKSB7IHJldHVybiB0aGlzLmlucHV0U3RhdGUuY29tcG9zaW5nID49IDA7IH1cbiAgICAvKipcbiAgICBUaGUgZG9jdW1lbnQgb3Igc2hhZG93IHJvb3QgdGhhdCB0aGUgdmlldyBsaXZlcyBpbi5cbiAgICAqL1xuICAgIGdldCByb290KCkgeyByZXR1cm4gdGhpcy5fcm9vdDsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHdpbigpIHsgcmV0dXJuIHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93OyB9XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbmV3IHZpZXcuIFlvdSdsbCB3YW50IHRvIGVpdGhlciBwcm92aWRlIGEgYHBhcmVudGBcbiAgICBvcHRpb24sIG9yIHB1dCBgdmlldy5kb21gIGludG8geW91ciBkb2N1bWVudCBhZnRlciBjcmVhdGluZyBhXG4gICAgdmlldywgc28gdGhhdCB0aGUgdXNlciBjYW4gc2VlIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpbk1hcCA9IG5ldyBNYXA7XG4gICAgICAgIHRoaXMuZWRpdG9yQXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmNsYXNzTmFtZSA9IFwiY20tc2Nyb2xsZXJcIjtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uY2xhc3NOYW1lID0gXCJjbS1hbm5vdW5jZWRcIjtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIik7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5hbm5vdW5jZURPTSk7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsRE9NKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wYXJlbnQpXG4gICAgICAgICAgICBjb25maWcucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgbGV0IHsgZGlzcGF0Y2ggfSA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9ucyA9IGNvbmZpZy5kaXNwYXRjaFRyYW5zYWN0aW9ucyB8fFxuICAgICAgICAgICAgKGRpc3BhdGNoICYmICgodHJzKSA9PiB0cnMuZm9yRWFjaCh0ciA9PiBkaXNwYXRjaCh0ciwgdGhpcykpKSkgfHxcbiAgICAgICAgICAgICgodHJzKSA9PiB0aGlzLnVwZGF0ZSh0cnMpKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IChjb25maWcucm9vdCB8fCBnZXRSb290KGNvbmZpZy5wYXJlbnQpIHx8IGRvY3VtZW50KTtcbiAgICAgICAgdGhpcy52aWV3U3RhdGUgPSBuZXcgVmlld1N0YXRlKGNvbmZpZy5zdGF0ZSB8fCBzdGF0ZS5FZGl0b3JTdGF0ZS5jcmVhdGUoY29uZmlnKSk7XG4gICAgICAgIGlmIChjb25maWcuc2Nyb2xsVG8gJiYgY29uZmlnLnNjcm9sbFRvLmlzKHNjcm9sbEludG9WaWV3KSlcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9IGNvbmZpZy5zY3JvbGxUby52YWx1ZS5jbGlwKHRoaXMudmlld1N0YXRlLnN0YXRlKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBET01PYnNlcnZlcih0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlID0gbmV3IElucHV0U3RhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLnBsdWdpbnMpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBuZXcgRG9jVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgaWYgKChfYSA9IGRvY3VtZW50LmZvbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHkpXG4gICAgICAgICAgICBkb2N1bWVudC5mb250cy5yZWFkeS50aGVuKCgpID0+IHRoaXMucmVxdWVzdE1lYXN1cmUoKSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKC4uLmlucHV0KSB7XG4gICAgICAgIGxldCB0cnMgPSBpbnB1dC5sZW5ndGggPT0gMSAmJiBpbnB1dFswXSBpbnN0YW5jZW9mIHN0YXRlLlRyYW5zYWN0aW9uID8gaW5wdXRcbiAgICAgICAgICAgIDogaW5wdXQubGVuZ3RoID09IDEgJiYgQXJyYXkuaXNBcnJheShpbnB1dFswXSkgPyBpbnB1dFswXVxuICAgICAgICAgICAgICAgIDogW3RoaXMuc3RhdGUudXBkYXRlKC4uLmlucHV0KV07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbnModHJzLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgdHJhbnNhY3Rpb25zLiBUaGlzIHdpbGxcbiAgICB1cGRhdGUgdGhlIHZpc2libGUgZG9jdW1lbnQgYW5kIHNlbGVjdGlvbiB0byBtYXRjaCB0aGUgc3RhdGVcbiAgICBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb25zLCBhbmQgbm90aWZ5IHZpZXcgcGx1Z2lucyBvZiB0aGVcbiAgICBjaGFuZ2UuIFlvdSBzaG91bGQgdXN1YWxseSBjYWxsXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLCB3aGljaCB1c2VzIHRoaXNcbiAgICBhcyBhIHByaW1pdGl2ZS5cbiAgICAqL1xuICAgIHVwZGF0ZSh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy51cGRhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgbGV0IHJlZHJhd24gPSBmYWxzZSwgYXR0cnNDaGFuZ2VkID0gZmFsc2UsIHVwZGF0ZTtcbiAgICAgICAgbGV0IHN0YXRlJDEgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0ci5zdGFydFN0YXRlICE9IHN0YXRlJDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gdXBkYXRlIHN0YXRlIHdpdGggYSB0cmFuc2FjdGlvbiB0aGF0IGRvZXNuJ3Qgc3RhcnQgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXCIpO1xuICAgICAgICAgICAgc3RhdGUkMSA9IHRyLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBzdGF0ZSQxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb2N1cyA9IHRoaXMuaGFzRm9jdXMsIGZvY3VzRmxhZyA9IDAsIGRpc3BhdGNoRm9jdXMgPSBudWxsO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuYW5ub3RhdGlvbihpc0ZvY3VzQ2hhbmdlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgICAgIC8vIElmIGEgZm9jdXMtY2hhbmdlIHRyYW5zYWN0aW9uIGlzIGJlaW5nIGRpc3BhdGNoZWQsIHNldCB0aGlzIHVwZGF0ZSBmbGFnLlxuICAgICAgICAgICAgZm9jdXNGbGFnID0gMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvY3VzICE9IHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgc2VwYXJhdGUgZm9jdXMgdHJhbnNhY3Rpb24gaWYgbmVjZXNzYXJ5LCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIGFkZCBhIGZsYWcgdG8gdGhpcyB1cGRhdGVcbiAgICAgICAgICAgIGRpc3BhdGNoRm9jdXMgPSBmb2N1c0NoYW5nZVRyYW5zYWN0aW9uKHN0YXRlJDEsIGZvY3VzKTtcbiAgICAgICAgICAgIGlmICghZGlzcGF0Y2hGb2N1cylcbiAgICAgICAgICAgICAgICBmb2N1c0ZsYWcgPSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcGVuZGluZyBET00gY2hhbmdlLCBlYWdlcmx5IHJlYWQgaXQgYW5kIHRyeSB0b1xuICAgICAgICAvLyBhcHBseSBpdCBhZnRlciB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb25zLlxuICAgICAgICBsZXQgcGVuZGluZ0tleSA9IHRoaXMub2JzZXJ2ZXIuZGVsYXllZEFuZHJvaWRLZXksIGRvbUNoYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChwZW5kaW5nS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcbiAgICAgICAgICAgIGRvbUNoYW5nZSA9IHRoaXMub2JzZXJ2ZXIucmVhZENoYW5nZSgpO1xuICAgICAgICAgICAgLy8gT25seSB0cnkgdG8gYXBwbHkgRE9NIGNoYW5nZXMgaWYgdGhlIHRyYW5zYWN0aW9ucyBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgZG9jIG9yIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIGlmIChkb21DaGFuZ2UgJiYgIXRoaXMuc3RhdGUuZG9jLmVxKHN0YXRlJDEuZG9jKSB8fCAhdGhpcy5zdGF0ZS5zZWxlY3Rpb24uZXEoc3RhdGUkMS5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIGRvbUNoYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgcGhyYXNlcyBjaGFuZ2UsIHJlZHJhdyB0aGUgZWRpdG9yXG4gICAgICAgIGlmIChzdGF0ZSQxLmZhY2V0KHN0YXRlLkVkaXRvclN0YXRlLnBocmFzZXMpICE9IHRoaXMuc3RhdGUuZmFjZXQoc3RhdGUuRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShzdGF0ZSQxKTtcbiAgICAgICAgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgc3RhdGUkMSwgdHJhbnNhY3Rpb25zKTtcbiAgICAgICAgdXBkYXRlLmZsYWdzIHw9IGZvY3VzRmxhZztcbiAgICAgICAgbGV0IHNjcm9sbFRhcmdldCA9IHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0Lm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAodHIuc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgbWFpbiB9ID0gdHIuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBuZXcgU2Nyb2xsVGFyZ2V0KG1haW4uZW1wdHkgPyBtYWluIDogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihtYWluLmhlYWQsIG1haW4uaGVhZCA+IG1haW4uYW5jaG9yID8gLTEgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuaXMoc2Nyb2xsSW50b1ZpZXcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gZS52YWx1ZS5jbGlwKHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUudXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gQ2FjaGVkT3JkZXIudXBkYXRlKHRoaXMuYmlkaUNhY2hlLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZHJhd24gPSB0aGlzLmRvY1ZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSkgIT0gdGhpcy5zdHlsZU1vZHVsZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICAgICAgYXR0cnNDaGFuZ2VkID0gdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgdGhpcy5zaG93QW5ub3VuY2VtZW50cyh0cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbihyZWRyYXduLCB0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5pc1VzZXJFdmVudChcInNlbGVjdC5wb2ludGVyXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldCh0aGVtZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHRoZW1lKSlcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIGlmIChyZWRyYXduIHx8IGF0dHJzQ2hhbmdlZCB8fCBzY3JvbGxUYXJnZXQgfHwgdGhpcy52aWV3U3RhdGUubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQpXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmIChyZWRyYXduKVxuICAgICAgICAgICAgdGhpcy5kb2NWaWV3VXBkYXRlKCk7XG4gICAgICAgIGlmICghdXBkYXRlLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSwgXCJ1cGRhdGUgbGlzdGVuZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGF0Y2hGb2N1cyB8fCBkb21DaGFuZ2UpXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2hGb2N1cyAmJiB0aGlzLnN0YXRlID09IGRpc3BhdGNoRm9jdXMuc3RhcnRTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChkaXNwYXRjaEZvY3VzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXBwbHlET01DaGFuZ2UodGhpcywgZG9tQ2hhbmdlKSAmJiBwZW5kaW5nS2V5LmZvcmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodGhpcy5jb250ZW50RE9NLCBwZW5kaW5nS2V5LmtleSwgcGVuZGluZ0tleS5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzZXQgdGhlIHZpZXcgdG8gdGhlIGdpdmVuIHN0YXRlLiAoVGhpcyB3aWxsIGNhdXNlIHRoZSBlbnRpcmVcbiAgICBkb2N1bWVudCB0byBiZSByZWRyYXduIGFuZCBhbGwgdmlldyBwbHVnaW5zIHRvIGJlIHJlaW5pdGlhbGl6ZWQsXG4gICAgc28geW91IHNob3VsZCBwcm9iYWJseSBvbmx5IHVzZSBpdCB3aGVuIHRoZSBuZXcgc3RhdGUgaXNuJ3RcbiAgICBkZXJpdmVkIGZyb20gdGhlIG9sZCBzdGF0ZS4gT3RoZXJ3aXNlLCB1c2VcbiAgICBbYGRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpIGluc3RlYWQuKVxuICAgICovXG4gICAgc2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy5zZXRTdGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgIGxldCBoYWRGb2N1cyA9IHRoaXMuaGFzRm9jdXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUgPSBuZXcgVmlld1N0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucyA9IG5ld1N0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5jbGVhcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFkRm9jdXMpXG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2lucyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZTcGVjcyA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLCBzcGVjcyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcykge1xuICAgICAgICAgICAgbGV0IG5ld1BsdWdpbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBwcmV2U3BlY3MuaW5kZXhPZihzcGVjKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ubXVzdFVwZGF0ZSAhPSB1cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwLm11c3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnBsdWdpbnNbaV0udXBkYXRlKHRoaXMpO1xuICAgICAgICBpZiAocHJldlNwZWNzICE9IHNwZWNzKVxuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgfVxuICAgIGRvY1ZpZXdVcGRhdGUoKSB7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBwbHVnaW4udmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsICYmIHZhbC5kb2NWaWV3VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRvY1ZpZXdVcGRhdGUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlLCBcImRvYyB2aWV3IHVwZGF0ZSBsaXN0ZW5lclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtZWFzdXJlKGZsdXNoID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCk7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLmRlbGF5ZWRBbmRyb2lkS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAwOyAvLyBQcmV2ZW50IHJlcXVlc3RNZWFzdXJlIGNhbGxzIGZyb20gc2NoZWR1bGluZyBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBpZiAoZmx1c2gpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xuICAgICAgICBsZXQgc0RPTSA9IHRoaXMuc2Nyb2xsRE9NLCBzY3JvbGxUb3AgPSBzRE9NLnNjcm9sbFRvcCAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsZXQgeyBzY3JvbGxBbmNob3JQb3MsIHNjcm9sbEFuY2hvckhlaWdodCB9ID0gdGhpcy52aWV3U3RhdGU7XG4gICAgICAgIGlmIChNYXRoLmFicyhzY3JvbGxUb3AgLSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUb3ApID4gMSlcbiAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbEFuY2hvckhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2Nyb2xsZWRUb0JvdHRvbShzRE9NKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9yUG9zID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvclBvcyA9IGJsb2NrLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSBibG9jay50b3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDEgLyogVXBkYXRlU3RhdGUuTWVhc3VyaW5nICovO1xuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy52aWV3U3RhdGUubWVhc3VyZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZWQgJiYgIXRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCAmJiB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJNZWFzdXJlIGxvb3AgcmVzdGFydGVkIG1vcmUgdGhhbiA1IHRpbWVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJWaWV3cG9ydCBmYWlsZWQgdG8gc3RhYmlsaXplXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmluZyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIG1lYXN1cmUgcmVxdWVzdHMgaW4gdGhpcyBjeWNsZSB3aGVuIHRoZSB2aWV3cG9ydCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKCEoY2hhbmdlZCAmIDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLykpXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLm1lYXN1cmVSZXF1ZXN0cywgbWVhc3VyaW5nXSA9IFttZWFzdXJpbmcsIHRoaXMubWVhc3VyZVJlcXVlc3RzXTtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZWQgPSBtZWFzdXJpbmcubWFwKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0ucmVhZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhZE1lYXN1cmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgdGhpcy5zdGF0ZSwgW10pLCByZWRyYXduID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVkKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5mbGFncyB8PSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZHJhd24pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXdVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWFzdXJpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlZFtpXSAhPSBCYWRNZWFzdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtID0gbWVhc3VyaW5nW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLndyaXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLndyaXRlKG1lYXN1cmVkW2ldLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhd24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUudmlld3BvcnRDaGFuZ2VkICYmIHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcuc2Nyb2xsSW50b1ZpZXcodGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0FuY2hvckhlaWdodCA9IHNjcm9sbEFuY2hvclBvcyA8IDAgPyB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRNYXAuaGVpZ2h0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQoc2Nyb2xsQW5jaG9yUG9zKS50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpZmYgPSBuZXdBbmNob3JIZWlnaHQgLSBzY3JvbGxBbmNob3JIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAxIHx8IGRpZmYgPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3AgPSBzY3JvbGxUb3AgKyBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzRE9NLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCAvIHRoaXMuc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZCAmJiAhdXBkYXRlZC5lbXB0eSlcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGUuZmFjZXQodXBkYXRlTGlzdGVuZXIpKVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHVwZGF0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIENTUyBjbGFzc2VzIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZGl0b3IgdGhlbWVzLlxuICAgICovXG4gICAgZ2V0IHRoZW1lQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VUaGVtZUlEICsgXCIgXCIgK1xuICAgICAgICAgICAgKHRoaXMuc3RhdGUuZmFjZXQoZGFya1RoZW1lKSA/IGJhc2VEYXJrSUQgOiBiYXNlTGlnaHRJRCkgKyBcIiBcIiArXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmZhY2V0KHRoZW1lKTtcbiAgICB9XG4gICAgdXBkYXRlQXR0cnMoKSB7XG4gICAgICAgIGxldCBlZGl0b3JBdHRycyA9IGF0dHJzRnJvbUZhY2V0KHRoaXMsIGVkaXRvckF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWVkaXRvclwiICsgKHRoaXMuaGFzRm9jdXMgPyBcIiBjbS1mb2N1c2VkIFwiIDogXCIgXCIpICsgdGhpcy50aGVtZUNsYXNzZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjb250ZW50QXR0cnMgPSB7XG4gICAgICAgICAgICBzcGVsbGNoZWNrOiBcImZhbHNlXCIsXG4gICAgICAgICAgICBhdXRvY29ycmVjdDogXCJvZmZcIixcbiAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiBcIm9mZlwiLFxuICAgICAgICAgICAgdHJhbnNsYXRlOiBcIm5vXCIsXG4gICAgICAgICAgICBjb250ZW50ZWRpdGFibGU6ICF0aGlzLnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tY29udGVudFwiLFxuICAgICAgICAgICAgc3R5bGU6IGAke2Jyb3dzZXIudGFiU2l6ZX06ICR7dGhpcy5zdGF0ZS50YWJTaXplfWAsXG4gICAgICAgICAgICByb2xlOiBcInRleHRib3hcIixcbiAgICAgICAgICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogXCJ0cnVlXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICBjb250ZW50QXR0cnNbXCJhcmlhLXJlYWRvbmx5XCJdID0gXCJ0cnVlXCI7XG4gICAgICAgIGF0dHJzRnJvbUZhY2V0KHRoaXMsIGNvbnRlbnRBdHRyaWJ1dGVzLCBjb250ZW50QXR0cnMpO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkQ29udGVudCA9IHVwZGF0ZUF0dHJzKHRoaXMuY29udGVudERPTSwgdGhpcy5jb250ZW50QXR0cnMsIGNvbnRlbnRBdHRycyk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlZEVkaXRvciA9IHVwZGF0ZUF0dHJzKHRoaXMuZG9tLCB0aGlzLmVkaXRvckF0dHJzLCBlZGl0b3JBdHRycyk7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZENvbnRlbnQgfHwgY2hhbmdlZEVkaXRvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yQXR0cnMgPSBlZGl0b3JBdHRycztcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSBjb250ZW50QXR0cnM7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiAgICBzaG93QW5ub3VuY2VtZW50cyh0cnMpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJzKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhFZGl0b3JWaWV3LmFubm91bmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm91bmNlRE9NLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpdiA9IHRoaXMuYW5ub3VuY2VET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi50ZXh0Q29udGVudCA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgfVxuICAgIG1vdW50U3R5bGVzKCkge1xuICAgICAgICB0aGlzLnN0eWxlTW9kdWxlcyA9IHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpO1xuICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuY3NwTm9uY2UpO1xuICAgICAgICBzdHlsZU1vZC5TdHlsZU1vZHVsZS5tb3VudCh0aGlzLnJvb3QsIHRoaXMuc3R5bGVNb2R1bGVzLmNvbmNhdChiYXNlVGhlbWUkMSkucmV2ZXJzZSgpLCBub25jZSA/IHsgbm9uY2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWRpbmcgdGhlIGVkaXRvciBsYXlvdXQgaXNuJ3QgYWxsb3dlZCBkdXJpbmcgYW4gdXBkYXRlXCIpO1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSA9PSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8gJiYgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmUoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBTY2hlZHVsZSBhIGxheW91dCBtZWFzdXJlbWVudCwgb3B0aW9uYWxseSBwcm92aWRpbmcgY2FsbGJhY2tzIHRvXG4gICAgZG8gY3VzdG9tIERPTSBtZWFzdXJpbmcgZm9sbG93ZWQgYnkgYSBET00gd3JpdGUgcGhhc2UuIFVzaW5nXG4gICAgdGhpcyBpcyBwcmVmZXJhYmxlIHJlYWRpbmcgRE9NIGxheW91dCBkaXJlY3RseSBmcm9tLCBmb3JcbiAgICBleGFtcGxlLCBhbiBldmVudCBoYW5kbGVyLCBiZWNhdXNlIGl0J2xsIG1ha2Ugc3VyZSBtZWFzdXJpbmcgYW5kXG4gICAgZHJhd2luZyBkb25lIGJ5IG90aGVyIGNvbXBvbmVudHMgaXMgc3luY2hyb25pemVkLCBhdm9pZGluZ1xuICAgIHVubmVjZXNzYXJ5IERPTSBsYXlvdXQgY29tcHV0YXRpb25zLlxuICAgICovXG4gICAgcmVxdWVzdE1lYXN1cmUocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkIDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IHRoaXMud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLm1lYXN1cmUoKSk7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZWFzdXJlUmVxdWVzdHMuaW5kZXhPZihyZXF1ZXN0KSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldLmtleSA9PT0gcmVxdWVzdC5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmljIHBsdWdpbiwgaWYgcHJlc2VudC4gTm90ZSB0aGF0XG4gICAgcGx1Z2lucyB0aGF0IGNyYXNoIGNhbiBiZSBkcm9wcGVkIGZyb20gYSB2aWV3LCBzbyBldmVuIHdoZW4geW91XG4gICAga25vdyB5b3UgcmVnaXN0ZXJlZCBhIGdpdmVuIHBsdWdpbiwgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2hlY2tcbiAgICB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgbWV0aG9kLlxuICAgICovXG4gICAgcGx1Z2luKHBsdWdpbikge1xuICAgICAgICBsZXQga25vd24gPSB0aGlzLnBsdWdpbk1hcC5nZXQocGx1Z2luKTtcbiAgICAgICAgaWYgKGtub3duID09PSB1bmRlZmluZWQgfHwga25vd24gJiYga25vd24uc3BlYyAhPSBwbHVnaW4pXG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5zZXQocGx1Z2luLCBrbm93biA9IHRoaXMucGx1Z2lucy5maW5kKHAgPT4gcC5zcGVjID09IHBsdWdpbikgfHwgbnVsbCk7XG4gICAgICAgIHJldHVybiBrbm93biAmJiBrbm93bi51cGRhdGUodGhpcykudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGRvY3VtZW50LCBpbiBzY3JlZW4gY29vcmRpbmF0ZXMuIFRoaXNcbiAgICBtYXkgYmUgbmVnYXRpdmUgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGVkIGRvd24uIFBvaW50c1xuICAgIGRpcmVjdGx5IHRvIHRoZSB0b3Agb2YgdGhlIGZpcnN0IGxpbmUsIG5vdCBhYm92ZSB0aGUgcGFkZGluZy5cbiAgICAqL1xuICAgIGdldCBkb2N1bWVudFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBvcnRzIHRoZSBwYWRkaW5nIGFib3ZlIGFuZCBiZWxvdyB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMudmlld1N0YXRlLnBhZGRpbmdUb3AsIGJvdHRvbTogdGhpcy52aWV3U3RhdGUucGFkZGluZ0JvdHRvbSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBJZiB0aGUgZWRpdG9yIGlzIHRyYW5zZm9ybWVkIHdpdGggQ1NTLCB0aGlzIHByb3ZpZGVzIHRoZSBzY2FsZVxuICAgIGFsb25nIHRoZSBYIGF4aXMuIE90aGVyd2lzZSwgaXQgd2lsbCBqdXN0IGJlIDEuIE5vdGUgdGhhdFxuICAgIHRyYW5zZm9ybXMgb3RoZXIgdGhhbiB0cmFuc2xhdGlvbiBhbmQgc2NhbGluZyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAqL1xuICAgIGdldCBzY2FsZVgoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVg7IH1cbiAgICAvKipcbiAgICBQcm92aWRlIHRoZSBDU1MgdHJhbnNmb3JtZWQgc2NhbGUgYWxvbmcgdGhlIFkgYXhpcy5cbiAgICAqL1xuICAgIGdldCBzY2FsZVkoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVk7IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGxpbmUgb3IgYmxvY2sgd2lkZ2V0IGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbFxuICAgIHBvc2l0aW9uICh3aGljaCBpcyBpbnRlcnByZXRlZCBhcyByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApKS5cbiAgICAqL1xuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmVsZW1lbnRBdEhlaWdodChoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBsaW5lIGJsb2NrIChzZWVcbiAgICBbYGxpbmVCbG9ja0F0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpIGF0IHRoZSBnaXZlblxuICAgIGhlaWdodCwgYWdhaW4gaW50ZXJwcmV0ZWQgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKS5cbiAgICAqL1xuICAgIGxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBleHRlbnQgYW5kIHZlcnRpY2FsIHBvc2l0aW9uIG9mIGFsbCBbbGluZVxuICAgIGJsb2Nrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpIGluIHRoZSB2aWV3cG9ydC4gUG9zaXRpb25zXG4gICAgYXJlIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCk7XG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRMaW5lQmxvY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlld3BvcnRMaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbGluZSBibG9jayBhcm91bmQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLiBBIGxpbmVcbiAgICBibG9jayBpcyBhIHJhbmdlIGRlbGltaXRlZCBvbiBib3RoIHNpZGVzIGJ5IGVpdGhlciBhXG4gICAgbm9uLVtoaWRkZW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXnJlcGxhY2UpIGxpbmUgYnJlYWssIG9yIHRoZVxuICAgIHN0YXJ0L2VuZCBvZiB0aGUgZG9jdW1lbnQuIEl0IHdpbGwgdXN1YWxseSBqdXN0IGhvbGQgYSBsaW5lIG9mXG4gICAgdGV4dCwgYnV0IG1heSBiZSBicm9rZW4gaW50byBtdWx0aXBsZSB0ZXh0YmxvY2tzIGJ5IGJsb2NrXG4gICAgd2lkZ2V0cy5cbiAgICAqL1xuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQocG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVkaXRvcidzIHRvdGFsIGNvbnRlbnQgaGVpZ2h0LlxuICAgICovXG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGEgY3Vyc29yIHBvc2l0aW9uIGJ5IFtncmFwaGVtZVxuICAgIGNsdXN0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuZmluZENsdXN0ZXJCcmVhaykuIGBmb3J3YXJkYCBkZXRlcm1pbmVzIHdoZXRoZXJcbiAgICB0aGUgbW90aW9uIGlzIGF3YXkgZnJvbSB0aGUgbGluZSBzdGFydCwgb3IgdG93YXJkcyBpdC4gSW5cbiAgICBiaWRpcmVjdGlvbmFsIHRleHQsIHRoZSBsaW5lIGlzIHRyYXZlcnNlZCBpbiB2aXN1YWwgb3JkZXIsIHVzaW5nXG4gICAgdGhlIGVkaXRvcidzIFt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuXG4gICAgV2hlbiB0aGUgc3RhcnQgcG9zaXRpb24gd2FzIHRoZSBsYXN0IG9uZSBvbiB0aGUgbGluZSwgdGhlXG4gICAgcmV0dXJuZWQgcG9zaXRpb24gd2lsbCBiZSBhY3Jvc3MgdGhlIGxpbmUgYnJlYWsuIElmIHRoZXJlIGlzIG5vXG4gICAgZnVydGhlciBsaW5lLCB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgXG4gICAgQnkgZGVmYXVsdCwgdGhpcyBtZXRob2QgbW92ZXMgb3ZlciBhIHNpbmdsZSBjbHVzdGVyLiBUaGVcbiAgICBvcHRpb25hbCBgYnlgIGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIG1vdmUgYWNyb3NzIG1vcmUuIEl0IHdpbGxcbiAgICBiZSBjYWxsZWQgd2l0aCB0aGUgZmlyc3QgY2x1c3RlciBhcyBhcmd1bWVudCwgYW5kIHNob3VsZCByZXR1cm5cbiAgICBhIHByZWRpY2F0ZSB0aGF0IGRldGVybWluZXMsIGZvciBlYWNoIHN1YnNlcXVlbnQgY2x1c3RlcixcbiAgICB3aGV0aGVyIGl0IHNob3VsZCBhbHNvIGJlIG1vdmVkIG92ZXIuXG4gICAgKi9cbiAgICBtb3ZlQnlDaGFyKHN0YXJ0LCBmb3J3YXJkLCBieSkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBieSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGEgY3Vyc29yIHBvc2l0aW9uIGFjcm9zcyB0aGUgbmV4dCBncm91cCBvZiBlaXRoZXJcbiAgICBbbGV0dGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpIG9yIG5vbi1sZXR0ZXJcbiAgICBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgbW92ZUJ5R3JvdXAoc3RhcnQsIGZvcndhcmQpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZUJ5Q2hhcih0aGlzLCBzdGFydCwgZm9yd2FyZCwgaW5pdGlhbCA9PiBieUdyb3VwKHRoaXMsIHN0YXJ0LmhlYWQsIGluaXRpYWwpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY3Vyc29yIHBvc2l0aW9uIHZpc3VhbGx5IGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBsaW5lLlxuICAgIE5vdGUgdGhhdCB0aGlzIG1heSBkaWZmZXIgZnJvbSB0aGUgX2xvZ2ljYWxfIHBvc2l0aW9uIGF0IGl0c1xuICAgIHN0YXJ0IG9yIGVuZCAod2hpY2ggaXMgc2ltcGx5IGF0IGBsaW5lLmZyb21gL2BsaW5lLnRvYCkgaWYgdGV4dFxuICAgIGF0IHRoZSBzdGFydCBvciBlbmQgZ29lcyBhZ2FpbnN0IHRoZSBsaW5lJ3MgYmFzZSB0ZXh0IGRpcmVjdGlvbi5cbiAgICAqL1xuICAgIHZpc3VhbExpbmVTaWRlKGxpbmUsIGVuZCkge1xuICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLmJpZGlTcGFucyhsaW5lKSwgZGlyID0gdGhpcy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltlbmQgPyBvcmRlci5sZW5ndGggLSAxIDogMF07XG4gICAgICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHNwYW4uc2lkZShlbmQsIGRpcikgKyBsaW5lLmZyb20sIHNwYW4uZm9yd2FyZCghZW5kLCBkaXIpID8gMSA6IC0xKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uIElmXG4gICAgYGluY2x1ZGVXcmFwYCBpcyB0cnVlLCBsaW5lIHdyYXBwaW5nIGlzIG9uLCBhbmQgdGhlcmUgaXMgYVxuICAgIGZ1cnRoZXIgd3JhcCBwb2ludCBvbiB0aGUgY3VycmVudCBsaW5lLCB0aGUgd3JhcCBwb2ludCB3aWxsIGJlXG4gICAgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzdGFydCBvciBlbmRcbiAgICBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIG1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBtb3ZlVG9MaW5lQm91bmRhcnkodGhpcywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiB2ZXJ0aWNhbGx5LiBXaGVuIGBkaXN0YW5jZWAgaXNuJ3QgZ2l2ZW4sXG4gICAgaXQgZGVmYXVsdHMgdG8gbW92aW5nIHRvIHRoZSBuZXh0IGxpbmUgKGluY2x1ZGluZyB3cmFwcGVkXG4gICAgbGluZXMpLiBPdGhlcndpc2UsIGBkaXN0YW5jZWAgc2hvdWxkIHByb3ZpZGUgYSBwb3NpdGl2ZSBkaXN0YW5jZVxuICAgIGluIHBpeGVscy5cbiAgICBcbiAgICBXaGVuIGBzdGFydGAgaGFzIGFcbiAgICBbYGdvYWxDb2x1bW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmdvYWxDb2x1bW4pLCB0aGUgdmVydGljYWxcbiAgICBtb3Rpb24gd2lsbCB1c2UgdGhhdCBhcyBhIHRhcmdldCBob3Jpem9udGFsIHBvc2l0aW9uLiBPdGhlcndpc2UsXG4gICAgdGhlIGN1cnNvcidzIG93biBob3Jpem9udGFsIHBvc2l0aW9uIGlzIHVzZWQuIFRoZSByZXR1cm5lZFxuICAgIGN1cnNvciB3aWxsIGhhdmUgaXRzIGdvYWwgY29sdW1uIHNldCB0byB3aGljaGV2ZXIgY29sdW1uIHdhc1xuICAgIHVzZWQuXG4gICAgKi9cbiAgICBtb3ZlVmVydGljYWxseShzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZVZlcnRpY2FsbHkodGhpcywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwYXJlbnQgbm9kZSBhbmQgb2Zmc2V0IChjaGlsZCBvZmZzZXQgaWYgYG5vZGVgIGlzXG4gICAgYW4gZWxlbWVudCwgY2hhcmFjdGVyIG9mZnNldCB3aGVuIGl0IGlzIGEgdGV4dCBub2RlKSBhdCB0aGVcbiAgICBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBcbiAgICBOb3RlIHRoYXQgZm9yIHBvc2l0aW9ucyB0aGF0IGFyZW4ndCBjdXJyZW50bHkgaW5cbiAgICBgdmlzaWJsZVJhbmdlc2AsIHRoZSByZXN1bHRpbmcgRE9NIHBvc2l0aW9uIGlzbid0IG5lY2Vzc2FyaWx5XG4gICAgbWVhbmluZ2Z1bCAoaXQgbWF5IGp1c3QgcG9pbnQgYmVmb3JlIG9yIGFmdGVyIGEgcGxhY2Vob2xkZXJcbiAgICBlbGVtZW50KS5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUF0UG9zKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBET00gbm9kZS4gQ2FuIGJlIHVzZWZ1bFxuICAgIGZvciBhc3NvY2lhdGluZyBwb3NpdGlvbnMgd2l0aCBET00gZXZlbnRzLiBXaWxsIHJhaXNlIGFuIGVycm9yXG4gICAgd2hlbiBgbm9kZWAgaXNuJ3QgcGFydCBvZiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMsIHByZWNpc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHNjcmVlbiBjb29yZGluYXRlcyBhdCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYHNpZGVgIGRldGVybWluZXMgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGJhc2VkIG9uIHRoZVxuICAgIGVsZW1lbnQgYmVmb3JlICgtMSkgb3IgYWZ0ZXIgKDEpIHRoZSBwb3NpdGlvbiAoaWYgbm8gZWxlbWVudCBpc1xuICAgIGF2YWlsYWJsZSBvbiB0aGUgZ2l2ZW4gc2lkZSwgdGhlIG1ldGhvZCB3aWxsIHRyYW5zcGFyZW50bHkgdXNlXG4gICAgYW5vdGhlciBzdHJhdGVneSB0byBnZXQgcmVhc29uYWJsZSBjb29yZGluYXRlcykuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5kb2NWaWV3LmNvb3Jkc0F0KHBvcywgc2lkZSk7XG4gICAgICAgIGlmICghcmVjdCB8fCByZWN0LmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBvcmRlciA9IHRoaXMuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW0JpZGlTcGFuLmZpbmQob3JkZXIsIHBvcyAtIGxpbmUuZnJvbSwgLTEsIHNpZGUpXTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsIChzcGFuLmRpciA9PSBleHBvcnRzLkRpcmVjdGlvbi5MVFIpID09IChzaWRlID4gMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIHJlY3RhbmdsZSBhcm91bmQgYSBnaXZlbiBjaGFyYWN0ZXIuIElmIGBwb3NgIGRvZXMgbm90XG4gICAgcG9pbnQgaW4gZnJvbnQgb2YgYSBjaGFyYWN0ZXIgdGhhdCBpcyBpbiB0aGUgdmlld3BvcnQgYW5kXG4gICAgcmVuZGVyZWQgKGkuZS4gbm90IHJlcGxhY2VkLCBub3QgYSBsaW5lIGJyZWFrKSwgdGhpcyB3aWxsIHJldHVyblxuICAgIG51bGwuIEZvciBzcGFjZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIGEgbGluZSB3cmFwIHBvaW50LCB0aGlzIHdpbGxcbiAgICByZXR1cm4gdGhlIHBvc2l0aW9uIGJlZm9yZSB0aGUgbGluZSBicmVhay5cbiAgICAqL1xuICAgIGNvb3Jkc0ZvckNoYXIocG9zKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcuY29vcmRzRm9yQ2hhcihwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCB3aWR0aCBvZiBhIGNoYXJhY3RlciBpbiB0aGUgZWRpdG9yLiBNYXkgbm90XG4gICAgYWNjdXJhdGVseSByZWZsZWN0IHRoZSB3aWR0aCBvZiBhbGwgY2hhcmFjdGVycyAoZ2l2ZW4gdmFyaWFibGVcbiAgICB3aWR0aCBmb250cyBvciBzdHlsaW5nIG9mIGludmlkaWR1YWwgcmFuZ2VzKS5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0Q2hhcmFjdGVyV2lkdGgoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUuY2hhcldpZHRoOyB9XG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgaGVpZ2h0IG9mIGEgbGluZSBpbiB0aGUgZWRpdG9yLiBNYXkgbm90IGJlIGFjY3VyYXRlXG4gICAgZm9yIGFsbCBsaW5lcy5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0TGluZUhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lSGVpZ2h0OyB9XG4gICAgLyoqXG4gICAgVGhlIHRleHQgZGlyZWN0aW9uXG4gICAgKFtgZGlyZWN0aW9uYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2RpcmVjdGlvbilcbiAgICBDU1MgcHJvcGVydHkpIG9mIHRoZSBlZGl0b3IncyBjb250ZW50IGVsZW1lbnQuXG4gICAgKi9cbiAgICBnZXQgdGV4dERpcmVjdGlvbigpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmRlZmF1bHRUZXh0RGlyZWN0aW9uOyB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGJsb2NrIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYXNcbiAgICBhc3NpZ25lZCBieSBDU1MuIElmXG4gICAgW2BwZXJMaW5lVGV4dERpcmVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnBlckxpbmVUZXh0RGlyZWN0aW9uKVxuICAgIGlzbid0IGVuYWJsZWQsIG9yIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydCxcbiAgICB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgc2FtZSBhc1xuICAgIFtgdGV4dERpcmVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLiBOb3RlIHRoYXRcbiAgICB0aGlzIG1heSB0cmlnZ2VyIGEgRE9NIGxheW91dC5cbiAgICAqL1xuICAgIHRleHREaXJlY3Rpb25BdChwb3MpIHtcbiAgICAgICAgbGV0IHBlckxpbmUgPSB0aGlzLnN0YXRlLmZhY2V0KHBlckxpbmVUZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKCFwZXJMaW5lIHx8IHBvcyA8IHRoaXMudmlld3BvcnQuZnJvbSB8fCBwb3MgPiB0aGlzLnZpZXdwb3J0LnRvKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dERpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy50ZXh0RGlyZWN0aW9uQXQocG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGlzIGVkaXRvciBbd3JhcHMgbGluZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVXcmFwcGluZylcbiAgICAoYXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICBbYHdoaXRlLXNwYWNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3doaXRlLXNwYWNlKVxuICAgIENTUyBwcm9wZXJ0eSBvZiBpdHMgY29udGVudCBlbGVtZW50KS5cbiAgICAqL1xuICAgIGdldCBsaW5lV3JhcHBpbmcoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgYmlkaXJlY3Rpb25hbCB0ZXh0IHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW4gbGluZVxuICAgICh3aGljaCBzaG91bGQgYmUgaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQpIGFzIGFuIGFycmF5IG9mIHNwYW5cbiAgICBvYmplY3RzLiBUaGUgb3JkZXIgb2YgdGhlc2Ugc3BhbnMgbWF0Y2hlcyB0aGUgW3RleHRcbiAgICBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24p4oCUaWYgdGhhdCBpc1xuICAgIGxlZnQtdG8tcmlnaHQsIHRoZSBsZWZ0bW9zdCBzcGFucyBjb21lIGZpcnN0LCBvdGhlcndpc2UgdGhlXG4gICAgcmlnaHRtb3N0IHNwYW5zIGNvbWUgZmlyc3QuXG4gICAgKi9cbiAgICBiaWRpU3BhbnMobGluZSkge1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPiBNYXhCaWRpTGluZSlcbiAgICAgICAgICAgIHJldHVybiB0cml2aWFsT3JkZXIobGluZS5sZW5ndGgpO1xuICAgICAgICBsZXQgZGlyID0gdGhpcy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKSwgaXNvbGF0ZXM7XG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIHRoaXMuYmlkaUNhY2hlKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkuZnJvbSA9PSBsaW5lLmZyb20gJiYgZW50cnkuZGlyID09IGRpciAmJlxuICAgICAgICAgICAgICAgIChlbnRyeS5mcmVzaCB8fCBpc29sYXRlc0VxKGVudHJ5Lmlzb2xhdGVzLCBpc29sYXRlcyA9IGdldElzb2xhdGVkUmFuZ2VzKHRoaXMsIGxpbmUpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNvbGF0ZXMpXG4gICAgICAgICAgICBpc29sYXRlcyA9IGdldElzb2xhdGVkUmFuZ2VzKHRoaXMsIGxpbmUpO1xuICAgICAgICBsZXQgb3JkZXIgPSBjb21wdXRlT3JkZXIobGluZS50ZXh0LCBkaXIsIGlzb2xhdGVzKTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUucHVzaChuZXcgQ2FjaGVkT3JkZXIobGluZS5mcm9tLCBsaW5lLnRvLCBkaXIsIGlzb2xhdGVzLCB0cnVlLCBvcmRlcikpO1xuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlIGVkaXRvciBoYXMgZm9jdXMuXG4gICAgKi9cbiAgICBnZXQgaGFzRm9jdXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gU2FmYXJpIHJldHVybiBmYWxzZSBmb3IgaGFzRm9jdXMgd2hlbiB0aGUgY29udGV4dCBtZW51IGlzIG9wZW5cbiAgICAgICAgLy8gb3IgY2xvc2luZywgd2hpY2ggbGVhZHMgdXMgdG8gaWdub3JlIHNlbGVjdGlvbiBjaGFuZ2VzIGZyb20gdGhlXG4gICAgICAgIC8vIGNvbnRleHQgbWVudSBiZWNhdXNlIGl0IGxvb2tzIGxpa2UgdGhlIGVkaXRvciBpc24ndCBmb2N1c2VkLlxuICAgICAgICAvLyBUaGlzIGtsdWRnZXMgYXJvdW5kIHRoYXQuXG4gICAgICAgIHJldHVybiAodGhpcy5kb20ub3duZXJEb2N1bWVudC5oYXNGb2N1cygpIHx8IGJyb3dzZXIuc2FmYXJpICYmICgoX2EgPSB0aGlzLmlucHV0U3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0Q29udGV4dE1lbnUpID4gRGF0ZS5ub3coKSAtIDNlNCkgJiZcbiAgICAgICAgICAgIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuY29udGVudERPTTtcbiAgICB9XG4gICAgLyoqXG4gICAgUHV0IGZvY3VzIG9uIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgZm9jdXNQcmV2ZW50U2Nyb2xsKHRoaXMuY29udGVudERPTSk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIFtyb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvIyN2aWV3LkVkaXRvclZpZXdDb25maWcucm9vdCkgaW4gd2hpY2ggdGhlIGVkaXRvciBsaXZlcy4gVGhpcyBpcyBvbmx5XG4gICAgbmVjZXNzYXJ5IHdoZW4gbW92aW5nIHRoZSBlZGl0b3IncyBleGlzdGluZyBET00gdG8gYSBuZXcgd2luZG93IG9yIHNoYWRvdyByb290LlxuICAgICovXG4gICAgc2V0Um9vdChyb290KSB7XG4gICAgICAgIGlmICh0aGlzLl9yb290ICE9IHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSByb290O1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5zZXRXaW5kb3coKHJvb3Qubm9kZVR5cGUgPT0gOSA/IHJvb3QgOiByb290Lm93bmVyRG9jdW1lbnQpLmRlZmF1bHRWaWV3IHx8IHdpbmRvdyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2xlYW4gdXAgdGhpcyBlZGl0b3IgdmlldywgcmVtb3ZpbmcgaXRzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICBkb2N1bWVudCwgdW5yZWdpc3RlcmluZyBldmVudCBoYW5kbGVycywgYW5kIG5vdGlmeWluZ1xuICAgIHBsdWdpbnMuIFRoZSB2aWV3IGluc3RhbmNlIGNhbiBubyBsb25nZXIgYmUgdXNlZCBhZnRlclxuICAgIGNhbGxpbmcgdGhpcy5cbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET00uYmx1cigpO1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCk7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBlZmZlY3QgdGhhdCBjYW4gYmVcbiAgICBbYWRkZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRvIGEgdHJhbnNhY3Rpb24gdG9cbiAgICBjYXVzZSBpdCB0byBzY3JvbGwgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIHJhbmdlIGludG8gdmlldy5cbiAgICAqL1xuICAgIHN0YXRpYyBzY3JvbGxJbnRvVmlldyhwb3MsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gc2Nyb2xsSW50b1ZpZXcub2YobmV3IFNjcm9sbFRhcmdldCh0eXBlb2YgcG9zID09IFwibnVtYmVyXCIgPyBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcykgOiBwb3MsIG9wdGlvbnMueSwgb3B0aW9ucy54LCBvcHRpb25zLnlNYXJnaW4sIG9wdGlvbnMueE1hcmdpbikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYW4gZWZmZWN0IHRoYXQgcmVzZXRzIHRoZSBlZGl0b3IgdG8gaXRzIGN1cnJlbnQgKGF0IHRoZVxuICAgIHRpbWUgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCkgc2Nyb2xsIHBvc2l0aW9uLiBOb3RlIHRoYXQgdGhpc1xuICAgIG9ubHkgYWZmZWN0cyB0aGUgZWRpdG9yJ3Mgb3duIHNjcm9sbGFibGUgZWxlbWVudCwgbm90IHBhcmVudHMuXG4gICAgU2VlIGFsc29cbiAgICBbYEVkaXRvclZpZXdDb25maWcuc2Nyb2xsVG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld0NvbmZpZy5zY3JvbGxUbykuXG4gICAgXG4gICAgVGhlIGVmZmVjdCBzaG91bGQgYmUgdXNlZCB3aXRoIGEgZG9jdW1lbnQgaWRlbnRpY2FsIHRvIHRoZSBvbmVcbiAgICBpdCB3YXMgY3JlYXRlZCBmb3IuIEZhaWxpbmcgdG8gZG8gc28gaXMgbm90IGFuIGVycm9yLCBidXQgbWF5XG4gICAgbm90IHNjcm9sbCB0byB0aGUgZXhwZWN0ZWQgcG9zaXRpb24uIFlvdSBjYW5cbiAgICBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0Lm1hcCkgdGhlIGVmZmVjdCB0byBhY2NvdW50IGZvciBjaGFuZ2VzLlxuICAgICovXG4gICAgc2Nyb2xsU25hcHNob3QoKSB7XG4gICAgICAgIGxldCB7IHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCB9ID0gdGhpcy5zY3JvbGxET007XG4gICAgICAgIGxldCByZWYgPSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxBbmNob3JBdChzY3JvbGxUb3ApO1xuICAgICAgICByZXR1cm4gc2Nyb2xsSW50b1ZpZXcub2YobmV3IFNjcm9sbFRhcmdldChzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJlZi5mcm9tKSwgXCJzdGFydFwiLCBcInN0YXJ0XCIsIHJlZi50b3AgLSBzY3JvbGxUb3AsIHNjcm9sbExlZnQsIHRydWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRW5hYmxlIG9yIGRpc2FibGUgdGFiLWZvY3VzIG1vZGUsIHdoaWNoIGRpc2FibGVzIGtleSBiaW5kaW5nc1xuICAgIGZvciBUYWIgYW5kIFNoaWZ0LVRhYiwgbGV0dGluZyB0aGUgYnJvd3NlcidzIGRlZmF1bHRcbiAgICBmb2N1cy1jaGFuZ2luZyBiZWhhdmlvciBnbyB0aHJvdWdoIGluc3RlYWQuIFRoaXMgaXMgdXNlZnVsIHRvXG4gICAgcHJldmVudCB0cmFwcGluZyBrZXlib2FyZCB1c2VycyBpbiB5b3VyIGVkaXRvci5cbiAgICBcbiAgICBXaXRob3V0IGFyZ3VtZW50LCB0aGlzIHRvZ2dsZXMgdGhlIG1vZGUuIFdpdGggYSBib29sZWFuLCBpdFxuICAgIGVuYWJsZXMgKHRydWUpIG9yIGRpc2FibGVzIGl0IChmYWxzZSkuIEdpdmVuIGEgbnVtYmVyLCBpdFxuICAgIHRlbXBvcmFyaWx5IGVuYWJsZXMgdGhlIG1vZGUgdW50aWwgdGhhdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gICAgaGF2ZSBwYXNzZWQgb3IgYW5vdGhlciBub24tVGFiIGtleSBpcyBwcmVzc2VkLlxuICAgICovXG4gICAgc2V0VGFiRm9jdXNNb2RlKHRvKSB7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSA9IHRoaXMuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgPCAwID8gMCA6IC0xO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdG8gPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudGFiRm9jdXNNb2RlID0gdG8gPyAwIDogLTE7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgIT0gMClcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgPSBEYXRlLm5vdygpICsgdG87XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIERPTSBldmVudCBoYW5kbGVycy5cbiAgICBUaGUgdmFsdWUgc2hvdWxkIGJlIGFuIG9iamVjdCBtYXBwaW5nIGV2ZW50IG5hbWVzIHRvIGhhbmRsZXJcbiAgICBmdW5jdGlvbnMuIEZvciBhbnkgZ2l2ZW4gZXZlbnQsIHN1Y2ggZnVuY3Rpb25zIGFyZSBvcmRlcmVkIGJ5XG4gICAgZXh0ZW5zaW9uIHByZWNlZGVuY2UsIGFuZCB0aGUgZmlyc3QgaGFuZGxlciB0byByZXR1cm4gdHJ1ZSB3aWxsXG4gICAgYmUgYXNzdW1lZCB0byBoYXZlIGhhbmRsZWQgdGhhdCBldmVudCwgYW5kIG5vIG90aGVyIGhhbmRsZXJzIG9yXG4gICAgYnVpbHQtaW4gYmVoYXZpb3Igd2lsbCBiZSBhY3RpdmF0ZWQgZm9yIGl0LiBUaGVzZSBhcmUgcmVnaXN0ZXJlZFxuICAgIG9uIHRoZSBbY29udGVudCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb250ZW50RE9NKSwgZXhjZXB0XG4gICAgZm9yIGBzY3JvbGxgIGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSB0aGVcbiAgICBlZGl0b3IncyBbc2Nyb2xsIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnNjcm9sbERPTSkgb3Igb25lIG9mXG4gICAgaXRzIHBhcmVudCBub2RlcyBpcyBzY3JvbGxlZC5cbiAgICAqL1xuICAgIHN0YXRpYyBkb21FdmVudEhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSgoKSA9PiAoe30pLCB7IGV2ZW50SGFuZGxlcnM6IGhhbmRsZXJzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgcmVnaXN0ZXJzIERPTSBldmVudCBvYnNlcnZlcnMuIENvbnRyYXJ5XG4gICAgdG8gZXZlbnQgW2hhbmRsZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kb21FdmVudEhhbmRsZXJzKSxcbiAgICBvYnNlcnZlcnMgY2FuJ3QgYmUgcHJldmVudGVkIGZyb20gcnVubmluZyBieSBhIGhpZ2hlci1wcmVjZWRlbmNlXG4gICAgaGFuZGxlciByZXR1cm5pbmcgdHJ1ZS4gVGhleSBhbHNvIGRvbid0IHByZXZlbnQgb3RoZXIgaGFuZGxlcnNcbiAgICBhbmQgb2JzZXJ2ZXJzIGZyb20gcnVubmluZyB3aGVuIHRoZXkgcmV0dXJuIHRydWUsIGFuZCBzaG91bGQgbm90XG4gICAgY2FsbCBgcHJldmVudERlZmF1bHRgLlxuICAgICovXG4gICAgc3RhdGljIGRvbUV2ZW50T2JzZXJ2ZXJzKG9ic2VydmVycykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKCkgPT4gKHt9KSwgeyBldmVudE9ic2VydmVyczogb2JzZXJ2ZXJzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0aGVtZSBleHRlbnNpb24uIFRoZSBmaXJzdCBhcmd1bWVudCBjYW4gYmUgYVxuICAgIFtgc3R5bGUtbW9kYF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pXG4gICAgc3R5bGUgc3BlYyBwcm92aWRpbmcgdGhlIHN0eWxlcyBmb3IgdGhlIHRoZW1lLiBUaGVzZSB3aWxsIGJlXG4gICAgcHJlZml4ZWQgd2l0aCBhIGdlbmVyYXRlZCBjbGFzcyBmb3IgdGhlIHN0eWxlLlxuICAgIFxuICAgIEJlY2F1c2UgdGhlIHNlbGVjdG9ycyB3aWxsIGJlIHByZWZpeGVkIHdpdGggYSBzY29wZSBjbGFzcywgcnVsZVxuICAgIHRoYXQgZGlyZWN0bHkgbWF0Y2ggdGhlIGVkaXRvcidzIFt3cmFwcGVyXG4gICAgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9tKeKAlHRvIHdoaWNoIHRoZSBzY29wZSBjbGFzcyB3aWxsIGJlXG4gICAgYWRkZWTigJRuZWVkIHRvIGJlIGV4cGxpY2l0bHkgZGlmZmVyZW50aWF0ZWQgYnkgYWRkaW5nIGFuIGAmYCB0b1xuICAgIHRoZSBzZWxlY3RvciBmb3IgdGhhdCBlbGVtZW504oCUZm9yIGV4YW1wbGVcbiAgICBgJi5jbS1mb2N1c2VkYC5cbiAgICBcbiAgICBXaGVuIGBkYXJrYCBpcyBzZXQgdG8gdHJ1ZSwgdGhlIHRoZW1lIHdpbGwgYmUgbWFya2VkIGFzIGRhcmssXG4gICAgd2hpY2ggd2lsbCBjYXVzZSB0aGUgYCZkYXJrYCBydWxlcyBmcm9tIFtiYXNlXG4gICAgdGhlbWVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15iYXNlVGhlbWUpIHRvIGJlIHVzZWQgKGFzIG9wcG9zZWQgdG9cbiAgICBgJmxpZ2h0YCB3aGVuIGEgbGlnaHQgdGhlbWUgaXMgYWN0aXZlKS5cbiAgICAqL1xuICAgIHN0YXRpYyB0aGVtZShzcGVjLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSBzdHlsZU1vZC5TdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbdGhlbWUub2YocHJlZml4KSwgc3R5bGVNb2R1bGUub2YoYnVpbGRUaGVtZShgLiR7cHJlZml4fWAsIHNwZWMpKV07XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGFyaylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhcmtUaGVtZS5vZih0cnVlKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBhZGRzIHN0eWxlcyB0byB0aGUgYmFzZSB0aGVtZS4gTGlrZVxuICAgIHdpdGggW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSwgdXNlIGAmYCB0byBpbmRpY2F0ZSB0aGVcbiAgICBwbGFjZSBvZiB0aGUgZWRpdG9yIHdyYXBwZXIgZWxlbWVudCB3aGVuIGRpcmVjdGx5IHRhcmdldGluZ1xuICAgIHRoYXQuIFlvdSBjYW4gYWxzbyB1c2UgYCZkYXJrYCBvciBgJmxpZ2h0YCBpbnN0ZWFkIHRvIG9ubHlcbiAgICB0YXJnZXQgZWRpdG9ycyB3aXRoIGEgZGFyayBvciBsaWdodCB0aGVtZS5cbiAgICAqL1xuICAgIHN0YXRpYyBiYXNlVGhlbWUoc3BlYykge1xuICAgICAgICByZXR1cm4gc3RhdGUuUHJlYy5sb3dlc3Qoc3R5bGVNb2R1bGUub2YoYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCBzcGVjLCBsaWdodERhcmtJRHMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIGFuIGVkaXRvciB2aWV3IGluc3RhbmNlIGZyb20gdGhlIHZpZXcncyBET01cbiAgICByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kRnJvbURPTShkb20pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY29udGVudCA9IGRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLWNvbnRlbnRcIik7XG4gICAgICAgIGxldCBjVmlldyA9IGNvbnRlbnQgJiYgQ29udGVudFZpZXcuZ2V0KGNvbnRlbnQpIHx8IENvbnRlbnRWaWV3LmdldChkb20pO1xuICAgICAgICByZXR1cm4gKChfYSA9IGNWaWV3ID09PSBudWxsIHx8IGNWaWV3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjVmlldy5yb290VmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpZXcpIHx8IG51bGw7XG4gICAgfVxufVxuLyoqXG5GYWNldCB0byBhZGQgYSBbc3R5bGVcbm1vZHVsZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pIHRvXG5hbiBlZGl0b3Igdmlldy4gVGhlIHZpZXcgd2lsbCBlbnN1cmUgdGhhdCB0aGUgbW9kdWxlIGlzXG5tb3VudGVkIGluIGl0cyBbZG9jdW1lbnRcbnJvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnN0cnVjdG9yXmNvbmZpZy5yb290KS5cbiovXG5FZGl0b3JWaWV3LnN0eWxlTW9kdWxlID0gc3R5bGVNb2R1bGU7XG4vKipcbkFuIGlucHV0IGhhbmRsZXIgY2FuIG92ZXJyaWRlIHRoZSB3YXkgY2hhbmdlcyB0byB0aGUgZWRpdGFibGVcbkRPTSBjb250ZW50IGFyZSBoYW5kbGVkLiBIYW5kbGVycyBhcmUgcGFzc2VkIHRoZSBkb2N1bWVudFxucG9zaXRpb25zIGJldHdlZW4gd2hpY2ggdGhlIGNoYW5nZSB3YXMgZm91bmQsIGFuZCB0aGUgbmV3XG5jb250ZW50LiBXaGVuIG9uZSByZXR1cm5zIHRydWUsIG5vIGZ1cnRoZXIgaW5wdXQgaGFuZGxlcnMgYXJlXG5jYWxsZWQgYW5kIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHByZXZlbnRlZC5cblxuVGhlIGBpbnNlcnRgIGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIGdldCB0aGUgZGVmYXVsdCB0cmFuc2FjdGlvblxudGhhdCB3b3VsZCBiZSBhcHBsaWVkIGZvciB0aGlzIGlucHV0LiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlblxuZGlzcGF0Y2hpbmcgdGhlIGN1c3RvbSBiZWhhdmlvciBhcyBhIHNlcGFyYXRlIHRyYW5zYWN0aW9uLlxuKi9cbkVkaXRvclZpZXcuaW5wdXRIYW5kbGVyID0gaW5wdXRIYW5kbGVyO1xuLyoqXG5GdW5jdGlvbnMgcHJvdmlkZWQgaW4gdGhpcyBmYWNldCB3aWxsIGJlIHVzZWQgdG8gdHJhbnNmb3JtIHRleHRcbnBhc3RlZCBvciBkcm9wcGVkIGludG8gdGhlIGVkaXRvci5cbiovXG5FZGl0b3JWaWV3LmNsaXBib2FyZElucHV0RmlsdGVyID0gY2xpcGJvYXJkSW5wdXRGaWx0ZXI7XG4vKipcblRyYW5zZm9ybSB0ZXh0IGNvcGllZCBvciBkcmFnZ2VkIGZyb20gdGhlIGVkaXRvci5cbiovXG5FZGl0b3JWaWV3LmNsaXBib2FyZE91dHB1dEZpbHRlciA9IGNsaXBib2FyZE91dHB1dEZpbHRlcjtcbi8qKlxuU2Nyb2xsIGhhbmRsZXJzIGNhbiBvdmVycmlkZSBob3cgdGhpbmdzIGFyZSBzY3JvbGxlZCBpbnRvIHZpZXcuXG5JZiB0aGV5IHJldHVybiBgdHJ1ZWAsIG5vIGZ1cnRoZXIgaGFuZGxpbmcgaGFwcGVucyBmb3IgdGhlXG5zY3JvbGxpbmcuIElmIHRoZXkgcmV0dXJuIGZhbHNlLCB0aGUgZGVmYXVsdCBzY3JvbGwgYmVoYXZpb3IgaXNcbmFwcGxpZWQuIFNjcm9sbCBoYW5kbGVycyBzaG91bGQgbmV2ZXIgaW5pdGlhdGUgZWRpdG9yIHVwZGF0ZXMuXG4qL1xuRWRpdG9yVmlldy5zY3JvbGxIYW5kbGVyID0gc2Nyb2xsSGFuZGxlcjtcbi8qKlxuVGhpcyBmYWNldCBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGZ1bmN0aW9ucyB0aGF0IGNyZWF0ZSBlZmZlY3RzXG50byBiZSBkaXNwYXRjaGVkIHdoZW4gdGhlIGVkaXRvcidzIGZvY3VzIHN0YXRlIGNoYW5nZXMuXG4qL1xuRWRpdG9yVmlldy5mb2N1c0NoYW5nZUVmZmVjdCA9IGZvY3VzQ2hhbmdlRWZmZWN0O1xuLyoqXG5CeSBkZWZhdWx0LCB0aGUgZWRpdG9yIGFzc3VtZXMgYWxsIGl0cyBjb250ZW50IGhhcyB0aGUgc2FtZVxuW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGlyZWN0aW9uKS4gQ29uZmlndXJlIHRoaXMgd2l0aCBhIGB0cnVlYFxudmFsdWUgdG8gbWFrZSBpdCByZWFkIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiBldmVyeSAocmVuZGVyZWQpXG5saW5lIHNlcGFyYXRlbHkuXG4qL1xuRWRpdG9yVmlldy5wZXJMaW5lVGV4dERpcmVjdGlvbiA9IHBlckxpbmVUZXh0RGlyZWN0aW9uO1xuLyoqXG5BbGxvd3MgeW91IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGVcbmxpYnJhcnkgY2F0Y2hlcyBhbiBleGNlcHRpb24gZnJvbSBhbiBleHRlbnNpb24gKG1vc3RseSBmcm9tIHZpZXdcbnBsdWdpbnMsIGJ1dCBtYXkgYmUgdXNlZCBieSBvdGhlciBleHRlbnNpb25zIHRvIHJvdXRlIGV4Y2VwdGlvbnNcbmZyb20gdXNlci1jb2RlLXByb3ZpZGVkIGNhbGxiYWNrcykuIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3JcbmRlYnVnZ2luZyBhbmQgbG9nZ2luZy4gU2VlIFtgbG9nRXhjZXB0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmxvZ0V4Y2VwdGlvbikuXG4qL1xuRWRpdG9yVmlldy5leGNlcHRpb25TaW5rID0gZXhjZXB0aW9uU2luaztcbi8qKlxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZ2lzdGVyIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5ldmVyeSB0aW1lIHRoZSB2aWV3IHVwZGF0ZXMuXG4qL1xuRWRpdG9yVmlldy51cGRhdGVMaXN0ZW5lciA9IHVwZGF0ZUxpc3RlbmVyO1xuLyoqXG5GYWNldCB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgdGhlIGVkaXRvciBjb250ZW50IERPTSBpcyBlZGl0YWJsZS5cbldoZW4gaXRzIGhpZ2hlc3QtcHJlY2VkZW5jZSB2YWx1ZSBpcyBgZmFsc2VgLCB0aGUgZWxlbWVudCB3aWxsXG5ub3QgaGF2ZSBpdHMgYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIHNldC4gKE5vdGUgdGhhdCB0aGlzXG5kb2Vzbid0IGFmZmVjdCBBUEkgY2FsbHMgdGhhdCBjaGFuZ2UgdGhlIGVkaXRvciBjb250ZW50LCBldmVuXG53aGVuIHRob3NlIGFyZSBib3VuZCB0byBrZXlzIG9yIGJ1dHRvbnMuIFNlZSB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBmYWNldCBmb3IgdGhhdC4pXG4qL1xuRWRpdG9yVmlldy5lZGl0YWJsZSA9IGVkaXRhYmxlO1xuLyoqXG5BbGxvd3MgeW91IHRvIGluZmx1ZW5jZSB0aGUgd2F5IG1vdXNlIHNlbGVjdGlvbiBoYXBwZW5zLiBUaGVcbmZ1bmN0aW9ucyBpbiB0aGlzIGZhY2V0IHdpbGwgYmUgY2FsbGVkIGZvciBhIGBtb3VzZWRvd25gIGV2ZW50XG5vbiB0aGUgZWRpdG9yLCBhbmQgY2FuIHJldHVybiBhbiBvYmplY3QgdGhhdCBvdmVycmlkZXMgdGhlIHdheSBhXG5zZWxlY3Rpb24gaXMgY29tcHV0ZWQgZnJvbSB0aGF0IG1vdXNlIGNsaWNrIG9yIGRyYWcuXG4qL1xuRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlID0gbW91c2VTZWxlY3Rpb25TdHlsZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGlvbiBkcmFnIGV2ZW50XG5zaG91bGQgbW92ZSBvciBjb3B5IHRoZSBzZWxlY3Rpb24uIFRoZSBnaXZlbiBwcmVkaWNhdGUgd2lsbCBiZVxuY2FsbGVkIHdpdGggdGhlIGBtb3VzZWRvd25gIGV2ZW50LCBhbmQgY2FuIHJldHVybiBgdHJ1ZWAgd2hlblxudGhlIGRyYWcgc2hvdWxkIG1vdmUgdGhlIGNvbnRlbnQuXG4qL1xuRWRpdG9yVmlldy5kcmFnTW92ZXNTZWxlY3Rpb24gPSBkcmFnTW92ZXNTZWxlY3Rpb24kMTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGluZyBjbGljayBhZGRzIGFcbm5ldyByYW5nZSB0byB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uIG9yIHJlcGxhY2VzIGl0IGVudGlyZWx5LiBUaGVcbmRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gY2hlY2sgYGV2ZW50Lm1ldGFLZXlgIG9uIG1hY09TLCBhbmRcbmBldmVudC5jdHJsS2V5YCBlbHNld2hlcmUuXG4qL1xuRWRpdG9yVmlldy5jbGlja0FkZHNTZWxlY3Rpb25SYW5nZSA9IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlO1xuLyoqXG5BIGZhY2V0IHRoYXQgZGV0ZXJtaW5lcyB3aGljaCBbZGVjb3JhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKVxuYXJlIHNob3duIGluIHRoZSB2aWV3LiBEZWNvcmF0aW9ucyBjYW4gYmUgcHJvdmlkZWQgaW4gdHdvXG53YXlz4oCUZGlyZWN0bHksIG9yIHZpYSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gZWRpdG9yIHZpZXcuXG5cbk9ubHkgZGVjb3JhdGlvbiBzZXRzIHByb3ZpZGVkIGRpcmVjdGx5IGFyZSBhbGxvd2VkIHRvIGluZmx1ZW5jZVxudGhlIGVkaXRvcidzIHZlcnRpY2FsIGxheW91dCBzdHJ1Y3R1cmUuIFRoZSBvbmVzIHByb3ZpZGVkIGFzXG5mdW5jdGlvbnMgYXJlIGNhbGxlZCBfYWZ0ZXJfIHRoZSBuZXcgdmlld3BvcnQgaGFzIGJlZW4gY29tcHV0ZWQsXG5hbmQgdGh1cyAqKm11c3Qgbm90KiogaW50cm9kdWNlIGJsb2NrIHdpZGdldHMgb3IgcmVwbGFjaW5nXG5kZWNvcmF0aW9ucyB0aGF0IGNvdmVyIGxpbmUgYnJlYWtzLlxuXG5JZiB5b3Ugd2FudCBkZWNvcmF0ZWQgcmFuZ2VzIHRvIGJlaGF2ZSBsaWtlIGF0b21pYyB1bml0cyBmb3JcbmN1cnNvciBtb3Rpb24gYW5kIGRlbGV0aW9uIHB1cnBvc2VzLCBhbHNvIHByb3ZpZGUgdGhlIHJhbmdlIHNldFxuY29udGFpbmluZyB0aGUgZGVjb3JhdGlvbnMgdG9cbltgRWRpdG9yVmlldy5hdG9taWNSYW5nZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15hdG9taWNSYW5nZXMpLlxuKi9cbkVkaXRvclZpZXcuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbi8qKlxuRmFjZXQgdGhhdCB3b3JrcyBtdWNoIGxpa2VcbltgZGVjb3JhdGlvbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucyksIGJ1dCBwdXRzIGl0c1xuaW5wdXRzIGF0IHRoZSB2ZXJ5IGJvdHRvbSBvZiB0aGUgcHJlY2VkZW5jZSBzdGFjaywgbWVhbmluZyBtYXJrXG5kZWNvcmF0aW9ucyBwcm92aWRlZCBoZXJlIHdpbGwgb25seSBiZSBzcGxpdCBieSBvdGhlciwgcGFydGlhbGx5XG5vdmVybGFwcGluZyBcXGBvdXRlckRlY29yYXRpb25zXFxgIHJhbmdlcywgYW5kIHdyYXAgYXJvdW5kIGFsbFxucmVndWxhciBkZWNvcmF0aW9ucy4gVXNlIHRoaXMgZm9yIG1hcmsgZWxlbWVudHMgdGhhdCBzaG91bGQsIGFzXG5tdWNoIGFzIHBvc3NpYmxlLCByZW1haW4gaW4gb25lIHBpZWNlLlxuKi9cbkVkaXRvclZpZXcub3V0ZXJEZWNvcmF0aW9ucyA9IG91dGVyRGVjb3JhdGlvbnM7XG4vKipcblVzZWQgdG8gcHJvdmlkZSByYW5nZXMgdGhhdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhdG9tcyBhcyBmYXIgYXNcbmN1cnNvciBtb3Rpb24gaXMgY29uY2VybmVkLiBUaGlzIGNhdXNlcyBtZXRob2RzIGxpa2VcbltgbW92ZUJ5Q2hhcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVCeUNoYXIpIGFuZFxuW2Btb3ZlVmVydGljYWxseWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVWZXJ0aWNhbGx5KSAoYW5kIHRoZVxuY29tbWFuZHMgYnVpbHQgb24gdG9wIG9mIHRoZW0pIHRvIHNraXAgYWNyb3NzIHN1Y2ggcmVnaW9ucyB3aGVuXG5hIHNlbGVjdGlvbiBlbmRwb2ludCB3b3VsZCBlbnRlciB0aGVtLiBUaGlzIGRvZXMgX25vdF8gcHJldmVudFxuZGlyZWN0IHByb2dyYW1tYXRpYyBbc2VsZWN0aW9uXG51cGRhdGVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGZyb20gbW92aW5nIGludG8gc3VjaFxucmVnaW9ucy5cbiovXG5FZGl0b3JWaWV3LmF0b21pY1JhbmdlcyA9IGF0b21pY1Jhbmdlcztcbi8qKlxuV2hlbiByYW5nZSBkZWNvcmF0aW9ucyBhZGQgYSBgdW5pY29kZS1iaWRpOiBpc29sYXRlYCBzdHlsZSwgdGhleVxuc2hvdWxkIGFsc28gaW5jbHVkZSBhXG5bYGJpZGlJc29sYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lk1hcmtEZWNvcmF0aW9uU3BlYy5iaWRpSXNvbGF0ZSkgcHJvcGVydHlcbmluIHRoZWlyIGRlY29yYXRpb24gc3BlYywgYW5kIGJlIGV4cG9zZWQgdGhyb3VnaCB0aGlzIGZhY2V0LCBzb1xudGhhdCB0aGUgZWRpdG9yIGNhbiBjb21wdXRlIHRoZSBwcm9wZXIgdGV4dCBvcmRlci4gKE90aGVyIHZhbHVlc1xuZm9yIGB1bmljb2RlLWJpZGlgLCBleGNlcHQgb2YgY291cnNlIGBub3JtYWxgLCBhcmUgbm90XG5zdXBwb3J0ZWQuKVxuKi9cbkVkaXRvclZpZXcuYmlkaUlzb2xhdGVkUmFuZ2VzID0gYmlkaUlzb2xhdGVkUmFuZ2VzO1xuLyoqXG5GYWNldCB0aGF0IGFsbG93cyBleHRlbnNpb25zIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBzY3JvbGxcbm1hcmdpbnMgKHNwYWNlIGFyb3VuZCB0aGUgc2lkZXMgb2YgdGhlIHNjcm9sbGluZyBlbGVtZW50IHRoYXRcbnNob3VsZCBiZSBjb25zaWRlcmVkIGludmlzaWJsZSkuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZVxucGx1Z2luIGludHJvZHVjZXMgZWxlbWVudHMgdGhhdCBjb3ZlciBwYXJ0IG9mIHRoYXQgZWxlbWVudCAoZm9yXG5leGFtcGxlIGEgaG9yaXpvbnRhbGx5IGZpeGVkIGd1dHRlcikuXG4qL1xuRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zID0gc2Nyb2xsTWFyZ2lucztcbi8qKlxuVGhpcyBmYWNldCByZWNvcmRzIHdoZXRoZXIgYSBkYXJrIHRoZW1lIGlzIGFjdGl2ZS4gVGhlIGV4dGVuc2lvblxucmV0dXJuZWQgYnkgW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSBhdXRvbWF0aWNhbGx5XG5pbmNsdWRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIHdoZW4gdGhlIGBkYXJrYCBvcHRpb24gaXMgc2V0IHRvXG50cnVlLlxuKi9cbkVkaXRvclZpZXcuZGFya1RoZW1lID0gZGFya1RoZW1lO1xuLyoqXG5Qcm92aWRlcyBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IG5vbmNlIHRvIHVzZSB3aGVuIGNyZWF0aW5nXG50aGUgc3R5bGUgc2hlZXRzIGZvciB0aGUgZWRpdG9yLiBIb2xkcyB0aGUgZW1wdHkgc3RyaW5nIHdoZW4gbm9cbm5vbmNlIGhhcyBiZWVuIHByb3ZpZGVkLlxuKi9cbkVkaXRvclZpZXcuY3NwTm9uY2UgPSBzdGF0ZS5GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IFwiXCIgfSk7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgYWRkaXRpb25hbCBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzXG5lZGl0YWJsZSBET00gZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzID0gY29udGVudEF0dHJpYnV0ZXM7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3IncyBvdXRlclxuZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmVkaXRvckF0dHJpYnV0ZXMgPSBlZGl0b3JBdHRyaWJ1dGVzO1xuLyoqXG5BbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGxpbmUgd3JhcHBpbmcgaW4gdGhlIGVkaXRvciAoYnlcbnNldHRpbmcgQ1NTIGB3aGl0ZS1zcGFjZWAgdG8gYHByZS13cmFwYCBpbiB0aGUgY29udGVudCkuXG4qL1xuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcgPSBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHsgXCJjbGFzc1wiOiBcImNtLWxpbmVXcmFwcGluZ1wiIH0pO1xuLyoqXG5TdGF0ZSBlZmZlY3QgdXNlZCB0byBpbmNsdWRlIHNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50cyBpbiBhXG50cmFuc2FjdGlvbi4gVGhlc2Ugd2lsbCBiZSBhZGRlZCB0byB0aGUgRE9NIGluIGEgdmlzdWFsbHkgaGlkZGVuXG5lbGVtZW50IHdpdGggYGFyaWEtbGl2ZT1cInBvbGl0ZVwiYCBzZXQsIGFuZCBzaG91bGQgYmUgdXNlZCB0b1xuZGVzY3JpYmUgZWZmZWN0cyB0aGF0IGFyZSB2aXN1YWxseSBvYnZpb3VzIGJ1dCBtYXkgbm90IGJlXG5ub3RpY2VkIGJ5IHNjcmVlbiByZWFkZXIgdXNlcnMgKHN1Y2ggYXMgbW92aW5nIHRvIHRoZSBuZXh0XG5zZWFyY2ggbWF0Y2gpLlxuKi9cbkVkaXRvclZpZXcuYW5ub3VuY2UgPSBzdGF0ZS5TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8vIE1heGltdW0gbGluZSBsZW5ndGggZm9yIHdoaWNoIHdlIGNvbXB1dGUgYWNjdXJhdGUgYmlkaSBpbmZvXG5jb25zdCBNYXhCaWRpTGluZSA9IDQwOTY7XG5jb25zdCBCYWRNZWFzdXJlID0ge307XG5jbGFzcyBDYWNoZWRPcmRlciB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpciwgaXNvbGF0ZXMsIGZyZXNoLCBvcmRlcikge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLmlzb2xhdGVzID0gaXNvbGF0ZXM7XG4gICAgICAgIHRoaXMuZnJlc2ggPSBmcmVzaDtcbiAgICAgICAgdGhpcy5vcmRlciA9IG9yZGVyO1xuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlKGNhY2hlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmVtcHR5ICYmICFjYWNoZS5zb21lKGMgPT4gYy5mcmVzaCkpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgbGFzdERpciA9IGNhY2hlLmxlbmd0aCA/IGNhY2hlW2NhY2hlLmxlbmd0aCAtIDFdLmRpciA6IGV4cG9ydHMuRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGgubWF4KDAsIGNhY2hlLmxlbmd0aCAtIDEwKTsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSBjYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5kaXIgPT0gbGFzdERpciAmJiAhY2hhbmdlcy50b3VjaGVzUmFuZ2UoZW50cnkuZnJvbSwgZW50cnkudG8pKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBDYWNoZWRPcmRlcihjaGFuZ2VzLm1hcFBvcyhlbnRyeS5mcm9tLCAxKSwgY2hhbmdlcy5tYXBQb3MoZW50cnkudG8sIC0xKSwgZW50cnkuZGlyLCBlbnRyeS5pc29sYXRlcywgZmFsc2UsIGVudHJ5Lm9yZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyc0Zyb21GYWNldCh2aWV3LCBmYWNldCwgYmFzZSkge1xuICAgIGZvciAobGV0IHNvdXJjZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGZhY2V0KSwgaSA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHNvdXJjZXNbaV0sIHZhbHVlID0gdHlwZW9mIHNvdXJjZSA9PSBcImZ1bmN0aW9uXCIgPyBzb3VyY2UodmlldykgOiBzb3VyY2U7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGNvbWJpbmVBdHRycyh2YWx1ZSwgYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xufVxuXG5jb25zdCBjdXJyZW50UGxhdGZvcm0gPSBicm93c2VyLm1hYyA/IFwibWFjXCIgOiBicm93c2VyLndpbmRvd3MgPyBcIndpblwiIDogYnJvd3Nlci5saW51eCA/IFwibGludXhcIiA6IFwia2V5XCI7XG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUsIHBsYXRmb3JtKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpXG4gICAgICAgIHJlc3VsdCA9IFwiIFwiO1xuICAgIGxldCBhbHQsIGN0cmwsIHNoaWZ0LCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtID09IFwibWFjXCIpXG4gICAgICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcbiAgICB9XG4gICAgaWYgKGFsdClcbiAgICAgICAgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XG4gICAgaWYgKGN0cmwpXG4gICAgICAgIHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgcmVzdWx0ID0gXCJNZXRhLVwiICsgcmVzdWx0O1xuICAgIGlmIChzaGlmdClcbiAgICAgICAgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCkge1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTtcbiAgICBpZiAoc2hpZnQgIT09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5jb25zdCBoYW5kbGVLZXlFdmVudHMgPSBzdGF0ZS5QcmVjLmRlZmF1bHQoRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICBrZXlkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBcImVkaXRvclwiKTtcbiAgICB9XG59KSk7XG4vKipcbkZhY2V0IHVzZWQgZm9yIHJlZ2lzdGVyaW5nIGtleW1hcHMuXG5cbllvdSBjYW4gYWRkIG11bHRpcGxlIGtleW1hcHMgdG8gYW4gZWRpdG9yLiBUaGVpciBwcmlvcml0aWVzXG5kZXRlcm1pbmUgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgc3BlY2lmaWVkIGVhcmx5IG9yIHdpdGggaGlnaFxucHJpb3JpdHkgZ2V0IGNoZWNrZWQgZmlyc3QpLiBXaGVuIGEgaGFuZGxlciBoYXMgcmV0dXJuZWQgYHRydWVgXG5mb3IgYSBnaXZlbiBrZXksIG5vIGZ1cnRoZXIgaGFuZGxlcnMgYXJlIGNhbGxlZC5cbiovXG5jb25zdCBrZXltYXAgPSBzdGF0ZS5GYWNldC5kZWZpbmUoeyBlbmFibGVzOiBoYW5kbGVLZXlFdmVudHMgfSk7XG5jb25zdCBLZXltYXBzID0gbmV3IFdlYWtNYXAoKTtcbi8vIFRoaXMgaXMgaGlkZGVuIGJlaGluZCBhbiBpbmRpcmVjdGlvbiwgcmF0aGVyIHRoYW4gZGlyZWN0bHkgY29tcHV0ZWRcbi8vIGJ5IHRoZSBmYWNldCwgdG8ga2VlcCBpbnRlcm5hbCB0eXBlcyBvdXQgb2YgdGhlIGZhY2V0J3MgdHlwZS5cbmZ1bmN0aW9uIGdldEtleW1hcChzdGF0ZSkge1xuICAgIGxldCBiaW5kaW5ncyA9IHN0YXRlLmZhY2V0KGtleW1hcCk7XG4gICAgbGV0IG1hcCA9IEtleW1hcHMuZ2V0KGJpbmRpbmdzKTtcbiAgICBpZiAoIW1hcClcbiAgICAgICAgS2V5bWFwcy5zZXQoYmluZGluZ3MsIG1hcCA9IGJ1aWxkS2V5bWFwKGJpbmRpbmdzLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKSkpO1xuICAgIHJldHVybiBtYXA7XG59XG4vKipcblJ1biB0aGUga2V5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gc2NvcGUuIFRoZSBldmVudFxub2JqZWN0IHNob3VsZCBiZSBhIGBcImtleWRvd25cImAgZXZlbnQuIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlXG5oYW5kbGVycyBoYW5kbGVkIGl0LlxuKi9cbmZ1bmN0aW9uIHJ1blNjb3BlSGFuZGxlcnModmlldywgZXZlbnQsIHNjb3BlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIHNjb3BlKTtcbn1cbmxldCBzdG9yZWRQcmVmaXggPSBudWxsO1xuY29uc3QgUHJlZml4VGltZW91dCA9IDQwMDA7XG5mdW5jdGlvbiBidWlsZEtleW1hcChiaW5kaW5ncywgcGxhdGZvcm0gPSBjdXJyZW50UGxhdGZvcm0pIHtcbiAgICBsZXQgYm91bmQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBpc1ByZWZpeCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNoZWNrUHJlZml4ID0gKG5hbWUsIGlzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gaXNQcmVmaXhbbmFtZV07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG51bGwpXG4gICAgICAgICAgICBpc1ByZWZpeFtuYW1lXSA9IGlzO1xuICAgICAgICBlbHNlIGlmIChjdXJyZW50ICE9IGlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGJpbmRpbmcgXCIgKyBuYW1lICsgXCIgaXMgdXNlZCBib3RoIGFzIGEgcmVndWxhciBiaW5kaW5nIGFuZCBhcyBhIG11bHRpLXN0cm9rZSBwcmVmaXhcIik7XG4gICAgfTtcbiAgICBsZXQgYWRkID0gKHNjb3BlLCBrZXksIGNvbW1hbmQsIHByZXZlbnREZWZhdWx0LCBzdG9wUHJvcGFnYXRpb24pID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHNjb3BlT2JqID0gYm91bmRbc2NvcGVdIHx8IChib3VuZFtzY29wZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgbGV0IHBhcnRzID0ga2V5LnNwbGl0KC8gKD8hJCkvKS5tYXAoayA9PiBub3JtYWxpemVLZXlOYW1lKGssIHBsYXRmb3JtKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwcmVmaXggPSBwYXJ0cy5zbGljZSgwLCBpKS5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIGNoZWNrUHJlZml4KHByZWZpeCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXNjb3BlT2JqW3ByZWZpeF0pXG4gICAgICAgICAgICAgICAgc2NvcGVPYmpbcHJlZml4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJ1bjogWyh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG91ck9iaiA9IHN0b3JlZFByZWZpeCA9IHsgdmlldywgcHJlZml4LCBzY29wZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBpZiAoc3RvcmVkUHJlZml4ID09IG91ck9iailcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDsgfSwgUHJlZml4VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bGwgPSBwYXJ0cy5qb2luKFwiIFwiKTtcbiAgICAgICAgY2hlY2tQcmVmaXgoZnVsbCwgZmFsc2UpO1xuICAgICAgICBsZXQgYmluZGluZyA9IHNjb3BlT2JqW2Z1bGxdIHx8IChzY29wZU9ialtmdWxsXSA9IHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBydW46ICgoX2IgPSAoX2EgPSBzY29wZU9iai5fYW55KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucnVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2xpY2UoKSkgfHwgW11cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb21tYW5kKVxuICAgICAgICAgICAgYmluZGluZy5ydW4ucHVzaChjb21tYW5kKTtcbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgYmluZGluZy5wcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGlmIChzdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICBiaW5kaW5nLnN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgfTtcbiAgICBmb3IgKGxldCBiIG9mIGJpbmRpbmdzKSB7XG4gICAgICAgIGxldCBzY29wZXMgPSBiLnNjb3BlID8gYi5zY29wZS5zcGxpdChcIiBcIikgOiBbXCJlZGl0b3JcIl07XG4gICAgICAgIGlmIChiLmFueSlcbiAgICAgICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZU9iai5fYW55KVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9iai5fYW55ID0geyBwcmV2ZW50RGVmYXVsdDogZmFsc2UsIHN0b3BQcm9wYWdhdGlvbjogZmFsc2UsIHJ1bjogW10gfTtcbiAgICAgICAgICAgICAgICBsZXQgeyBhbnkgfSA9IGI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHNjb3BlT2JqKVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9ialtrZXldLnJ1bi5wdXNoKHZpZXcgPT4gYW55KHZpZXcsIGN1cnJlbnRLZXlFdmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZSA9IGJbcGxhdGZvcm1dIHx8IGIua2V5O1xuICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgICAgICAgICBhZGQoc2NvcGUsIG5hbWUsIGIucnVuLCBiLnByZXZlbnREZWZhdWx0LCBiLnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgICAgICBpZiAoYi5zaGlmdClcbiAgICAgICAgICAgICAgICBhZGQoc2NvcGUsIFwiU2hpZnQtXCIgKyBuYW1lLCBiLnNoaWZ0LCBiLnByZXZlbnREZWZhdWx0LCBiLnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kO1xufVxubGV0IGN1cnJlbnRLZXlFdmVudCA9IG51bGw7XG5mdW5jdGlvbiBydW5IYW5kbGVycyhtYXAsIGV2ZW50LCB2aWV3LCBzY29wZSkge1xuICAgIGN1cnJlbnRLZXlFdmVudCA9IGV2ZW50O1xuICAgIGxldCBuYW1lID0gdzNjS2V5bmFtZS5rZXlOYW1lKGV2ZW50KTtcbiAgICBsZXQgY2hhckNvZGUgPSBzdGF0ZS5jb2RlUG9pbnRBdChuYW1lLCAwKSwgaXNDaGFyID0gc3RhdGUuY29kZVBvaW50U2l6ZShjaGFyQ29kZSkgPT0gbmFtZS5sZW5ndGggJiYgbmFtZSAhPSBcIiBcIjtcbiAgICBsZXQgcHJlZml4ID0gXCJcIiwgaGFuZGxlZCA9IGZhbHNlLCBwcmV2ZW50ZWQgPSBmYWxzZSwgc3RvcFByb3BhZ2F0aW9uID0gZmFsc2U7XG4gICAgaWYgKHN0b3JlZFByZWZpeCAmJiBzdG9yZWRQcmVmaXgudmlldyA9PSB2aWV3ICYmIHN0b3JlZFByZWZpeC5zY29wZSA9PSBzY29wZSkge1xuICAgICAgICBwcmVmaXggPSBzdG9yZWRQcmVmaXgucHJlZml4ICsgXCIgXCI7XG4gICAgICAgIGlmIChtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKSB7XG4gICAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuID0gbmV3IFNldDtcbiAgICBsZXQgcnVuRm9yID0gKGJpbmRpbmcpID0+IHtcbiAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNtZCBvZiBiaW5kaW5nLnJ1bilcbiAgICAgICAgICAgICAgICBpZiAoIXJhbi5oYXMoY21kKSkge1xuICAgICAgICAgICAgICAgICAgICByYW4uYWRkKGNtZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWQodmlldykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaW5kaW5nLnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmluZGluZy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGlmIChiaW5kaW5nLnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGxldCBzY29wZU9iaiA9IG1hcFtzY29wZV0sIGJhc2VOYW1lLCBzaGlmdE5hbWU7XG4gICAgaWYgKHNjb3BlT2JqKSB7XG4gICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCAhaXNDaGFyKV0pKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NoYXIgJiYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpICYmXG4gICAgICAgICAgICAvLyBDdHJsLUFsdCBtYXkgYmUgdXNlZCBmb3IgQWx0R3Igb24gV2luZG93c1xuICAgICAgICAgICAgIShicm93c2VyLndpbmRvd3MgJiYgZXZlbnQuY3RybEtleSAmJiBldmVudC5hbHRLZXkpICYmXG4gICAgICAgICAgICAoYmFzZU5hbWUgPSB3M2NLZXluYW1lLmJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKGJhc2VOYW1lLCBldmVudCwgdHJ1ZSldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgKHNoaWZ0TmFtZSA9IHczY0tleW5hbWUuc2hpZnRbZXZlbnQua2V5Q29kZV0pICE9IG5hbWUgJiYgc2hpZnROYW1lICE9IGJhc2VOYW1lICYmXG4gICAgICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhzaGlmdE5hbWUsIGV2ZW50LCBmYWxzZSldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hhciAmJiBldmVudC5zaGlmdEtleSAmJlxuICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgdHJ1ZSldKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVkICYmIHJ1bkZvcihzY29wZU9iai5fYW55KSlcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJldmVudGVkKVxuICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICBpZiAoaGFuZGxlZCAmJiBzdG9wUHJvcGFnYXRpb24pXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGN1cnJlbnRLZXlFdmVudCA9IG51bGw7XG4gICAgcmV0dXJuIGhhbmRsZWQ7XG59XG5cbi8qKlxuSW1wbGVtZW50YXRpb24gb2YgW2BMYXllck1hcmtlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5MYXllck1hcmtlcikgdGhhdCBjcmVhdGVzXG5hIHJlY3RhbmdsZSBhdCBhIGdpdmVuIHNldCBvZiBjb29yZGluYXRlcy5cbiovXG5jbGFzcyBSZWN0YW5nbGVNYXJrZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmtlciB3aXRoIHRoZSBnaXZlbiBjbGFzcyBhbmQgZGltZW5zaW9ucy4gSWYgYHdpZHRoYFxuICAgIGlzIG51bGwsIHRoZSBET00gZWxlbWVudCB3aWxsIGdldCBubyB3aWR0aCBzdHlsZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsYXNzTmFtZSwgXG4gICAgLyoqXG4gICAgVGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIG1hcmtlciAoaW4gcGl4ZWxzLCBkb2N1bWVudC1yZWxhdGl2ZSkuXG4gICAgKi9cbiAgICBsZWZ0LCBcbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXG4gICAgKi9cbiAgICB0b3AsIFxuICAgIC8qKlxuICAgIFRoZSB3aWR0aCBvZiB0aGUgbWFya2VyLCBvciBudWxsIGlmIGl0IHNob3VsZG4ndCBnZXQgYSB3aWR0aCBhc3NpZ25lZC5cbiAgICAqL1xuICAgIHdpZHRoLCBcbiAgICAvKipcbiAgICBUaGUgaGVpZ2h0IG9mIHRoZSBtYXJrZXIuXG4gICAgKi9cbiAgICBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmFkanVzdChlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICB1cGRhdGUoZWx0LCBwcmV2KSB7XG4gICAgICAgIGlmIChwcmV2LmNsYXNzTmFtZSAhPSB0aGlzLmNsYXNzTmFtZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFkanVzdChlbHQpIHtcbiAgICAgICAgZWx0LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS50b3AgPSB0aGlzLnRvcCArIFwicHhcIjtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT0gbnVsbClcbiAgICAgICAgICAgIGVsdC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICB9XG4gICAgZXEocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0ID09IHAubGVmdCAmJiB0aGlzLnRvcCA9PSBwLnRvcCAmJiB0aGlzLndpZHRoID09IHAud2lkdGggJiYgdGhpcy5oZWlnaHQgPT0gcC5oZWlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID09IHAuY2xhc3NOYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgcmVjdGFuZ2xlcyBmb3IgdGhlIGdpdmVuIHNlbGVjdGlvbiByYW5nZSxcbiAgICBhc3NpZ25pbmcgdGhlbSB0aGVjbGFzc2BjbGFzc05hbWVgLiBXaWxsIGNyZWF0ZSBhIHNpbmdsZVxuICAgIHJlY3RhbmdsZSBmb3IgZW1wdHkgcmFuZ2VzLCBhbmQgYSBzZXQgb2Ygc2VsZWN0aW9uLXN0eWxlXG4gICAgcmVjdGFuZ2xlcyBjb3ZlcmluZyB0aGUgcmFuZ2UncyBjb250ZW50IChpbiBhIGJpZGktYXdhcmVcbiAgICB3YXkpIGZvciBub24tZW1wdHkgb25lcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHZpZXcuY29vcmRzQXRQb3MocmFuZ2UuaGVhZCwgcmFuZ2UuYXNzb2MgfHwgMSk7XG4gICAgICAgICAgICBpZiAoIXBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBwb3MubGVmdCAtIGJhc2UubGVmdCwgcG9zLnRvcCAtIGJhc2UudG9wLCBudWxsLCBwb3MuYm90dG9tIC0gcG9zLnRvcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RhbmdsZXNGb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEJhc2Uodmlldykge1xuICAgIGxldCByZWN0ID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGxlZnQgPSB2aWV3LnRleHREaXJlY3Rpb24gPT0gZXhwb3J0cy5EaXJlY3Rpb24uTFRSID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodCAtIHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoICogdmlldy5zY2FsZVg7XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgKiB2aWV3LnNjYWxlWCwgdG9wOiByZWN0LnRvcCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHZpZXcuc2NhbGVZIH07XG59XG5mdW5jdGlvbiB3cmFwcGVkTGluZSh2aWV3LCBwb3MsIHNpZGUsIGluc2lkZSkge1xuICAgIGxldCBjb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcywgc2lkZSAqIDIpO1xuICAgIGlmICghY29vcmRzKVxuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgIGxldCBlZGl0b3JSZWN0ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHkgPSAoY29vcmRzLnRvcCArIGNvb3Jkcy5ib3R0b20pIC8gMjtcbiAgICBsZXQgbGVmdCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBlZGl0b3JSZWN0LmxlZnQgKyAxLCB5IH0pO1xuICAgIGxldCByaWdodCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBlZGl0b3JSZWN0LnJpZ2h0IC0gMSwgeSB9KTtcbiAgICBpZiAobGVmdCA9PSBudWxsIHx8IHJpZ2h0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgcmV0dXJuIHsgZnJvbTogTWF0aC5tYXgoaW5zaWRlLmZyb20sIE1hdGgubWluKGxlZnQsIHJpZ2h0KSksIHRvOiBNYXRoLm1pbihpbnNpZGUudG8sIE1hdGgubWF4KGxlZnQsIHJpZ2h0KSkgfTtcbn1cbmZ1bmN0aW9uIHJlY3RhbmdsZXNGb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnRvIDw9IHZpZXcudmlld3BvcnQuZnJvbSB8fCByYW5nZS5mcm9tID49IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHJhbmdlLmZyb20sIHZpZXcudmlld3BvcnQuZnJvbSksIHRvID0gTWF0aC5taW4ocmFuZ2UudG8sIHZpZXcudmlld3BvcnQudG8pO1xuICAgIGxldCBsdHIgPSB2aWV3LnRleHREaXJlY3Rpb24gPT0gZXhwb3J0cy5EaXJlY3Rpb24uTFRSO1xuICAgIGxldCBjb250ZW50ID0gdmlldy5jb250ZW50RE9NLCBjb250ZW50UmVjdCA9IGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgIGxldCBsaW5lRWx0ID0gY29udGVudC5xdWVyeVNlbGVjdG9yKFwiLmNtLWxpbmVcIiksIGxpbmVTdHlsZSA9IGxpbmVFbHQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUobGluZUVsdCk7XG4gICAgbGV0IGxlZnRTaWRlID0gY29udGVudFJlY3QubGVmdCArXG4gICAgICAgIChsaW5lU3R5bGUgPyBwYXJzZUludChsaW5lU3R5bGUucGFkZGluZ0xlZnQpICsgTWF0aC5taW4oMCwgcGFyc2VJbnQobGluZVN0eWxlLnRleHRJbmRlbnQpKSA6IDApO1xuICAgIGxldCByaWdodFNpZGUgPSBjb250ZW50UmVjdC5yaWdodCAtIChsaW5lU3R5bGUgPyBwYXJzZUludChsaW5lU3R5bGUucGFkZGluZ1JpZ2h0KSA6IDApO1xuICAgIGxldCBzdGFydEJsb2NrID0gYmxvY2tBdCh2aWV3LCBmcm9tKSwgZW5kQmxvY2sgPSBibG9ja0F0KHZpZXcsIHRvKTtcbiAgICBsZXQgdmlzdWFsU3RhcnQgPSBzdGFydEJsb2NrLnR5cGUgPT0gZXhwb3J0cy5CbG9ja1R5cGUuVGV4dCA/IHN0YXJ0QmxvY2sgOiBudWxsO1xuICAgIGxldCB2aXN1YWxFbmQgPSBlbmRCbG9jay50eXBlID09IGV4cG9ydHMuQmxvY2tUeXBlLlRleHQgPyBlbmRCbG9jayA6IG51bGw7XG4gICAgaWYgKHZpc3VhbFN0YXJ0ICYmICh2aWV3LmxpbmVXcmFwcGluZyB8fCBzdGFydEJsb2NrLndpZGdldExpbmVCcmVha3MpKVxuICAgICAgICB2aXN1YWxTdGFydCA9IHdyYXBwZWRMaW5lKHZpZXcsIGZyb20sIDEsIHZpc3VhbFN0YXJ0KTtcbiAgICBpZiAodmlzdWFsRW5kICYmICh2aWV3LmxpbmVXcmFwcGluZyB8fCBlbmRCbG9jay53aWRnZXRMaW5lQnJlYWtzKSlcbiAgICAgICAgdmlzdWFsRW5kID0gd3JhcHBlZExpbmUodmlldywgdG8sIC0xLCB2aXN1YWxFbmQpO1xuICAgIGlmICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgJiYgdmlzdWFsU3RhcnQuZnJvbSA9PSB2aXN1YWxFbmQuZnJvbSAmJiB2aXN1YWxTdGFydC50byA9PSB2aXN1YWxFbmQudG8pIHtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyhkcmF3Rm9yTGluZShyYW5nZS5mcm9tLCByYW5nZS50bywgdmlzdWFsU3RhcnQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB0b3AgPSB2aXN1YWxTdGFydCA/IGRyYXdGb3JMaW5lKHJhbmdlLmZyb20sIG51bGwsIHZpc3VhbFN0YXJ0KSA6IGRyYXdGb3JXaWRnZXQoc3RhcnRCbG9jaywgZmFsc2UpO1xuICAgICAgICBsZXQgYm90dG9tID0gdmlzdWFsRW5kID8gZHJhd0ZvckxpbmUobnVsbCwgcmFuZ2UudG8sIHZpc3VhbEVuZCkgOiBkcmF3Rm9yV2lkZ2V0KGVuZEJsb2NrLCB0cnVlKTtcbiAgICAgICAgbGV0IGJldHdlZW4gPSBbXTtcbiAgICAgICAgaWYgKCh2aXN1YWxTdGFydCB8fCBzdGFydEJsb2NrKS50byA8ICh2aXN1YWxFbmQgfHwgZW5kQmxvY2spLmZyb20gLSAodmlzdWFsU3RhcnQgJiYgdmlzdWFsRW5kID8gMSA6IDApIHx8XG4gICAgICAgICAgICBzdGFydEJsb2NrLndpZGdldExpbmVCcmVha3MgPiAxICYmIHRvcC5ib3R0b20gKyB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC8gMiA8IGJvdHRvbS50b3ApXG4gICAgICAgICAgICBiZXR3ZWVuLnB1c2gocGllY2UobGVmdFNpZGUsIHRvcC5ib3R0b20sIHJpZ2h0U2lkZSwgYm90dG9tLnRvcCkpO1xuICAgICAgICBlbHNlIGlmICh0b3AuYm90dG9tIDwgYm90dG9tLnRvcCAmJiB2aWV3LmVsZW1lbnRBdEhlaWdodCgodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMikudHlwZSA9PSBleHBvcnRzLkJsb2NrVHlwZS5UZXh0KVxuICAgICAgICAgICAgdG9wLmJvdHRvbSA9IGJvdHRvbS50b3AgPSAodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMjtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyh0b3ApLmNvbmNhdChiZXR3ZWVuKS5jb25jYXQocGllY2VzKGJvdHRvbSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZShsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBsZWZ0IC0gYmFzZS5sZWZ0LCB0b3AgLSBiYXNlLnRvcCAtIDAuMDEgLyogQy5FcHNpbG9uICovLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCArIDAuMDEgLyogQy5FcHNpbG9uICovKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2VzKHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfSkge1xuICAgICAgICBsZXQgcGllY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9yaXpvbnRhbC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHBpZWNlKGhvcml6b250YWxbaV0sIHRvcCwgaG9yaXpvbnRhbFtpICsgMV0sIGJvdHRvbSkpO1xuICAgICAgICByZXR1cm4gcGllY2VzO1xuICAgIH1cbiAgICAvLyBHZXRzIHBhc3NlZCBmcm9tL3RvIGluIGxpbmUtbG9jYWwgcG9zaXRpb25zXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUoZnJvbSwgdG8sIGxpbmUpIHtcbiAgICAgICAgbGV0IHRvcCA9IDFlOSwgYm90dG9tID0gLTFlOSwgaG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRTcGFuKGZyb20sIGZyb21PcGVuLCB0bywgdG9PcGVuLCBkaXIpIHtcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgMi8tMiBpcyBhIGtsdWRnZSB0byBmb3JjZSB0aGUgdmlldyB0byByZXR1cm5cbiAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIG9uIHRoZSBwcm9wZXIgc2lkZSBvZiBibG9jayB3aWRnZXRzLCBzaW5jZVxuICAgICAgICAgICAgLy8gbm9ybWFsaXppbmcgdGhlIHNpZGUgdGhlcmUsIHRob3VnaCBhcHByb3ByaWF0ZSBmb3IgbW9zdFxuICAgICAgICAgICAgLy8gY29vcmRzQXRQb3MgcXVlcmllcywgd291bGQgYnJlYWsgc2VsZWN0aW9uIGRyYXdpbmcuXG4gICAgICAgICAgICBsZXQgZnJvbUNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MoZnJvbSwgKGZyb20gPT0gbGluZS50byA/IC0yIDogMikpO1xuICAgICAgICAgICAgbGV0IHRvQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyh0bywgKHRvID09IGxpbmUuZnJvbSA/IDIgOiAtMikpO1xuICAgICAgICAgICAgaWYgKCFmcm9tQ29vcmRzIHx8ICF0b0Nvb3JkcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbihmcm9tQ29vcmRzLnRvcCwgdG9Db29yZHMudG9wLCB0b3ApO1xuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoZnJvbUNvb3Jkcy5ib3R0b20sIHRvQ29vcmRzLmJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gZXhwb3J0cy5EaXJlY3Rpb24uTFRSKVxuICAgICAgICAgICAgICAgIGhvcml6b250YWwucHVzaChsdHIgJiYgZnJvbU9wZW4gPyBsZWZ0U2lkZSA6IGZyb21Db29yZHMubGVmdCwgbHRyICYmIHRvT3BlbiA/IHJpZ2h0U2lkZSA6IHRvQ29vcmRzLnJpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2goIWx0ciAmJiB0b09wZW4gPyBsZWZ0U2lkZSA6IHRvQ29vcmRzLmxlZnQsICFsdHIgJiYgZnJvbU9wZW4gPyByaWdodFNpZGUgOiBmcm9tQ29vcmRzLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBsaW5lLmZyb20sIGVuZCA9IHRvICE9PSBudWxsICYmIHRvICE9PSB2b2lkIDAgPyB0byA6IGxpbmUudG87XG4gICAgICAgIC8vIFNwbGl0IHRoZSByYW5nZSBieSB2aXNpYmxlIHJhbmdlIGFuZCBkb2N1bWVudCBsaW5lXG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKVxuICAgICAgICAgICAgaWYgKHIudG8gPiBzdGFydCAmJiByLmZyb20gPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSBNYXRoLm1heChyLmZyb20sIHN0YXJ0KSwgZW5kUG9zID0gTWF0aC5taW4oci50bywgZW5kKTs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkb2NMaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNwYW4gb2Ygdmlldy5iaWRpU3BhbnMoZG9jTGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFuRnJvbSA9IHNwYW4uZnJvbSArIGRvY0xpbmUuZnJvbSwgc3BhblRvID0gc3Bhbi50byArIGRvY0xpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuRnJvbSA+PSBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhblRvID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNwYW4oTWF0aC5tYXgoc3BhbkZyb20sIHBvcyksIGZyb20gPT0gbnVsbCAmJiBzcGFuRnJvbSA8PSBzdGFydCwgTWF0aC5taW4oc3BhblRvLCBlbmRQb3MpLCB0byA9PSBudWxsICYmIHNwYW5UbyA+PSBlbmQsIHNwYW4uZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBkb2NMaW5lLnRvICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChob3Jpem9udGFsLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgYWRkU3BhbihzdGFydCwgZnJvbSA9PSBudWxsLCBlbmQsIHRvID09IG51bGwsIHZpZXcudGV4dERpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB7IHRvcCwgYm90dG9tLCBob3Jpem9udGFsIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYXdGb3JXaWRnZXQoYmxvY2ssIHRvcCkge1xuICAgICAgICBsZXQgeSA9IGNvbnRlbnRSZWN0LnRvcCArICh0b3AgPyBibG9jay50b3AgOiBibG9jay5ib3R0b20pO1xuICAgICAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgaG9yaXpvbnRhbDogW10gfTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lTWFya2VyKGEsIGIpIHtcbiAgICByZXR1cm4gYS5jb25zdHJ1Y3RvciA9PSBiLmNvbnN0cnVjdG9yICYmIGEuZXEoYik7XG59XG5jbGFzcyBMYXllclZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGxheWVyKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgdGhpcy5kcmF3biA9IFtdO1xuICAgICAgICB0aGlzLnNjYWxlWCA9IDE7XG4gICAgICAgIHRoaXMuc2NhbGVZID0gMTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLm1lYXN1cmUuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMuZHJhdy5iaW5kKHRoaXMpIH07XG4gICAgICAgIHRoaXMuZG9tID0gdmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1sYXllclwiKTtcbiAgICAgICAgaWYgKGxheWVyLmFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxheWVyLWFib3ZlXCIpO1xuICAgICAgICBpZiAobGF5ZXIuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKGxheWVyLmNsYXNzKTtcbiAgICAgICAgdGhpcy5zY2FsZSgpO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuc2V0T3JkZXIodmlldy5zdGF0ZSk7XG4gICAgICAgIHZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgaWYgKGxheWVyLm1vdW50KVxuICAgICAgICAgICAgbGF5ZXIubW91bnQodGhpcy5kb20sIHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsYXllck9yZGVyKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGF5ZXJPcmRlcikpXG4gICAgICAgICAgICB0aGlzLnNldE9yZGVyKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmxheWVyLnVwZGF0ZSh1cGRhdGUsIHRoaXMuZG9tKSB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlKCk7XG4gICAgICAgICAgICB1cGRhdGUudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvY1ZpZXdVcGRhdGUodmlldykge1xuICAgICAgICBpZiAodGhpcy5sYXllci51cGRhdGVPbkRvY1ZpZXdVcGRhdGUgIT09IGZhbHNlKVxuICAgICAgICAgICAgdmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgIH1cbiAgICBzZXRPcmRlcihzdGF0ZSkge1xuICAgICAgICBsZXQgcG9zID0gMCwgb3JkZXIgPSBzdGF0ZS5mYWNldChsYXllck9yZGVyKTtcbiAgICAgICAgd2hpbGUgKHBvcyA8IG9yZGVyLmxlbmd0aCAmJiBvcmRlcltwb3NdICE9IHRoaXMubGF5ZXIpXG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgdGhpcy5kb20uc3R5bGUuekluZGV4ID0gU3RyaW5nKCh0aGlzLmxheWVyLmFib3ZlID8gMTUwIDogLTEpIC0gcG9zKTtcbiAgICB9XG4gICAgbWVhc3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIubWFya2Vycyh0aGlzLnZpZXcpO1xuICAgIH1cbiAgICBzY2FsZSgpIHtcbiAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgaWYgKHNjYWxlWCAhPSB0aGlzLnNjYWxlWCB8fCBzY2FsZVkgIT0gdGhpcy5zY2FsZVkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHsxIC8gc2NhbGVYfSwgJHsxIC8gc2NhbGVZfSlgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcobWFya2Vycykge1xuICAgICAgICBpZiAobWFya2Vycy5sZW5ndGggIT0gdGhpcy5kcmF3bi5sZW5ndGggfHwgbWFya2Vycy5zb21lKChwLCBpKSA9PiAhc2FtZU1hcmtlcihwLCB0aGlzLmRyYXduW2ldKSkpIHtcbiAgICAgICAgICAgIGxldCBvbGQgPSB0aGlzLmRvbS5maXJzdENoaWxkLCBvbGRJID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IG1hcmtlciBvZiBtYXJrZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci51cGRhdGUgJiYgb2xkICYmIG1hcmtlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmRyYXduW29sZEldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci51cGRhdGUob2xkLCB0aGlzLmRyYXduW29sZEldKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGQgPSBvbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIG9sZEkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIuZHJhdygpLCBvbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChvbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG9sZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBvbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgb2xkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhd24gPSBtYXJrZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVyLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLmxheWVyLmRlc3Ryb3kodGhpcy5kb20sIHRoaXMudmlldyk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgIH1cbn1cbmNvbnN0IGxheWVyT3JkZXIgPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbi8qKlxuRGVmaW5lIGEgbGF5ZXIuXG4qL1xuZnVuY3Rpb24gbGF5ZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgVmlld1BsdWdpbi5kZWZpbmUodiA9PiBuZXcgTGF5ZXJWaWV3KHYsIGNvbmZpZykpLFxuICAgICAgICBsYXllck9yZGVyLm9mKGNvbmZpZylcbiAgICBdO1xufVxuXG5jb25zdCBDYW5IaWRlUHJpbWFyeSA9ICFicm93c2VyLmlvczsgLy8gRklYTUUgdGVzdCBJRVxuY29uc3Qgc2VsZWN0aW9uQ29uZmlnID0gc3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAxMjAwLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGN1cnNvckJsaW5rUmF0ZTogKGEsIGIpID0+IE1hdGgubWluKGEsIGIpLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGhpZGVzIHRoZSBicm93c2VyJ3MgbmF0aXZlIHNlbGVjdGlvbiBhbmRcbmN1cnNvciwgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBhIGJhY2tncm91bmQgYmVoaW5kIHRoZSB0ZXh0XG4od2l0aCB0aGUgYGNtLXNlbGVjdGlvbkJhY2tncm91bmRgIGNsYXNzKSwgYW5kIHRoZVxuY3Vyc29ycyB3aXRoIGVsZW1lbnRzIG92ZXJsYWlkIG92ZXIgdGhlIGNvZGUgKHVzaW5nXG5gY20tY3Vyc29yLXByaW1hcnlgIGFuZCBgY20tY3Vyc29yLXNlY29uZGFyeWApLlxuXG5UaGlzIGFsbG93cyB0aGUgZWRpdG9yIHRvIGRpc3BsYXkgc2Vjb25kYXJ5IHNlbGVjdGlvbiByYW5nZXMsIGFuZFxudGVuZHMgdG8gcHJvZHVjZSBhIHR5cGUgb2Ygc2VsZWN0aW9uIG1vcmUgaW4gbGluZSB3aXRoIHRoYXQgdXNlcnNcbmV4cGVjdCBpbiBhIHRleHQgZWRpdG9yICh0aGUgbmF0aXZlIHNlbGVjdGlvbiBzdHlsaW5nIHdpbGwgb2Z0ZW5cbmxlYXZlIGdhcHMgYmV0d2VlbiBsaW5lcyBhbmQgd29uJ3QgZmlsbCB0aGUgaG9yaXpvbnRhbCBzcGFjZSBhZnRlclxuYSBsaW5lIHdoZW4gdGhlIHNlbGVjdGlvbiBjb250aW51ZXMgcGFzdCBpdCkuXG5cbkl0IGRvZXMgaGF2ZSBhIHBlcmZvcm1hbmNlIGNvc3QsIGluIHRoYXQgaXQgcmVxdWlyZXMgYW4gZXh0cmEgRE9NXG5sYXlvdXQgY3ljbGUgZm9yIG1hbnkgdXBkYXRlcyAodGhlIHNlbGVjdGlvbiBpcyBkcmF3biBiYXNlZCBvbiBET01cbmxheW91dCBpbmZvcm1hdGlvbiB0aGF0J3Mgb25seSBhdmFpbGFibGUgYWZ0ZXIgbGF5aW5nIG91dCB0aGVcbmNvbnRlbnQpLlxuKi9cbmZ1bmN0aW9uIGRyYXdTZWxlY3Rpb24oY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzZWxlY3Rpb25Db25maWcub2YoY29uZmlnKSxcbiAgICAgICAgY3Vyc29yTGF5ZXIsXG4gICAgICAgIHNlbGVjdGlvbkxheWVyLFxuICAgICAgICBoaWRlTmF0aXZlU2VsZWN0aW9uLFxuICAgICAgICBuYXRpdmVTZWxlY3Rpb25IaWRkZW4ub2YodHJ1ZSlcbiAgICBdO1xufVxuLyoqXG5SZXRyaWV2ZSB0aGUgW2BkcmF3U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pIGNvbmZpZ3VyYXRpb25cbmZvciB0aGlzIHN0YXRlLiAoTm90ZSB0aGF0IHRoaXMgd2lsbCByZXR1cm4gYSBzZXQgb2YgZGVmYXVsdHMgZXZlblxuaWYgYGRyYXdTZWxlY3Rpb25gIGlzbid0IGVuYWJsZWQuKVxuKi9cbmZ1bmN0aW9uIGdldERyYXdTZWxlY3Rpb25Db25maWcoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ0NoYW5nZWQodXBkYXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG59XG5jb25zdCBjdXJzb3JMYXllciA9IGxheWVyKHtcbiAgICBhYm92ZTogdHJ1ZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgbGV0IHsgc3RhdGU6IHN0YXRlJDEgfSA9IHZpZXcsIGNvbmYgPSBzdGF0ZSQxLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGxldCBjdXJzb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2Ygc3RhdGUkMS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgcHJpbSA9IHIgPT0gc3RhdGUkMS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGlmIChyLmVtcHR5ID8gIXByaW0gfHwgQ2FuSGlkZVByaW1hcnkgOiBjb25mLmRyYXdSYW5nZUN1cnNvcikge1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBwcmltID8gXCJjbS1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tY3Vyc29yIGNtLWN1cnNvci1zZWNvbmRhcnlcIjtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gci5lbXB0eSA/IHIgOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHIuaGVhZCwgci5oZWFkID4gci5hbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBpZWNlIG9mIFJlY3RhbmdsZU1hcmtlci5mb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIGN1cnNvcikpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcnMucHVzaChwaWVjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcnM7XG4gICAgfSxcbiAgICB1cGRhdGUodXBkYXRlLCBkb20pIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSBkb20uc3R5bGUuYW5pbWF0aW9uTmFtZSA9PSBcImNtLWJsaW5rXCIgPyBcImNtLWJsaW5rMlwiIDogXCJjbS1ibGlua1wiO1xuICAgICAgICBsZXQgY29uZkNoYW5nZSA9IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2UpXG4gICAgICAgICAgICBzZXRCbGlua1JhdGUodXBkYXRlLnN0YXRlLCBkb20pO1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCBjb25mQ2hhbmdlO1xuICAgIH0sXG4gICAgbW91bnQoZG9tLCB2aWV3KSB7XG4gICAgICAgIHNldEJsaW5rUmF0ZSh2aWV3LnN0YXRlLCBkb20pO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tY3Vyc29yTGF5ZXJcIlxufSk7XG5mdW5jdGlvbiBzZXRCbGlua1JhdGUoc3RhdGUsIGRvbSkge1xuICAgIGRvbS5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykuY3Vyc29yQmxpbmtSYXRlICsgXCJtc1wiO1xufVxuY29uc3Qgc2VsZWN0aW9uTGF5ZXIgPSBsYXllcih7XG4gICAgYWJvdmU6IGZhbHNlLFxuICAgIG1hcmtlcnModmlldykge1xuICAgICAgICByZXR1cm4gdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLm1hcChyID0+IHIuZW1wdHkgPyBbXSA6IFJlY3RhbmdsZU1hcmtlci5mb3JSYW5nZSh2aWV3LCBcImNtLXNlbGVjdGlvbkJhY2tncm91bmRcIiwgcikpXG4gICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XG4gICAgfSxcbiAgICB1cGRhdGUodXBkYXRlLCBkb20pIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBjb25maWdDaGFuZ2VkKHVwZGF0ZSk7XG4gICAgfSxcbiAgICBjbGFzczogXCJjbS1zZWxlY3Rpb25MYXllclwiXG59KTtcbmNvbnN0IHRoZW1lU3BlYyA9IHtcbiAgICBcIi5jbS1saW5lXCI6IHtcbiAgICAgICAgXCImIDo6c2VsZWN0aW9uLCAmOjpzZWxlY3Rpb25cIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiIH0sXG4gICAgfSxcbiAgICBcIi5jbS1jb250ZW50XCI6IHtcbiAgICAgICAgXCImIDpmb2N1c1wiOiB7XG4gICAgICAgICAgICBjYXJldENvbG9yOiBcImluaXRpYWwgIWltcG9ydGFudFwiLFxuICAgICAgICAgICAgXCImOjpzZWxlY3Rpb24sICYgOjpzZWxlY3Rpb25cIjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJIaWdobGlnaHQgIWltcG9ydGFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuaWYgKENhbkhpZGVQcmltYXJ5KVxuICAgIHRoZW1lU3BlY1tcIi5jbS1saW5lXCJdLmNhcmV0Q29sb3IgPSB0aGVtZVNwZWNbXCIuY20tY29udGVudFwiXS5jYXJldENvbG9yID0gXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCI7XG5jb25zdCBoaWRlTmF0aXZlU2VsZWN0aW9uID0gc3RhdGUuUHJlYy5oaWdoZXN0KEVkaXRvclZpZXcudGhlbWUodGhlbWVTcGVjKSk7XG5cbmNvbnN0IHNldERyb3BDdXJzb3JQb3MgPSBzdGF0ZS5TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChwb3MsIG1hcHBpbmcpIHsgcmV0dXJuIHBvcyA9PSBudWxsID8gbnVsbCA6IG1hcHBpbmcubWFwUG9zKHBvcyk7IH1cbn0pO1xuY29uc3QgZHJvcEN1cnNvclBvcyA9IHN0YXRlLlN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgIHVwZGF0ZShwb3MsIHRyKSB7XG4gICAgICAgIGlmIChwb3MgIT0gbnVsbClcbiAgICAgICAgICAgIHBvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHBvcyk7XG4gICAgICAgIHJldHVybiB0ci5lZmZlY3RzLnJlZHVjZSgocG9zLCBlKSA9PiBlLmlzKHNldERyb3BDdXJzb3JQb3MpID8gZS52YWx1ZSA6IHBvcywgcG9zKTtcbiAgICB9XG59KTtcbmNvbnN0IGRyYXdEcm9wQ3Vyc29yID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3Q3Vyc29yLmJpbmQodGhpcykgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjdXJzb3JQb3MgPSB1cGRhdGUuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGlmIChjdXJzb3JQb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnNvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IuY2xhc3NOYW1lID0gXCJjbS1kcm9wQ3Vyc29yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gY3Vyc29yUG9zIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZFBvcygpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGxldCByZWN0ID0gcG9zICE9IG51bGwgJiYgdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAoIXJlY3QpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG91dGVyID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBvdXRlci5sZWZ0ICsgdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCAqIHZpZXcuc2NhbGVYLFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG91dGVyLnRvcCArIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHZpZXcuc2NhbGVZLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRyYXdDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5oZWlnaHQgPSBwb3MuaGVpZ2h0IC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCA9IFwiLTEwMDAwMHB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKVxuICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVtb3ZlKCk7XG4gICAgfVxuICAgIHNldERyb3BQb3MocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gcG9zKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0RHJvcEN1cnNvclBvcy5vZihwb3MpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICBkcmFnb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKHRoaXMudmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy52aWV3LmNvbnRlbnRET00gfHwgIXRoaXMudmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJvcCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5EcmF3cyBhIGN1cnNvciBhdCB0aGUgY3VycmVudCBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nIGlzXG5kcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cbiovXG5mdW5jdGlvbiBkcm9wQ3Vyc29yKCkge1xuICAgIHJldHVybiBbZHJvcEN1cnNvclBvcywgZHJhd0Ryb3BDdXJzb3JdO1xufVxuXG5mdW5jdGlvbiBpdGVyTWF0Y2hlcyhkb2MsIHJlLCBmcm9tLCB0bywgZikge1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY3Vyc29yID0gZG9jLml0ZXJSYW5nZShmcm9tLCB0byksIHBvcyA9IGZyb20sIG07ICFjdXJzb3IubmV4dCgpLmRvbmU7IHBvcyArPSBjdXJzb3IudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghY3Vyc29yLmxpbmVCcmVhaylcbiAgICAgICAgICAgIHdoaWxlIChtID0gcmUuZXhlYyhjdXJzb3IudmFsdWUpKVxuICAgICAgICAgICAgICAgIGYocG9zICsgbS5pbmRleCwgbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hSYW5nZXModmlldywgbWF4TGVuZ3RoKSB7XG4gICAgbGV0IHZpc2libGUgPSB2aWV3LnZpc2libGVSYW5nZXM7XG4gICAgaWYgKHZpc2libGUubGVuZ3RoID09IDEgJiYgdmlzaWJsZVswXS5mcm9tID09IHZpZXcudmlld3BvcnQuZnJvbSAmJlxuICAgICAgICB2aXNpYmxlWzBdLnRvID09IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgdmlzaWJsZSkge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgodmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLmZyb20sIGZyb20gLSBtYXhMZW5ndGgpO1xuICAgICAgICB0byA9IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh0bykudG8sIHRvICsgbWF4TGVuZ3RoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA+PSBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA9IHRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IZWxwZXIgY2xhc3MgdXNlZCB0byBtYWtlIGl0IGVhc2llciB0byBtYWludGFpbiBkZWNvcmF0aW9ucyBvblxudmlzaWJsZSBjb2RlIHRoYXQgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVG8gYmUgdXNlZFxuaW4gYSBbdmlldyBwbHVnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKS4gSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0XG5yZXByZXNlbnQgYSBtYXRjaGluZyBjb25maWd1cmF0aW9uLlxuKi9cbmNsYXNzIE1hdGNoRGVjb3JhdG9yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBkZWNvcmF0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyByZWdleHAsIGRlY29yYXRpb24sIGRlY29yYXRlLCBib3VuZGFyeSwgbWF4TGVuZ3RoID0gMTAwMCB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoIXJlZ2V4cC5nbG9iYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2l2ZW4gdG8gTWF0Y2hEZWNvcmF0b3Igc2hvdWxkIGhhdmUgaXRzICdnJyBmbGFnIHNldFwiKTtcbiAgICAgICAgdGhpcy5yZWdleHAgPSByZWdleHA7XG4gICAgICAgIGlmIChkZWNvcmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgdmlldywgZnJvbSwgYWRkKSA9PiBkZWNvcmF0ZShhZGQsIGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIG1hdGNoLCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVjb3JhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkZWNvID0gZGVjb3JhdGlvbihtYXRjaCwgdmlldywgZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgICAgIGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgX3ZpZXcsIGZyb20sIGFkZCkgPT4gYWRkKGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIGRlY29yYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFaXRoZXIgJ2RlY29yYXRlJyBvciAnZGVjb3JhdGlvbicgc2hvdWxkIGJlIHByb3ZpZGVkIHRvIE1hdGNoRGVjb3JhdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGZ1bGwgc2V0IG9mIGRlY29yYXRpb25zIGZvciBtYXRjaGVzIGluIHRoZSBnaXZlblxuICAgIHZpZXcncyB2aWV3cG9ydC4gWW91J2xsIHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXJcbiAgICBwbHVnaW4uXG4gICAgKi9cbiAgICBjcmVhdGVEZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IHN0YXRlLlJhbmdlU2V0QnVpbGRlcigpLCBhZGQgPSBidWlsZC5hZGQuYmluZChidWlsZCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtYXRjaFJhbmdlcyh2aWV3LCB0aGlzLm1heExlbmd0aCkpXG4gICAgICAgICAgICBpdGVyTWF0Y2hlcyh2aWV3LnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIGZyb20sIHRvLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIGEgdmlldyB1cGRhdGUuIGBkZWNvYCBfbXVzdF8gYmVcbiAgICB0aGUgc2V0IG9mIGRlY29yYXRpb25zIHByb2R1Y2VkIGJ5IF90aGlzXyBgTWF0Y2hEZWNvcmF0b3JgIGZvclxuICAgIHRoZSB2aWV3IHN0YXRlIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICovXG4gICAgdXBkYXRlRGVjbyh1cGRhdGUsIGRlY28pIHtcbiAgICAgICAgbGV0IGNoYW5nZUZyb20gPSAxZTksIGNoYW5nZVRvID0gLTE7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChfZiwgX3QsIGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSAmJiBmcm9tIDwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRnJvbSA9IE1hdGgubWluKGZyb20sIGNoYW5nZUZyb20pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUbyA9IE1hdGgubWF4KHRvLCBjaGFuZ2VUbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IGNoYW5nZVRvIC0gY2hhbmdlRnJvbSA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgaWYgKGNoYW5nZVRvID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVSYW5nZSh1cGRhdGUudmlldywgZGVjby5tYXAodXBkYXRlLmNoYW5nZXMpLCBjaGFuZ2VGcm9tLCBjaGFuZ2VUbyk7XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbiAgICB1cGRhdGVSYW5nZSh2aWV3LCBkZWNvLCB1cGRhdGVGcm9tLCB1cGRhdGVUbykge1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChyLmZyb20sIHVwZGF0ZUZyb20pLCB0byA9IE1hdGgubWluKHIudG8sIHVwZGF0ZVRvKTtcbiAgICAgICAgICAgIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIHRvTGluZSA9IGZyb21MaW5lLnRvIDwgdG8gPyB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pIDogZnJvbUxpbmU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoci5mcm9tLCBmcm9tTGluZS5mcm9tKSwgZW5kID0gTWF0aC5taW4oci50bywgdG9MaW5lLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZnJvbSA+IGZyb21MaW5lLmZyb207IGZyb20tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QoZnJvbUxpbmUudGV4dFtmcm9tIC0gMSAtIGZyb21MaW5lLmZyb21dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHRvIDwgdG9MaW5lLnRvOyB0bysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdCh0b0xpbmUudGV4dFt0byAtIHRvTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdLCBtO1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSAoZnJvbSwgdG8sIGRlY28pID0+IHJhbmdlcy5wdXNoKGRlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUxpbmUgPT0gdG9MaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnZXhwLmxhc3RJbmRleCA9IHN0YXJ0IC0gZnJvbUxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtID0gdGhpcy5yZWdleHAuZXhlYyhmcm9tTGluZS50ZXh0KSkgJiYgbS5pbmRleCA8IGVuZCAtIGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIG0uaW5kZXggKyBmcm9tTGluZS5mcm9tLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBzdGFydCwgZW5kLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjbyA9IGRlY28udXBkYXRlKHsgZmlsdGVyRnJvbTogc3RhcnQsIGZpbHRlclRvOiBlbmQsIGZpbHRlcjogKGZyb20sIHRvKSA9PiBmcm9tIDwgc3RhcnQgfHwgdG8gPiBlbmQsIGFkZDogcmFuZ2VzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbn1cblxuY29uc3QgVW5pY29kZVJlZ2V4cFN1cHBvcnQgPSAveC8udW5pY29kZSAhPSBudWxsID8gXCJndVwiIDogXCJnXCI7XG5jb25zdCBTcGVjaWFscyA9IG5ldyBSZWdFeHAoXCJbXFx1MDAwMC1cXHUwMDA4XFx1MDAwYS1cXHUwMDFmXFx1MDA3Zi1cXHUwMDlmXFx1MDBhZFxcdTA2MWNcXHUyMDBiXFx1MjAwZVxcdTIwMGZcXHUyMDI4XFx1MjAyOVxcdTIwMmRcXHUyMDJlXFx1MjA2NlxcdTIwNjdcXHUyMDY5XFx1ZmVmZlxcdWZmZjktXFx1ZmZmY11cIiwgVW5pY29kZVJlZ2V4cFN1cHBvcnQpO1xuY29uc3QgTmFtZXMgPSB7XG4gICAgMDogXCJudWxsXCIsXG4gICAgNzogXCJiZWxsXCIsXG4gICAgODogXCJiYWNrc3BhY2VcIixcbiAgICAxMDogXCJuZXdsaW5lXCIsXG4gICAgMTE6IFwidmVydGljYWwgdGFiXCIsXG4gICAgMTM6IFwiY2FycmlhZ2UgcmV0dXJuXCIsXG4gICAgMjc6IFwiZXNjYXBlXCIsXG4gICAgODIwMzogXCJ6ZXJvIHdpZHRoIHNwYWNlXCIsXG4gICAgODIwNDogXCJ6ZXJvIHdpZHRoIG5vbi1qb2luZXJcIixcbiAgICA4MjA1OiBcInplcm8gd2lkdGggam9pbmVyXCIsXG4gICAgODIwNjogXCJsZWZ0LXRvLXJpZ2h0IG1hcmtcIixcbiAgICA4MjA3OiBcInJpZ2h0LXRvLWxlZnQgbWFya1wiLFxuICAgIDgyMzI6IFwibGluZSBzZXBhcmF0b3JcIixcbiAgICA4MjM3OiBcImxlZnQtdG8tcmlnaHQgb3ZlcnJpZGVcIixcbiAgICA4MjM4OiBcInJpZ2h0LXRvLWxlZnQgb3ZlcnJpZGVcIixcbiAgICA4Mjk0OiBcImxlZnQtdG8tcmlnaHQgaXNvbGF0ZVwiLFxuICAgIDgyOTU6IFwicmlnaHQtdG8tbGVmdCBpc29sYXRlXCIsXG4gICAgODI5NzogXCJwb3AgZGlyZWN0aW9uYWwgaXNvbGF0ZVwiLFxuICAgIDgyMzM6IFwicGFyYWdyYXBoIHNlcGFyYXRvclwiLFxuICAgIDY1Mjc5OiBcInplcm8gd2lkdGggbm8tYnJlYWsgc3BhY2VcIixcbiAgICA2NTUzMjogXCJvYmplY3QgcmVwbGFjZW1lbnRcIlxufTtcbmxldCBfc3VwcG9ydHNUYWJTaXplID0gbnVsbDtcbmZ1bmN0aW9uIHN1cHBvcnRzVGFiU2l6ZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKF9zdXBwb3J0c1RhYlNpemUgPT0gbnVsbCAmJiB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIGxldCBzdHlsZXMgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgICBfc3VwcG9ydHNUYWJTaXplID0gKChfYSA9IHN0eWxlcy50YWJTaXplKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdHlsZXMuTW96VGFiU2l6ZSkgIT0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9zdXBwb3J0c1RhYlNpemUgfHwgZmFsc2U7XG59XG5jb25zdCBzcGVjaWFsQ2hhckNvbmZpZyA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCBjb25maWcgPSBzdGF0ZS5jb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgICAgIHNwZWNpYWxDaGFyczogU3BlY2lhbHMsXG4gICAgICAgICAgICBhZGRTcGVjaWFsQ2hhcnM6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcucmVwbGFjZVRhYnMgPSAhc3VwcG9ydHNUYWJTaXplKCkpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChcIlxcdHxcIiArIGNvbmZpZy5zcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIGlmIChjb25maWcuYWRkU3BlY2lhbENoYXJzKVxuICAgICAgICAgICAgY29uZmlnLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAoY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UgKyBcInxcIiArIGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgaGlnaGxpZ2h0aW5nIG9mIHNwZWNpYWxcbmNoYXJhY3RlcnMuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U3BlY2lhbENoYXJzKFxuLyoqXG5Db25maWd1cmF0aW9uIG9wdGlvbnMuXG4qL1xuY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW3NwZWNpYWxDaGFyQ29uZmlnLm9mKGNvbmZpZyksIHNwZWNpYWxDaGFyUGx1Z2luKCldO1xufVxubGV0IF9wbHVnaW4gPSBudWxsO1xuZnVuY3Rpb24gc3BlY2lhbENoYXJQbHVnaW4oKSB7XG4gICAgcmV0dXJuIF9wbHVnaW4gfHwgKF9wbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3Iodmlldy5zdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgbWFrZURlY29yYXRvcihjb25mKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICAgICAgICAgICAgICByZWdleHA6IGNvbmYuc3BlY2lhbENoYXJzLFxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IChtLCB2aWV3LCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZG9jIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IHN0YXRlLmNvZGVQb2ludEF0KG1bMF0sIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdmlldy5zdGF0ZS50YWJTaXplLCBjb2wgPSBzdGF0ZS5jb3VudENvbHVtbihsaW5lLnRleHQsIHNpemUsIHBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBUYWJXaWRnZXQoKHNpemUgLSAoY29sICUgc2l6ZSkpICogdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAvIHRoaXMudmlldy5zY2FsZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9uQ2FjaGVbY29kZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSA9IERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFNwZWNpYWxDaGFyV2lkZ2V0KGNvbmYsIGNvZGUpIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5OiBjb25mLnJlcGxhY2VUYWJzID8gdW5kZWZpbmVkIDogL1teXS9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykgIT0gY29uZikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdG9yID0gdGhpcy5tYWtlRGVjb3JhdG9yKGNvbmYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci51cGRhdGVEZWNvKHVwZGF0ZSwgdGhpcy5kZWNvcmF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbiAgICB9KSk7XG59XG5jb25zdCBEZWZhdWx0UGxhY2Vob2xkZXIgPSBcIlxcdTIwMjJcIjtcbi8vIEFzc2lnbnMgcGxhY2Vob2xkZXIgY2hhcmFjdGVycyBmcm9tIHRoZSBDb250cm9sIFBpY3R1cmVzIGJsb2NrIHRvXG4vLyBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBsYWNlaG9sZGVyJDEoY29kZSkge1xuICAgIGlmIChjb2RlID49IDMyKVxuICAgICAgICByZXR1cm4gRGVmYXVsdFBsYWNlaG9sZGVyO1xuICAgIGlmIChjb2RlID09IDEwKVxuICAgICAgICByZXR1cm4gXCJcXHUyNDI0XCI7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTIxNiArIGNvZGUpO1xufVxuY2xhc3MgU3BlY2lhbENoYXJXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5jb2RlID09IHRoaXMuY29kZTsgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IHBoID0gcGxhY2Vob2xkZXIkMSh0aGlzLmNvZGUpO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuc3RhdGUucGhyYXNlKFwiQ29udHJvbCBjaGFyYWN0ZXJcIikgKyBcIiBcIiArIChOYW1lc1t0aGlzLmNvZGVdIHx8IFwiMHhcIiArIHRoaXMuY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy5vcHRpb25zLnJlbmRlciAmJiB0aGlzLm9wdGlvbnMucmVuZGVyKHRoaXMuY29kZSwgZGVzYywgcGgpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHBoO1xuICAgICAgICBzcGFuLnRpdGxlID0gZGVzYztcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGRlc2MpO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tc3BlY2lhbENoYXJcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmNsYXNzIFRhYldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLndpZHRoID09IHRoaXMud2lkdGg7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiXFx0XCI7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS10YWJcIjtcbiAgICAgICAgc3Bhbi5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbmNvbnN0IHBsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxMDAwO1xuICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogXCJwYWRkaW5nLWJvdHRvbTogMTAwMHB4XCIgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB1cGRhdGU7XG4gICAgICAgIGxldCBoZWlnaHQgPSB2aWV3LnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQgLVxuICAgICAgICAgICAgdmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCAtIDAuNTtcbiAgICAgICAgaWYgKGhlaWdodCA+PSAwICYmIGhlaWdodCAhPSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogYHBhZGRpbmctYm90dG9tOiAke2hlaWdodH1weGAgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IG1ha2VzIHN1cmUgdGhlIGNvbnRlbnQgaGFzIGEgYm90dG9tXG5tYXJnaW4gZXF1aXZhbGVudCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBlZGl0b3IsIG1pbnVzIG9uZSBsaW5lXG5oZWlnaHQsIHNvIHRoYXQgZXZlcnkgbGluZSBpbiB0aGUgZG9jdW1lbnQgY2FuIGJlIHNjcm9sbGVkIHRvIHRoZVxudG9wIG9mIHRoZSBlZGl0b3IuXG5cblRoaXMgaXMgb25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxhYmxlLCBhbmQgc2hvdWxkXG5ub3QgYmUgZW5hYmxlZCBpbiBlZGl0b3JzIHRoYXQgdGFrZSB0aGUgc2l6ZSBvZiB0aGVpciBjb250ZW50LlxuKi9cbmZ1bmN0aW9uIHNjcm9sbFBhc3RFbmQoKSB7XG4gICAgcmV0dXJuIFtwbHVnaW4sIGNvbnRlbnRBdHRyaWJ1dGVzLm9mKHZpZXcgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzKSB8fCBudWxsOyB9KV07XG59XG5cbi8qKlxuTWFyayBsaW5lcyB0aGF0IGhhdmUgYSBjdXJzb3Igb24gdGhlbSB3aXRoIHRoZSBgXCJjbS1hY3RpdmVMaW5lXCJgXG5ET00gY2xhc3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgbGluZURlY28gPSBEZWNvcmF0aW9uLmxpbmUoeyBjbGFzczogXCJjbS1hY3RpdmVMaW5lXCIgfSk7XG5jb25zdCBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXIgPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldykge1xuICAgICAgICBsZXQgbGFzdExpbmVTdGFydCA9IC0xLCBkZWNvID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQoci5oZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPiBsYXN0TGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZGVjby5wdXNoKGxpbmVEZWNvLnJhbmdlKGxpbmUuZnJvbSkpO1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lU3RhcnQgPSBsaW5lLmZyb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcblxuY2xhc3MgUGxhY2Vob2xkZXIgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXBsYWNlaG9sZGVyXCI7XG4gICAgICAgIHdyYXAuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY29udGVudCkgOlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuY29udGVudCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLmNvbnRlbnQodmlldykgOlxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwicGxhY2Vob2xkZXIgXCIgKyB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgfVxuICAgIGNvb3Jkc0F0KGRvbSkge1xuICAgICAgICBsZXQgcmVjdHMgPSBkb20uZmlyc3RDaGlsZCA/IGNsaWVudFJlY3RzRm9yKGRvbS5maXJzdENoaWxkKSA6IFtdO1xuICAgICAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20ucGFyZW50Tm9kZSk7XG4gICAgICAgIGxldCByZWN0ID0gZmxhdHRlblJlY3QocmVjdHNbMF0sIHN0eWxlLmRpcmVjdGlvbiAhPSBcInJ0bFwiKTtcbiAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSBwYXJzZUludChzdHlsZS5saW5lSGVpZ2h0KTtcbiAgICAgICAgaWYgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBsaW5lSGVpZ2h0ICogMS41KVxuICAgICAgICAgICAgcmV0dXJuIHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGxpbmVIZWlnaHQgfTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhIHBsYWNlaG9sZGVy4oCUYSBwaWVjZSBvZiBleGFtcGxlIGNvbnRlbnRcbnRvIHNob3cgd2hlbiB0aGUgZWRpdG9yIGlzIGVtcHR5LlxuKi9cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICA/IERlY29yYXRpb24uc2V0KFtEZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogbmV3IFBsYWNlaG9sZGVyKGNvbnRlbnQpLCBzaWRlOiAxIH0pLnJhbmdlKDApXSlcbiAgICAgICAgICAgICAgICA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGVjb3JhdGlvbnMoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IERlY29yYXRpb24ubm9uZSA6IHRoaXMucGxhY2Vob2xkZXI7IH1cbiAgICB9LCB7IGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnMgfSk7XG59XG5cbi8vIERvbid0IGNvbXB1dGUgcHJlY2lzZSBjb2x1bW4gcG9zaXRpb25zIGZvciBsaW5lIG9mZnNldHMgYWJvdmUgdGhpc1xuLy8gKHNpbmNlIGl0IGNvdWxkIGdldCBleHBlbnNpdmUpLiBBc3N1bWUgb2Zmc2V0PT1jb2x1bW4gZm9yIHRoZW0uXG5jb25zdCBNYXhPZmYgPSAyMDAwO1xuZnVuY3Rpb24gcmVjdGFuZ2xlRm9yKHN0YXRlJDEsIGEsIGIpIHtcbiAgICBsZXQgc3RhcnRMaW5lID0gTWF0aC5taW4oYS5saW5lLCBiLmxpbmUpLCBlbmRMaW5lID0gTWF0aC5tYXgoYS5saW5lLCBiLmxpbmUpO1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBpZiAoYS5vZmYgPiBNYXhPZmYgfHwgYi5vZmYgPiBNYXhPZmYgfHwgYS5jb2wgPCAwIHx8IGIuY29sIDwgMCkge1xuICAgICAgICBsZXQgc3RhcnRPZmYgPSBNYXRoLm1pbihhLm9mZiwgYi5vZmYpLCBlbmRPZmYgPSBNYXRoLm1heChhLm9mZiwgYi5vZmYpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZSQxLmRvYy5saW5lKGkpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDw9IGVuZE9mZilcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnRPZmYsIGxpbmUudG8gKyBlbmRPZmYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHN0YXJ0Q29sID0gTWF0aC5taW4oYS5jb2wsIGIuY29sKSwgZW5kQ29sID0gTWF0aC5tYXgoYS5jb2wsIGIuY29sKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUkMS5kb2MubGluZShpKTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHN0YXRlLmZpbmRDb2x1bW4obGluZS50ZXh0LCBzdGFydENvbCwgc3RhdGUkMS50YWJTaXplLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGxpbmUudG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBzdGF0ZS5maW5kQ29sdW1uKGxpbmUudGV4dCwgZW5kQ29sLCBzdGF0ZSQxLnRhYlNpemUpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHN0YXRlLkVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydCwgbGluZS5mcm9tICsgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIGFic29sdXRlQ29sdW1uKHZpZXcsIHgpIHtcbiAgICBsZXQgcmVmID0gdmlldy5jb29yZHNBdFBvcyh2aWV3LnZpZXdwb3J0LmZyb20pO1xuICAgIHJldHVybiByZWYgPyBNYXRoLnJvdW5kKE1hdGguYWJzKChyZWYubGVmdCAtIHgpIC8gdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpKSA6IC0xO1xufVxuZnVuY3Rpb24gZ2V0UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IG9mZnNldCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChvZmZzZXQpLCBvZmYgPSBvZmZzZXQgLSBsaW5lLmZyb207XG4gICAgbGV0IGNvbCA9IG9mZiA+IE1heE9mZiA/IC0xXG4gICAgICAgIDogb2ZmID09IGxpbmUubGVuZ3RoID8gYWJzb2x1dGVDb2x1bW4odmlldywgZXZlbnQuY2xpZW50WClcbiAgICAgICAgICAgIDogc3RhdGUuY291bnRDb2x1bW4obGluZS50ZXh0LCB2aWV3LnN0YXRlLnRhYlNpemUsIG9mZnNldCAtIGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIHsgbGluZTogbGluZS5udW1iZXIsIGNvbCwgb2ZmIH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IGdldFBvcyh2aWV3LCBldmVudCksIHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCFzdGFydClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lKHN0YXJ0LmxpbmUpLmZyb20pO1xuICAgICAgICAgICAgICAgIGxldCBuZXdMaW5lID0gdXBkYXRlLnN0YXRlLmRvYy5saW5lQXQobmV3U3RhcnQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0geyBsaW5lOiBuZXdMaW5lLm51bWJlciwgY29sOiBzdGFydC5jb2wsIG9mZjogTWF0aC5taW4oc3RhcnQub2ZmLCBuZXdMaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgX2V4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBnZXRQb3ModmlldywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFjdXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHJlY3RhbmdsZUZvcih2aWV3LnN0YXRlLCBzdGFydCwgY3VyKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmNvbmNhdChzdGFydFNlbC5yYW5nZXMpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgcmVjdGFuZ3VsYXIgc2VsZWN0aW9ucy4gQnlcbmRlZmF1bHQsIGl0IHdpbGwgcmVhY3QgdG8gbGVmdCBtb3VzZSBkcmFnIHdpdGggdGhlIEFsdCBrZXkgaGVsZFxuZG93bi4gV2hlbiBzdWNoIGEgc2VsZWN0aW9uIG9jY3VycywgdGhlIHRleHQgd2l0aGluIHRoZSByZWN0YW5nbGVcbnRoYXQgd2FzIGRyYWdnZWQgb3ZlciB3aWxsIGJlIHNlbGVjdGVkLCBhcyBvbmUgc2VsZWN0aW9uXG5bcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UpIHBlciBsaW5lLlxuKi9cbmZ1bmN0aW9uIHJlY3Rhbmd1bGFyU2VsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlsdGVyID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudEZpbHRlcikgfHwgKGUgPT4gZS5hbHRLZXkgJiYgZS5idXR0b24gPT0gMCk7XG4gICAgcmV0dXJuIEVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZS5vZigodmlldywgZXZlbnQpID0+IGZpbHRlcihldmVudCkgPyByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkgOiBudWxsKTtcbn1cbmNvbnN0IGtleXMgPSB7XG4gICAgQWx0OiBbMTgsIGUgPT4gISFlLmFsdEtleV0sXG4gICAgQ29udHJvbDogWzE3LCBlID0+ICEhZS5jdHJsS2V5XSxcbiAgICBTaGlmdDogWzE2LCBlID0+ICEhZS5zaGlmdEtleV0sXG4gICAgTWV0YTogWzkxLCBlID0+ICEhZS5tZXRhS2V5XVxufTtcbmNvbnN0IHNob3dDcm9zc2hhaXIgPSB7IHN0eWxlOiBcImN1cnNvcjogY3Jvc3NoYWlyXCIgfTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCB0dXJucyB0aGUgcG9pbnRlciBjdXJzb3IgaW50byBhXG5jcm9zc2hhaXIgd2hlbiBhIGdpdmVuIG1vZGlmaWVyIGtleSwgZGVmYXVsdGluZyB0byBBbHQsIGlzIGhlbGRcbmRvd24uIENhbiBzZXJ2ZSBhcyBhIHZpc3VhbCBoaW50IHRoYXQgcmVjdGFuZ3VsYXIgc2VsZWN0aW9uIGlzXG5nb2luZyB0byBoYXBwZW4gd2hlbiBwYWlyZWQgd2l0aFxuW2ByZWN0YW5ndWxhclNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5yZWN0YW5ndWxhclNlbGVjdGlvbikuXG4qL1xuZnVuY3Rpb24gY3Jvc3NoYWlyQ3Vyc29yKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBbY29kZSwgZ2V0dGVyXSA9IGtleXNbb3B0aW9ucy5rZXkgfHwgXCJBbHRcIl07XG4gICAgbGV0IHBsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGlzRG93bikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEb3duICE9IGlzRG93bikge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEb3duID0gaXNEb3duO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy51cGRhdGUoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICAgICAga2V5ZG93bihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZS5rZXlDb2RlID09IGNvZGUgfHwgZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXl1cChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSBjb2RlIHx8ICFnZXR0ZXIoZSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VzZW1vdmUoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGdldHRlcihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBwbHVnaW4sXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEb3duKSA/IHNob3dDcm9zc2hhaXIgOiBudWxsOyB9KVxuICAgIF07XG59XG5cbmNvbnN0IE91dHNpZGUgPSBcIi0xMDAwMHB4XCI7XG5jbGFzcyBUb29sdGlwVmlld01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGZhY2V0LCBjcmVhdGVUb29sdGlwVmlldywgcmVtb3ZlVG9vbHRpcFZpZXcpIHtcbiAgICAgICAgdGhpcy5mYWNldCA9IGZhY2V0O1xuICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXBWaWV3ID0gY3JlYXRlVG9vbHRpcFZpZXc7XG4gICAgICAgIHRoaXMucmVtb3ZlVG9vbHRpcFZpZXcgPSByZW1vdmVUb29sdGlwVmlldztcbiAgICAgICAgdGhpcy5pbnB1dCA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdGhpcy5pbnB1dC5maWx0ZXIodCA9PiB0KTtcbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRoaXMudG9vbHRpcHMubWFwKHQgPT4gcHJldiA9IGNyZWF0ZVRvb2x0aXBWaWV3KHQsIHByZXYpKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgYWJvdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaW5wdXQgPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhpcy5mYWNldCk7XG4gICAgICAgIGxldCB0b29sdGlwcyA9IGlucHV0LmZpbHRlcih4ID0+IHgpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgaWYgKHQudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b29sdGlwVmlld3MgPSBbXSwgbmV3QWJvdmUgPSBhYm92ZSA/IFtdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpcCA9IHRvb2x0aXBzW2ldLCBrbm93biA9IC0xO1xuICAgICAgICAgICAgaWYgKCF0aXApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSB0aGlzLnRvb2x0aXBzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlciAmJiBvdGhlci5jcmVhdGUgPT0gdGlwLmNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAga25vd24gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcodGlwLCBpID8gdG9vbHRpcFZpZXdzW2kgLSAxXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdBYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgbmV3QWJvdmVbaV0gPSAhIXRpcC5hYm92ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b29sdGlwVmlldyA9IHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMudG9vbHRpcFZpZXdzW2tub3duXTtcbiAgICAgICAgICAgICAgICBpZiAobmV3QWJvdmUpXG4gICAgICAgICAgICAgICAgICAgIG5ld0Fib3ZlW2ldID0gYWJvdmVba25vd25dO1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwVmlldy51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICBpZiAodG9vbHRpcFZpZXdzLmluZGV4T2YodCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUb29sdGlwVmlldyh0KTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoYWJvdmUpIHtcbiAgICAgICAgICAgIG5ld0Fib3ZlLmZvckVhY2goKHZhbCwgaSkgPT4gYWJvdmVbaV0gPSB2YWwpO1xuICAgICAgICAgICAgYWJvdmUubGVuZ3RoID0gbmV3QWJvdmUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy50b29sdGlwcyA9IHRvb2x0aXBzO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRvb2x0aXBWaWV3cztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG5DcmVhdGVzIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgdG9vbHRpcCBiZWhhdmlvci5cbiovXG5mdW5jdGlvbiB0b29sdGlwcyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiB0b29sdGlwQ29uZmlnLm9mKGNvbmZpZyk7XG59XG5mdW5jdGlvbiB3aW5kb3dTcGFjZSh2aWV3KSB7XG4gICAgbGV0IHsgd2luIH0gPSB2aWV3O1xuICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCB9O1xufVxuY29uc3QgdG9vbHRpcENvbmZpZyA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgcG9zaXRpb246IGJyb3dzZXIuaW9zID8gXCJhYnNvbHV0ZVwiIDogKChfYSA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wb3NpdGlvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbikgfHwgXCJmaXhlZFwiLFxuICAgICAgICAgICAgcGFyZW50OiAoKF9iID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBhcmVudCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQpIHx8IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwU3BhY2U6ICgoX2MgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYudG9vbHRpcFNwYWNlKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvb2x0aXBTcGFjZSkgfHwgd2luZG93U3BhY2UsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3Qga25vd25IZWlnaHQgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdG9vbHRpcFBsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuYWJvdmUgPSBbXTtcbiAgICAgICAgdGhpcy5pblZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLm1hZGVBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBjb25maWcucG9zaXRpb247XG4gICAgICAgIHRoaXMucGFyZW50ID0gY29uZmlnLnBhcmVudDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gdmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5yZWFkTWVhc3VyZS5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy53cml0ZU1lYXN1cmUuYmluZCh0aGlzKSwga2V5OiB0aGlzIH07XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiID8gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHRoaXMubWVhc3VyZVNvb24oKSkgOiBudWxsO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgVG9vbHRpcFZpZXdNYW5hZ2VyKHZpZXcsIHNob3dUb29sdGlwLCAodCwgcCkgPT4gdGhpcy5jcmVhdGVUb29sdGlwKHQsIHApLCB0ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKVxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHQuZG9tKTtcbiAgICAgICAgICAgIHQuZG9tLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hYm92ZSA9IHRoaXMubWFuYWdlci50b29sdGlwcy5tYXAodCA9PiAhIXQuYWJvdmUpO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIiA/IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gdGhpcy5sYXN0VHJhbnNhY3Rpb24gLSA1MCAmJlxuICAgICAgICAgICAgICAgIGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPCAxKVxuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVNvb24oKTtcbiAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IFsxXSB9KSA6IG51bGw7XG4gICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICB2aWV3Lndpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24gPSB0aGlzLm1lYXN1cmVTb29uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH1cbiAgICBjcmVhdGVDb250YWluZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLnZpZXcuZG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmVJbnRlcnNlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXAgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUodG9vbHRpcC5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb24gPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHRoaXMubWFuYWdlci51cGRhdGUodXBkYXRlLCB0aGlzLmFib3ZlKTtcbiAgICAgICAgaWYgKHVwZGF0ZWQpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbnRlcnNlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNob3VsZE1lYXN1cmUgPSB1cGRhdGVkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQ7XG4gICAgICAgIGxldCBuZXdDb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XG4gICAgICAgIGlmIChuZXdDb25maWcucG9zaXRpb24gIT0gdGhpcy5wb3NpdGlvbiAmJiAhdGhpcy5tYWRlQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXdDb25maWcucG9zaXRpb247XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdC5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wYXJlbnQgIT0gdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbmV3Q29uZmlnLnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodC5kb20pO1xuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy52aWV3LnRoZW1lQ2xhc3NlcyAhPSB0aGlzLmNsYXNzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZE1lYXN1cmUpXG4gICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH1cbiAgICBjcmVhdGVUb29sdGlwKHRvb2x0aXAsIHByZXYpIHtcbiAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcC5jcmVhdGUodGhpcy52aWV3KTtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHByZXYgPyBwcmV2LmRvbSA6IG51bGw7XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcFwiKTtcbiAgICAgICAgaWYgKHRvb2x0aXAuYXJyb3cgJiYgIXRvb2x0aXBWaWV3LmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAgPiAuY20tdG9vbHRpcC1hcnJvd1wiKSkge1xuICAgICAgICAgICAgbGV0IGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGFycm93LmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcC1hcnJvd1wiO1xuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmFwcGVuZENoaWxkKGFycm93KTtcbiAgICAgICAgfVxuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUodG9vbHRpcFZpZXcuZG9tLCBiZWZvcmUpO1xuICAgICAgICBpZiAodG9vbHRpcFZpZXcubW91bnQpXG4gICAgICAgICAgICB0b29sdGlwVmlldy5tb3VudCh0aGlzLnZpZXcpO1xuICAgICAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcilcbiAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0b29sdGlwVmlldy5kb20pO1xuICAgICAgICByZXR1cm4gdG9vbHRpcFZpZXc7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLnZpZXcud2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5tZWFzdXJlU29vbik7XG4gICAgICAgIGZvciAobGV0IHRvb2x0aXBWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3LmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgIChfYSA9IHRvb2x0aXBWaWV3LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRvb2x0aXBWaWV3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgKF9iID0gdGhpcy5yZXNpemVPYnNlcnZlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9jID0gdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubWVhc3VyZVRpbWVvdXQpO1xuICAgIH1cbiAgICByZWFkTWVhc3VyZSgpIHtcbiAgICAgICAgbGV0IHNjYWxlWCA9IDEsIHNjYWxlWSA9IDEsIG1ha2VBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSBcImZpeGVkXCIgJiYgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IGRvbSB9ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1swXTtcbiAgICAgICAgICAgIGlmIChicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzZXRzIHRoZSBlbGVtZW50J3MgYG9mZnNldFBhcmVudGAgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtZWQgZWxlbWVudCB3aGVuIGEgdHJhbnNmb3JtIGludGVyZmVyZXMgd2l0aCBmaXhlZFxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uaW5nLlxuICAgICAgICAgICAgICAgIG1ha2VBYnNvbHV0ZSA9IGRvbS5vZmZzZXRQYXJlbnQgIT0gdGhpcy5jb250YWluZXIub3duZXJEb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLnN0eWxlLnRvcCA9PSBPdXRzaWRlICYmIGRvbS5zdHlsZS5sZWZ0ID09IFwiMHB4XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBvdGhlciBicm93c2Vycywgd2UgaGF2ZSB0byBhd2t3YXJkbHkgdHJ5IGFuZCB1c2Ugb3RoZXJcbiAgICAgICAgICAgICAgICAvLyBpbmZvcm1hdGlvbiB0byBkZXRlY3QgYSB0cmFuc2Zvcm0uXG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbWFrZUFic29sdXRlID0gTWF0aC5hYnMocmVjdC50b3AgKyAxMDAwMCkgPiAxIHx8IE1hdGguYWJzKHJlY3QubGVmdCkgPiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYWtlQWJzb2x1dGUgfHwgdGhpcy5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdGhpcy5wYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVYID0gcmVjdC53aWR0aCAvIHRoaXMucGFyZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVkgPSByZWN0LmhlaWdodCAvIHRoaXMucGFyZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoeyBzY2FsZVgsIHNjYWxlWSB9ID0gdGhpcy52aWV3LnZpZXdTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpc2libGUgPSB0aGlzLnZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBtYXJnaW5zID0gZ2V0U2Nyb2xsTWFyZ2lucyh0aGlzLnZpZXcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHZpc2libGUubGVmdCArIG1hcmdpbnMubGVmdCwgdG9wOiB2aXNpYmxlLnRvcCArIG1hcmdpbnMudG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB2aXNpYmxlLnJpZ2h0IC0gbWFyZ2lucy5yaWdodCwgYm90dG9tOiB2aXNpYmxlLmJvdHRvbSAtIG1hcmdpbnMuYm90dG9tXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCA/IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogdGhpcy52aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHBvczogdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLm1hcCgodCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0diA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR2LmdldENvb3JkcyA/IHR2LmdldENvb3Jkcyh0LnBvcykgOiB0aGlzLnZpZXcuY29vcmRzQXRQb3ModC5wb3MpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzaXplOiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzLm1hcCgoeyBkb20gfSkgPT4gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxcbiAgICAgICAgICAgIHNwYWNlOiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZykudG9vbHRpcFNwYWNlKHRoaXMudmlldyksXG4gICAgICAgICAgICBzY2FsZVgsIHNjYWxlWSwgbWFrZUFic29sdXRlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHdyaXRlTWVhc3VyZShtZWFzdXJlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChtZWFzdXJlZC5tYWtlQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHRoaXMubWFkZUFic29sdXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdC5kb20uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgdmlzaWJsZSwgc3BhY2UsIHNjYWxlWCwgc2NhbGVZIH0gPSBtZWFzdXJlZDtcbiAgICAgICAgbGV0IG90aGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFuYWdlci50b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLm1hbmFnZXIudG9vbHRpcHNbaV0sIHRWaWV3ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tpXSwgeyBkb20gfSA9IHRWaWV3O1xuICAgICAgICAgICAgbGV0IHBvcyA9IG1lYXN1cmVkLnBvc1tpXSwgc2l6ZSA9IG1lYXN1cmVkLnNpemVbaV07XG4gICAgICAgICAgICAvLyBIaWRlIHRvb2x0aXBzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGVkaXRvci5cbiAgICAgICAgICAgIGlmICghcG9zIHx8IHRvb2x0aXAuY2xpcCAhPT0gZmFsc2UgJiYgKHBvcy5ib3R0b20gPD0gTWF0aC5tYXgodmlzaWJsZS50b3AsIHNwYWNlLnRvcCkgfHxcbiAgICAgICAgICAgICAgICBwb3MudG9wID49IE1hdGgubWluKHZpc2libGUuYm90dG9tLCBzcGFjZS5ib3R0b20pIHx8XG4gICAgICAgICAgICAgICAgcG9zLnJpZ2h0IDwgTWF0aC5tYXgodmlzaWJsZS5sZWZ0LCBzcGFjZS5sZWZ0KSAtIC4xIHx8XG4gICAgICAgICAgICAgICAgcG9zLmxlZnQgPiBNYXRoLm1pbih2aXNpYmxlLnJpZ2h0LCBzcGFjZS5yaWdodCkgKyAuMSkpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhcnJvdyA9IHRvb2x0aXAuYXJyb3cgPyB0Vmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwLWFycm93XCIpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJvd0hlaWdodCA9IGFycm93ID8gNyAvKiBBcnJvdy5TaXplICovIDogMDtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHNpemUucmlnaHQgLSBzaXplLmxlZnQsIGhlaWdodCA9IChfYSA9IGtub3duSGVpZ2h0LmdldCh0VmlldykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNpemUuYm90dG9tIC0gc2l6ZS50b3A7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdFZpZXcub2Zmc2V0IHx8IG5vT2Zmc2V0LCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBleHBvcnRzLkRpcmVjdGlvbi5MVFI7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHNpemUud2lkdGggPiBzcGFjZS5yaWdodCAtIHNwYWNlLmxlZnRcbiAgICAgICAgICAgICAgICA/IChsdHIgPyBzcGFjZS5sZWZ0IDogc3BhY2UucmlnaHQgLSBzaXplLndpZHRoKVxuICAgICAgICAgICAgICAgIDogbHRyID8gTWF0aC5tYXgoc3BhY2UubGVmdCwgTWF0aC5taW4ocG9zLmxlZnQgLSAoYXJyb3cgPyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gOiAwKSArIG9mZnNldC54LCBzcGFjZS5yaWdodCAtIHdpZHRoKSlcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbihNYXRoLm1heChzcGFjZS5sZWZ0LCBwb3MubGVmdCAtIHdpZHRoICsgKGFycm93ID8gMTQgLyogQXJyb3cuT2Zmc2V0ICovIDogMCkgLSBvZmZzZXQueCksIHNwYWNlLnJpZ2h0IC0gd2lkdGgpO1xuICAgICAgICAgICAgbGV0IGFib3ZlID0gdGhpcy5hYm92ZVtpXTtcbiAgICAgICAgICAgIGlmICghdG9vbHRpcC5zdHJpY3RTaWRlICYmIChhYm92ZVxuICAgICAgICAgICAgICAgID8gcG9zLnRvcCAtIGhlaWdodCAtIGFycm93SGVpZ2h0IC0gb2Zmc2V0LnkgPCBzcGFjZS50b3BcbiAgICAgICAgICAgICAgICA6IHBvcy5ib3R0b20gKyBoZWlnaHQgKyBhcnJvd0hlaWdodCArIG9mZnNldC55ID4gc3BhY2UuYm90dG9tKSAmJlxuICAgICAgICAgICAgICAgIGFib3ZlID09IChzcGFjZS5ib3R0b20gLSBwb3MuYm90dG9tID4gcG9zLnRvcCAtIHNwYWNlLnRvcCkpXG4gICAgICAgICAgICAgICAgYWJvdmUgPSB0aGlzLmFib3ZlW2ldID0gIWFib3ZlO1xuICAgICAgICAgICAgbGV0IHNwYWNlVmVydCA9IChhYm92ZSA/IHBvcy50b3AgLSBzcGFjZS50b3AgOiBzcGFjZS5ib3R0b20gLSBwb3MuYm90dG9tKSAtIGFycm93SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHNwYWNlVmVydCA8IGhlaWdodCAmJiB0Vmlldy5yZXNpemUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlVmVydCA8IHRoaXMudmlldy5kZWZhdWx0TGluZUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtub3duSGVpZ2h0LnNldCh0VmlldywgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUuaGVpZ2h0ID0gKGhlaWdodCA9IHNwYWNlVmVydCkgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb20uc3R5bGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gYWJvdmUgPyBwb3MudG9wIC0gaGVpZ2h0IC0gYXJyb3dIZWlnaHQgLSBvZmZzZXQueSA6IHBvcy5ib3R0b20gKyBhcnJvd0hlaWdodCArIG9mZnNldC55O1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBvdGhlcnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmxlZnQgPCByaWdodCAmJiByLnJpZ2h0ID4gbGVmdCAmJiByLnRvcCA8IHRvcCArIGhlaWdodCAmJiByLmJvdHRvbSA+IHRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IGFib3ZlID8gci50b3AgLSBoZWlnaHQgLSAyIC0gYXJyb3dIZWlnaHQgOiByLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgMjtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIikge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSAodG9wIC0gbWVhc3VyZWQucGFyZW50LnRvcCkgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmxlZnQgPSAobGVmdCAtIG1lYXN1cmVkLnBhcmVudC5sZWZ0KSAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSB0b3AgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmxlZnQgPSBsZWZ0IC8gc2NhbGVYICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFycm93KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFycm93TGVmdCA9IHBvcy5sZWZ0ICsgKGx0ciA/IG9mZnNldC54IDogLW9mZnNldC54KSAtIChsZWZ0ICsgMTQgLyogQXJyb3cuT2Zmc2V0ICovIC0gNyAvKiBBcnJvdy5TaXplICovKTtcbiAgICAgICAgICAgICAgICBhcnJvdy5zdHlsZS5sZWZ0ID0gYXJyb3dMZWZ0IC8gc2NhbGVYICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgb3RoZXJzLnB1c2goeyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b206IHRvcCArIGhlaWdodCB9KTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1hYm92ZVwiLCBhYm92ZSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYmVsb3dcIiwgIWFib3ZlKTtcbiAgICAgICAgICAgIGlmICh0Vmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIHRWaWV3LnBvc2l0aW9uZWQobWVhc3VyZWQuc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlTWVhc3VyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci50b29sdGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5WaWV3ICE9IHRoaXMudmlldy5pblZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMudmlldy5pblZpZXc7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHYgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHR2LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgICAgIHNjcm9sbCgpIHsgdGhpcy5tYXliZU1lYXN1cmUoKTsgfVxuICAgIH1cbn0pO1xuY29uc3QgYmFzZVRoZW1lID0gRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICB6SW5kZXg6IDUwMCxcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtc2VjdGlvbjpub3QoOmZpcnN0LWNoaWxkKVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2JiYlwiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAtYXJyb3dcIjoge1xuICAgICAgICBoZWlnaHQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgIHdpZHRoOiBgJHs3IC8qIEFycm93LlNpemUgKi8gKiAyfXB4YCxcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgekluZGV4OiAtMSxcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIFwiJjpiZWZvcmUsICY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgY29udGVudDogXCInJ1wiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgYm9yZGVyTGVmdDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgICB9LFxuICAgICAgICBcIi5jbS10b29sdGlwLWFib3ZlICZcIjoge1xuICAgICAgICAgICAgYm90dG9tOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiBcIjFweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiLmNtLXRvb2x0aXAtYmVsb3cgJlwiOiB7XG4gICAgICAgICAgICB0b3A6IGAtJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2JiYmAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjZjVmNWY1YCxcbiAgICAgICAgICAgICAgICB0b3A6IFwiMXB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAgLmNtLXRvb2x0aXAtYXJyb3dcIjoge1xuICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgIGJvcmRlclRvcENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcIiMzMzMzMzhcIlxuICAgICAgICB9LFxuICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuY29uc3Qgbm9PZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbi8qKlxuRmFjZXQgdG8gd2hpY2ggYW4gZXh0ZW5zaW9uIGNhbiBhZGQgYSB2YWx1ZSB0byBzaG93IGEgdG9vbHRpcC5cbiovXG5jb25zdCBzaG93VG9vbHRpcCA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgZW5hYmxlczogW3Rvb2x0aXBQbHVnaW4sIGJhc2VUaGVtZV1cbn0pO1xuY29uc3Qgc2hvd0hvdmVyVG9vbHRpcCA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogaW5wdXRzID0+IGlucHV0cy5yZWR1Y2UoKGEsIGkpID0+IGEuY29uY2F0KGkpLCBbXSlcbn0pO1xuY2xhc3MgSG92ZXJUb29sdGlwSG9zdCB7XG4gICAgLy8gTmVlZHMgdG8gYmUgc3RhdGljIHNvIHRoYXQgaG9zdCB0b29sdGlwIGluc3RhbmNlcyBhbHdheXMgbWF0Y2hcbiAgICBzdGF0aWMgY3JlYXRlKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIb3ZlclRvb2x0aXBIb3N0KHZpZXcpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLWhvdmVyXCIpO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgVG9vbHRpcFZpZXdNYW5hZ2VyKHZpZXcsIHNob3dIb3ZlclRvb2x0aXAsICh0LCBwKSA9PiB0aGlzLmNyZWF0ZUhvc3RlZFZpZXcodCwgcCksIHQgPT4gdC5kb20ucmVtb3ZlKCkpO1xuICAgIH1cbiAgICBjcmVhdGVIb3N0ZWRWaWV3KHRvb2x0aXAsIHByZXYpIHtcbiAgICAgICAgbGV0IGhvc3RlZFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICBob3N0ZWRWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1zZWN0aW9uXCIpO1xuICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUoaG9zdGVkVmlldy5kb20sIHByZXYgPyBwcmV2LmRvbS5uZXh0U2libGluZyA6IHRoaXMuZG9tLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAodGhpcy5tb3VudGVkICYmIGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiBob3N0ZWRWaWV3O1xuICAgIH1cbiAgICBtb3VudCh2aWV3KSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3LnBvc2l0aW9uZWQoc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XG4gICAgfVxuICAgIHBhc3NQcm9wKG5hbWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGxldCBnaXZlbiA9IHZpZXdbbmFtZV07XG4gICAgICAgICAgICBpZiAoZ2l2ZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdpdmVuO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSBnaXZlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwib2Zmc2V0XCIpOyB9XG4gICAgZ2V0IGdldENvb3JkcygpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJnZXRDb29yZHNcIik7IH1cbiAgICBnZXQgb3ZlcmxhcCgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJvdmVybGFwXCIpOyB9XG4gICAgZ2V0IHJlc2l6ZSgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJyZXNpemVcIik7IH1cbn1cbmNvbnN0IHNob3dIb3ZlclRvb2x0aXBIb3N0ID0gc2hvd1Rvb2x0aXAuY29tcHV0ZShbc2hvd0hvdmVyVG9vbHRpcF0sIHN0YXRlID0+IHtcbiAgICBsZXQgdG9vbHRpcHMgPSBzdGF0ZS5mYWNldChzaG93SG92ZXJUb29sdGlwKTtcbiAgICBpZiAodG9vbHRpcHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IE1hdGgubWluKC4uLnRvb2x0aXBzLm1hcCh0ID0+IHQucG9zKSksXG4gICAgICAgIGVuZDogTWF0aC5tYXgoLi4udG9vbHRpcHMubWFwKHQgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0LmVuZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdC5wb3M7IH0pKSxcbiAgICAgICAgY3JlYXRlOiBIb3ZlclRvb2x0aXBIb3N0LmNyZWF0ZSxcbiAgICAgICAgYWJvdmU6IHRvb2x0aXBzWzBdLmFib3ZlLFxuICAgICAgICBhcnJvdzogdG9vbHRpcHMuc29tZSh0ID0+IHQuYXJyb3cpLFxuICAgIH07XG59KTtcbmNsYXNzIEhvdmVyUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzb3VyY2UsIGZpZWxkLCBzZXRIb3ZlciwgaG92ZXJUaW1lKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuc2V0SG92ZXIgPSBzZXRIb3ZlcjtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWUgPSBob3ZlclRpbWU7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogMCwgeTogMCwgdGFyZ2V0OiB2aWV3LmRvbSwgdGltZTogMCB9O1xuICAgICAgICB0aGlzLmNoZWNrSG92ZXIgPSB0aGlzLmNoZWNrSG92ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5tb3VzZWxlYXZlID0gdGhpcy5tb3VzZWxlYXZlLmJpbmQodGhpcykpO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlID0gdGhpcy5tb3VzZW1vdmUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhcnRIb3ZlcigpLCAyMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICB9XG4gICAgY2hlY2tIb3ZlcigpIHtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGhvdmVyZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0TW92ZS50aW1lO1xuICAgICAgICBpZiAoaG92ZXJlZCA8IHRoaXMuaG92ZXJUaW1lKVxuICAgICAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tIb3ZlciwgdGhpcy5ob3ZlclRpbWUgLSBob3ZlcmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zdGFydEhvdmVyKCk7XG4gICAgfVxuICAgIHN0YXJ0SG92ZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgbGV0IHsgdmlldywgbGFzdE1vdmUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3QobGFzdE1vdmUudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFkZXNjKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zLCBzaWRlID0gMTtcbiAgICAgICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBXaWRnZXRWaWV3KSB7XG4gICAgICAgICAgICBwb3MgPSBkZXNjLnBvc0F0U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGxhc3RNb3ZlKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcG9zQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICAgICAgaWYgKCFwb3NDb29yZHMgfHxcbiAgICAgICAgICAgICAgICBsYXN0TW92ZS55IDwgcG9zQ29vcmRzLnRvcCB8fCBsYXN0TW92ZS55ID4gcG9zQ29vcmRzLmJvdHRvbSB8fFxuICAgICAgICAgICAgICAgIGxhc3RNb3ZlLnggPCBwb3NDb29yZHMubGVmdCAtIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoIHx8XG4gICAgICAgICAgICAgICAgbGFzdE1vdmUueCA+IHBvc0Nvb3Jkcy5yaWdodCArIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBiaWRpID0gdmlldy5iaWRpU3BhbnModmlldy5zdGF0ZS5kb2MubGluZUF0KHBvcykpLmZpbmQocyA9PiBzLmZyb20gPD0gcG9zICYmIHMudG8gPj0gcG9zKTtcbiAgICAgICAgICAgIGxldCBydGwgPSBiaWRpICYmIGJpZGkuZGlyID09IGV4cG9ydHMuRGlyZWN0aW9uLlJUTCA/IC0xIDogMTtcbiAgICAgICAgICAgIHNpZGUgPSAobGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0ID8gLXJ0bCA6IHJ0bCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLnNvdXJjZSh2aWV3LCBwb3MsIHNpZGUpO1xuICAgICAgICBpZiAob3BlbiA9PT0gbnVsbCB8fCBvcGVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVuLnRoZW4pIHtcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nID0geyBwb3MgfTtcbiAgICAgICAgICAgIG9wZW4udGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcgPT0gcGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmICEoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmICFyZXN1bHQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKEFycmF5LmlzQXJyYXkocmVzdWx0KSA/IHJlc3VsdCA6IFtyZXN1bHRdKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBlID0+IGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcImhvdmVyIHRvb2x0aXBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZW4gJiYgIShBcnJheS5pc0FycmF5KG9wZW4pICYmICFvcGVuLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKEFycmF5LmlzQXJyYXkob3BlbikgPyBvcGVuIDogW29wZW5dKSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdG9vbHRpcCgpIHtcbiAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMudmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgICAgIGxldCBpbmRleCA9IHBsdWdpbiA/IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBzLmZpbmRJbmRleCh0ID0+IHQuY3JlYXRlID09IEhvdmVyVG9vbHRpcEhvc3QuY3JlYXRlKSA6IC0xO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tpbmRleF0gOiBudWxsO1xuICAgIH1cbiAgICBtb3VzZW1vdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdGFyZ2V0OiBldmVudC50YXJnZXQsIHRpbWU6IERhdGUubm93KCkgfTtcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lKTtcbiAgICAgICAgbGV0IHsgYWN0aXZlLCB0b29sdGlwIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCAmJiB0b29sdGlwICYmICFpc0luVG9vbHRpcCh0b29sdGlwLmRvbSwgZXZlbnQpIHx8IHRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgbGV0IHsgcG9zIH0gPSBhY3RpdmVbMF0gfHwgdGhpcy5wZW5kaW5nLCBlbmQgPSAoX2IgPSAoX2EgPSBhY3RpdmVbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHBvcztcbiAgICAgICAgICAgIGlmICgocG9zID09IGVuZCA/IHRoaXMudmlldy5wb3NBdENvb3Jkcyh0aGlzLmxhc3RNb3ZlKSAhPSBwb3NcbiAgICAgICAgICAgICAgICA6ICFpc092ZXJSYW5nZSh0aGlzLnZpZXcsIHBvcywgZW5kLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKFtdKSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1vdXNlbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgbGV0IHsgYWN0aXZlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgdG9vbHRpcCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBpblRvb2x0aXAgPSB0b29sdGlwICYmIHRvb2x0aXAuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICAgICAgaWYgKCFpblRvb2x0aXApXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihbXSkgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy53YXRjaFRvb2x0aXBMZWF2ZSh0b29sdGlwLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2F0Y2hUb29sdGlwTGVhdmUodG9vbHRpcCkge1xuICAgICAgICBsZXQgd2F0Y2ggPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRvb2x0aXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgd2F0Y2gpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlLmxlbmd0aCAmJiAhdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKFtdKSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdG9vbHRpcC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB3YXRjaCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhvdmVyVGltZW91dCk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5tb3VzZWxlYXZlKTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlKTtcbiAgICB9XG59XG5jb25zdCB0b29sdGlwTWFyZ2luID0gNDtcbmZ1bmN0aW9uIGlzSW5Ub29sdGlwKHRvb2x0aXAsIGV2ZW50KSB7XG4gICAgbGV0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSB0b29sdGlwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBhcnJvdztcbiAgICBpZiAoYXJyb3cgPSB0b29sdGlwLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcC1hcnJvd1wiKSkge1xuICAgICAgICBsZXQgYXJyb3dSZWN0ID0gYXJyb3cuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRvcCA9IE1hdGgubWluKGFycm93UmVjdC50b3AsIHRvcCk7XG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGFycm93UmVjdC5ib3R0b20sIGJvdHRvbSk7XG4gICAgfVxuICAgIHJldHVybiBldmVudC5jbGllbnRYID49IGxlZnQgLSB0b29sdGlwTWFyZ2luICYmIGV2ZW50LmNsaWVudFggPD0gcmlnaHQgKyB0b29sdGlwTWFyZ2luICYmXG4gICAgICAgIGV2ZW50LmNsaWVudFkgPj0gdG9wIC0gdG9vbHRpcE1hcmdpbiAmJiBldmVudC5jbGllbnRZIDw9IGJvdHRvbSArIHRvb2x0aXBNYXJnaW47XG59XG5mdW5jdGlvbiBpc092ZXJSYW5nZSh2aWV3LCBmcm9tLCB0bywgeCwgeSwgbWFyZ2luKSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZG9jQm90dG9tID0gdmlldy5kb2N1bWVudFRvcCArIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCArIHZpZXcuY29udGVudEhlaWdodDtcbiAgICBpZiAocmVjdC5sZWZ0ID4geCB8fCByZWN0LnJpZ2h0IDwgeCB8fCByZWN0LnRvcCA+IHkgfHwgTWF0aC5taW4ocmVjdC5ib3R0b20sIGRvY0JvdHRvbSkgPCB5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4LCB5IH0sIGZhbHNlKTtcbiAgICByZXR1cm4gcG9zID49IGZyb20gJiYgcG9zIDw9IHRvO1xufVxuLyoqXG5TZXQgdXAgYSBob3ZlciB0b29sdGlwLCB3aGljaCBzaG93cyB1cCB3aGVuIHRoZSBwb2ludGVyIGhvdmVyc1xub3ZlciByYW5nZXMgb2YgdGV4dC4gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBob3ZlcnNcbm92ZXIgdGhlIGRvY3VtZW50IHRleHQuIEl0IHNob3VsZCwgaWYgdGhlcmUgaXMgYSB0b29sdGlwXG5hc3NvY2lhdGVkIHdpdGggcG9zaXRpb24gYHBvc2AsIHJldHVybiB0aGUgdG9vbHRpcCBkZXNjcmlwdGlvblxuKGVpdGhlciBkaXJlY3RseSBvciBpbiBhIHByb21pc2UpLiBUaGUgYHNpZGVgIGFyZ3VtZW50IGluZGljYXRlc1xub24gd2hpY2ggc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhlIHBvaW50ZXIgaXPigJRpdCB3aWxsIGJlIC0xIGlmIHRoZVxucG9pbnRlciBpcyBiZWZvcmUgdGhlIHBvc2l0aW9uLCAxIGlmIGFmdGVyIHRoZSBwb3NpdGlvbi5cblxuTm90ZSB0aGF0IGFsbCBob3ZlciB0b29sdGlwcyBhcmUgaG9zdGVkIHdpdGhpbiBhIHNpbmdsZSB0b29sdGlwXG5jb250YWluZXIgZWxlbWVudC4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgdG9vbHRpcHMgb3ZlciB0aGUgc2FtZVxucmFuZ2UgdG8gYmUgXCJtZXJnZWRcIiB0b2dldGhlciB3aXRob3V0IG92ZXJsYXBwaW5nLlxuXG5UaGUgcmV0dXJuIHZhbHVlIGlzIGEgdmFsaWQgW2VkaXRvciBleHRlbnNpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRXh0ZW5zaW9uKVxuYnV0IGFsc28gcHJvdmlkZXMgYW4gYGFjdGl2ZWAgcHJvcGVydHkgaG9sZGluZyBhIHN0YXRlIGZpZWxkIHRoYXRcbmNhbiBiZSB1c2VkIHRvIHJlYWQgdGhlIGN1cnJlbnRseSBhY3RpdmUgdG9vbHRpcHMgcHJvZHVjZWQgYnkgdGhpc1xuZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIGhvdmVyVG9vbHRpcChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBzZXRIb3ZlciA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuICAgIGxldCBob3ZlclN0YXRlID0gc3RhdGUuU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgICAgICBjcmVhdGUoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhpZGVPbkNoYW5nZSAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGlkZU9uKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmZpbHRlcih2ID0+ICFvcHRpb25zLmhpZGVPbih0ciwgdikpO1xuICAgICAgICAgICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdG9vbHRpcCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1BvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHRvb2x0aXAucG9zLCAtMSwgc3RhdGUuTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3UG9zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgdG9vbHRpcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weS5wb3MgPSBuZXdQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcHkuZW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuZW5kID0gdHIuY2hhbmdlcy5tYXBQb3MoY29weS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlZC5wdXNoKGNvcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRIb3ZlcikpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlOiBmID0+IHNob3dIb3ZlclRvb2x0aXAuZnJvbShmKVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjdGl2ZTogaG92ZXJTdGF0ZSxcbiAgICAgICAgZXh0ZW5zaW9uOiBbXG4gICAgICAgICAgICBob3ZlclN0YXRlLFxuICAgICAgICAgICAgVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgSG92ZXJQbHVnaW4odmlldywgc291cmNlLCBob3ZlclN0YXRlLCBzZXRIb3Zlciwgb3B0aW9ucy5ob3ZlclRpbWUgfHwgMzAwIC8qIEhvdmVyLlRpbWUgKi8pKSxcbiAgICAgICAgICAgIHNob3dIb3ZlclRvb2x0aXBIb3N0XG4gICAgICAgIF1cbiAgICB9O1xufVxuLyoqXG5HZXQgdGhlIGFjdGl2ZSB0b29sdGlwIHZpZXcgZm9yIGEgZ2l2ZW4gdG9vbHRpcCwgaWYgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXAodmlldywgdG9vbHRpcCkge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICBpZiAoIXBsdWdpbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZvdW5kID0gcGx1Z2luLm1hbmFnZXIudG9vbHRpcHMuaW5kZXhPZih0b29sdGlwKTtcbiAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tmb3VuZF07XG59XG4vKipcblJldHVybnMgdHJ1ZSBpZiBhbnkgaG92ZXIgdG9vbHRpcHMgYXJlIGN1cnJlbnRseSBhY3RpdmUuXG4qL1xuZnVuY3Rpb24gaGFzSG92ZXJUb29sdGlwcyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5mYWNldChzaG93SG92ZXJUb29sdGlwKS5zb21lKHggPT4geCk7XG59XG5jb25zdCBjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBlZmZlY3QgdGhhdCBjbG9zZXMgYWxsIGhvdmVyIHRvb2x0aXBzLlxuKi9cbmNvbnN0IGNsb3NlSG92ZXJUb29sdGlwcyA9IGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0Lm9mKG51bGwpO1xuLyoqXG5UZWxsIHRoZSB0b29sdGlwIGV4dGVuc2lvbiB0byByZWNvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RpdmVcbnRvb2x0aXBzLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBzb21ldGhpbmcgaGFwcGVucyAoc3VjaCBhcyBhXG5yZS1wb3NpdGlvbmluZyBvciBDU1MgY2hhbmdlIGFmZmVjdGluZyB0aGUgZWRpdG9yKSB0aGF0IGNvdWxkXG5pbnZhbGlkYXRlIHRoZSBleGlzdGluZyB0b29sdGlwIHBvc2l0aW9ucy5cbiovXG5mdW5jdGlvbiByZXBvc2l0aW9uVG9vbHRpcHModmlldykge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICBpZiAocGx1Z2luKVxuICAgICAgICBwbHVnaW4ubWF5YmVNZWFzdXJlKCk7XG59XG5cbmNvbnN0IHBhbmVsQ29uZmlnID0gc3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgbGV0IHRvcENvbnRhaW5lciwgYm90dG9tQ29udGFpbmVyO1xuICAgICAgICBmb3IgKGxldCBjIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgICAgIHRvcENvbnRhaW5lciA9IHRvcENvbnRhaW5lciB8fCBjLnRvcENvbnRhaW5lcjtcbiAgICAgICAgICAgIGJvdHRvbUNvbnRhaW5lciA9IGJvdHRvbUNvbnRhaW5lciB8fCBjLmJvdHRvbUNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lciB9O1xuICAgIH1cbn0pO1xuLyoqXG5Db25maWd1cmVzIHRoZSBwYW5lbC1tYW5hZ2luZyBleHRlbnNpb24uXG4qL1xuZnVuY3Rpb24gcGFuZWxzKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcgPyBbcGFuZWxDb25maWcub2YoY29uZmlnKV0gOiBbXTtcbn1cbi8qKlxuR2V0IHRoZSBhY3RpdmUgcGFuZWwgY3JlYXRlZCBieSB0aGUgZ2l2ZW4gY29uc3RydWN0b3IsIGlmIGFueS5cblRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIGFjY2VzcyB0byB5b3VyIHBhbmVscycgRE9NXG5zdHJ1Y3R1cmUuXG4qL1xuZnVuY3Rpb24gZ2V0UGFuZWwodmlldywgcGFuZWwpIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4ocGFuZWxQbHVnaW4pO1xuICAgIGxldCBpbmRleCA9IHBsdWdpbiA/IHBsdWdpbi5zcGVjcy5pbmRleE9mKHBhbmVsKSA6IC0xO1xuICAgIHJldHVybiBpbmRleCA+IC0xID8gcGx1Z2luLnBhbmVsc1tpbmRleF0gOiBudWxsO1xufVxuY29uc3QgcGFuZWxQbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICB0aGlzLnNwZWNzID0gdGhpcy5pbnB1dC5maWx0ZXIocyA9PiBzKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSB0aGlzLnNwZWNzLm1hcChzcGVjID0+IHNwZWModmlldykpO1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5ib3R0b20gPSBuZXcgUGFuZWxHcm91cCh2aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB0aGlzLnRvcC5zeW5jKHRoaXMucGFuZWxzLmZpbHRlcihwID0+IHAudG9wKSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gIXAudG9wKSk7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgIGlmIChwLm1vdW50KVxuICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHBhbmVsQ29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMudG9wLmNvbnRhaW5lciAhPSBjb25mLnRvcENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCB0cnVlLCBjb25mLnRvcENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm90dG9tLmNvbnRhaW5lciAhPSBjb25mLmJvdHRvbUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9wLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgbGV0IHNwZWNzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XG4gICAgICAgICAgICBsZXQgcGFuZWxzID0gW10sIHRvcCA9IFtdLCBib3R0b20gPSBbXSwgbW91bnQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSB0aGlzLnNwZWNzLmluZGV4T2Yoc3BlYyksIHBhbmVsO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwgPSBzcGVjKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgbW91bnQucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHRoaXMucGFuZWxzW2tub3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVsLnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYW5lbHMucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgKHBhbmVsLnRvcCA/IHRvcCA6IGJvdHRvbSkucHVzaChwYW5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgICAgICB0aGlzLnBhbmVscyA9IHBhbmVscztcbiAgICAgICAgICAgIHRoaXMudG9wLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tLnN5bmMoYm90dG9tKTtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgbW91bnQpIHtcbiAgICAgICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XG4gICAgICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICAgICAgaWYgKHAudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG9wLnN5bmMoW10pO1xuICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucy5vZih2aWV3ID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHsgdG9wOiB2YWx1ZS50b3Auc2Nyb2xsTWFyZ2luKCksIGJvdHRvbTogdmFsdWUuYm90dG9tLnNjcm9sbE1hcmdpbigpIH07XG4gICAgfSlcbn0pO1xuY2xhc3MgUGFuZWxHcm91cCB7XG4gICAgY29uc3RydWN0b3IodmlldywgdG9wLCBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gXCJcIjtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5zeW5jQ2xhc3NlcygpO1xuICAgIH1cbiAgICBzeW5jKHBhbmVscykge1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGFuZWxzKVxuICAgICAgICAgICAgaWYgKHAuZGVzdHJveSAmJiBwYW5lbHMuaW5kZXhPZihwKSA8IDApXG4gICAgICAgICAgICAgICAgcC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICB0aGlzLnN5bmNET00oKTtcbiAgICB9XG4gICAgc3luY0RPTSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZWxzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSB0aGlzLnRvcCA/IFwiY20tcGFuZWxzIGNtLXBhbmVscy10b3BcIiA6IFwiY20tcGFuZWxzIGNtLXBhbmVscy1ib3R0b21cIjtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlW3RoaXMudG9wID8gXCJ0b3BcIiA6IFwiYm90dG9tXCJdID0gXCIwXCI7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5jb250YWluZXIgfHwgdGhpcy52aWV3LmRvbTtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHRoaXMudG9wID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VyRE9NID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgcGFuZWwgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIGlmIChwYW5lbC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJET00gIT0gcGFuZWwuZG9tKVxuICAgICAgICAgICAgICAgICAgICBjdXJET00gPSBybShjdXJET00pO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IGN1ckRPTS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShwYW5lbC5kb20sIGN1ckRPTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGN1ckRPTSlcbiAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgfVxuICAgIHNjcm9sbE1hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRvbSB8fCB0aGlzLmNvbnRhaW5lciA/IDBcbiAgICAgICAgICAgIDogTWF0aC5tYXgoMCwgdGhpcy50b3AgP1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIE1hdGgubWF4KDAsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSA6XG4gICAgICAgICAgICAgICAgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKSAtIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCk7XG4gICAgfVxuICAgIHN5bmNDbGFzc2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyIHx8IHRoaXMuY2xhc3NlcyA9PSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgdGhpcy5jbGFzc2VzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgKHRoaXMuY2xhc3NlcyA9IHRoaXMudmlldy50aGVtZUNsYXNzZXMpLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJtKG5vZGUpIHtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8qKlxuT3BlbmluZyBhIHBhbmVsIGlzIGRvbmUgYnkgcHJvdmlkaW5nIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yXG50aGUgcGFuZWwgdGhyb3VnaCB0aGlzIGZhY2V0LiAoVGhlIHBhbmVsIGlzIGNsb3NlZCBhZ2FpbiB3aGVuIGl0c1xuY29uc3RydWN0b3IgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLikgVmFsdWVzIG9mIGBudWxsYCBhcmUgaWdub3JlZC5cbiovXG5jb25zdCBzaG93UGFuZWwgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IHBhbmVsUGx1Z2luXG59KTtcblxuLyoqXG5BIGd1dHRlciBtYXJrZXIgcmVwcmVzZW50cyBhIGJpdCBvZiBpbmZvcm1hdGlvbiBhdHRhY2hlZCB0byBhIGxpbmVcbmluIGEgc3BlY2lmaWMgZ3V0dGVyLiBZb3VyIG93biBjdXN0b20gbWFya2VycyBoYXZlIHRvIGV4dGVuZCB0aGlzXG5jbGFzcy5cbiovXG5jbGFzcyBHdXR0ZXJNYXJrZXIgZXh0ZW5kcyBzdGF0ZS5SYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIG1hcmtlciB0byBhbm90aGVyIG1hcmtlciBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ2FsbGVkIGlmIHRoZSBtYXJrZXIgaGFzIGEgYHRvRE9NYCBtZXRob2QgYW5kIGl0cyByZXByZXNlbnRhdGlvblxuICAgIHdhcyByZW1vdmVkIGZyb20gYSBndXR0ZXIuXG4gICAgKi9cbiAgICBkZXN0cm95KGRvbSkgeyB9XG59XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLmVsZW1lbnRDbGFzcyA9IFwiXCI7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnRvRE9NID0gdW5kZWZpbmVkO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5tYXBNb2RlID0gc3RhdGUuTWFwTW9kZS5UcmFja0JlZm9yZTtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUuc3RhcnRTaWRlID0gR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbmRTaWRlID0gLTE7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBhZGQgYSBjbGFzcyB0byBhbGwgZ3V0dGVyIGVsZW1lbnRzIGZvciBhIGdpdmVuIGxpbmUuXG5NYXJrZXJzIGdpdmVuIHRvIHRoaXMgZmFjZXQgc2hvdWxkIF9vbmx5XyBkZWZpbmUgYW5cbltgZWxlbWVudGNsYXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lkd1dHRlck1hcmtlci5lbGVtZW50Q2xhc3MpLCBub3QgYVxuW2B0b0RPTWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIudG9ET00pIChvciB0aGUgbWFya2VyIHdpbGwgYXBwZWFyXG5pbiBhbGwgZ3V0dGVycyBmb3IgdGhlIGxpbmUpLlxuKi9cbmNvbnN0IGd1dHRlckxpbmVDbGFzcyA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuLyoqXG5GYWNldCB1c2VkIHRvIGFkZCBhIGNsYXNzIHRvIGFsbCBndXR0ZXIgZWxlbWVudHMgbmV4dCB0byBhIHdpZGdldC5cblNob3VsZCBub3QgcHJvdmlkZSB3aWRnZXRzIHdpdGggYSBgdG9ET01gIG1ldGhvZC5cbiovXG5jb25zdCBndXR0ZXJXaWRnZXRDbGFzcyA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgY2xhc3M6IFwiXCIsXG4gICAgcmVuZGVyRW1wdHlFbGVtZW50czogZmFsc2UsXG4gICAgZWxlbWVudFN0eWxlOiBcIlwiLFxuICAgIG1hcmtlcnM6ICgpID0+IHN0YXRlLlJhbmdlU2V0LmVtcHR5LFxuICAgIGxpbmVNYXJrZXI6ICgpID0+IG51bGwsXG4gICAgd2lkZ2V0TWFya2VyOiAoKSA9PiBudWxsLFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IG51bGwsXG4gICAgaW5pdGlhbFNwYWNlcjogbnVsbCxcbiAgICB1cGRhdGVTcGFjZXI6IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge31cbn07XG5jb25zdCBhY3RpdmVHdXR0ZXJzID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG4vKipcbkRlZmluZSBhbiBlZGl0b3IgZ3V0dGVyLiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIGd1dHRlcnMgYXBwZWFyIGlzXG5kZXRlcm1pbmVkIGJ5IHRoZWlyIGV4dGVuc2lvbiBwcmlvcml0eS5cbiovXG5mdW5jdGlvbiBndXR0ZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtndXR0ZXJzKCksIGFjdGl2ZUd1dHRlcnMub2YoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyksIGNvbmZpZykpXTtcbn1cbmNvbnN0IHVuZml4R3V0dGVycyA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuLyoqXG5UaGUgZ3V0dGVyLWRyYXdpbmcgcGx1Z2luIGlzIGF1dG9tYXRpY2FsbHkgZW5hYmxlZCB3aGVuIHlvdSBhZGQgYVxuZ3V0dGVyLCBidXQgeW91IGNhbiB1c2UgdGhpcyBmdW5jdGlvbiB0byBleHBsaWNpdGx5IGNvbmZpZ3VyZSBpdC5cblxuVW5sZXNzIGBmaXhlZGAgaXMgZXhwbGljaXRseSBzZXQgdG8gYGZhbHNlYCwgdGhlIGd1dHRlcnMgYXJlXG5maXhlZCwgbWVhbmluZyB0aGV5IGRvbid0IHNjcm9sbCBhbG9uZyB3aXRoIHRoZSBjb250ZW50XG5ob3Jpem9udGFsbHkgKGV4Y2VwdCBvbiBJbnRlcm5ldCBFeHBsb3Jlciwgd2hpY2ggZG9lc24ndCBzdXBwb3J0XG5DU1MgW2Bwb3NpdGlvbjpcbnN0aWNreWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9wb3NpdGlvbiNzdGlja3kpKS5cbiovXG5mdW5jdGlvbiBndXR0ZXJzKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbXG4gICAgICAgIGd1dHRlclZpZXcsXG4gICAgXTtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5maXhlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJlc3VsdC5wdXNoKHVuZml4R3V0dGVycy5vZih0cnVlKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGd1dHRlclZpZXcgPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnByZXZWaWV3cG9ydCA9IHZpZXcudmlld3BvcnQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJzXCI7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gKHRoaXMudmlldy5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZ3V0dGVycyA9IHZpZXcuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycykubWFwKGNvbmYgPT4gbmV3IFNpbmdsZUd1dHRlclZpZXcodmlldywgY29uZikpO1xuICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZ3V0dGVyLmRvbSk7XG4gICAgICAgIHRoaXMuZml4ZWQgPSAhdmlldy5zdGF0ZS5mYWNldCh1bmZpeEd1dHRlcnMpO1xuICAgICAgICBpZiAodGhpcy5maXhlZCkge1xuICAgICAgICAgICAgLy8gRklYTUUgSUUxMSBmYWxsYmFjaywgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHBvc2l0aW9uOiBzdGlja3ksXG4gICAgICAgICAgICAvLyBieSB1c2luZyBwb3NpdGlvbjogcmVsYXRpdmUgKyBldmVudCBoYW5kbGVycyB0aGF0IHJlYWxpZ24gdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXIgKG9yIGp1c3QgZm9yY2UgZml4ZWQ9ZmFsc2Ugb24gSUUxMT8pXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwic3RpY2t5XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jR3V0dGVycyhmYWxzZSk7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdmlldy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVHdXR0ZXJzKHVwZGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIERldGFjaCBkdXJpbmcgc3luYyB3aGVuIHRoZSB2aWV3cG9ydCBjaGFuZ2VkIHNpZ25pZmljYW50bHlcbiAgICAgICAgICAgIC8vIChzdWNoIGFzIGR1cmluZyBzY3JvbGxpbmcpLCBzaW5jZSBmb3IgbGFyZ2UgdXBkYXRlcyB0aGF0IGlzXG4gICAgICAgICAgICAvLyBmYXN0ZXIuXG4gICAgICAgICAgICBsZXQgdnBBID0gdGhpcy5wcmV2Vmlld3BvcnQsIHZwQiA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICAgICAgbGV0IHZwT3ZlcmxhcCA9IE1hdGgubWluKHZwQS50bywgdnBCLnRvKSAtIE1hdGgubWF4KHZwQS5mcm9tLCB2cEIuZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnN5bmNHdXR0ZXJzKHZwT3ZlcmxhcCA8ICh2cEIudG8gLSB2cEIuZnJvbSkgKiAwLjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5taW5IZWlnaHQgPSAodGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZKSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZhY2V0KHVuZml4R3V0dGVycykgIT0gIXRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZml4ZWQgPSAhdGhpcy5maXhlZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgfVxuICAgIHN5bmNHdXR0ZXJzKGRldGFjaCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICBsZXQgbGluZUNsYXNzZXMgPSBzdGF0ZS5SYW5nZVNldC5pdGVyKHRoaXMudmlldy5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB0aGlzLnZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgICAgIGxldCBjbGFzc1NldCA9IFtdO1xuICAgICAgICBsZXQgY29udGV4dHMgPSB0aGlzLmd1dHRlcnMubWFwKGd1dHRlciA9PiBuZXcgVXBkYXRlQ29udGV4dChndXR0ZXIsIHRoaXMudmlldy52aWV3cG9ydCwgLXRoaXMudmlldy5kb2N1bWVudFBhZGRpbmcudG9wKSk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgaWYgKGNsYXNzU2V0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBjbGFzc1NldCA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PSBleHBvcnRzLkJsb2NrVHlwZS5UZXh0ICYmIGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgYi5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LmxpbmUodGhpcy52aWV3LCBiLCBjbGFzc1NldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC53aWRnZXQodGhpcy52aWV3LCBiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUudHlwZSA9PSBleHBvcnRzLkJsb2NrVHlwZS5UZXh0KSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgIGN4LmxpbmUodGhpcy52aWV3LCBsaW5lLCBjbGFzc1NldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lLndpZGdldCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgICAgICBjeC53aWRnZXQodGhpcy52aWV3LCBsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgIGN4LmZpbmlzaCgpO1xuICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5pbnNlcnRCZWZvcmUodGhpcy5kb20sIGFmdGVyKTtcbiAgICB9XG4gICAgdXBkYXRlR3V0dGVycyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXYgPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKSwgY3VyID0gdXBkYXRlLnN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpO1xuICAgICAgICBsZXQgY2hhbmdlID0gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLmhlaWdodENoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgIXN0YXRlLlJhbmdlU2V0LmVxKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB1cGRhdGUudmlldy52aWV3cG9ydC5mcm9tLCB1cGRhdGUudmlldy52aWV3cG9ydC50byk7XG4gICAgICAgIGlmIChwcmV2ID09IGN1cikge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3V0dGVyIG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgICAgICBpZiAoZ3V0dGVyLnVwZGF0ZSh1cGRhdGUpKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBndXR0ZXJzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjb25mIG9mIGN1cikge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHByZXYuaW5kZXhPZihjb25mKTtcbiAgICAgICAgICAgICAgICBpZiAoa25vd24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGd1dHRlcnMucHVzaChuZXcgU2luZ2xlR3V0dGVyVmlldyh0aGlzLnZpZXcsIGNvbmYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3V0dGVyc1trbm93bl0udXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGd1dHRlcnMucHVzaCh0aGlzLmd1dHRlcnNba25vd25dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBnIG9mIHRoaXMuZ3V0dGVycykge1xuICAgICAgICAgICAgICAgIGcuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChndXR0ZXJzLmluZGV4T2YoZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICBnLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgZ3V0dGVycylcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChnLmRvbSk7XG4gICAgICAgICAgICB0aGlzLmd1dHRlcnMgPSBndXR0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4gRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zLm9mKHZpZXcgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmd1dHRlcnMubGVuZ3RoID09IDAgfHwgIXZhbHVlLmZpeGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB2aWV3LnRleHREaXJlY3Rpb24gPT0gZXhwb3J0cy5EaXJlY3Rpb24uTFRSXG4gICAgICAgICAgICA/IHsgbGVmdDogdmFsdWUuZG9tLm9mZnNldFdpZHRoICogdmlldy5zY2FsZVggfVxuICAgICAgICAgICAgOiB7IHJpZ2h0OiB2YWx1ZS5kb20ub2Zmc2V0V2lkdGggKiB2aWV3LnNjYWxlWCB9O1xuICAgIH0pXG59KTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsKSB7IHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pOyB9XG5mdW5jdGlvbiBhZHZhbmNlQ3Vyc29yKGN1cnNvciwgY29sbGVjdCwgcG9zKSB7XG4gICAgd2hpbGUgKGN1cnNvci52YWx1ZSAmJiBjdXJzb3IuZnJvbSA8PSBwb3MpIHtcbiAgICAgICAgaWYgKGN1cnNvci5mcm9tID09IHBvcylcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgIH1cbn1cbmNsYXNzIFVwZGF0ZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGd1dHRlciwgdmlld3BvcnQsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmd1dHRlciA9IGd1dHRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gc3RhdGUuUmFuZ2VTZXQuaXRlcihndXR0ZXIubWFya2Vycywgdmlld3BvcnQuZnJvbSk7XG4gICAgfVxuICAgIGFkZEVsZW1lbnQodmlldywgYmxvY2ssIG1hcmtlcnMpIHtcbiAgICAgICAgbGV0IHsgZ3V0dGVyIH0gPSB0aGlzLCBhYm92ZSA9IChibG9jay50b3AgLSB0aGlzLmhlaWdodCkgLyB2aWV3LnNjYWxlWSwgaGVpZ2h0ID0gYmxvY2suaGVpZ2h0IC8gdmlldy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLmkgPT0gZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5ld0VsdCA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzLnB1c2gobmV3RWx0KTtcbiAgICAgICAgICAgIGd1dHRlci5kb20uYXBwZW5kQ2hpbGQobmV3RWx0LmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHNbdGhpcy5pXS51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBibG9jay5ib3R0b207XG4gICAgICAgIHRoaXMuaSsrO1xuICAgIH1cbiAgICBsaW5lKHZpZXcsIGxpbmUsIGV4dHJhTWFya2Vycykge1xuICAgICAgICBsZXQgbG9jYWxNYXJrZXJzID0gW107XG4gICAgICAgIGFkdmFuY2VDdXJzb3IodGhpcy5jdXJzb3IsIGxvY2FsTWFya2VycywgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGV4dHJhTWFya2Vycy5sZW5ndGgpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMgPSBsb2NhbE1hcmtlcnMuY29uY2F0KGV4dHJhTWFya2Vycyk7XG4gICAgICAgIGxldCBmb3JMaW5lID0gdGhpcy5ndXR0ZXIuY29uZmlnLmxpbmVNYXJrZXIodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgaWYgKGZvckxpbmUpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICBpZiAobG9jYWxNYXJrZXJzLmxlbmd0aCA9PSAwICYmICFndXR0ZXIuY29uZmlnLnJlbmRlckVtcHR5RWxlbWVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBsaW5lLCBsb2NhbE1hcmtlcnMpO1xuICAgIH1cbiAgICB3aWRnZXQodmlldywgYmxvY2spIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IHRoaXMuZ3V0dGVyLmNvbmZpZy53aWRnZXRNYXJrZXIodmlldywgYmxvY2sud2lkZ2V0LCBibG9jayksIG1hcmtlcnMgPSBtYXJrZXIgPyBbbWFya2VyXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNscyBvZiB2aWV3LnN0YXRlLmZhY2V0KGd1dHRlcldpZGdldENsYXNzKSkge1xuICAgICAgICAgICAgbGV0IG1hcmtlciA9IGNscyh2aWV3LCBibG9jay53aWRnZXQsIGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIpXG4gICAgICAgICAgICAgICAgKG1hcmtlcnMgfHwgKG1hcmtlcnMgPSBbXSkpLnB1c2gobWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VycylcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBibG9jaywgbWFya2Vycyk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICB3aGlsZSAoZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCA+IHRoaXMuaSkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBndXR0ZXIuZWxlbWVudHMucG9wKCk7XG4gICAgICAgICAgICBndXR0ZXIuZG9tLnJlbW92ZUNoaWxkKGxhc3QuZG9tKTtcbiAgICAgICAgICAgIGxhc3QuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2luZ2xlR3V0dGVyVmlldyB7XG4gICAgY29uc3RydWN0b3IodmlldywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuc3BhY2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlclwiICsgKHRoaXMuY29uZmlnLmNsYXNzID8gXCIgXCIgKyB0aGlzLmNvbmZpZy5jbGFzcyA6IFwiXCIpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGNvbmZpZy5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKHByb3AsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQsIHk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSB0aGlzLmRvbSAmJiB0aGlzLmRvbS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0YXJnZXQucGFyZW50Tm9kZSAhPSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0SGVpZ2h0KHkgLSB2aWV3LmRvY3VtZW50VG9wKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRvbUV2ZW50SGFuZGxlcnNbcHJvcF0odmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheShjb25maWcubWFya2Vycyh2aWV3KSk7XG4gICAgICAgIGlmIChjb25maWcuaW5pdGlhbFNwYWNlcikge1xuICAgICAgICAgICAgdGhpcy5zcGFjZXIgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCAwLCAwLCBbY29uZmlnLmluaXRpYWxTcGFjZXIodmlldyldKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc3BhY2VyLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnNwYWNlci5kb20uc3R5bGUuY3NzVGV4dCArPSBcInZpc2liaWxpdHk6IGhpZGRlbjsgcG9pbnRlci1ldmVudHM6IG5vbmVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2TWFya2VycyA9IHRoaXMubWFya2VycztcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheSh0aGlzLmNvbmZpZy5tYXJrZXJzKHVwZGF0ZS52aWV3KSk7XG4gICAgICAgIGlmICh0aGlzLnNwYWNlciAmJiB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0sIHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlZCAhPSB0aGlzLnNwYWNlci5tYXJrZXJzWzBdKVxuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VyLnVwZGF0ZSh1cGRhdGUudmlldywgMCwgMCwgW3VwZGF0ZWRdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdnAgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgcmV0dXJuICFzdGF0ZS5SYW5nZVNldC5lcSh0aGlzLm1hcmtlcnMsIHByZXZNYXJrZXJzLCB2cC5mcm9tLCB2cC50bykgfHxcbiAgICAgICAgICAgICh0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlID8gdGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSh1cGRhdGUpIDogZmFsc2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5lbGVtZW50cylcbiAgICAgICAgICAgIGVsdC5kZXN0cm95KCk7XG4gICAgfVxufVxuY2xhc3MgR3V0dGVyRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLmFib3ZlID0gMDtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgIH1cbiAgICB1cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hYm92ZSAhPSBhYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1hcmdpblRvcCA9ICh0aGlzLmFib3ZlID0gYWJvdmUpID8gYWJvdmUgKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICBpZiAoIXNhbWVNYXJrZXJzKHRoaXMubWFya2VycywgbWFya2VycykpXG4gICAgICAgICAgICB0aGlzLnNldE1hcmtlcnModmlldywgbWFya2Vycyk7XG4gICAgfVxuICAgIHNldE1hcmtlcnModmlldywgbWFya2Vycykge1xuICAgICAgICBsZXQgY2xzID0gXCJjbS1ndXR0ZXJFbGVtZW50XCIsIGRvbVBvcyA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAobGV0IGlOZXcgPSAwLCBpT2xkID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgc2tpcFRvID0gaU9sZCwgbWFya2VyID0gaU5ldyA8IG1hcmtlcnMubGVuZ3RoID8gbWFya2Vyc1tpTmV3KytdIDogbnVsbCwgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICAgICAgICAgIGxldCBjID0gbWFya2VyLmVsZW1lbnRDbGFzcztcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiICsgYztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaU9sZDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2Vyc1tpXS5jb21wYXJlKG1hcmtlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUbyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBza2lwVG8gPSB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGlPbGQgPCBza2lwVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubWFya2Vyc1tpT2xkKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuZGVzdHJveShkb21Qb3MpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkb21Qb3MubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gYWZ0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobWFya2VyLnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpXG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcyA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIudG9ET00odmlldyksIGRvbVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICBpT2xkKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gY2xzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBtYXJrZXJzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldE1hcmtlcnMobnVsbCwgW10pOyAvLyBGaXJzdCBhcmd1bWVudCBub3QgdXNlZCB1bmxlc3MgY3JlYXRpbmcgbWFya2Vyc1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVNYXJrZXJzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5jb21wYXJlKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5GYWNldCB1c2VkIHRvIHByb3ZpZGUgbWFya2VycyB0byB0aGUgbGluZSBudW1iZXIgZ3V0dGVyLlxuKi9cbmNvbnN0IGxpbmVOdW1iZXJNYXJrZXJzID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IHVzZWQgdG8gY3JlYXRlIG1hcmtlcnMgaW4gdGhlIGxpbmUgbnVtYmVyIGd1dHRlciBuZXh0IHRvIHdpZGdldHMuXG4qL1xuY29uc3QgbGluZU51bWJlcldpZGdldE1hcmtlciA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuY29uc3QgbGluZU51bWJlckNvbmZpZyA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbWJpbmVDb25maWcodmFsdWVzLCB7IGZvcm1hdE51bWJlcjogU3RyaW5nLCBkb21FdmVudEhhbmRsZXJzOiB7fSB9LCB7XG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcmVzdWx0W2V2ZW50XSwgYWRkID0gYltldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtldmVudF0gPSBleGlzdHMgPyAodmlldywgbGluZSwgZXZlbnQpID0+IGV4aXN0cyh2aWV3LCBsaW5lLCBldmVudCkgfHwgYWRkKHZpZXcsIGxpbmUsIGV2ZW50KSA6IGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jbGFzcyBOdW1iZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMubnVtYmVyID09IG90aGVyLm51bWJlcjsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5udW1iZXIpOyB9XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIodmlldywgbnVtYmVyKSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZm9ybWF0TnVtYmVyKG51bWJlciwgdmlldy5zdGF0ZSk7XG59XG5jb25zdCBsaW5lTnVtYmVyR3V0dGVyID0gYWN0aXZlR3V0dGVycy5jb21wdXRlKFtsaW5lTnVtYmVyQ29uZmlnXSwgc3RhdGUgPT4gKHtcbiAgICBjbGFzczogXCJjbS1saW5lTnVtYmVyc1wiLFxuICAgIHJlbmRlckVtcHR5RWxlbWVudHM6IGZhbHNlLFxuICAgIG1hcmtlcnModmlldykgeyByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChsaW5lTnVtYmVyTWFya2Vycyk7IH0sXG4gICAgbGluZU1hcmtlcih2aWV3LCBsaW5lLCBvdGhlcnMpIHtcbiAgICAgICAgaWYgKG90aGVycy5zb21lKG0gPT4gbS50b0RPTSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJNYXJrZXIoZm9ybWF0TnVtYmVyKHZpZXcsIHZpZXcuc3RhdGUuZG9jLmxpbmVBdChsaW5lLmZyb20pLm51bWJlcikpO1xuICAgIH0sXG4gICAgd2lkZ2V0TWFya2VyOiAodmlldywgd2lkZ2V0LCBibG9jaykgPT4ge1xuICAgICAgICBmb3IgKGxldCBtIG9mIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlcldpZGdldE1hcmtlcikpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtKHZpZXcsIHdpZGdldCwgYmxvY2spO1xuICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgbGluZU1hcmtlckNoYW5nZTogdXBkYXRlID0+IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSxcbiAgICBpbml0aWFsU3BhY2VyKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJNYXJrZXIoZm9ybWF0TnVtYmVyKHZpZXcsIG1heExpbmVOdW1iZXIodmlldy5zdGF0ZS5kb2MubGluZXMpKSk7XG4gICAgfSxcbiAgICB1cGRhdGVTcGFjZXIoc3BhY2VyLCB1cGRhdGUpIHtcbiAgICAgICAgbGV0IG1heCA9IGZvcm1hdE51bWJlcih1cGRhdGUudmlldywgbWF4TGluZU51bWJlcih1cGRhdGUudmlldy5zdGF0ZS5kb2MubGluZXMpKTtcbiAgICAgICAgcmV0dXJuIG1heCA9PSBzcGFjZXIubnVtYmVyID8gc3BhY2VyIDogbmV3IE51bWJlck1hcmtlcihtYXgpO1xuICAgIH0sXG4gICAgZG9tRXZlbnRIYW5kbGVyczogc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZG9tRXZlbnRIYW5kbGVyc1xufSkpO1xuLyoqXG5DcmVhdGUgYSBsaW5lIG51bWJlciBndXR0ZXIgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIGxpbmVOdW1iZXJzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbGluZU51bWJlckNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBndXR0ZXJzKCksXG4gICAgICAgIGxpbmVOdW1iZXJHdXR0ZXJcbiAgICBdO1xufVxuZnVuY3Rpb24gbWF4TGluZU51bWJlcihsaW5lcykge1xuICAgIGxldCBsYXN0ID0gOTtcbiAgICB3aGlsZSAobGFzdCA8IGxpbmVzKVxuICAgICAgICBsYXN0ID0gbGFzdCAqIDEwICsgOTtcbiAgICByZXR1cm4gbGFzdDtcbn1cbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIgPSBuZXcgY2xhc3MgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmVsZW1lbnRDbGFzcyA9IFwiY20tYWN0aXZlTGluZUd1dHRlclwiO1xuICAgIH1cbn07XG5jb25zdCBhY3RpdmVMaW5lR3V0dGVySGlnaGxpZ2h0ZXIgPSBndXR0ZXJMaW5lQ2xhc3MuY29tcHV0ZShbXCJzZWxlY3Rpb25cIl0sIHN0YXRlJDEgPT4ge1xuICAgIGxldCBtYXJrcyA9IFtdLCBsYXN0ID0gLTE7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUkMS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBsaW5lUG9zID0gc3RhdGUkMS5kb2MubGluZUF0KHJhbmdlLmhlYWQpLmZyb207XG4gICAgICAgIGlmIChsaW5lUG9zID4gbGFzdCkge1xuICAgICAgICAgICAgbGFzdCA9IGxpbmVQb3M7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIucmFuZ2UobGluZVBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5SYW5nZVNldC5vZihtYXJrcyk7XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLWFjdGl2ZUxpbmVHdXR0ZXJgIGNsYXNzIHRvXG5hbGwgZ3V0dGVyIGVsZW1lbnRzIG9uIHRoZSBbYWN0aXZlXG5saW5lXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0QWN0aXZlTGluZSkuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcigpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyKGRlY29yYXRvcikge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+ICh7XG4gICAgICAgIGRlY29yYXRpb25zOiBkZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KSxcbiAgICAgICAgdXBkYXRlKHUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0b3IudXBkYXRlRGVjbyh1LCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9KSwge1xuICAgICAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG4gICAgfSk7XG59XG5jb25zdCB0YWJEZWNvID0gRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20taGlnaGxpZ2h0VGFiXCIgfSk7XG5jb25zdCBzcGFjZURlY28gPSBEZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1oaWdobGlnaHRTcGFjZVwiIH0pO1xuY29uc3Qgd2hpdGVzcGFjZUhpZ2hsaWdodGVyID0gbWF0Y2hlcihuZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgIHJlZ2V4cDogL1xcdHwgL2csXG4gICAgZGVjb3JhdGlvbjogbWF0Y2ggPT4gbWF0Y2hbMF0gPT0gXCJcXHRcIiA/IHRhYkRlY28gOiBzcGFjZURlY28sXG4gICAgYm91bmRhcnk6IC9cXFMvLFxufSkpO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGhpZ2hsaWdodHMgd2hpdGVzcGFjZSwgYWRkaW5nIGFcbmBjbS1oaWdobGlnaHRTcGFjZWAgY2xhc3MgdG8gc3RyZXRjaGVzIG9mIHNwYWNlcywgYW5kIGFcbmBjbS1oaWdobGlnaHRUYWJgIGNsYXNzIHRvIGluZGl2aWR1YWwgdGFiIGNoYXJhY3RlcnMuIEJ5IGRlZmF1bHQsXG50aGUgZm9ybWVyIGFyZSBzaG93biBhcyBmYWludCBkb3RzLCBhbmQgdGhlIGxhdHRlciBhcyBhcnJvd3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0V2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gd2hpdGVzcGFjZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgdHJhaWxpbmdIaWdobGlnaHRlciA9IG1hdGNoZXIobmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICByZWdleHA6IC9cXHMrJC9nLFxuICAgIGRlY29yYXRpb246IERlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXRyYWlsaW5nU3BhY2VcIiB9KSxcbiAgICBib3VuZGFyeTogL1xcUy8sXG59KSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBhIGBjbS10cmFpbGluZ1NwYWNlYCBjbGFzcyB0byBhbGxcbnRyYWlsaW5nIHdoaXRlc3BhY2UuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlKCkge1xuICAgIHJldHVybiB0cmFpbGluZ0hpZ2hsaWdodGVyO1xufVxuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fdGVzdCA9IHsgSGVpZ2h0TWFwLCBIZWlnaHRPcmFjbGUsIE1lYXN1cmVkSGVpZ2h0cywgUXVlcnlUeXBlLCBDaGFuZ2VkUmFuZ2UsIGNvbXB1dGVPcmRlcixcbiAgICBtb3ZlVmlzdWFsbHksIGNsZWFySGVpZ2h0Q2hhbmdlRmxhZywgZ2V0SGVpZ2h0Q2hhbmdlRmxhZzogKCkgPT4gaGVpZ2h0Q2hhbmdlRmxhZyB9O1xuXG5leHBvcnRzLkJpZGlTcGFuID0gQmlkaVNwYW47XG5leHBvcnRzLkJsb2NrSW5mbyA9IEJsb2NrSW5mbztcbmV4cG9ydHMuRGVjb3JhdGlvbiA9IERlY29yYXRpb247XG5leHBvcnRzLkVkaXRvclZpZXcgPSBFZGl0b3JWaWV3O1xuZXhwb3J0cy5HdXR0ZXJNYXJrZXIgPSBHdXR0ZXJNYXJrZXI7XG5leHBvcnRzLk1hdGNoRGVjb3JhdG9yID0gTWF0Y2hEZWNvcmF0b3I7XG5leHBvcnRzLlJlY3RhbmdsZU1hcmtlciA9IFJlY3RhbmdsZU1hcmtlcjtcbmV4cG9ydHMuVmlld1BsdWdpbiA9IFZpZXdQbHVnaW47XG5leHBvcnRzLlZpZXdVcGRhdGUgPSBWaWV3VXBkYXRlO1xuZXhwb3J0cy5XaWRnZXRUeXBlID0gV2lkZ2V0VHlwZTtcbmV4cG9ydHMuX190ZXN0ID0gX190ZXN0O1xuZXhwb3J0cy5jbG9zZUhvdmVyVG9vbHRpcHMgPSBjbG9zZUhvdmVyVG9vbHRpcHM7XG5leHBvcnRzLmNyb3NzaGFpckN1cnNvciA9IGNyb3NzaGFpckN1cnNvcjtcbmV4cG9ydHMuZHJhd1NlbGVjdGlvbiA9IGRyYXdTZWxlY3Rpb247XG5leHBvcnRzLmRyb3BDdXJzb3IgPSBkcm9wQ3Vyc29yO1xuZXhwb3J0cy5nZXREcmF3U2VsZWN0aW9uQ29uZmlnID0gZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZztcbmV4cG9ydHMuZ2V0UGFuZWwgPSBnZXRQYW5lbDtcbmV4cG9ydHMuZ2V0VG9vbHRpcCA9IGdldFRvb2x0aXA7XG5leHBvcnRzLmd1dHRlciA9IGd1dHRlcjtcbmV4cG9ydHMuZ3V0dGVyTGluZUNsYXNzID0gZ3V0dGVyTGluZUNsYXNzO1xuZXhwb3J0cy5ndXR0ZXJXaWRnZXRDbGFzcyA9IGd1dHRlcldpZGdldENsYXNzO1xuZXhwb3J0cy5ndXR0ZXJzID0gZ3V0dGVycztcbmV4cG9ydHMuaGFzSG92ZXJUb29sdGlwcyA9IGhhc0hvdmVyVG9vbHRpcHM7XG5leHBvcnRzLmhpZ2hsaWdodEFjdGl2ZUxpbmUgPSBoaWdobGlnaHRBY3RpdmVMaW5lO1xuZXhwb3J0cy5oaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyID0gaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcjtcbmV4cG9ydHMuaGlnaGxpZ2h0U3BlY2lhbENoYXJzID0gaGlnaGxpZ2h0U3BlY2lhbENoYXJzO1xuZXhwb3J0cy5oaWdobGlnaHRUcmFpbGluZ1doaXRlc3BhY2UgPSBoaWdobGlnaHRUcmFpbGluZ1doaXRlc3BhY2U7XG5leHBvcnRzLmhpZ2hsaWdodFdoaXRlc3BhY2UgPSBoaWdobGlnaHRXaGl0ZXNwYWNlO1xuZXhwb3J0cy5ob3ZlclRvb2x0aXAgPSBob3ZlclRvb2x0aXA7XG5leHBvcnRzLmtleW1hcCA9IGtleW1hcDtcbmV4cG9ydHMubGF5ZXIgPSBsYXllcjtcbmV4cG9ydHMubGluZU51bWJlck1hcmtlcnMgPSBsaW5lTnVtYmVyTWFya2VycztcbmV4cG9ydHMubGluZU51bWJlcldpZGdldE1hcmtlciA9IGxpbmVOdW1iZXJXaWRnZXRNYXJrZXI7XG5leHBvcnRzLmxpbmVOdW1iZXJzID0gbGluZU51bWJlcnM7XG5leHBvcnRzLmxvZ0V4Y2VwdGlvbiA9IGxvZ0V4Y2VwdGlvbjtcbmV4cG9ydHMucGFuZWxzID0gcGFuZWxzO1xuZXhwb3J0cy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuZXhwb3J0cy5yZWN0YW5ndWxhclNlbGVjdGlvbiA9IHJlY3Rhbmd1bGFyU2VsZWN0aW9uO1xuZXhwb3J0cy5yZXBvc2l0aW9uVG9vbHRpcHMgPSByZXBvc2l0aW9uVG9vbHRpcHM7XG5leHBvcnRzLnJ1blNjb3BlSGFuZGxlcnMgPSBydW5TY29wZUhhbmRsZXJzO1xuZXhwb3J0cy5zY3JvbGxQYXN0RW5kID0gc2Nyb2xsUGFzdEVuZDtcbmV4cG9ydHMuc2hvd1BhbmVsID0gc2hvd1BhbmVsO1xuZXhwb3J0cy5zaG93VG9vbHRpcCA9IHNob3dUb29sdGlwO1xuZXhwb3J0cy50b29sdGlwcyA9IHRvb2x0aXBzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcblRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG4qL1xuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8qKlxuRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG5jYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbiovXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgaXQgZG9lcy5cbiAgICAqL1xuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG5Qcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbnNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbmZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbiovXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG5hdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xub2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuKi9cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5Vc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG50eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG5gXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbiovXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuQXR0YWNoZWQgdG8gbm9kZXMgdG8gaW5kaWNhdGUgdGhlc2Ugc2hvdWxkIGJlXG5bZGlzcGxheWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKVxuaW4gYSBiaWRpcmVjdGlvbmFsIHRleHQgaXNvbGF0ZSwgc28gdGhhdCBkaXJlY3Rpb24tbmV1dHJhbFxuY2hhcmFjdGVycyBvbiB0aGVpciBzaWRlcyBkb24ndCBpbmNvcnJlY3RseSBnZXQgYXNzb2NpYXRlZCB3aXRoXG5zdXJyb3VuZGluZyB0ZXh0LiBZb3UnbGwgZ2VuZXJhbGx5IHdhbnQgdG8gc2V0IHRoaXMgZm9yIG5vZGVzXG50aGF0IGNvbnRhaW4gYXJiaXRyYXJ5IHRleHQsIGxpa2Ugc3RyaW5ncyBhbmQgY29tbWVudHMsIGFuZCBmb3Jcbm5vZGVzIHRoYXQgYXBwZWFyIF9pbnNpZGVfIGFyYml0cmFyeSB0ZXh0LCBsaWtlIEhUTUwgdGFncy4gV2hlblxubm90IGdpdmVuIGEgdmFsdWUsIGluIGEgZ3JhbW1hciBkZWNsYXJhdGlvbiwgZGVmYXVsdHMgdG9cbmBcImF1dG9cImAuXG4qL1xuTm9kZVByb3AuaXNvbGF0ZSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPSBcInJ0bFwiICYmIHZhbHVlICE9IFwibHRyXCIgJiYgdmFsdWUgIT0gXCJhdXRvXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIGlzb2xhdGU6IFwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgXCJhdXRvXCI7XG4gICAgfSB9KTtcbi8qKlxuVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG50aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuY29udGV4dHVhbCBub2Rlcy5cbiovXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbmxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG5wYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3JcbmVmZmljaWVuY3kgcmVhc29ucy4pXG4qL1xuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxubm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuZGlmZmVyZW50IGxhbmd1YWdlcyBpbiBtaXhlZC1sYW5ndWFnZSBwYXJzZXJzLlxuKi9cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5BIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbmEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG5yZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG4qL1xuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBpbm5lciB0cmVlLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgKi9cbiAgICBvdmVybGF5LCBcbiAgICAvKipcbiAgICBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICAqL1xuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS5wcm9wcyAmJiB0cmVlLnByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdO1xuICAgIH1cbn1cbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5FYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIHJvbGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHByb3BzLCBcbiAgICAvKipcbiAgICBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIE5vZGVGbGFnLlRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBOb2RlRmxhZy5FcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgICovXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICAqL1xuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogTm9kZUZsYWcuRXJyb3IgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgICovXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmdW5jdGlvbiBmcm9tIG5vZGUgdHlwZXMgdG8gYXJiaXRyYXJ5IHZhbHVlcyBieVxuICAgIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbiovXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8qKlxuQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG5mdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG5baGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG5idWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG5mcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxudHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXG4qL1xuY2xhc3MgTm9kZVNldCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICAqL1xuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBjYW4gYmUgY3JlYXRlZCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgKi9cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNbYWRkWzBdLmlkXSA9IGFkZFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeXBlcy5wdXNoKG5ld1Byb3BzID8gbmV3IE5vZGVUeXBlKHR5cGUubmFtZSwgbmV3UHJvcHMsIHR5cGUuaWQsIHR5cGUuZmxhZ3MpIDogdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWROb2RlID0gbmV3IFdlYWtNYXAoKSwgQ2FjaGVkSW5uZXJOb2RlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuT3B0aW9ucyB0aGF0IGNvbnRyb2wgaXRlcmF0aW9uLiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYHxgXG5vcGVyYXRvciB0byBlbmFibGUgbXVsdGlwbGUgb25lcy5cbiovXG5leHBvcnRzLkl0ZXJNb2RlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChJdGVyTW9kZSkge1xuICAgIC8qKlxuICAgIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgb2JqZWN0cywgbm90IG5vZGVzIHBhY2tlZCBpbnRvXG4gICAgW2BUcmVlQnVmZmVyYF0oI2NvbW1vbi5UcmVlQnVmZmVyKXMuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XG4gICAgLyoqXG4gICAgRW5hYmxlIHRoaXMgdG8gbWFrZSBpdGVyYXRpb24gaW5jbHVkZSBhbm9ueW1vdXMgbm9kZXMgKHN1Y2ggYXNcbiAgICB0aGUgbm9kZXMgdGhhdCB3cmFwIHJlcGVhdGVkIGdyYW1tYXIgY29uc3RydWN0cyBpbnRvIGEgYmFsYW5jZWRcbiAgICB0cmVlKS5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSW5jbHVkZUFub255bW91c1wiXSA9IDJdID0gXCJJbmNsdWRlQW5vbnltb3VzXCI7XG4gICAgLyoqXG4gICAgQnkgZGVmYXVsdCwgcmVndWxhciBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBub2Rlc1xuICAgIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cbiAgICBpbnN0ZWFkLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVNb3VudHNcIl0gPSA0XSA9IFwiSWdub3JlTW91bnRzXCI7XG4gICAgLyoqXG4gICAgVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXG4gICAgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlciktc3R5bGUgbWV0aG9kcy4gSXQgdGVsbHMgdGhlXG4gICAgbGlicmFyeSB0byBub3QgZW50ZXIgbW91bnRlZCBvdmVybGF5cyBpZiBvbmUgY292ZXJzIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVPdmVybGF5c1wiXSA9IDhdID0gXCJJZ25vcmVPdmVybGF5c1wiO1xufSkoZXhwb3J0cy5JdGVyTW9kZSB8fCAoZXhwb3J0cy5JdGVyTW9kZSA9IHt9KSk7XG4vKipcbkEgcGllY2Ugb2Ygc3ludGF4IHRyZWUuIFRoZXJlIGFyZSB0d28gd2F5cyB0byBhcHByb2FjaCB0aGVzZVxudHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuY29udmVuaWVudCB3YXkuXG5cblN5bnRheCB0cmVlcyBhcmUgc3RvcmVkIGFzIGEgdHJlZSBvZiBgVHJlZWAgYW5kIGBUcmVlQnVmZmVyYFxub2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxubm9kZXMsIHRoZSByZXByZXNlbnRhdGlvbiBpcyBtYWRlIGEgbG90IG1vcmUgbWVtb3J5LWVmZmljaWVudC5cblxuSG93ZXZlciwgd2hlbiB5b3Ugd2FudCB0byBhY3R1YWxseSB3b3JrIHdpdGggdHJlZSBub2RlcywgdGhpc1xucmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xudXNlIHRoZSBbYFRyZWVDdXJzb3JgXSgjY29tbW9uLlRyZWVDdXJzb3IpIG9yXG5bYFN5bnRheE5vZGVgXSgjY29tbW9uLlN5bnRheE5vZGUpIGludGVyZmFjZSBpbnN0ZWFkLCB3aGljaCBwcm92aWRlc1xuYSB2aWV3IG9uIHNvbWUgcGFydCBvZiB0aGlzIGRhdGEgc3RydWN0dXJlLCBhbmQgY2FuIGJlIHVzZWQgdG9cbm1vdmUgYXJvdW5kIHRvIGFkamFjZW50IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWUge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5ldyB0cmVlLiBTZWUgYWxzbyBbYFRyZWUuYnVpbGRgXSgjY29tbW9uLlRyZWVeYnVpbGQpLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdGhlIHRvcCBub2RlLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhpcyBub2RlJ3MgY2hpbGQgbm9kZXMuXG4gICAgKi9cbiAgICBjaGlsZHJlbiwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9ucyAob2Zmc2V0cyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhpcyB0cmVlKSBvZlxuICAgIHRoZSBjaGlsZHJlbi5cbiAgICAqL1xuICAgIHBvc2l0aW9ucywgXG4gICAgLyoqXG4gICAgVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGlzIHRyZWVcbiAgICAqL1xuICAgIGxlbmd0aCwgXG4gICAgLyoqXG4gICAgUGVyLW5vZGUgW25vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3ApIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIHByb3BzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucHJvcHMgPSBudWxsO1xuICAgICAgICBpZiAocHJvcHMgJiYgcHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAobGV0IFtwcm9wLCB2YWx1ZV0gb2YgcHJvcHMpXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wc1t0eXBlb2YgcHJvcCA9PSBcIm51bWJlclwiID8gcHJvcCA6IHByb3AuaWRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBNb3VudGVkVHJlZS5nZXQodGhpcyk7XG4gICAgICAgIGlmIChtb3VudGVkICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gbW91bnRlZC50cmVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBjaC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gXCIsXCI7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb3NpdGlvbmVkIGF0IHRoZSB0b3Agb2ZcbiAgICB0aGUgdHJlZS4gTW9kZSBjYW4gYmUgdXNlZCB0byBbY29udHJvbF0oI2NvbW1vbi5JdGVyTW9kZSkgd2hpY2hcbiAgICBub2RlcyB0aGUgY3Vyc29yIHZpc2l0cy5cbiAgICAqL1xuICAgIGN1cnNvcihtb2RlID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcy50b3BOb2RlLCBtb2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHBvaW50aW5nIGludG8gdGhpcyB0cmVlXG4gICAgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlIChzZWVcbiAgICBbYG1vdmVUb2BdKCNjb21tb24uVHJlZUN1cnNvci5tb3ZlVG8pLlxuICAgICovXG4gICAgY3Vyc29yQXQocG9zLCBzaWRlID0gMCwgbW9kZSA9IDApIHtcbiAgICAgICAgbGV0IHNjb3BlID0gQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3Ioc2NvcGUpO1xuICAgICAgICBjdXJzb3IubW92ZVRvKHBvcywgc2lkZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIGN1cnNvci5fdHJlZSk7XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBvYmplY3QgZm9yIHRoZSB0b3Agb2YgdGhlXG4gICAgdHJlZS5cbiAgICAqL1xuICAgIGdldCB0b3BOb2RlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgSWYgYHNpZGVgIGlzIC0xLCB0aGlzIHdpbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgZW5kIGF0IHRoZVxuICAgIHBvc2l0aW9uLiBJZiAxLCBpdCdsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBzdGFydCBhdCB0aGVcbiAgICBwb3NpdGlvbi4gV2l0aCAwLCBpdCdsbCBvbmx5IGVudGVyIG5vZGVzIHRoYXQgY292ZXIgdGhlIHBvc2l0aW9uXG4gICAgZnJvbSBib3RoIHNpZGVzLlxuICAgIFxuICAgIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGVudGVyXG4gICAgW292ZXJsYXlzXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpLCBhbmQgeW91IG9mdGVuIHdhbnRcbiAgICBbYHJlc29sdmVJbm5lcmBdKCNjb21tb24uVHJlZS5yZXNvbHZlSW5uZXIpIGluc3RlYWQuXG4gICAgKi9cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgbGV0IG5vZGUgPSByZXNvbHZlTm9kZShDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2ByZXNvbHZlYF0oI2NvbW1vbi5UcmVlLnJlc29sdmUpLCBidXQgd2lsbCBlbnRlclxuICAgIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSBub2RlcywgcHJvZHVjaW5nIGEgc3ludGF4IG5vZGVcbiAgICBwb2ludGluZyBpbnRvIHRoZSBpbm5lcm1vc3Qgb3ZlcmxhaWQgdHJlZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICAod2l0aCBwYXJlbnQgbGlua3MgZ29pbmcgdGhyb3VnaCBhbGwgcGFyZW50IHN0cnVjdHVyZSwgaW5jbHVkaW5nXG4gICAgdGhlIGhvc3QgdHJlZXMpLlxuICAgICovXG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgbGV0IG5vZGUgPSByZXNvbHZlTm9kZShDYWNoZWRJbm5lck5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICAgICAgQ2FjaGVkSW5uZXJOb2RlLnNldCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEluIHNvbWUgc2l0dWF0aW9ucywgaXQgY2FuIGJlIHVzZWZ1bCB0byBpdGVyYXRlIHRocm91Z2ggYWxsXG4gICAgbm9kZXMgYXJvdW5kIGEgcG9zaXRpb24sIGluY2x1ZGluZyB0aG9zZSBpbiBvdmVybGF5cyB0aGF0IGRvbid0XG4gICAgZGlyZWN0bHkgY292ZXIgdGhlIHBvc2l0aW9uLiBUaGlzIG1ldGhvZCBnaXZlcyB5b3UgYW4gaXRlcmF0b3JcbiAgICB0aGF0IHdpbGwgcHJvZHVjZSBhbGwgbm9kZXMsIGZyb20gc21hbGwgdG8gYmlnLCBhcm91bmQgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICByZXNvbHZlU3RhY2socG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gc3RhY2tJdGVyYXRvcih0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHRyZWUgYW5kIGl0cyBjaGlsZHJlbiwgY2FsbGluZyBgZW50ZXJgIGZvciBhbnlcbiAgICBub2RlIHRoYXQgdG91Y2hlcyB0aGUgYGZyb21gL2B0b2AgcmVnaW9uIChpZiBnaXZlbikgYmVmb3JlXG4gICAgcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIGxlYXZpbmcgdGhlIG5vZGUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIHRoYXQgbm9kZSB3aWxsXG4gICAgbm90IGhhdmUgaXRzIGNoaWxkcmVuIGl0ZXJhdGVkIG92ZXIgKG9yIGBsZWF2ZWAgY2FsbGVkKS5cbiAgICAqL1xuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBsZXQgbW9kZSA9IHNwZWMubW9kZSB8fCAwLCBhbm9uID0gKG1vZGUgJiBleHBvcnRzLkl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID4gMDtcbiAgICAgICAgZm9yIChsZXQgYyA9IHRoaXMuY3Vyc29yKG1vZGUgfCBleHBvcnRzLkl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoIWFub24gJiYgYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmIChhbm9uIHx8ICFjLnR5cGUuaXNBbm9ueW1vdXMpKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBbbm9kZSBwcm9wXSgjY29tbW9uLk5vZGVQcm9wKSBmb3IgdGhpc1xuICAgIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgICBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgY29uc3RydWN0b3IuXG4gICAgKi9cbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goWytpZCwgdGhpcy5wcm9wc1tpZF1dKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxuICAgICovXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyA/IHRoaXMgOlxuICAgICAgICAgICAgYmFsYW5jZVJhbmdlKE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgICovXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgdHJlZVxuKi9cblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8qKlxuVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxubm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbmJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG5jaGlsZHJlbiBiZWxvbmcgdG8gaXQpLlxuKi9cbmNsYXNzIFRyZWVCdWZmZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGJ1ZmZlcidzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgICovXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbGljZShzdGFydEksIGVuZEksIGZyb20pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSksIGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICAgICAgbGVuID0gTWF0aC5tYXgobGVuLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIGxlbiwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogU2lkZS5CZWZvcmUgKi86IHJldHVybiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIC0xIC8qIFNpZGUuQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogU2lkZS5Bcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogU2lkZS5BdE9yQWZ0ZXIgKi86IHJldHVybiBmcm9tIDw9IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAyIC8qIFNpZGUuQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIFNpZGUuRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVOb2RlKG5vZGUsIHBvcywgc2lkZSwgb3ZlcmxheXMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUgKG5vZGUuZnJvbSA9PSBub2RlLnRvIHx8XG4gICAgICAgIChzaWRlIDwgMSA/IG5vZGUuZnJvbSA+PSBwb3MgOiBub2RlLmZyb20gPiBwb3MpIHx8XG4gICAgICAgIChzaWRlID4gLTEgPyBub2RlLnRvIDw9IHBvcyA6IG5vZGUudG8gPCBwb3MpKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAhb3ZlcmxheXMgJiYgbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIG5vZGUuaW5kZXggPCAwID8gbnVsbCA6IG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICBsZXQgbW9kZSA9IG92ZXJsYXlzID8gMCA6IGV4cG9ydHMuSXRlck1vZGUuSWdub3JlT3ZlcmxheXM7XG4gICAgLy8gTXVzdCBnbyB1cCBvdXQgb2Ygb3ZlcmxheXMgd2hlbiB0aG9zZSBkbyBub3Qgb3ZlcmxhcCB3aXRoIHBvc1xuICAgIGlmIChvdmVybGF5cylcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIHBhcmVudCA9IHNjYW4ucGFyZW50OyBwYXJlbnQ7IHNjYW4gPSBwYXJlbnQsIHBhcmVudCA9IHNjYW4ucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoc2NhbiBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIHNjYW4uaW5kZXggPCAwICYmICgoX2EgPSBwYXJlbnQuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyb20pICE9IHNjYW4uZnJvbSlcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgaW5uZXIgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgbW9kZSk7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IGlubmVyO1xuICAgIH1cbn1cbmNsYXNzIEJhc2VOb2RlIHtcbiAgICBjdXJzb3IobW9kZSA9IDApIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMsIG1vZGUpOyB9XG4gICAgZ2V0Q2hpbGQodHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgbWF0Y2hDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5wYXJlbnQsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHtcbiAgICAgICAgbGV0IHNjYW4gPSB0aGlzLmNoaWxkQmVmb3JlKHBvcyksIG5vZGUgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBzY2FuLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghbGFzdCB8fCBsYXN0LnRvICE9IHNjYW4udG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobGFzdC50eXBlLmlzRXJyb3IgJiYgbGFzdC5mcm9tID09IGxhc3QudG8pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gc2NhbjtcbiAgICAgICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMucGFyZW50OyB9XG59XG5jbGFzcyBUcmVlTm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihfdHJlZSwgZnJvbSwgXG4gICAgLy8gSW5kZXggaW4gcGFyZW50IG5vZGUsIHNldCB0byAtMSBpZiB0aGUgbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgX3BhcmVudC5ub2RlIChvdmVybGF5KVxuICAgIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBfdHJlZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLl90cmVlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5fdHJlZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIGV4cG9ydHMuSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV4dC5maW5kQ2hpbGQoMCwgbmV4dC5idWZmZXIubGVuZ3RoLCBkaXIsIHBvcyAtIHN0YXJ0LCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUobmV3IEJ1ZmZlckNvbnRleHQocGFyZW50LCBuZXh0LCBpLCBzdGFydCksIG51bGwsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG1vZGUgJiBleHBvcnRzLkl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICghbmV4dC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobW9kZSAmIGV4cG9ydHMuSXRlck1vZGUuSWdub3JlTW91bnRzKSAmJiAobW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldChuZXh0KSkgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gbmV3IFRyZWVOb2RlKG5leHQsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZGUgJiBleHBvcnRzLkl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFpbm5lci50eXBlLmlzQW5vbnltb3VzID8gaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5uZXIubmV4dENoaWxkKGRpciA8IDAgPyBuZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtb2RlICYgZXhwb3J0cy5JdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhcGFyZW50LnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAocGFyZW50LmluZGV4ID49IDApXG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudC5pbmRleCArIGRpcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll9wYXJlbnQuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgaWYgKCEobW9kZSAmIGV4cG9ydHMuSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMuX3RyZWUpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IoKSwgcmVzdWx0ID0gW107XG4gICAgaWYgKCFjdXIuZmlyc3RDaGlsZCgpKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChiZWZvcmUgIT0gbnVsbClcbiAgICAgICAgZm9yIChsZXQgZm91bmQgPSBmYWxzZTsgIWZvdW5kOykge1xuICAgICAgICAgICAgZm91bmQgPSBjdXIudHlwZS5pcyhiZWZvcmUpO1xuICAgICAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoTm9kZUNvbnRleHQobm9kZSwgY29udGV4dCwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlOyBpID49IDA7IHAgPSBwLnBhcmVudCkge1xuICAgICAgICBpZiAoIXApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcC50eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dFtpXSAmJiBjb250ZXh0W2ldICE9IHAubmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBCdWZmZXJDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGJ1ZmZlciwgaW5kZXgsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyTm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBfcGFyZW50LCBpbmRleCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IGNvbnRleHQuYnVmZmVyLnNldC50eXBlc1tjb250ZXh0LmJ1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICB9XG4gICAgY2hpbGQoZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBpZiAobW9kZSAmIGV4cG9ydHMuSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgdGhpcy50byAtIHRoaXMuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XG59XG5mdW5jdGlvbiBpdGVyU3RhY2soaGVhZHMpIHtcbiAgICBpZiAoIWhlYWRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHBpY2sgPSAwLCBwaWNrZWQgPSBoZWFkc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gaGVhZHNbaV07XG4gICAgICAgIGlmIChub2RlLmZyb20gPiBwaWNrZWQuZnJvbSB8fCBub2RlLnRvIDwgcGlja2VkLnRvKSB7XG4gICAgICAgICAgICBwaWNrZWQgPSBub2RlO1xuICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHQgPSBwaWNrZWQgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBwaWNrZWQuaW5kZXggPCAwID8gbnVsbCA6IHBpY2tlZC5wYXJlbnQ7XG4gICAgbGV0IG5ld0hlYWRzID0gaGVhZHMuc2xpY2UoKTtcbiAgICBpZiAobmV4dClcbiAgICAgICAgbmV3SGVhZHNbcGlja10gPSBuZXh0O1xuICAgIGVsc2VcbiAgICAgICAgbmV3SGVhZHMuc3BsaWNlKHBpY2ssIDEpO1xuICAgIHJldHVybiBuZXcgU3RhY2tJdGVyYXRvcihuZXdIZWFkcywgcGlja2VkKTtcbn1cbmNsYXNzIFN0YWNrSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYWRzLCBub2RlKSB7XG4gICAgICAgIHRoaXMuaGVhZHMgPSBoZWFkcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiBpdGVyU3RhY2sodGhpcy5oZWFkcyk7IH1cbn1cbmZ1bmN0aW9uIHN0YWNrSXRlcmF0b3IodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGlubmVyID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBzaWRlKSwgbGF5ZXJzID0gbnVsbDtcbiAgICBmb3IgKGxldCBzY2FuID0gaW5uZXIgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IGlubmVyIDogaW5uZXIuY29udGV4dC5wYXJlbnQ7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudCkge1xuICAgICAgICBpZiAoc2Nhbi5pbmRleCA8IDApIHsgLy8gVGhpcyBpcyBhbiBvdmVybGF5IHJvb3RcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzY2FuLnBhcmVudDtcbiAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHBhcmVudC5yZXNvbHZlKHBvcywgc2lkZSkpO1xuICAgICAgICAgICAgc2NhbiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtb3VudCA9IE1vdW50ZWRUcmVlLmdldChzY2FuLnRyZWUpO1xuICAgICAgICAgICAgLy8gUmVsZXZhbnQgb3ZlcmxheSBicmFuY2hpbmcgb2ZmXG4gICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQub3ZlcmxheSAmJiBtb3VudC5vdmVybGF5WzBdLmZyb20gPD0gcG9zICYmIG1vdW50Lm92ZXJsYXlbbW91bnQub3ZlcmxheS5sZW5ndGggLSAxXS50byA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm9vdCA9IG5ldyBUcmVlTm9kZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBzY2FuLmZyb20sIC0xLCBzY2FuKTtcbiAgICAgICAgICAgICAgICAobGF5ZXJzIHx8IChsYXllcnMgPSBbaW5uZXJdKSkucHVzaChyZXNvbHZlTm9kZShyb290LCBwb3MsIHNpZGUsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheWVycyA/IGl0ZXJTdGFjayhsYXllcnMpIDogaW5uZXI7XG59XG4vKipcbkEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8qKlxuICAgIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgICovXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgKi9cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcbiAgICBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcbiAgICBzZXQgdG8gZmFsc2UuXG4gICAgKi9cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgZXhwb3J0cy5JdGVyTW9kZS5FeGNsdWRlQnVmZmVycyA/IGZhbHNlIDogdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5vZGUncyBwYXJlbnQgbm9kZSwgaWYgdGhpcyBpc24ndCB0aGUgdG9wIG5vZGUuXG4gICAgKi9cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUoKHRoaXMubW9kZSAmIGV4cG9ydHMuSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gKHRoaXMubW9kZSAmIGV4cG9ydHMuSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgKi9cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Ll90cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIGV4cG9ydHMuSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWNoaWxkLnR5cGUuaXNBbm9ueW1vdXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1vdmUoZGlyLCBlbnRlcikge1xuICAgICAgICBpZiAoZW50ZXIgJiYgdGhpcy5lbnRlckNoaWxkKGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWJsaW5nKGRpcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hdExhc3ROb2RlKGRpcikgfHwgIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgW3ByZS1vcmRlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJlZV90cmF2ZXJzYWwjUHJlLW9yZGVyLF9OTFIpXG4gICAgdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIGN1cnJlbnQgbm9kZSBpcyBlbXB0eSBvciBgZW50ZXJgIGlzIGZhbHNlLCBpdHMgbmV4dCBzaWJsaW5nIG9yXG4gICAgdGhlIG5leHQgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50IG5vZGUgdGhhdCBoYXMgb25lLlxuICAgICovXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYSBsYXN0LXRvLWZpcnN0IHByZS1vcmRlciB0cmF2ZXJzYWwuIEFcbiAgICBub2RlIGlzIGZvbGxvd2VkIGJ5IGl0cyBsYXN0IGNoaWxkIG9yLCBpZiBpdCBoYXMgbm9uZSwgaXRzXG4gICAgcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XG4gICAgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgKi9cbiAgICBwcmV2KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKC0xLCBlbnRlcik7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgc3RhcnQgYXQgYHBvc2AuXG4gICAgKi9cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcbiAgICBidWZmZXJdKCNjb21tb24uVHJlZUJ1ZmZlcikuXG4gICAgKi9cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUuX3RyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgY3VycmVudCBub2RlIGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzLCBjYWxsaW5nXG4gICAgYGVudGVyYCB3aGVuIGVudGVyaW5nIGEgbm9kZSBhbmQgYGxlYXZlYCwgaWYgZ2l2ZW4sIHdoZW4gbGVhdmluZ1xuICAgIG9uZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgYW55IGNoaWxkcmVuIG9mIHRoYXQgbm9kZSBhcmVcbiAgICBza2lwcGVkLCBhbmQgYGxlYXZlYCBpc24ndCBjYWxsZWQgZm9yIGl0LlxuICAgICovXG4gICAgaXRlcmF0ZShlbnRlciwgbGVhdmUpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIodGhpcykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0aGlzLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgY3VycmVudCBub2RlIG1hdGNoZXMgYSBnaXZlbiBjb250ZXh04oCUYSBzZXF1ZW5jZVxuICAgIG9mIGRpcmVjdCBwYXJlbnQgbm9kZSBuYW1lcy4gRW1wdHkgc3RyaW5ncyBpbiB0aGUgY29udGV4dCBhcnJheVxuICAgIGFyZSB0cmVhdGVkIGFzIHdpbGRjYXJkcy5cbiAgICAqL1xuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUucGFyZW50LCBjb250ZXh0KTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgeyB0eXBlcyB9ID0gYnVmZmVyLnNldDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGlmIChkIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLl90cmVlLCBjb250ZXh0LCBpKTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdXV07XG4gICAgICAgICAgICBpZiAoIXR5cGUuaXNBbm9ueW1vdXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dFtpXSAmJiBjb250ZXh0W2ldICE9IHR5cGUubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUuY2hpbGRyZW4uc29tZShjaCA9PiBjaCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgIWNoLnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQoY2gpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGJ1ZmZlciwgbm9kZVNldCwgbWF4QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aCwgcmV1c2VkID0gW10sIG1pblJlcGVhdFR5cGUgPSBub2RlU2V0LnR5cGVzLmxlbmd0aCB9ID0gZGF0YTtcbiAgICBsZXQgY3Vyc29yID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gbmV3IEZsYXRCdWZmZXJDdXJzb3IoYnVmZmVyLCBidWZmZXIubGVuZ3RoKSA6IGJ1ZmZlcjtcbiAgICBsZXQgdHlwZXMgPSBub2RlU2V0LnR5cGVzO1xuICAgIGxldCBjb250ZXh0SGFzaCA9IDAsIGxvb2tBaGVhZCA9IDA7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQsIGRlcHRoKSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGxldCBsb29rQWhlYWRBdFN0YXJ0ID0gbG9va0FoZWFkLCBjb250ZXh0QXRTdGFydCA9IGNvbnRleHRIYXNoO1xuICAgICAgICB3aGlsZSAoc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PSAtMSAvKiBTcGVjaWFsUmVjb3JkLlJldXNlICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXVzZWRbaWRdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHsgLy8gQ29udGV4dCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5yZWNvZ25pemVkIHJlY29yZCBzaXplOiAke3NpemV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpZF0sIG5vZGUsIGJ1ZmZlcjtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKGVuZCAtIHN0YXJ0IDw9IG1heEJ1ZmZlckxlbmd0aCAmJiAoYnVmZmVyID0gZmluZEJ1ZmZlclNpemUoY3Vyc29yLnBvcyAtIG1pblBvcywgaW5SZXBlYXQpKSkge1xuICAgICAgICAgICAgLy8gU21hbGwgZW5vdWdoIGZvciBhIGJ1ZmZlciwgYW5kIG5vIHJldXNlZCBub2RlcyBpbnNpZGVcbiAgICAgICAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlci5zaXplIC0gYnVmZmVyLnNraXApO1xuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBidWZmZXIuc2l6ZSwgaW5kZXggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlci5zdGFydCwgZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlQnVmZmVyKGRhdGEsIGVuZCAtIGJ1ZmZlci5zdGFydCwgbm9kZVNldCk7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIGl0IGEgbm9kZVxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xuICAgICAgICAgICAgbGV0IGxhc3RHcm91cCA9IDAsIGxhc3RFbmQgPSBlbmQ7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgY3Vyc29yLmlkID09IGxvY2FsSW5SZXBlYXQgJiYgY3Vyc29yLnNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmVuZCA8PSBsYXN0RW5kIC0gbWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgY3Vyc29yLmVuZCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCwgY29udGV4dEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdyb3VwID0gbG9jYWxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RW5kID0gY3Vyc29yLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA+IDI1MDAgLyogQ3V0T2ZmLkRlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VGbGF0Tm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGxhc3RHcm91cCA+IDAgJiYgbGFzdEdyb3VwIDwgbG9jYWxDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0LCBjb250ZXh0QXRTdGFydCk7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID4gLTEgJiYgbGFzdEdyb3VwID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBtYWtlID0gbWFrZUJhbGFuY2VkKHR5cGUsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBub2RlID0gYmFsYW5jZVJhbmdlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCAwLCBsb2NhbENoaWxkcmVuLmxlbmd0aCwgMCwgZW5kIC0gc3RhcnQsIG1ha2UsIG1ha2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG1ha2VUcmVlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBlbmQgLSBzdGFydCwgbG9va0FoZWFkQXRTdGFydCAtIGVuZCwgY29udGV4dEF0U3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFrZUZsYXROb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gW107IC8vIFRlbXBvcmFyeSwgaW52ZXJ0ZWQgYXJyYXkgb2YgbGVhZiBub2RlcyBmb3VuZCwgd2l0aCBhYnNvbHV0ZSBwb3NpdGlvbnNcbiAgICAgICAgbGV0IG5vZGVDb3VudCA9IDAsIHN0b3BBdCA9IC0xO1xuICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IG1pblBvcykge1xuICAgICAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkgeyAvLyBOb3QgYSBsZWFmXG4gICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0b3BBdCA+IC0xICYmIHN0YXJ0IDwgc3RvcEF0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcEF0IDwgMClcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF0ID0gZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goaWQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIG5vZGVDb3VudCsrO1xuICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVDb3VudCkge1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShub2RlQ291bnQgKiA0KTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDMsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpICsgMV0gLSBzdGFydDtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2kgKyAyXSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IFRyZWVCdWZmZXIoYnVmZmVyLCBub2Rlc1syXSAtIHN0YXJ0LCBub2RlU2V0KSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydCAtIHBhcmVudFN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQmFsYW5jZWQodHlwZSwgY29udGV4dEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSAwLCBsYXN0SSA9IGNoaWxkcmVuLmxlbmd0aCAtIDEsIGxhc3QsIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICBpZiAobGFzdEkgPj0gMCAmJiAobGFzdCA9IGNoaWxkcmVuW2xhc3RJXSkgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0SSAmJiBsYXN0LnR5cGUgPT0gdHlwZSAmJiBsYXN0Lmxlbmd0aCA9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsb29rQWhlYWRQcm9wID0gbGFzdC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCkpXG4gICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IHBvc2l0aW9uc1tsYXN0SV0gKyBsYXN0Lmxlbmd0aCArIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQsIGNvbnRleHRIYXNoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVJlcGVhdExlYWYoY2hpbGRyZW4sIHBvc2l0aW9ucywgYmFzZSwgaSwgZnJvbSwgdG8sIHR5cGUsIGxvb2tBaGVhZCwgY29udGV4dEhhc2gpIHtcbiAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbi5wb3AoKSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucy5wb3AoKSArIGJhc2UgLSBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUcmVlKG5vZGVTZXQudHlwZXNbdHlwZV0sIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCB0byAtIGZyb20sIGxvb2tBaGVhZCAtIHRvLCBjb250ZXh0SGFzaCkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gYmFzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkLCBjb250ZXh0SGFzaCwgcHJvcHMpIHtcbiAgICAgICAgaWYgKGNvbnRleHRIYXNoKSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5jb250ZXh0SGFzaCwgY29udGV4dEhhc2hdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiAyNSkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AubG9va0FoZWFkLCBsb29rQWhlYWRdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHByb3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEJ1ZmZlclNpemUobWF4U2l6ZSwgaW5SZXBlYXQpIHtcbiAgICAgICAgLy8gU2NhbiB0aHJvdWdoIHRoZSBidWZmZXIgdG8gZmluZCBwcmV2aW91cyBzaWJsaW5ncyB0aGF0IGZpdFxuICAgICAgICAvLyB0b2dldGhlciBpbiBhIFRyZWVCdWZmZXIsIGFuZCBkb24ndCBjb250YWluIGFueSByZXVzZWQgbm9kZXNcbiAgICAgICAgLy8gKHdoaWNoIGNhbid0IGJlIHN0b3JlZCBpbiBhIGJ1ZmZlcikuXG4gICAgICAgIC8vIElmIGBpblJlcGVhdGAgaXMgPiAtMSwgaWdub3JlIG5vZGUgYm91bmRhcmllcyBvZiB0aGF0IHR5cGUgZm9yXG4gICAgICAgIC8vIG5lc3RpbmcsIGJ1dCBtYWtlIHN1cmUgdGhlIGVuZCBmYWxscyBlaXRoZXIgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIChgbWF4U2l6ZWApIG9yIGJlZm9yZSBzdWNoIGEgbm9kZS5cbiAgICAgICAgbGV0IGZvcmsgPSBjdXJzb3IuZm9yaygpO1xuICAgICAgICBsZXQgc2l6ZSA9IDAsIHN0YXJ0ID0gMCwgc2tpcCA9IDAsIG1pblN0YXJ0ID0gZm9yay5lbmQgLSBtYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHNpemU6IDAsIHN0YXJ0OiAwLCBza2lwOiAwIH07XG4gICAgICAgIHNjYW46IGZvciAobGV0IG1pblBvcyA9IGZvcmsucG9zIC0gbWF4U2l6ZTsgZm9yay5wb3MgPiBtaW5Qb3M7KSB7XG4gICAgICAgICAgICBsZXQgbm9kZVNpemUgPSBmb3JrLnNpemU7XG4gICAgICAgICAgICAvLyBQcmV0ZW5kIG5lc3RlZCByZXBlYXQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBkb24ndCBleGlzdFxuICAgICAgICAgICAgaWYgKGZvcmsuaWQgPT0gaW5SZXBlYXQgJiYgbm9kZVNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgICAgICAgICBza2lwICs9IDQ7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0UG9zID0gZm9yay5wb3MgLSBub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChub2RlU2l6ZSA8IDAgfHwgc3RhcnRQb3MgPCBtaW5Qb3MgfHwgZm9yay5zdGFydCA8IG1pblN0YXJ0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGxvY2FsU2tpcHBlZCA9IGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSA/IDQgOiAwO1xuICAgICAgICAgICAgbGV0IG5vZGVTdGFydCA9IGZvcmsuc3RhcnQ7XG4gICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlIChmb3JrLnBvcyA+IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gbm9kZVN0YXJ0O1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZTtcbiAgICAgICAgICAgIHNraXAgKz0gbG9jYWxTa2lwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpblJlcGVhdCA8IDAgfHwgc2l6ZSA9PSBtYXhTaXplKSB7XG4gICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnNpemUgPiA0ID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKHNpemUgPj0gMCAmJiBpZCA8IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIChzaXplIC0gNCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBlbmQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0IC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLykge1xuICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgZGF0YS5idWZmZXJTdGFydCB8fCAwLCBjaGlsZHJlbiwgcG9zaXRpb25zLCAtMSwgMCk7XG4gICAgbGV0IGxlbmd0aCA9IChfYSA9IGRhdGEubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoY2hpbGRyZW4ubGVuZ3RoID8gcG9zaXRpb25zWzBdICsgY2hpbGRyZW5bMF0ubGVuZ3RoIDogMCk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKHR5cGVzW2RhdGEudG9wSURdLCBjaGlsZHJlbi5yZXZlcnNlKCksIHBvc2l0aW9ucy5yZXZlcnNlKCksIGxlbmd0aCk7XG59XG5jb25zdCBub2RlU2l6ZUNhY2hlID0gbmV3IFdlYWtNYXA7XG5mdW5jdGlvbiBub2RlU2l6ZShiYWxhbmNlVHlwZSwgbm9kZSkge1xuICAgIGlmICghYmFsYW5jZVR5cGUuaXNBbm9ueW1vdXMgfHwgbm9kZSBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgbm9kZS50eXBlICE9IGJhbGFuY2VUeXBlKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgc2l6ZSA9IG5vZGVTaXplQ2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9IGJhbGFuY2VUeXBlIHx8ICEoY2hpbGQgaW5zdGFuY2VvZiBUcmVlKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVTaXplQ2FjaGUuc2V0KG5vZGUsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VSYW5nZShcbi8vIFRoZSB0eXBlIHRoZSBiYWxhbmNlZCB0cmVlJ3MgaW5uZXIgbm9kZXMuXG5iYWxhbmNlVHlwZSwgXG4vLyBUaGUgZGlyZWN0IGNoaWxkcmVuIGFuZCB0aGVpciBwb3NpdGlvbnNcbmNoaWxkcmVuLCBwb3NpdGlvbnMsIFxuLy8gVGhlIGluZGV4IHJhbmdlIGluIGNoaWxkcmVuL3Bvc2l0aW9ucyB0byB1c2VcbmZyb20sIHRvLCBcbi8vIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgbm9kZXMsIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudC5cbnN0YXJ0LCBcbi8vIExlbmd0aCBvZiB0aGUgb3V0ZXIgbm9kZVxubGVuZ3RoLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIHRoZSB0b3Agbm9kZSBvZiB0aGUgYmFsYW5jZWQgdHJlZVxubWtUb3AsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgaW50ZXJuYWwgbm9kZXMgZm9yIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RyZWUpIHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgICAgdG90YWwgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICBsZXQgbWF4Q2hpbGQgPSBNYXRoLmNlaWwoKHRvdGFsICogMS41KSAvIDggLyogQmFsYW5jZS5CcmFuY2hGYWN0b3IgKi8pO1xuICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgZnVuY3Rpb24gZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCBncm91cEZyb20gPSBpLCBncm91cFN0YXJ0ID0gcG9zaXRpb25zW2ldLCBncm91cFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgZm9yICg7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplICsgbmV4dFNpemUgPj0gbWF4Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGdyb3VwU2l6ZSArPSBuZXh0U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09IGdyb3VwRnJvbSArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplID4gbWF4Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9ubHkgPSBjaGlsZHJlbltncm91cEZyb21dOyAvLyBPbmx5IHRyZWVzIGNhbiBoYXZlIGEgc2l6ZSA+IDFcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlKG9ubHkuY2hpbGRyZW4sIG9ubHkucG9zaXRpb25zLCAwLCBvbmx5LmNoaWxkcmVuLmxlbmd0aCwgcG9zaXRpb25zW2dyb3VwRnJvbV0gKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuW2dyb3VwRnJvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHBvc2l0aW9uc1tpIC0gMV0gKyBjaGlsZHJlbltpIC0gMV0ubGVuZ3RoIC0gZ3JvdXBTdGFydDtcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goYmFsYW5jZVJhbmdlKGJhbGFuY2VUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBncm91cEZyb20sIGksIGdyb3VwU3RhcnQsIGxlbmd0aCwgbnVsbCwgbWtUcmVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKGdyb3VwU3RhcnQgKyBvZmZzZXQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCAwKTtcbiAgICByZXR1cm4gKG1rVG9wIHx8IG1rVHJlZSkobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxlbmd0aCk7XG59XG4vKipcblByb3ZpZGVzIGEgd2F5IHRvIGFzc29jaWF0ZSB2YWx1ZXMgd2l0aCBwaWVjZXMgb2YgdHJlZXMuIEFzIGxvbmdcbmFzIHRoYXQgcGFydCBvZiB0aGUgdHJlZSBpcyByZXVzZWQsIHRoZSBhc3NvY2lhdGVkIHZhbHVlcyBjYW4gYmVcbnJldHJpZXZlZCBmcm9tIGFuIHVwZGF0ZWQgdHJlZS5cbiovXG5jbGFzcyBOb2RlV2Vha01hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgc2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMubWFwLmdldChidWZmZXIpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGJ1ZmZlciwgaW5uZXIgPSBuZXcgTWFwKTtcbiAgICAgICAgaW5uZXIuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldEJ1ZmZlcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMubWFwLmdldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gaW5uZXIgJiYgaW5uZXIuZ2V0KGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZS5cbiAgICAqL1xuICAgIHNldChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSlcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChub2RlLnRyZWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdmFsdWUgZm9yIHRoaXMgc3ludGF4IG5vZGUsIGlmIGl0IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgICovXG4gICAgZ2V0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBCdWZmZXJOb2RlID8gdGhpcy5nZXRCdWZmZXIobm9kZS5jb250ZXh0LmJ1ZmZlciwgbm9kZS5pbmRleClcbiAgICAgICAgICAgIDogbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlID8gdGhpcy5tYXAuZ2V0KG5vZGUudHJlZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50cyB0by5cbiAgICAqL1xuICAgIGN1cnNvclNldChjdXJzb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChjdXJzb3IuYnVmZmVyKVxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCwgdmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoY3Vyc29yLnRyZWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdGhlIHZhbHVlIGZvciB0aGUgbm9kZSB0aGF0IGEgY3Vyc29yIGN1cnJlbnRseSBwb2ludHNcbiAgICB0by5cbiAgICAqL1xuICAgIGN1cnNvckdldChjdXJzb3IpIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5idWZmZXIgPyB0aGlzLmdldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4KSA6IHRoaXMubWFwLmdldChjdXJzb3IudHJlZSk7XG4gICAgfVxufVxuXG4vKipcblRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbnBhcnNpbmddKCNjb21tb24uUGFyc2VyLnN0YXJ0UGFyc2UpIHRvIHRyYWNrIHBhcnRzIG9mIG9sZCB0cmVlc1xudGhhdCBjYW4gYmUgcmV1c2VkIGluIGEgbmV3IHBhcnNlLiBBbiBhcnJheSBvZiBmcmFnbWVudHMgaXMgdXNlZFxudG8gdHJhY2sgcmVnaW9ucyBvZiBhbiBvbGQgdHJlZSB3aG9zZSBub2RlcyBtaWdodCBiZSByZXVzZWQgaW4gbmV3XG5wYXJzZXMuIFVzZSB0aGUgc3RhdGljXG5bYGFwcGx5Q2hhbmdlc2BdKCNjb21tb24uVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgbWV0aG9kIHRvXG51cGRhdGUgZnJhZ21lbnRzIGZvciBkb2N1bWVudCBjaGFuZ2VzLlxuKi9cbmNsYXNzIFRyZWVGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgdHJlZSBmcmFnbWVudC4gWW91J2xsIHVzdWFsbHkgd2FudCB0byB1c2VcbiAgICBbYGFkZFRyZWVgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hZGRUcmVlKSBhbmRcbiAgICBbYGFwcGx5Q2hhbmdlc2BdKCNjb21tb24uVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgaW5zdGVhZCBvZlxuICAgIGNhbGxpbmcgdGhpcyBkaXJlY3RseS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlIHBvaW50ZWQgdG8gYnkgdGhpcyBmcmFnbWVudC5cbiAgICBUaGlzIHJlZmVycyB0byBhbiBvZmZzZXQgaW4gdGhlIF91cGRhdGVkXyBkb2N1bWVudCAoYXMgb3Bwb3NlZFxuICAgIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgdHJlZSB0aGF0IHRoaXMgZnJhZ21lbnQgaXMgYmFzZWQgb24uXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICB0aGlzIGZyYWdtZW50IGNhbiBiZSB1c2VkIGFnYWluc3QuIEFkZCB0aGlzIHdoZW4gZ29pbmcgZnJvbVxuICAgIGRvY3VtZW50IHRvIHRyZWUgcG9zaXRpb25zLCBzdWJ0cmFjdCBpdCB0byBnbyBmcm9tIHRyZWUgdG9cbiAgICBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBvZmZzZXQsIG9wZW5TdGFydCA9IGZhbHNlLCBvcGVuRW5kID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5vcGVuID0gKG9wZW5TdGFydCA/IDEgLyogT3Blbi5TdGFydCAqLyA6IDApIHwgKG9wZW5FbmQgPyAyIC8qIE9wZW4uRW5kICovIDogMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiBhXG4gICAgcGFyc2UsIG9yIHRoZSBlbmQgb2YgYSBjaGFuZ2UuIChJbiB0aGUgc2Vjb25kIGNhc2UsIGl0IG1heSBub3RcbiAgICBiZSBzYWZlIHRvIHJldXNlIHNvbWUgbm9kZXMgYXQgdGhlIHN0YXJ0LCBkZXBlbmRpbmcgb24gdGhlXG4gICAgcGFyc2luZyBhbGdvcml0aG0uKVxuICAgICovXG4gICAgZ2V0IG9wZW5TdGFydCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAxIC8qIE9wZW4uU3RhcnQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIGFcbiAgICBmdWxsLWRvY3VtZW50IHBhcnNlLCBvciB0aGUgc3RhcnQgb2YgYSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIE9wZW4uRW5kICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgZnJhZ21lbnRzIGZyb20gYSBmcmVzaGx5IHBhcnNlZCB0cmVlLCBvciB1cGRhdGVcbiAgICBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICB3aXRoIGEgdHJlZSB3aXRoIGNvbnRlbnQgZnJvbSB0aGUgbmV3IHRyZWUuIFdoZW4gYHBhcnRpYWxgIGlzXG4gICAgdHJ1ZSwgdGhlIHBhcnNlIGlzIHRyZWF0ZWQgYXMgaW5jb21wbGV0ZSwgYW5kIHRoZSByZXN1bHRpbmdcbiAgICBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgdHJ1ZS5cbiAgICAqL1xuICAgIHN0YXRpYyBhZGRUcmVlKHRyZWUsIGZyYWdtZW50cyA9IFtdLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtuZXcgVHJlZUZyYWdtZW50KDAsIHRyZWUubGVuZ3RoLCB0cmVlLCAwLCBmYWxzZSwgcGFydGlhbCldO1xuICAgICAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cylcbiAgICAgICAgICAgIGlmIChmLnRvID4gdHJlZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICBzcGxpdHRpbmcgZnJhZ21lbnRzIGFzIG5lY2Vzc2FyeSB0byByZW1vdmUgZWRpdGVkIHJhbmdlcywgYW5kXG4gICAgYWRqdXN0aW5nIG9mZnNldHMgZm9yIGZyYWdtZW50cyB0aGF0IG1vdmVkLlxuICAgICovXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5BIHN1cGVyY2xhc3MgdGhhdCBwYXJzZXJzIHNob3VsZCBleHRlbmQuXG4qL1xuY2xhc3MgUGFyc2VyIHtcbiAgICAvKipcbiAgICBTdGFydCBhIHBhcnNlLCByZXR1cm5pbmcgYSBbcGFydGlhbCBwYXJzZV0oI2NvbW1vbi5QYXJ0aWFsUGFyc2UpXG4gICAgb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgbWFrZSB0aGUgcGFyc2UgaW5jcmVtZW50YWwuXG4gICAgXG4gICAgQnkgZGVmYXVsdCwgdGhlIGVudGlyZSBpbnB1dCBpcyBwYXJzZWQuIFlvdSBjYW4gcGFzcyBgcmFuZ2VzYCxcbiAgICB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICByYW5nZXMsIHRvIHBhcnNlIG9ubHkgdGhvc2UgcmFuZ2VzLiBUaGUgdHJlZSByZXR1cm5lZCBpbiB0aGF0XG4gICAgY2FzZSB3aWxsIHN0YXJ0IGF0IGByYW5nZXNbMF0uZnJvbWAuXG4gICAgKi9cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIGEgZnVsbCBwYXJzZSwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgdHJlZS5cbiAgICAqL1xuICAgIHBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBsZXQgcGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBwYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFN0cmluZ0lucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICBjaHVuayhmcm9tKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tKTsgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICByZWFkKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tLCB0byk7IH1cbn1cblxuLyoqXG5DcmVhdGUgYSBwYXJzZSB3cmFwcGVyIHRoYXQsIGFmdGVyIHRoZSBpbm5lciBwYXJzZSBjb21wbGV0ZXMsXG5zY2FucyBpdHMgdHJlZSBmb3IgbWl4ZWQgbGFuZ3VhZ2UgcmVnaW9ucyB3aXRoIHRoZSBgbmVzdGBcbmZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG5hbmQgdGhlbiBbbW91bnRzXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRoZWlyIHJlc3VsdHMgb250byB0aGVcbnRyZWUuXG4qL1xuZnVuY3Rpb24gcGFyc2VNaXhlZChuZXN0KSB7XG4gICAgcmV0dXJuIChwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSA9PiBuZXcgTWl4ZWRQYXJzZShwYXJzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbn1cbmNsYXNzIElubmVyUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcGFyc2UsIG92ZXJsYXksIHRhcmdldCwgZnJvbSkge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1JhbmdlcyhyYW5nZXMpIHtcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGggfHwgcmFuZ2VzLnNvbWUociA9PiByLmZyb20gPj0gci50bykpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbm5lciBwYXJzZSByYW5nZXMgZ2l2ZW46IFwiICsgSlNPTi5zdHJpbmdpZnkocmFuZ2VzKSk7XG59XG5jbGFzcyBBY3RpdmVPdmVybGF5IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHByZWRpY2F0ZSwgbW91bnRzLCBpbmRleCwgc3RhcnQsIHRhcmdldCwgcHJldikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMubW91bnRzID0gbW91bnRzO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgIH1cbn1cbmNvbnN0IHN0b3BwZWRJbm5lciA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG5jbGFzcyBNaXhlZFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5uZXN0ID0gbmVzdDtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBbXTtcbiAgICAgICAgdGhpcy5pbm5lckRvbmUgPSAwO1xuICAgICAgICB0aGlzLmJhc2VUcmVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmJhc2VQYXJzZSA9IGJhc2U7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSkge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmJhc2VQYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0aGlzLmJhc2VQYXJzZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJhc2VUcmVlID0gZG9uZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRJbm5lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5uZXIgb2YgdGhpcy5pbm5lcilcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIucGFyc2Uuc3RvcEF0KHRoaXMuc3RvcHBlZEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbm5lckRvbmUgPT0gdGhpcy5pbm5lci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmJhc2VUcmVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRyZWUocmVzdWx0LnR5cGUsIHJlc3VsdC5jaGlsZHJlbiwgcmVzdWx0LnBvc2l0aW9ucywgcmVzdWx0Lmxlbmd0aCwgcmVzdWx0LnByb3BWYWx1ZXMuY29uY2F0KFtbc3RvcHBlZElubmVyLCB0aGlzLnN0b3BwZWRBdF1dKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMuaW5uZXJbdGhpcy5pbm5lckRvbmVdLCBkb25lID0gaW5uZXIucGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5pbm5lckRvbmUrKztcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzb21ld2hhdCBkb2RneSBidXQgc3VwZXIgaGVscGZ1bCBoYWNrIHdoZXJlIHdlXG4gICAgICAgICAgICAvLyBwYXRjaCB1cCBub2RlcyBjcmVhdGVkIGJ5IHRoZSBpbm5lciBwYXJzZSAoYW5kIHRodXNcbiAgICAgICAgICAgIC8vIHByZXN1bWFibHkgbm90IGFsaWFzZWQgYW55d2hlcmUgZWxzZSkgdG8gaG9sZCB0aGUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIC8vIGFib3V0IHRoZSBpbm5lciBwYXJzZS5cbiAgICAgICAgICAgIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgaW5uZXIudGFyZ2V0LnByb3BzKTtcbiAgICAgICAgICAgIHByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdID0gbmV3IE1vdW50ZWRUcmVlKGRvbmUsIGlubmVyLm92ZXJsYXksIGlubmVyLnBhcnNlcik7XG4gICAgICAgICAgICBpbm5lci50YXJnZXQucHJvcHMgPSBwcm9wcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhcnNlZFBvcygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmlucHV0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5uZXJEb25lOyBpIDwgdGhpcy5pbm5lci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5uZXJbaV0uZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICBwb3MgPSBNYXRoLm1pbihwb3MsIHRoaXMuaW5uZXJbaV0ucGFyc2UucGFyc2VkUG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICB0aGlzLmJhc2VQYXJzZS5zdG9wQXQocG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5uZXJEb25lOyBpIDwgdGhpcy5pbm5lci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyW2ldLnBhcnNlLnN0b3BBdChwb3MpO1xuICAgIH1cbiAgICBzdGFydElubmVyKCkge1xuICAgICAgICBsZXQgZnJhZ21lbnRDdXJzb3IgPSBuZXcgRnJhZ21lbnRDdXJzb3IodGhpcy5mcmFnbWVudHMpO1xuICAgICAgICBsZXQgb3ZlcmxheSA9IG51bGw7XG4gICAgICAgIGxldCBjb3ZlcmVkID0gbnVsbDtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKG5ldyBUcmVlTm9kZSh0aGlzLmJhc2VUcmVlLCB0aGlzLnJhbmdlc1swXS5mcm9tLCAwLCBudWxsKSwgZXhwb3J0cy5JdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgZXhwb3J0cy5JdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBuZXN0LCBpc0NvdmVyZWQ7Oykge1xuICAgICAgICAgICAgbGV0IGVudGVyID0gdHJ1ZSwgcmFuZ2U7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBjdXJzb3IuZnJvbSA+PSB0aGlzLnN0b3BwZWRBdCkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50byAmJiAhb3ZlcmxheS5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBDb3Zlci5GdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpICYmXG4gICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvIHx8ICFuZXN0Lm92ZXJsYXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkTW91bnRzID0gZnJhZ21lbnRDdXJzb3IuZmluZE1vdW50cyhjdXJzb3IuZnJvbSwgbmVzdC5wYXJzZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVzdC5vdmVybGF5ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gbmV3IEFjdGl2ZU92ZXJsYXkobmVzdC5wYXJzZXIsIG5lc3Qub3ZlcmxheSwgb2xkTW91bnRzLCB0aGlzLmlubmVyLmxlbmd0aCwgY3Vyc29yLmZyb20sIGN1cnNvci50cmVlLCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgbmVzdC5vdmVybGF5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoY3Vyc29yLmZyb20gPCBjdXJzb3IudG8gPyBbbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pXSA6IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tSYW5nZXMocmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggfHwgIW5lc3Qub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIucHVzaChuZXcgSW5uZXJQYXJzZShuZXN0LnBhcnNlciwgcmFuZ2VzLmxlbmd0aCA/IG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob2xkTW91bnRzLCByYW5nZXMpLCByYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXN0LnBhcnNlci5zdGFydFBhcnNlKFwiXCIpLCBuZXN0Lm92ZXJsYXkgPyBuZXN0Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIGN1cnNvci5mcm9tLCByLnRvIC0gY3Vyc29yLmZyb20pKSA6IG51bGwsIGN1cnNvci50cmVlLCByYW5nZXMubGVuZ3RoID8gcmFuZ2VzWzBdLmZyb20gOiBjdXJzb3IuZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5lc3Qub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0geyByYW5nZXMsIGRlcHRoOiAwLCBwcmV2OiBjb3ZlcmVkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAmJiAocmFuZ2UgPSBvdmVybGF5LnByZWRpY2F0ZShjdXJzb3IpKSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPCByYW5nZS50bykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IG92ZXJsYXkucmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0ID49IDAgJiYgb3ZlcmxheS5yYW5nZXNbbGFzdF0udG8gPT0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzW2xhc3RdID0geyBmcm9tOiBvdmVybGF5LnJhbmdlc1tsYXN0XS5mcm9tLCB0bzogcmFuZ2UudG8gfTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGVyICYmIGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICYmICEtLW92ZXJsYXkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgb3ZlcmxheS5yYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1JhbmdlcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIuc3BsaWNlKG92ZXJsYXkuaW5kZXgsIDAsIG5ldyBJbm5lclBhcnNlKG92ZXJsYXkucGFyc2VyLCBvdmVybGF5LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG92ZXJsYXkubW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBvdmVybGF5LnJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gb3ZlcmxheS5zdGFydCwgci50byAtIG92ZXJsYXkuc3RhcnQpKSwgb3ZlcmxheS50YXJnZXQsIHJhbmdlc1swXS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBDb3Zlci5GdWxsICovIDogMSAvKiBDb3Zlci5QYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb3Zlci5Ob25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBzdGFjayA9IFtdO1xuICAgIGxldCBidWZmZXIgPSBub2RlLmNvbnRleHQuYnVmZmVyO1xuICAgIC8vIFNjYW4gdXAgdG8gdGhlIG5lYXJlc3QgdHJlZVxuICAgIGRvIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXJzb3IuaW5kZXgpO1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBiYXNlID0gY3Vyc29yLnRyZWUsIGkgPSBiYXNlLmNoaWxkcmVuLmluZGV4T2YoYnVmZmVyKTtcbiAgICBsZXQgYnVmID0gYmFzZS5jaGlsZHJlbltpXSwgYiA9IGJ1Zi5idWZmZXIsIG5ld1N0YWNrID0gW2ldO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCwgc3RhY2tQb3MpIHtcbiAgICAgICAgbGV0IHRhcmdldEkgPSBzdGFja1tzdGFja1Bvc107XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBzdGFydEksIHRhcmdldEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgbGV0IGZyb20gPSBiW3RhcmdldEkgKyAxXSwgdG8gPSBiW3RhcmdldEkgKyAyXTtcbiAgICAgICAgbmV3U3RhY2sucHVzaChjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICBsZXQgY2hpbGQgPSBzdGFja1Bvc1xuICAgICAgICAgICAgPyBzcGxpdCh0YXJnZXRJICsgNCwgYlt0YXJnZXRJICsgM10sIGJ1Zi5zZXQudHlwZXNbYlt0YXJnZXRJXV0sIGZyb20sIHRvIC0gZnJvbSwgc3RhY2tQb3MgLSAxKVxuICAgICAgICAgICAgOiBub2RlLnRvVHJlZSgpO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBiW3RhcmdldEkgKyAzXSwgZW5kSSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKTtcbiAgICB9XG4gICAgYmFzZS5jaGlsZHJlbltpXSA9IHNwbGl0KDAsIGIubGVuZ3RoLCBOb2RlVHlwZS5ub25lLCAwLCBidWYubGVuZ3RoLCBzdGFjay5sZW5ndGggLSAxKTtcbiAgICAvLyBNb3ZlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgdGFyZ2V0IG5vZGVcbiAgICBmb3IgKGxldCBpbmRleCBvZiBuZXdTdGFjaykge1xuICAgICAgICBsZXQgdHJlZSA9IGN1cnNvci50cmVlLmNoaWxkcmVuW2luZGV4XSwgcG9zID0gY3Vyc29yLnRyZWUucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgY3Vyc29yLnlpZWxkKG5ldyBUcmVlTm9kZSh0cmVlLCBwb3MgKyBjdXJzb3IuZnJvbSwgaW5kZXgsIGN1cnNvci5fdHJlZSkpO1xuICAgIH1cbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmN1cnNvcihleHBvcnRzLkl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBleHBvcnRzLkl0ZXJNb2RlLklnbm9yZU1vdW50cyk7XG4gICAgfVxuICAgIC8vIE1vdmUgdG8gdGhlIGZpcnN0IG5vZGUgKGluIHByZS1vcmRlcikgdGhhdCBzdGFydHMgYXQgb3IgYWZ0ZXIgYHBvc2AuXG4gICAgbW92ZVRvKHBvcykge1xuICAgICAgICBsZXQgeyBjdXJzb3IgfSA9IHRoaXMsIHAgPSBwb3MgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmRvbmUgJiYgY3Vyc29yLmZyb20gPCBwKSB7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IHBvcyAmJiBjdXJzb3IuZW50ZXIocCwgMSwgZXhwb3J0cy5JdGVyTW9kZS5JZ25vcmVPdmVybGF5cyB8IGV4cG9ydHMuSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLm5leHQoZmFsc2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oY3Vyc29yLmZyb20pO1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSAmJiB0aGlzLmN1cnNvci5mcm9tICsgdGhpcy5vZmZzZXQgPT0gY3Vyc29yLmZyb20gJiYgdGhpcy5jdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSA9IHRoaXMuY3Vyc29yLnRyZWU7Oykge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlID09IGN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJlZS5jaGlsZHJlbi5sZW5ndGggJiYgdHJlZS5wb3NpdGlvbnNbMF0gPT0gMCAmJiB0cmVlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmN1clRvID0gMDtcbiAgICAgICAgdGhpcy5mcmFnSSA9IDA7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmN1ckZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZmlyc3QudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpcnN0LnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZmlyc3QudHJlZSwgLWZpcnN0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VyRnJhZyAmJiBub2RlLmZyb20gPj0gdGhpcy5jdXJUbylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyRnJhZyAmJiB0aGlzLmN1ckZyYWcuZnJvbSA8PSBub2RlLmZyb20gJiYgdGhpcy5jdXJUbyA+PSBub2RlLnRvICYmIHRoaXMuaW5uZXIuaGFzTm9kZShub2RlKTtcbiAgICB9XG4gICAgbmV4dEZyYWcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xuICAgICAgICBpZiAodGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1ckZyYWcgPSB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdJXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmcmFnLnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmcmFnLnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZnJhZy50cmVlLCAtZnJhZy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRNb3VudHMocG9zLCBwYXJzZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyLmN1cnNvci5tb3ZlVG8ocG9zLCAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBtb3VudCA9IChfYSA9IHBvcy50cmVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQucGFyc2VyID09IHBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFnSTsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZnJvbSA+PSBwb3MudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy50cmVlID09IHRoaXMuY3VyRnJhZy50cmVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3MuZnJvbSAtIGZyYWcub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVuY2hSYW5nZXMob3V0ZXIsIHJhbmdlcykge1xuICAgIGxldCBjb3B5ID0gbnVsbCwgY3VycmVudCA9IHJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG91dGVyW2kgLSAxXS50bywgZ2FwVG8gPSBvdXRlcltpXS5mcm9tO1xuICAgICAgICBmb3IgKDsgaiA8IGN1cnJlbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByID0gY3VycmVudFtqXTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gZ2FwVG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA8PSBnYXBGcm9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb3B5ID0gcmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoci5mcm9tIDwgZ2FwRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvcHlbal0gPSBuZXcgUmFuZ2Uoci5mcm9tLCBnYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoci50byA+IGdhcFRvKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqICsgMSwgMCwgbmV3IFJhbmdlKGdhcFRvLCByLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyLnRvID4gZ2FwVG8pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2otLV0gPSBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGZpbmRDb3ZlckNoYW5nZXMoYSwgYiwgZnJvbSwgdG8pIHtcbiAgICBsZXQgaUEgPSAwLCBpQiA9IDAsIGluQSA9IGZhbHNlLCBpbkIgPSBmYWxzZSwgcG9zID0gLTFlOTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbmV4dEEgPSBpQSA9PSBhLmxlbmd0aCA/IDFlOSA6IGluQSA/IGFbaUFdLnRvIDogYVtpQV0uZnJvbTtcbiAgICAgICAgbGV0IG5leHRCID0gaUIgPT0gYi5sZW5ndGggPyAxZTkgOiBpbkIgPyBiW2lCXS50byA6IGJbaUJdLmZyb207XG4gICAgICAgIGlmIChpbkEgIT0gaW5CKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIsIHRvKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IE1hdGgubWluKG5leHRBLCBuZXh0Qik7XG4gICAgICAgIGlmIChwb3MgPT0gMWU5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0QSA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5BKVxuICAgICAgICAgICAgICAgIGluQSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0QiA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5CKVxuICAgICAgICAgICAgICAgIGluQiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBHaXZlbiBhIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoZSBvdXRlciB0cmVlLCBhbmQgYSBzZXQgb2YgcmFuZ2VzXG4vLyB0byBwYXJzZSwgZmluZCBmcmFnbWVudHMgZm9yIGlubmVyIHRyZWVzIG1vdW50ZWQgYXJvdW5kIHRob3NlXG4vLyByYW5nZXMsIGlmIGFueS5cbmZ1bmN0aW9uIGVudGVyRnJhZ21lbnRzKG1vdW50cywgcmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgcG9zLCBtb3VudCwgZnJhZyB9IG9mIG1vdW50cykge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBwb3MgKyAobW91bnQub3ZlcmxheSA/IG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA6IDApLCBlbmRQb3MgPSBzdGFydFBvcyArIG1vdW50LnRyZWUubGVuZ3RoO1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KGZyYWcuZnJvbSwgc3RhcnRQb3MpLCB0byA9IE1hdGgubWluKGZyYWcudG8sIGVuZFBvcyk7XG4gICAgICAgIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxheSA9IG1vdW50Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSArIHBvcywgci50byArIHBvcykpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBmaW5kQ292ZXJDaGFuZ2VzKHJhbmdlcywgb3ZlcmxheSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IGZyb207OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gY2hhbmdlcy5sZW5ndGgsIGVuZCA9IGxhc3QgPyB0byA6IGNoYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KHBvcywgZW5kLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBwb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBjaGFuZ2VzW2ldLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChmcm9tLCB0bywgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gc3RhcnRQb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kUG9zIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMuRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG5leHBvcnRzLk1vdW50ZWRUcmVlID0gTW91bnRlZFRyZWU7XG5leHBvcnRzLk5vZGVQcm9wID0gTm9kZVByb3A7XG5leHBvcnRzLk5vZGVTZXQgPSBOb2RlU2V0O1xuZXhwb3J0cy5Ob2RlVHlwZSA9IE5vZGVUeXBlO1xuZXhwb3J0cy5Ob2RlV2Vha01hcCA9IE5vZGVXZWFrTWFwO1xuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG5leHBvcnRzLlRyZWUgPSBUcmVlO1xuZXhwb3J0cy5UcmVlQnVmZmVyID0gVHJlZUJ1ZmZlcjtcbmV4cG9ydHMuVHJlZUN1cnNvciA9IFRyZWVDdXJzb3I7XG5leHBvcnRzLlRyZWVGcmFnbWVudCA9IFRyZWVGcmFnbWVudDtcbmV4cG9ydHMucGFyc2VNaXhlZCA9IHBhcnNlTWl4ZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBsciA9IHJlcXVpcmUoJ0BsZXplci9scicpO1xudmFyIGhpZ2hsaWdodCA9IHJlcXVpcmUoJ0BsZXplci9oaWdobGlnaHQnKTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBkZXNjZW5kYW50T3AgPSA5OSxcbiAgVW5pdCA9IDEsXG4gIGNhbGxlZSA9IDEwMCxcbiAgaWRlbnRpZmllciA9IDEwMSxcbiAgVmFyaWFibGVOYW1lID0gMjtcblxuLyogSGFuZC13cml0dGVuIHRva2VuaXplcnMgZm9yIENTUyB0b2tlbnMgdGhhdCBjYW4ndCBiZVxuICAgZXhwcmVzc2VkIGJ5IExlemVyJ3MgYnVpbHQtaW4gdG9rZW5pemVyLiAqL1xuXG5jb25zdCBzcGFjZSA9IFs5LCAxMCwgMTEsIDEyLCAxMywgMzIsIDEzMywgMTYwLCA1NzYwLCA4MTkyLCA4MTkzLCA4MTk0LCA4MTk1LCA4MTk2LCA4MTk3LFxuICAgICAgICAgICAgICAgODE5OCwgODE5OSwgODIwMCwgODIwMSwgODIwMiwgODIzMiwgODIzMywgODIzOSwgODI4NywgMTIyODhdO1xuY29uc3QgY29sb24gPSA1OCwgcGFyZW5MID0gNDAsIHVuZGVyc2NvcmUgPSA5NSwgYnJhY2tldEwgPSA5MSwgZGFzaCA9IDQ1LCBwZXJpb2QgPSA0NixcbiAgICAgIGhhc2ggPSAzNSwgcGVyY2VudCA9IDM3LCBhbXBlcnNhbmQgPSAzOCwgYmFja3NsYXNoID0gOTIsIG5ld2xpbmUgPSAxMDtcblxuZnVuY3Rpb24gaXNBbHBoYShjaCkgeyByZXR1cm4gY2ggPj0gNjUgJiYgY2ggPD0gOTAgfHwgY2ggPj0gOTcgJiYgY2ggPD0gMTIyIHx8IGNoID49IDE2MSB9XG5cbmZ1bmN0aW9uIGlzRGlnaXQoY2gpIHsgcmV0dXJuIGNoID49IDQ4ICYmIGNoIDw9IDU3IH1cblxuY29uc3QgaWRlbnRpZmllcnMgPSBuZXcgbHIuRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBmb3IgKGxldCBpbnNpZGUgPSBmYWxzZSwgZGFzaGVzID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICBsZXQge25leHR9ID0gaW5wdXQ7XG4gICAgaWYgKGlzQWxwaGEobmV4dCkgfHwgbmV4dCA9PSBkYXNoIHx8IG5leHQgPT0gdW5kZXJzY29yZSB8fCAoaW5zaWRlICYmIGlzRGlnaXQobmV4dCkpKSB7XG4gICAgICBpZiAoIWluc2lkZSAmJiAobmV4dCAhPSBkYXNoIHx8IGkgPiAwKSkgaW5zaWRlID0gdHJ1ZTtcbiAgICAgIGlmIChkYXNoZXMgPT09IGkgJiYgbmV4dCA9PSBkYXNoKSBkYXNoZXMrKztcbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT0gYmFja3NsYXNoICYmIGlucHV0LnBlZWsoMSkgIT0gbmV3bGluZSkge1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgaWYgKGlucHV0Lm5leHQgPiAtMSkgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGluc2lkZSlcbiAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4obmV4dCA9PSBwYXJlbkwgPyBjYWxsZWUgOiBkYXNoZXMgPT0gMiAmJiBzdGFjay5jYW5TaGlmdChWYXJpYWJsZU5hbWUpID8gVmFyaWFibGVOYW1lIDogaWRlbnRpZmllcik7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufSk7XG5cbmNvbnN0IGRlc2NlbmRhbnQgPSBuZXcgbHIuRXh0ZXJuYWxUb2tlbml6ZXIoaW5wdXQgPT4ge1xuICBpZiAoc3BhY2UuaW5jbHVkZXMoaW5wdXQucGVlaygtMSkpKSB7XG4gICAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICAgIGlmIChpc0FscGhhKG5leHQpIHx8IG5leHQgPT0gdW5kZXJzY29yZSB8fCBuZXh0ID09IGhhc2ggfHwgbmV4dCA9PSBwZXJpb2QgfHxcbiAgICAgICAgbmV4dCA9PSBicmFja2V0TCB8fCBuZXh0ID09IGNvbG9uICYmIGlzQWxwaGEoaW5wdXQucGVlaygxKSkgfHxcbiAgICAgICAgbmV4dCA9PSBkYXNoIHx8IG5leHQgPT0gYW1wZXJzYW5kKVxuICAgICAgaW5wdXQuYWNjZXB0VG9rZW4oZGVzY2VuZGFudE9wKTtcbiAgfVxufSk7XG5cbmNvbnN0IHVuaXRUb2tlbiA9IG5ldyBsci5FeHRlcm5hbFRva2VuaXplcihpbnB1dCA9PiB7XG4gIGlmICghc3BhY2UuaW5jbHVkZXMoaW5wdXQucGVlaygtMSkpKSB7XG4gICAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICAgIGlmIChuZXh0ID09IHBlcmNlbnQpIHsgaW5wdXQuYWR2YW5jZSgpOyBpbnB1dC5hY2NlcHRUb2tlbihVbml0KTsgfVxuICAgIGlmIChpc0FscGhhKG5leHQpKSB7XG4gICAgICBkbyB7IGlucHV0LmFkdmFuY2UoKTsgfSB3aGlsZSAoaXNBbHBoYShpbnB1dC5uZXh0KSB8fCBpc0RpZ2l0KGlucHV0Lm5leHQpKVxuICAgICAgaW5wdXQuYWNjZXB0VG9rZW4oVW5pdCk7XG4gICAgfVxuICB9XG59KTtcblxuY29uc3QgY3NzSGlnaGxpZ2h0aW5nID0gaGlnaGxpZ2h0LnN0eWxlVGFncyh7XG4gIFwiQXRLZXl3b3JkIGltcG9ydCBjaGFyc2V0IG5hbWVzcGFjZSBrZXlmcmFtZXMgbWVkaWEgc3VwcG9ydHNcIjogaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiZnJvbSB0byBzZWxlY3RvclwiOiBoaWdobGlnaHQudGFncy5rZXl3b3JkLFxuICBOYW1lc3BhY2VOYW1lOiBoaWdobGlnaHQudGFncy5uYW1lc3BhY2UsXG4gIEtleWZyYW1lTmFtZTogaGlnaGxpZ2h0LnRhZ3MubGFiZWxOYW1lLFxuICBLZXlmcmFtZVJhbmdlTmFtZTogaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuICBUYWdOYW1lOiBoaWdobGlnaHQudGFncy50YWdOYW1lLFxuICBDbGFzc05hbWU6IGhpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSxcbiAgUHNldWRvQ2xhc3NOYW1lOiBoaWdobGlnaHQudGFncy5jb25zdGFudChoaWdobGlnaHQudGFncy5jbGFzc05hbWUpLFxuICBJZE5hbWU6IGhpZ2hsaWdodC50YWdzLmxhYmVsTmFtZSxcbiAgXCJGZWF0dXJlTmFtZSBQcm9wZXJ0eU5hbWVcIjogaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lLFxuICBBdHRyaWJ1dGVOYW1lOiBoaWdobGlnaHQudGFncy5hdHRyaWJ1dGVOYW1lLFxuICBOdW1iZXJMaXRlcmFsOiBoaWdobGlnaHQudGFncy5udW1iZXIsXG4gIEtleXdvcmRRdWVyeTogaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCxcbiAgVW5hcnlRdWVyeU9wOiBoaWdobGlnaHQudGFncy5vcGVyYXRvcktleXdvcmQsXG4gIFwiQ2FsbFRhZyBWYWx1ZU5hbWVcIjogaGlnaGxpZ2h0LnRhZ3MuYXRvbSxcbiAgVmFyaWFibGVOYW1lOiBoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUsXG4gIENhbGxlZTogaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuICBVbml0OiBoaWdobGlnaHQudGFncy51bml0LFxuICBcIlVuaXZlcnNhbFNlbGVjdG9yIE5lc3RpbmdTZWxlY3RvclwiOiBoaWdobGlnaHQudGFncy5kZWZpbml0aW9uT3BlcmF0b3IsXG4gIE1hdGNoT3A6IGhpZ2hsaWdodC50YWdzLmNvbXBhcmVPcGVyYXRvcixcbiAgXCJDaGlsZE9wIFNpYmxpbmdPcCwgTG9naWNPcFwiOiBoaWdobGlnaHQudGFncy5sb2dpY09wZXJhdG9yLFxuICBCaW5PcDogaGlnaGxpZ2h0LnRhZ3MuYXJpdGhtZXRpY09wZXJhdG9yLFxuICBJbXBvcnRhbnQ6IGhpZ2hsaWdodC50YWdzLm1vZGlmaWVyLFxuICBDb21tZW50OiBoaWdobGlnaHQudGFncy5ibG9ja0NvbW1lbnQsXG4gIENvbG9yTGl0ZXJhbDogaGlnaGxpZ2h0LnRhZ3MuY29sb3IsXG4gIFwiUGFyZW50aGVzaXplZENvbnRlbnQgU3RyaW5nTGl0ZXJhbFwiOiBoaWdobGlnaHQudGFncy5zdHJpbmcsXG4gIFwiOlwiOiBoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbixcbiAgXCJQc2V1ZG9PcCAjXCI6IGhpZ2hsaWdodC50YWdzLmRlcmVmT3BlcmF0b3IsXG4gIFwiOyAsXCI6IGhpZ2hsaWdodC50YWdzLnNlcGFyYXRvcixcbiAgXCIoIClcIjogaGlnaGxpZ2h0LnRhZ3MucGFyZW4sXG4gIFwiWyBdXCI6IGhpZ2hsaWdodC50YWdzLnNxdWFyZUJyYWNrZXQsXG4gIFwieyB9XCI6IGhpZ2hsaWdodC50YWdzLmJyYWNlXG59KTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX2NhbGxlZSA9IHtfX3Byb3RvX186bnVsbCxsYW5nOjMyLCBcIm50aC1jaGlsZFwiOjMyLCBcIm50aC1sYXN0LWNoaWxkXCI6MzIsIFwibnRoLW9mLXR5cGVcIjozMiwgXCJudGgtbGFzdC1vZi10eXBlXCI6MzIsIGRpcjozMiwgXCJob3N0LWNvbnRleHRcIjozMiwgdXJsOjYwLCBcInVybC1wcmVmaXhcIjo2MCwgZG9tYWluOjYwLCByZWdleHA6NjAsIHNlbGVjdG9yOjEzOH07XG5jb25zdCBzcGVjX0F0S2V5d29yZCA9IHtfX3Byb3RvX186bnVsbCxcIkBpbXBvcnRcIjoxMTgsIFwiQG1lZGlhXCI6MTQyLCBcIkBjaGFyc2V0XCI6MTQ2LCBcIkBuYW1lc3BhY2VcIjoxNTAsIFwiQGtleWZyYW1lc1wiOjE1NiwgXCJAc3VwcG9ydHNcIjoxNjh9O1xuY29uc3Qgc3BlY19pZGVudGlmaWVyID0ge19fcHJvdG9fXzpudWxsLG5vdDoxMzIsIG9ubHk6MTMyfTtcbmNvbnN0IHBhcnNlciA9IGxyLkxSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCI6alFZUVtPT08jX1FbT09QI2ZPV09PT09RUCcjQ2QnI0NkT09RUCcjQ2MnI0NjTyNrUVtPJyNDZk8kX1FYTycjQ2FPJGZRW08nI0NoTyRxUVtPJyNEVE8kdlFbTycjRFdPT1FQJyNFbScjRW1PJHtRZE8nI0RnTyVqUVtPJyNEdE8ke1FkTycjRHZPJXtRW08nI0R4TyZXUVtPJyNEe08mYFFbTycjRVJPJm5RW08nI0VUT09RUycjRWwnI0VsT09RUycjRVcnI0VXUVlRW09PTyZ1UVhPJyNDZE8nalFXTycjRGNPJ29RV08nI0VzTyd6UVtPJyNFc1FPUVdPT1AoVU8jdE8nI0NfUE9PTylDQFspQ0BbT09RUCcjQ2cnI0NnT09RUCw1OVEsNTlRTyNrUVtPLDU5UU8oYVFbTycjRVtPKHtRV08sNTh7TylUUVtPLDU5U08kcVFbTyw1OW9PJHZRW08sNTlyTyhhUVtPLDU5dU8oYVFbTyw1OXdPKGFRW08sNTl4TylgUVtPJyNEYk9PUVMsNTh7LDU4e09PUVAnI0NrJyNDa09PUU8nI0RSJyNEUk9PUVAsNTlTLDU5U08pZ1FXTyw1OVNPKWxRV08sNTlTT09RUCcjRFYnI0RWT09RUCw1OW8sNTlvT09RTycjRFgnI0RYTylxUWBPLDU5ck9PUVMnI0NwJyNDcE8ke1FkTycjQ3FPKXlRdk8nI0NzTytaUXRPLDU6Uk9PUU8nI0N4JyNDeE8pbFFXTycjQ3dPK29RV08nI0N5Tyt0UVtPJyNET09PUVMnI0VwJyNFcE9PUU8nI0RqJyNEak8rfFFbTycjRHFPLFtRV08nI0V0TyZgUVtPJyNEb08salFXTycjRHJPT1FPJyNFdScjRXVPKU9RV08sNTpgTyxvUXBPLDU6Yk9PUVMnI0R6JyNEek8sd1FXTyw1OmRPLHxRW08sNTpkT09RTycjRH0nI0R9Ty1VUVdPLDU6Z08tWlFXTyw1Om1PLWNRV08sNTpvT09RUy1FOFUtRThVTy1rUWRPLDU5fU8te1FbTycjRV5PLllRV08sNTtfTy5ZUVdPLDU7X1BPT08nI0VWJyNFVlAuZU8jdE8sNTh5UE9PTyw1OHksNTh5T09RUDFHLmwxRy5sTy9bUVhPLDU6dk9PUU8tRThZLUU4WU9PUVMxRy5nMUcuZ09PUVAxRy5uMUcubk8pZ1FXTzFHLm5PKWxRV08xRy5uT09RUDFHL1oxRy9aTy9pUWBPMUcvXk8wU1FYTzFHL2FPMGpRWE8xRy9jTzFRUVhPMUcvZE8xaFFXTyw1OXxPMW1RW08nI0RTTzF0UWRPJyNDb09PUVAxRy9eMUcvXk8ke1FkTzFHL15PMXtRcE8sNTldT09RUyw1OV8sNTlfTyR7UWRPLDU5YU8yVFFXTzFHL21PT1FTLDU5Yyw1OWNPMllRIWJPLDU5ZU9PUVMnI0RQJyNEUE9PUVMnI0VZJyNFWU8yZVFbTyw1OWpPT1FTLDU5aiw1OWpPMm1RV08nI0RqTzJ4UVdPLDU6Vk8yfVFXTyw1Ol1PJmBRW08sNTpYTyZgUVtPJyNFX08zVlFXTyw1O2BPM2JRV08sNTpaTyhhUVtPLDU6Xk9PUVMxRy96MUcvek9PUVMxRy98MUcvfE9PUVMxRzBPMUcwT08zc1FXTzFHME9PM3hRZE8nI0VPT09RUzFHMFIxRzBST09RUzFHMFgxRzBYT09RUzFHMFoxRzBaTzRUUXRPMUcvaU9PUU8xRy9pMUcvaU9PUU8sNTp4LDU6eE80a1FbTyw1OnhPT1FPLUU4Wy1FOFtPNHhRV08xRzB5UE9PTy1FOFQtRThUUE9PTzFHLmUxRy5lT09RUDcrJFk3KyRZT09RUDcrJHg3KyR4TyR7UWRPNyskeE9PUVMxRy9oMUcvaE81VFFYTycjRXJPNVtRV08sNTluTzVhUXRPJyNFWE82WFFkTycjRW9PNmNRV08sNTlaTzZoUXBPNyskeE9PUVMxRy53MUcud09PUVMxRy57MUcue09PUVM3KyVYNyslWE9PUVMxRy9QMUcvUE82cFFXTzFHL1BPT1FTLUU4Vy1FOFdPT1FTMUcvVTFHL1VPJHtRZE8xRy9xT09RTzFHL3cxRy93T09RTzFHL3MxRy9zTzZ1UVdPLDU6eU9PUU8tRThdLUU4XU83VFFYTzFHL3hPT1FTNyslajcrJWpPN1tRWU8nI0NzT09RTycjRVEnI0VRTzdnUWBPJyNFUE9PUU8nI0VQJyNFUE83clFXTycjRWBPN3pRZE8sNTpqT09RUyw1OmosNTpqTzhWUXRPJyNFXU8ke1FkTycjRV1POVdRZE83KyVUT09RTzcrJVQ3KyVUT09RTzFHMGQxRzBkTzlrUXBPPDxIZE85c1FXTyw1O15PT1FQMUcvWTFHL1lPT1FTLUU4Vi1FOFZPJHtRZE8nI0VaTzl7UVdPLDU7Wk9PUVQxRy51MUcudU9PUVA8PEhkPDxIZE9PUVM3KyRrNyska086VFFkTzcrJV1PT1FPNyslZDcrJWRPT1FPLDU6ayw1OmtPM3tRZE8nI0VhTzdyUVdPLDU6ek9PUVMsNTp6LDU6ek9PUVMtRTheLUU4Xk9PUVMxRzBVMUcwVU86W1F0Tyw1OndPT1FTLUU4Wi1FOFpPT1FPPDxIbzw8SG9PT1FQQU4+T0FOPk9PO11RZE8sNTp1T09RTy1FOFgtRThYT09RTzw8SHc8PEh3T09RTyw1OnssNTp7T09RTy1FOF8tRThfT09RUzFHMGYxRzBmXCIsXG4gIHN0YXRlRGF0YTogXCI7b35PI1pPUyNbUVF+T1VZT1hZT11WT15WT3FYT3hXTyFbYU8hXVpPIWlbTyFrXU8hbV5PIXBfTyF2YE8jWFJPI2JUT35PUWZPVVlPWFlPXVZPXlZPcVhPeFdPIVthTyFdWk8haVtPIWtdTyFtXk8hcF9PIXZgTyNYZU8jYlRPfk8jVSNnUH5QIVpPI1tqT35PI1hsT35PXXFPXnFPcXNPdG9PeHJPIU90TyFSdk8jVnVPI2JuT35PIVR3T35QI3BPYH1PI1d6TyNYeU9+TyNYIU9Pfk8jWCFRT35PUSFbT2IhVE9mIVtPaCFbT24hWU9xIVpPI1chV08jWCFTTyNlIVVPfk9iIV5PIWQhYE8hZyFhTyNYIV1PIVQjaFB+T2ghZk9uIVlPI1ghZU9+T2ghaE8jWCFoT35PYiFeTyFkIWBPIWchYU8jWCFdT35PIVkjaFB+UCVqT11XWF0hV1heV1hxV1h0V1h4V1ghT1dYIVJXWCFUV1gjVldYI2JXWH5PXSFtT35PIVkhbk8jVSNnWCFTI2dYfk8jVSNnWCFTI2dYflAhWk8jXSFxTyNeIXFPI18hc09+T1VZT1hZT11WT15WT3FYT3hXTyNYUk8jYlRPfk90b08hVHdPfk9gIXpPI1d6TyNYeU9+TyFTI2dQflAhWk9iI1JPfk9iI1NPfk9wI1RPfCNVT35PUCNXT2JnWGpnWCFZZ1ghZGdYIWdnWCNYZ1hhZ1hRZ1hmZ1hoZ1huZ1hxZ1h0Z1ghWGdYI1VnWCNXZ1gjZWdYcGdYIVNnWH5PYiFeT2ojWE8hZCFgTyFnIWFPI1ghXU8hWSNoUH5PYiNbT35PcCNgTyNYI11Pfk9iIV5PIWQhYE8hZyFhTyNYI2FPfk90I2VPIWIjZE8hVCNoWCFZI2hYfk9iI2hPfk9qI1hPIVkjak9+TyFZI2tPfk9oI2xPbiFZT35PIVQjbU9+TyFUd08hYiNkT35PIVR3TyFZI3BPfk8hWCNyTyFZIVZhI1UhVmEhUyFWYX5QJHtPIVkjUVgjVSNRWCFTI1FYflAhWk8hWSFuTyNVI2dhIVMjZ2F+TyNdIXFPI14hcU8jXyN4T35PXXFPXnFPcXNPeHJPIU90TyFSdk8jVnVPI2JuT35PdCNPYSFUI09hYSNPYX5QLnBPcCN6T3wje09+T11xT15xT3FzT3hyTyNibk9+T3R9aSFPfWkhUn1pIVR9aSNWfWlhfWl+UC9xT3QhUGkhTyFQaSFSIVBpIVQhUGkjViFQaWEhUGl+UC9xT3QhUWkhTyFRaSFSIVFpIVQhUWkjViFRaWEhUWl+UC9xTyFTI3xPfk9hI2ZQflAoYU9hI2NQflAke09hJFRPaiNYT35PIVkkVk9+T2EkV09oJFhPbyRYT35PcCRaTyNYI11Pfk9dIWBYYSFeWCFiIV5Yfk9dJFtPfk9hJF1PIWIjZE9+T3QjZU8hVCNoYSFZI2hhfk8hYiNkT3QhY2EhVCFjYSFZIWNhYSFjYX5PIVkkYk9+TyFTJGlPI1gkZE8jZSRjT35PaiNYT3Qka08hWCRtTyFZIVZpI1UhVmkhUyFWaX5QJHtPIVkjUWEjVSNRYSFTI1FhflAhWk8hWSFuTyNVI2dpIVMjZ2l+T2EjZlh+UCNwT2EkcU9+T2ojWE9RIXtYYSF7WGIhe1hmIXtYaCF7WG4he1hxIXtYdCF7WCNXIXtYI1ghe1gjZSF7WH5PdCRzT2EjY1h+UCR7T2EkdU9+T2ojWE9wJHZPfk9hJHdPfk8hYiNkT3QjUmEhVCNSYSFZI1Jhfk9hJHlPflAucE9QI1dPdGdYIVRnWH5PI2UkY090IXNYIVQhc1h+T3Qke08hVHdPfk8hUyVQTyNYJGRPI2UkY09+T2ojWE9RI1BYYiNQWGYjUFhoI1BYbiNQWHEjUFh0I1BYIVgjUFghWSNQWCNVI1BYI1cjUFgjWCNQWCNlI1BYIVMjUFh+T3Qka08hWCVTTyFZIVZxI1UhVnEhUyFWcX5QJHtPaiNYT3AlVE9+T3RvT2EjZmF+T3Qkc09hI2Nhfk9hJVdPflAke09qI1hPUSNQYWIjUGFmI1BhaCNQYW4jUGFxI1BhdCNQYSFYI1BhIVkjUGEjVSNQYSNXI1BhI1gjUGEjZSNQYSFTI1Bhfk9hIX1hdCF9YX5QJHtPI1pvI1sjZWohUiNlflwiLFxuICBnb3RvOiBcIi1nI2pQUFAja1AjblAjdyRXUCN3JGcjd1BQJG1QUFAkcyR8JHxQJWBQJHxQJHwleiZeUFBQUCR8JnZQJnonUSN3UCdXI3cnXlAjd1AjdyN3UFBQJ2QneShXUFAjblBQKF8oXyhpKF9QKF9QKF8oX1AjblAjblAjblAobCNuUChvKHIodSh8I25QI25QKVIpWCloKXYpfCpTKl4qZCpuKnQqelBQUFBQUFBQUFArUStaUCt2K3lQLG8scix4LVJSa1FfYk9QZGh3IW4jdGtZT1BkaG90dXZ3IW4jUiNoI3RrU09QZGhvdHV2dyFuI1IjaCN0UW1UUiF0blF7VlIheHFRIXh9USNaIVhSI3khenEhW1pdIVQhbSNTI1UjWCNxI3skUSRbJGskbCRzJHglVXAhW1pdIVQhbSNTI1UjWCNxI3skUSRbJGskbCRzJHglVVUkZiNtJGgke1IkeiRlcSFYWl0hVCFtI1MjVSNYI3EjeyRRJFskayRsJHMkeCVVcCFbWl0hVCFtI1MjVSNYI3EjeyRRJFskayRsJHMkeCVVUSFmXlIjbCFnVCNeIVojX1F8VlIheXFRIXh8UiN5IXlRIVBXUiF7clEhUlhSIXxzUXhVUSF3cFEjaSFjUSNvIWpRI3Aha1EkfSRnUiVaJHxTZ1B3USFwaFEjcyFuUiRuI3RaZlBodyFuI3RhIWJbYGEhViFeIWAjZCNlUiNiIV5SIWdeUiFpX1IjbiFpUyRnI20kaFIlWCR7ViRlI20kaCR7USFyalIjdyFyUWRPU2hQd1UhbGRoI3RSI3QhblEkUSNTVSRyJFEkeCVVUSR4JFtSJVUkc1EjXyFaUiRZI19RJHQkUVIlViR0UXBVUyF2cCRwUiRwI31RJGwjcVIlUiRsUSFvZ1MjdSFvI3ZSI3YhcFEjZiFfUiRgI2ZRJGgjbVIlTyRoUSR8JGdSJVkkfF9jT1BkaHchbiN0XlVPUGRodyFuI3RRIXVvUSF9dFEjT3VRI1B2USN9I1JSJGEjaFIkUiNTUSFWWlEhZF1RI1YhVFEjcSFtWyRQI1MkUSRbJHMkeCVVUSRTI1VRJFUjWFMkaiNxJGxRJG8je1IlUSRrUiRPI1JRaVBSI1F3USFjW1Eha2FSI1khVlUhX1thIVZRIWpgUSNjIV5RI2chYFEkXiNkUiRfI2VcIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBVbml0IFZhcmlhYmxlTmFtZSBDb21tZW50IFN0eWxlU2hlZXQgUnVsZVNldCBVbml2ZXJzYWxTZWxlY3RvciBUYWdTZWxlY3RvciBUYWdOYW1lIE5lc3RpbmdTZWxlY3RvciBDbGFzc1NlbGVjdG9yIENsYXNzTmFtZSBQc2V1ZG9DbGFzc1NlbGVjdG9yIDogOjogUHNldWRvQ2xhc3NOYW1lIFBzZXVkb0NsYXNzTmFtZSApICggQXJnTGlzdCBWYWx1ZU5hbWUgUGFyZW50aGVzaXplZFZhbHVlIENvbG9yTGl0ZXJhbCBOdW1iZXJMaXRlcmFsIFN0cmluZ0xpdGVyYWwgQmluYXJ5RXhwcmVzc2lvbiBCaW5PcCBDYWxsRXhwcmVzc2lvbiBDYWxsZWUgQ2FsbExpdGVyYWwgQ2FsbFRhZyBQYXJlbnRoZXNpemVkQ29udGVudCBdIFsgTGluZU5hbWVzIExpbmVOYW1lICwgUHNldWRvQ2xhc3NOYW1lIEFyZ0xpc3QgSWRTZWxlY3RvciAjIElkTmFtZSBBdHRyaWJ1dGVTZWxlY3RvciBBdHRyaWJ1dGVOYW1lIE1hdGNoT3AgQ2hpbGRTZWxlY3RvciBDaGlsZE9wIERlc2NlbmRhbnRTZWxlY3RvciBTaWJsaW5nU2VsZWN0b3IgU2libGluZ09wIH0geyBCbG9jayBEZWNsYXJhdGlvbiBQcm9wZXJ0eU5hbWUgSW1wb3J0YW50IDsgSW1wb3J0U3RhdGVtZW50IEF0S2V5d29yZCBpbXBvcnQgS2V5d29yZFF1ZXJ5IEZlYXR1cmVRdWVyeSBGZWF0dXJlTmFtZSBCaW5hcnlRdWVyeSBMb2dpY09wIFVuYXJ5UXVlcnkgVW5hcnlRdWVyeU9wIFBhcmVudGhlc2l6ZWRRdWVyeSBTZWxlY3RvclF1ZXJ5IHNlbGVjdG9yIE1lZGlhU3RhdGVtZW50IG1lZGlhIENoYXJzZXRTdGF0ZW1lbnQgY2hhcnNldCBOYW1lc3BhY2VTdGF0ZW1lbnQgbmFtZXNwYWNlIE5hbWVzcGFjZU5hbWUgS2V5ZnJhbWVzU3RhdGVtZW50IGtleWZyYW1lcyBLZXlmcmFtZU5hbWUgS2V5ZnJhbWVMaXN0IEtleWZyYW1lU2VsZWN0b3IgS2V5ZnJhbWVSYW5nZU5hbWUgU3VwcG9ydHNTdGF0ZW1lbnQgc3VwcG9ydHMgQXRSdWxlIFN0eWxlc1wiLFxuICBtYXhUZXJtOiAxMTcsXG4gIG5vZGVQcm9wczogW1xuICAgIFtcImlzb2xhdGVcIiwgLTIsMywyNCxcIlwiXSxcbiAgICBbXCJvcGVuZWRCeVwiLCAxNyxcIihcIiwzMixcIltcIiw1MCxcIntcIl0sXG4gICAgW1wiY2xvc2VkQnlcIiwgMTgsXCIpXCIsMzMsXCJdXCIsNTEsXCJ9XCJdXG4gIF0sXG4gIHByb3BTb3VyY2VzOiBbY3NzSGlnaGxpZ2h0aW5nXSxcbiAgc2tpcHBlZE5vZGVzOiBbMCwzLDg3XSxcbiAgcmVwZWF0Tm9kZUNvdW50OiAxMSxcbiAgdG9rZW5EYXRhOiBcIkpeflIhXk9YJH1YXiV1XnAkfXBxJXVxcilYcnMuUnN0L3V0dTZkdXYkfXZ3N153eDdveHk5Xnl6OW96ezl0e3w6X3x9P1F9IU8/YyFPIVBAUSFQIVFAaSFRIVtBYiFbIV1CXSFdIV5DWCFeIV8kfSFfIWBDaiFgIWFDeyFhIWIkfSFiIWNEdyFjIX0kfSF9I09GYSNPI1AkfSNQI1FGciNRI1I2ZCNSI1QkfSNUI1VHVCNVI2MkfSNjI2RIZiNkI28kfSNvI3BIeyNwI3E2ZCNxI3JJXiNyI3NJbyNzI3kkfSN5I3oldSN6JGYkfSRmJGcldSRnI0JZJH0jQlkjQloldSNCWiRJUyR9JElTJElfJXUkSV8kSXwkfSRJfCRKTyV1JEpPJEpUJH0kSlQkSlUldSRKVSRLViR9JEtWJEtXJXUkS1cmRlUkfSZGVSZGViV1JkZWOydTJH07J1M7PWBKVzwlbE8kfWAlUVNPeSVeejsnUyVeOydTOz1gJW88JWxPJV5gJWNTb2BPeSVeejsnUyVeOydTOz1gJW88JWxPJV5gJXJQOz1gPCVsJV5+JXpoI1p+T1glXlheJ2ZecCVecHEnZnF5JV56I3klXiN5I3onZiN6JGYlXiRmJGcnZiRnI0JZJV4jQlkjQlonZiNCWiRJUyVeJElTJElfJ2YkSV8kSXwlXiRJfCRKTydmJEpPJEpUJV4kSlQkSlUnZiRKVSRLViVeJEtWJEtXJ2YkS1cmRlUlXiZGVSZGVidmJkZWOydTJV47J1M7PWAlbzwlbE8lXn4nbWgjWn5vYE9YJV5YXidmXnAlXnBxJ2ZxeSVeeiN5JV4jeSN6J2YjeiRmJV4kZiRnJ2YkZyNCWSVeI0JZI0JaJ2YjQlokSVMlXiRJUyRJXydmJElfJEl8JV4kSXwkSk8nZiRKTyRKVCVeJEpUJEpVJ2YkSlUkS1YlXiRLViRLVydmJEtXJkZVJV4mRlUmRlYnZiZGVjsnUyVeOydTOz1gJW88JWxPJV5sKVtVT3klXnojXSVeI10jXiluI147J1MlXjsnUzs9YCVvPCVsTyVebClzVW9gT3klXnojYSVeI2EjYipWI2I7J1MlXjsnUzs9YCVvPCVsTyVebCpbVW9gT3klXnojZCVeI2QjZSpuI2U7J1MlXjsnUzs9YCVvPCVsTyVebCpzVW9gT3klXnojYyVeI2MjZCtWI2Q7J1MlXjsnUzs9YCVvPCVsTyVebCtbVW9gT3klXnojZiVeI2YjZytuI2c7J1MlXjsnUzs9YCVvPCVsTyVebCtzVW9gT3klXnojaCVeI2gjaSxWI2k7J1MlXjsnUzs9YCVvPCVsTyVebCxbVW9gT3klXnojVCVeI1QjVSxuI1U7J1MlXjsnUzs9YCVvPCVsTyVebCxzVW9gT3klXnojYiVeI2IjYy1WI2M7J1MlXjsnUzs9YCVvPCVsTyVebC1bVW9gT3klXnojaCVeI2gjaS1uI2k7J1MlXjsnUzs9YCVvPCVsTyVebC11UyFYW29gT3klXno7J1MlXjsnUzs9YCVvPCVsTyVefi5VV09ZLlJaci5ScnMubnMjTy5SI08jUC5zI1A7J1MuUjsnUzs9YC9vPCVsTy5Sfi5zT2h+fi52Uk87J1MuUjsnUzs9YC9QOz1gTy5Sfi9TWE9ZLlJaci5ScnMubnMjTy5SI08jUC5zI1A7J1MuUjsnUzs9YC9vOz1gPCVsLlI8JWxPLlJ+L3JQOz1gPCVsLlJuL3pZeFFPeSVeeiFRJV4hUSFbMGohWyFjJV4hYyFpMGohaSNUJV4jVCNaMGojWjsnUyVeOydTOz1gJW88JWxPJV5sMG9Zb2BPeSVeeiFRJV4hUSFbMV8hWyFjJV4hYyFpMV8haSNUJV4jVCNaMV8jWjsnUyVeOydTOz1gJW88JWxPJV5sMWRZb2BPeSVeeiFRJV4hUSFbMlMhWyFjJV4hYyFpMlMhaSNUJV4jVCNaMlMjWjsnUyVeOydTOz1gJW88JWxPJV5sMlpZZltvYE95JV56IVElXiFRIVsyeSFbIWMlXiFjIWkyeSFpI1QlXiNUI1oyeSNaOydTJV47J1M7PWAlbzwlbE8lXmwzUVlmW29gT3klXnohUSVeIVEhWzNwIVshYyVeIWMhaTNwIWkjVCVeI1QjWjNwI1o7J1MlXjsnUzs9YCVvPCVsTyVebDN1WW9gT3klXnohUSVeIVEhWzRlIVshYyVeIWMhaTRlIWkjVCVeI1QjWjRlI1o7J1MlXjsnUzs9YCVvPCVsTyVebDRsWWZbb2BPeSVeeiFRJV4hUSFbNVshWyFjJV4hYyFpNVshaSNUJV4jVCNaNVsjWjsnUyVeOydTOz1gJW88JWxPJV5sNWFZb2BPeSVeeiFRJV4hUSFbNlAhWyFjJV4hYyFpNlAhaSNUJV4jVCNaNlAjWjsnUyVeOydTOz1gJW88JWxPJV5sNldTZltvYE95JV56OydTJV47J1M7PWAlbzwlbE8lXmQ2Z1VPeSVeeiFfJV4hXyFgNnkhYDsnUyVeOydTOz1gJW88JWxPJV5kN1FTfFNvYE95JV56OydTJV47J1M7PWAlbzwlbE8lXmI3Y1NYUU95JV56OydTJV47J1M7PWAlbzwlbE8lXn43cldPWTdvWnc3b3d4Lm54I083byNPI1A4WyNQOydTN287J1M7PWA5VzwlbE83b344X1JPOydTN287J1M7PWA4aDs9YE83b344a1hPWTdvWnc3b3d4Lm54I083byNPI1A4WyNQOydTN287J1M7PWA5Vzs9YDwlbDdvPCVsTzdvfjlaUDs9YDwlbDdvbjljU2JeT3klXno7J1MlXjsnUzs9YCVvPCVsTyVefjl0T2F+bjl7VVVRaldPeSVeeiFfJV4hXyFgNnkhYDsnUyVeOydTOz1gJW88JWxPJV5uOmZXalchUlFPeSVeeiFPJV4hTyFQO08hUCFRJV4hUSFbPlQhWzsnUyVeOydTOz1gJW88JWxPJV5sO1RVb2BPeSVeeiFRJV4hUSFbO2chWzsnUyVeOydTOz1gJW88JWxPJV5sO25Zb2AjZVtPeSVeeiFRJV4hUSFbO2chWyFnJV4hZyFoPF4haCNYJV4jWCNZPF4jWTsnUyVeOydTOz1gJW88JWxPJV5sPGNZb2BPeSVeenslXnt8PVJ8fSVefSFPPVIhTyFRJV4hUSFbPWohWzsnUyVeOydTOz1gJW88JWxPJV5sPVdVb2BPeSVeeiFRJV4hUSFbPWohWzsnUyVeOydTOz1gJW88JWxPJV5sPXFVb2AjZVtPeSVeeiFRJV4hUSFbPWohWzsnUyVeOydTOz1gJW88JWxPJV5sPltbb2AjZVtPeSVeeiFPJV4hTyFQO2chUCFRJV4hUSFbPlQhWyFnJV4hZyFoPF4haCNYJV4jWCNZPF4jWTsnUyVeOydTOz1gJW88JWxPJV5uP1ZTdF5PeSVeejsnUyVeOydTOz1gJW88JWxPJV5sP2hXaldPeSVeeiFPJV4hTyFQO08hUCFRJV4hUSFbPlQhWzsnUyVeOydTOz1gJW88JWxPJV5uQFZVI2JRT3klXnohUSVeIVEhWztnIVs7J1MlXjsnUzs9YCVvPCVsTyVefkBuVGpXT3klXnp7QH17OydTJV47J1M7PWAlbzwlbE8lXn5BVVNvYCNbfk95JV56OydTJV47J1M7PWAlbzwlbE8lXmxBZ1sjZVtPeSVeeiFPJV4hTyFQO2chUCFRJV4hUSFbPlQhWyFnJV4hZyFoPF4haCNYJV4jWCNZPF4jWTsnUyVeOydTOz1gJW88JWxPJV5iQmJVXVFPeSVeeiFbJV4hWyFdQnQhXTsnUyVeOydTOz1gJW88JWxPJV5iQntTXlFvYE95JV56OydTJV47J1M7PWAlbzwlbE8lXm5DXlMhWV5PeSVeejsnUyVeOydTOz1gJW88JWxPJV5kQ29TfFNPeSVeejsnUyVeOydTOz1gJW88JWxPJV5iRFFVIU9RT3klXnohYCVeIWAhYURkIWE7J1MlXjsnUzs9YCVvPCVsTyVeYkRrUyFPUW9gT3klXno7J1MlXjsnUzs9YCVvPCVsTyVeYkR6V095JV56IWMlXiFjIX1FZCF9I1QlXiNUI29FZCNvOydTJV47J1M7PWAlbzwlbE8lXmJFa1shW1FvYE95JV56fSVefSFPRWQhTyFRJV4hUSFbRWQhWyFjJV4hYyF9RWQhfSNUJV4jVCNvRWQjbzsnUyVeOydTOz1gJW88JWxPJV5uRmZTcV5PeSVeejsnUyVeOydTOz1gJW88JWxPJV5uRndTcF5PeSVeejsnUyVeOydTOz1gJW88JWxPJV5iR1dVT3klXnojYiVeI2IjY0dqI2M7J1MlXjsnUzs9YCVvPCVsTyVeYkdvVW9gT3klXnojVyVeI1cjWEhSI1g7J1MlXjsnUzs9YCVvPCVsTyVeYkhZUyFiUW9gT3klXno7J1MlXjsnUzs9YCVvPCVsTyVeYkhpVU95JV56I2YlXiNmI2dIUiNnOydTJV47J1M7PWAlbzwlbE8lXmZJUVMhVFVPeSVeejsnUyVeOydTOz1gJW88JWxPJV5uSWNTIVNeT3klXno7J1MlXjsnUzs9YCVvPCVsTyVeZkl0VSFSUU95JV56IV8lXiFfIWA2eSFgOydTJV47J1M7PWAlbzwlbE8lXmBKWlA7PWA8JWwkfVwiLFxuICB0b2tlbml6ZXJzOiBbZGVzY2VuZGFudCwgdW5pdFRva2VuLCBpZGVudGlmaWVycywgMSwgMiwgMywgNCwgbmV3IGxyLkxvY2FsVG9rZW5Hcm91cChcIm1+UlJZWlt6e2F+fmd+YU8jXn5+ZFAhUCFRZ35sTyNffn5cIiwgMjgsIDEwNSldLFxuICB0b3BSdWxlczoge1wiU3R5bGVTaGVldFwiOlswLDRdLFwiU3R5bGVzXCI6WzEsODZdfSxcbiAgc3BlY2lhbGl6ZWQ6IFt7dGVybTogMTAwLCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY19jYWxsZWVbdmFsdWVdIHx8IC0xfSx7dGVybTogNTgsIGdldDogKHZhbHVlKSA9PiBzcGVjX0F0S2V5d29yZFt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiAxMDEsIGdldDogKHZhbHVlKSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogMTIxOVxufSk7XG5cbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnQGxlemVyL2NvbW1vbicpO1xuXG5sZXQgbmV4dFRhZ0lEID0gMDtcbi8qKlxuSGlnaGxpZ2h0aW5nIHRhZ3MgYXJlIG1hcmtlcnMgdGhhdCBkZW5vdGUgYSBoaWdobGlnaHRpbmcgY2F0ZWdvcnkuXG5UaGV5IGFyZSBbYXNzb2NpYXRlZF0oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpIHdpdGggcGFydHMgb2YgYSBzeW50YXhcbnRyZWUgYnkgYSBsYW5ndWFnZSBtb2RlLCBhbmQgdGhlbiBtYXBwZWQgdG8gYW4gYWN0dWFsIENTUyBzdHlsZSBieVxuYSBbaGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLlxuXG5CZWNhdXNlIHN5bnRheCB0cmVlIG5vZGUgdHlwZXMgYW5kIGhpZ2hsaWdodCBzdHlsZXMgaGF2ZSB0byBiZVxuYWJsZSB0byB0YWxrIHRoZSBzYW1lIGxhbmd1YWdlLCBDb2RlTWlycm9yIHVzZXMgYSBtb3N0bHkgX2Nsb3NlZF9cblt2b2NhYnVsYXJ5XSgjaGlnaGxpZ2h0LnRhZ3MpIG9mIHN5bnRheCB0YWdzIChhcyBvcHBvc2VkIHRvXG50cmFkaXRpb25hbCBvcGVuIHN0cmluZy1iYXNlZCBzeXN0ZW1zLCB3aGljaCBtYWtlIGl0IGhhcmQgZm9yXG5oaWdobGlnaHRpbmcgdGhlbWVzIHRvIGNvdmVyIGFsbCB0aGUgdG9rZW5zIHByb2R1Y2VkIGJ5IHRoZVxudmFyaW91cyBsYW5ndWFnZXMpLlxuXG5JdCBfaXNfIHBvc3NpYmxlIHRvIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgeW91ciBvd25cbmhpZ2hsaWdodGluZyB0YWdzIGZvciBzeXN0ZW0taW50ZXJuYWwgdXNlICh3aGVyZSB5b3UgY29udHJvbCBib3RoXG50aGUgbGFuZ3VhZ2UgcGFja2FnZSBhbmQgdGhlIGhpZ2hsaWdodGVyKSwgYnV0IHN1Y2ggdGFncyB3aWxsIG5vdFxuYmUgcGlja2VkIHVwIGJ5IHJlZ3VsYXIgaGlnaGxpZ2h0ZXJzICh0aG91Z2ggeW91IGNhbiBkZXJpdmUgdGhlbVxuZnJvbSBzdGFuZGFyZCB0YWdzIHRvIGFsbG93IGhpZ2hsaWdodGVycyB0byBmYWxsIGJhY2sgdG8gdGhvc2UpLlxuKi9cbmNsYXNzIFRhZyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgb3B0aW9uYWwgbmFtZSBvZiB0aGUgYmFzZSB0YWcgQGludGVybmFsXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBUaGUgc2V0IG9mIHRoaXMgdGFnIGFuZCBhbGwgaXRzIHBhcmVudCB0YWdzLCBzdGFydGluZyB3aXRoXG4gICAgdGhpcyBvbmUgaXRzZWxmIGFuZCBzb3J0ZWQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZyBzcGVjaWZpY2l0eS5cbiAgICAqL1xuICAgIHNldCwgXG4gICAgLyoqXG4gICAgVGhlIGJhc2UgdW5tb2RpZmllZCB0YWcgdGhhdCB0aGlzIG9uZSBpcyBiYXNlZCBvbiwgaWYgaXQnc1xuICAgIG1vZGlmaWVkIEBpbnRlcm5hbFxuICAgICovXG4gICAgYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIG1vZGlmaWVycyBhcHBsaWVkIHRvIHRoaXMuYmFzZSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1vZGlmaWVkKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLm1vZGlmaWVkID0gbW9kaWZpZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRUYWdJRCsrO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHsgbmFtZSB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgbW9kIG9mIHRoaXMubW9kaWZpZWQpXG4gICAgICAgICAgICBpZiAobW9kLm5hbWUpXG4gICAgICAgICAgICAgICAgbmFtZSA9IGAke21vZC5uYW1lfSgke25hbWV9KWA7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmaW5lKG5hbWVPclBhcmVudCwgcGFyZW50KSB7XG4gICAgICAgIGxldCBuYW1lID0gdHlwZW9mIG5hbWVPclBhcmVudCA9PSBcInN0cmluZ1wiID8gbmFtZU9yUGFyZW50IDogXCI/XCI7XG4gICAgICAgIGlmIChuYW1lT3JQYXJlbnQgaW5zdGFuY2VvZiBUYWcpXG4gICAgICAgICAgICBwYXJlbnQgPSBuYW1lT3JQYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuYmFzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGVyaXZlIGZyb20gYSBtb2RpZmllZCB0YWdcIik7XG4gICAgICAgIGxldCB0YWcgPSBuZXcgVGFnKG5hbWUsIFtdLCBudWxsLCBbXSk7XG4gICAgICAgIHRhZy5zZXQucHVzaCh0YWcpO1xuICAgICAgICBpZiAocGFyZW50KVxuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiBwYXJlbnQuc2V0KVxuICAgICAgICAgICAgICAgIHRhZy5zZXQucHVzaCh0KTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgdGFnIF9tb2RpZmllcl8sIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSB0YWcsXG4gICAgd2lsbCByZXR1cm4gYSB0YWcgdGhhdCBpcyBhIHN1YnRhZyBvZiB0aGUgb3JpZ2luYWwuIEFwcGx5aW5nIHRoZVxuICAgIHNhbWUgbW9kaWZpZXIgdG8gYSB0d2ljZSB0YWcgd2lsbCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgKGBtMSh0MSlcbiAgICA9PSBtMSh0MSlgKSBhbmQgYXBwbHlpbmcgbXVsdGlwbGUgbW9kaWZpZXJzIHdpbGwsIHJlZ2FyZGxlc3Mgb3JcbiAgICBvcmRlciwgcHJvZHVjZSB0aGUgc2FtZSB0YWcgKGBtMShtMih0MSkpID09IG0yKG0xKHQxKSlgKS5cbiAgICBcbiAgICBXaGVuIG11bHRpcGxlIG1vZGlmaWVycyBhcmUgYXBwbGllZCB0byBhIGdpdmVuIGJhc2UgdGFnLCBlYWNoXG4gICAgc21hbGxlciBzZXQgb2YgbW9kaWZpZXJzIGlzIHJlZ2lzdGVyZWQgYXMgYSBwYXJlbnQsIHNvIHRoYXQgZm9yXG4gICAgZXhhbXBsZSBgbTEobTIobTModDEpKSlgIGlzIGEgc3VidHlwZSBvZiBgbTEobTIodDEpKWAsXG4gICAgYG0xKG0zKHQxKWAsIGFuZCBzbyBvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmVNb2RpZmllcihuYW1lKSB7XG4gICAgICAgIGxldCBtb2QgPSBuZXcgTW9kaWZpZXIobmFtZSk7XG4gICAgICAgIHJldHVybiAodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFnLm1vZGlmaWVkLmluZGV4T2YobW9kKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuZ2V0KHRhZy5iYXNlIHx8IHRhZywgdGFnLm1vZGlmaWVkLmNvbmNhdChtb2QpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxubGV0IG5leHRNb2RpZmllcklEID0gMDtcbmNsYXNzIE1vZGlmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gW107XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0TW9kaWZpZXJJRCsrO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KGJhc2UsIG1vZHMpIHtcbiAgICAgICAgaWYgKCFtb2RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICBsZXQgZXhpc3RzID0gbW9kc1swXS5pbnN0YW5jZXMuZmluZCh0ID0+IHQuYmFzZSA9PSBiYXNlICYmIHNhbWVBcnJheShtb2RzLCB0Lm1vZGlmaWVkKSk7XG4gICAgICAgIGlmIChleGlzdHMpXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgICAgICBsZXQgc2V0ID0gW10sIHRhZyA9IG5ldyBUYWcoYmFzZS5uYW1lLCBzZXQsIGJhc2UsIG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBtIG9mIG1vZHMpXG4gICAgICAgICAgICBtLmluc3RhbmNlcy5wdXNoKHRhZyk7XG4gICAgICAgIGxldCBjb25maWdzID0gcG93ZXJTZXQobW9kcyk7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCBvZiBiYXNlLnNldClcbiAgICAgICAgICAgIGlmICghcGFyZW50Lm1vZGlmaWVkLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2goTW9kaWZpZXIuZ2V0KHBhcmVudCwgY29uZmlnKSk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoeCwgaSkgPT4geCA9PSBiW2ldKTtcbn1cbmZ1bmN0aW9uIHBvd2VyU2V0KGFycmF5KSB7XG4gICAgbGV0IHNldHMgPSBbW11dO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGUgPSBzZXRzLmxlbmd0aDsgaiA8IGU7IGorKykge1xuICAgICAgICAgICAgc2V0cy5wdXNoKHNldHNbal0uY29uY2F0KGFycmF5W2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldHMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XG59XG4vKipcblRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxudmlhIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuTFJQYXJzZXIuY29uZmlndXJlKS5cblxuVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbnRhZ3NdKCNoaWdobGlnaHQuVGFnKSBvciBhcnJheXMgb2YgdGFncy5cblxuTm9kZSBzZWxlY3RvcnMgbWF5IGhvbGQgb25lIG9yIG1vcmUgKHNwYWNlLXNlcGFyYXRlZCkgbm9kZSBwYXRocy5cblN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG5tdWx0aXBsZSBub2RlIG5hbWVzIChvciBgKmAgd2lsZGNhcmRzKSBzZXBhcmF0ZWQgYnkgc2xhc2hcbmNoYXJhY3RlcnMsIGFzIGluIGBcIkJsb2NrL0RlY2xhcmF0aW9uL1ZhcmlhYmxlTmFtZVwiYC4gU3VjaCBhIHBhdGhcbm1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxub3RoZXIgbm9kZXMgbWVudGlvbmVkLiBBIGAqYCBpbiBzdWNoIGEgcGF0aCBtYXRjaGVzIGFueSBwYXJlbnQsXG5idXQgb25seSBhIHNpbmdsZSBsZXZlbOKAlHdpbGRjYXJkcyB0aGF0IG1hdGNoIG11bHRpcGxlIHBhcmVudHNcbmFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxudHJlZXMgbWFrZSBpdCByYXRoZXIgaGFyZCB0byByZWFzb24gYWJvdXQgd2hhdCB0aGV5IHdvdWxkIG1hdGNoLilcblxuQSBwYXRoIGNhbiBiZSBlbmRlZCB3aXRoIGAvLi4uYCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0YWcgYXNzaWduZWRcbnRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG5tYXRjaCB0aGVpciBvd24gc3R5bGUgKGJ5IGRlZmF1bHQsIG9ubHkgdGhlIGlubmVybW9zdCBzdHlsZSBpc1xudXNlZCkuXG5cbldoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbmhhcHBlbnMgZm9yIHRoZSBub2RlJ3MgY2hpbGQgbm9kZXMsIGFuZCB0aGUgZW50aXJlIG5vZGUgZ2V0cyB0aGVcbmdpdmVuIHN0eWxlLlxuXG5JbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxubXVzdCBiZSBxdW90ZWQgYXMgSlNPTiBzdHJpbmdzLlxuXG5Gb3IgZXhhbXBsZTpcblxuYGBgamF2YXNjcmlwdFxucGFyc2VyLndpdGhQcm9wcyhcbiAgc3R5bGVUYWdzKHtcbiAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuICAgIFwiTnVtYmVyIEJpZ051bWJlclwiOiB0YWdzLm51bWJlcixcbiAgICAvLyBTdHlsZSBFc2NhcGUgbm9kZXMgd2hvc2UgcGFyZW50IGlzIFN0cmluZ1xuICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbiAgICAvLyBTdHlsZSBhbnl0aGluZyBpbnNpZGUgQXR0cmlidXRlcyBub2Rlc1xuICAgIFwiQXR0cmlidXRlcyFcIjogdGFncy5tZXRhLFxuICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbiAgICBcIkl0YWxpYy8uLi5cIjogdGFncy5lbXBoYXNpcyxcbiAgICAvLyBTdHlsZSBJbnZhbGlkU3RyaW5nIG5vZGVzIGFzIGJvdGggYHN0cmluZ2AgYW5kIGBpbnZhbGlkYFxuICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4gICAgLy8gU3R5bGUgdGhlIG5vZGUgbmFtZWQgXCIvXCIgYXMgcHVuY3R1YXRpb25cbiAgICAnXCIvXCInOiB0YWdzLnB1bmN0dWF0aW9uXG4gIH0pXG4pXG5gYGBcbiovXG5mdW5jdGlvbiBzdHlsZVRhZ3Moc3BlYykge1xuICAgIGxldCBieU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdGFncyA9IHNwZWNbcHJvcF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbdGFnc107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZXMgPSBbXSwgbW9kZSA9IDIgLyogTW9kZS5Ob3JtYWwgKi8sIHJlc3QgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCA9PSBcIi4uLlwiICYmIHBvcyA+IDAgJiYgcG9zICsgMyA9PSBwYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDEgLyogTW9kZS5Jbmhlcml0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAvXlwiKD86W15cIlxcXFxdfFxcXFwuKSo/XCJ8W15cXC8hXSsvLmV4ZWMocmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChtWzBdID09IFwiKlwiID8gXCJcIiA6IG1bMF1bMF0gPT0gJ1wiJyA/IEpTT04ucGFyc2UobVswXSkgOiBtWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydFtwb3MrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGggJiYgbmV4dCA9PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDAgLyogTW9kZS5PcGFxdWUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFydC5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IHBpZWNlcy5sZW5ndGggLSAxLCBpbm5lciA9IHBpZWNlc1tsYXN0XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IG5ldyBSdWxlKHRhZ3MsIG1vZGUsIGxhc3QgPiAwID8gcGllY2VzLnNsaWNlKDAsIGxhc3QpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgYnlOYW1lW2lubmVyXSA9IHJ1bGUuc29ydChieU5hbWVbaW5uZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVOb2RlUHJvcC5hZGQoYnlOYW1lKTtcbn1cbmNvbnN0IHJ1bGVOb2RlUHJvcCA9IG5ldyBjb21tb24uTm9kZVByb3AoKTtcbmNsYXNzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZ3MsIG1vZGUsIGNvbnRleHQsIG5leHQpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG4gICAgZ2V0IG9wYXF1ZSgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAwIC8qIE1vZGUuT3BhcXVlICovOyB9XG4gICAgZ2V0IGluaGVyaXQoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi87IH1cbiAgICBzb3J0KG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIgfHwgb3RoZXIuZGVwdGggPCB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBvdGhlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyLm5leHQgPSB0aGlzLnNvcnQob3RoZXIubmV4dCk7XG4gICAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0Lmxlbmd0aCA6IDA7IH1cbn1cblJ1bGUuZW1wdHkgPSBuZXcgUnVsZShbXSwgMiAvKiBNb2RlLk5vcm1hbCAqLywgbnVsbCk7XG4vKipcbkRlZmluZSBhIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikgZnJvbSBhbiBhcnJheSBvZlxudGFnL2NsYXNzIHBhaXJzLiBDbGFzc2VzIGFzc29jaWF0ZWQgd2l0aCBtb3JlIHNwZWNpZmljIHRhZ3Mgd2lsbFxudGFrZSBwcmVjZWRlbmNlLlxuKi9cbmZ1bmN0aW9uIHRhZ0hpZ2hsaWdodGVyKHRhZ3MsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBzdHlsZSBvZiB0YWdzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS50YWcpKVxuICAgICAgICAgICAgbWFwW3N0eWxlLnRhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHN0eWxlLnRhZylcbiAgICAgICAgICAgICAgICBtYXBbdGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgIH1cbiAgICBsZXQgeyBzY29wZSwgYWxsID0gbnVsbCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogKHRhZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBhbGw7XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiB0YWcuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWdDbGFzcyA9IG1hcFtzdWIuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9IGNscyA/IGNscyArIFwiIFwiICsgdGFnQ2xhc3MgOiB0YWdDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfSxcbiAgICAgICAgc2NvcGVcbiAgICB9O1xufVxuZnVuY3Rpb24gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHRhZ3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgdmFsdWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuSGlnaGxpZ2h0IHRoZSBnaXZlbiBbdHJlZV0oI2NvbW1vbi5UcmVlKSB3aXRoIHRoZSBnaXZlblxuW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS4gT2Z0ZW4sIHRoZSBoaWdoZXItbGV2ZWxcbltgaGlnaGxpZ2h0Q29kZWBdKCNoaWdobGlnaHQuaGlnaGxpZ2h0Q29kZSkgZnVuY3Rpb24gaXMgZWFzaWVyIHRvXG51c2UuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgXG4vKipcbkFzc2lnbiBzdHlsaW5nIHRvIGEgcmVnaW9uIG9mIHRoZSB0ZXh0LiBXaWxsIGJlIGNhbGxlZCwgaW4gb3JkZXJcbm9mIHBvc2l0aW9uLCBmb3IgYW55IHJhbmdlcyB3aGVyZSBtb3JlIHRoYW4gemVybyBjbGFzc2VzIGFwcGx5LlxuYGNsYXNzZXNgIGlzIGEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBDU1MgY2xhc3Nlcy5cbiovXG5wdXRTdHlsZSwgXG4vKipcblRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gaGlnaGxpZ2h0LlxuKi9cbmZyb20gPSAwLCBcbi8qKlxuVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4qL1xudG8gPSB0cmVlLmxlbmd0aCkge1xuICAgIGxldCBidWlsZGVyID0gbmV3IEhpZ2hsaWdodEJ1aWxkZXIoZnJvbSwgQXJyYXkuaXNBcnJheShoaWdobGlnaHRlcikgPyBoaWdobGlnaHRlciA6IFtoaWdobGlnaHRlcl0sIHB1dFN0eWxlKTtcbiAgICBidWlsZGVyLmhpZ2hsaWdodFJhbmdlKHRyZWUuY3Vyc29yKCksIGZyb20sIHRvLCBcIlwiLCBidWlsZGVyLmhpZ2hsaWdodGVycyk7XG4gICAgYnVpbGRlci5mbHVzaCh0byk7XG59XG4vKipcbkhpZ2hsaWdodCB0aGUgZ2l2ZW4gdHJlZSB3aXRoIHRoZSBnaXZlbiBoaWdobGlnaHRlciwgY2FsbGluZ1xuYHB1dFRleHRgIGZvciBldmVyeSBwaWVjZSBvZiB0ZXh0LCBlaXRoZXIgd2l0aCBhIHNldCBvZiBjbGFzc2VzIG9yXG53aXRoIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiB1bnN0eWxlZCwgYW5kIGBwdXRCcmVha2AgZm9yIGV2ZXJ5IGxpbmVcbmJyZWFrLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodENvZGUoY29kZSwgdHJlZSwgaGlnaGxpZ2h0ZXIsIHB1dFRleHQsIHB1dEJyZWFrLCBmcm9tID0gMCwgdG8gPSBjb2RlLmxlbmd0aCkge1xuICAgIGxldCBwb3MgPSBmcm9tO1xuICAgIGZ1bmN0aW9uIHdyaXRlVG8ocCwgY2xhc3Nlcykge1xuICAgICAgICBpZiAocCA8PSBwb3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IHRleHQgPSBjb2RlLnNsaWNlKHBvcywgcCksIGkgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QnJlYWsgPSB0ZXh0LmluZGV4T2YoXCJcXG5cIiwgaSk7XG4gICAgICAgICAgICBsZXQgdXB0byA9IG5leHRCcmVhayA8IDAgPyB0ZXh0Lmxlbmd0aCA6IG5leHRCcmVhaztcbiAgICAgICAgICAgIGlmICh1cHRvID4gaSlcbiAgICAgICAgICAgICAgICBwdXRUZXh0KHRleHQuc2xpY2UoaSwgdXB0byksIGNsYXNzZXMpO1xuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwdXRCcmVhaygpO1xuICAgICAgICAgICAgaSA9IG5leHRCcmVhayArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gcDtcbiAgICB9XG4gICAgaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgKGZyb20sIHRvLCBjbGFzc2VzKSA9PiB7XG4gICAgICAgIHdyaXRlVG8oZnJvbSwgXCJcIik7XG4gICAgICAgIHdyaXRlVG8odG8sIGNsYXNzZXMpO1xuICAgIH0sIGZyb20sIHRvKTtcbiAgICB3cml0ZVRvKHRvLCBcIlwiKTtcbn1cbmNsYXNzIEhpZ2hsaWdodEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGF0LCBoaWdobGlnaHRlcnMsIHNwYW4pIHtcbiAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVycyA9IGhpZ2hsaWdodGVycztcbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IFwiXCI7XG4gICAgfVxuICAgIHN0YXJ0U3BhbihhdCwgY2xzKSB7XG4gICAgICAgIGlmIChjbHMgIT0gdGhpcy5jbGFzcykge1xuICAgICAgICAgICAgdGhpcy5mbHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQgPiB0aGlzLmF0KVxuICAgICAgICAgICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgICAgIHRoaXMuY2xhc3MgPSBjbHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2godG8pIHtcbiAgICAgICAgaWYgKHRvID4gdGhpcy5hdCAmJiB0aGlzLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5zcGFuKHRoaXMuYXQsIHRvLCB0aGlzLmNsYXNzKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgeyB0eXBlLCBmcm9tOiBzdGFydCwgdG86IGVuZCB9ID0gY3Vyc29yO1xuICAgICAgICBpZiAoc3RhcnQgPj0gdG8gfHwgZW5kIDw9IGZyb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlLmlzVG9wKVxuICAgICAgICAgICAgaGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZSh0eXBlKSk7XG4gICAgICAgIGxldCBjbHMgPSBpbmhlcml0ZWRDbGFzcztcbiAgICAgICAgbGV0IHJ1bGUgPSBnZXRTdHlsZVRhZ3MoY3Vyc29yKSB8fCBSdWxlLmVtcHR5O1xuICAgICAgICBsZXQgdGFnQ2xzID0gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHJ1bGUudGFncyk7XG4gICAgICAgIGlmICh0YWdDbHMpIHtcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiO1xuICAgICAgICAgICAgY2xzICs9IHRhZ0NscztcbiAgICAgICAgICAgIGlmIChydWxlLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi8pXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkQ2xhc3MgKz0gKGluaGVyaXRlZENsYXNzID8gXCIgXCIgOiBcIlwiKSArIHRhZ0NscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1heChmcm9tLCBzdGFydCksIGNscyk7XG4gICAgICAgIGlmIChydWxlLm9wYXF1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBjdXJzb3IudHJlZSAmJiBjdXJzb3IudHJlZS5wcm9wKGNvbW1vbi5Ob2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBjdXJzb3Iubm9kZS5lbnRlcihtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHN0YXJ0LCAxKTtcbiAgICAgICAgICAgIGxldCBpbm5lckhpZ2hsaWdodGVycyA9IHRoaXMuaGlnaGxpZ2h0ZXJzLmZpbHRlcihoID0+ICFoLnNjb3BlIHx8IGguc2NvcGUobW91bnRlZC50cmVlLnR5cGUpKTtcbiAgICAgICAgICAgIGxldCBoYXNDaGlsZCA9IGN1cnNvci5maXJzdENoaWxkKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gc3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGkgPCBtb3VudGVkLm92ZXJsYXkubGVuZ3RoID8gbW91bnRlZC5vdmVybGF5W2ldIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHQgPyBuZXh0LmZyb20gKyBzdGFydCA6IGVuZDtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKSwgcmFuZ2VUbyA9IE1hdGgubWluKHRvLCBuZXh0UG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VGcm9tIDwgcmFuZ2VUbyAmJiBoYXNDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLmZyb20gPCByYW5nZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGN1cnNvciwgcmFuZ2VGcm9tLCByYW5nZVRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHJhbmdlVG8sIGN1cnNvci50byksIGNscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IG5leHRQb3MgfHwgIWN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbmV4dCB8fCBuZXh0UG9zID4gdG8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IG5leHQudG8gKyBzdGFydDtcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGlubmVyLmN1cnNvcigpLCBNYXRoLm1heChmcm9tLCBuZXh0LmZyb20gKyBzdGFydCksIE1hdGgubWluKHRvLCBwb3MpLCBcIlwiLCBpbm5lckhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBwb3MpLCBjbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNDaGlsZClcbiAgICAgICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgaWYgKG1vdW50ZWQpXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkQ2xhc3MgPSBcIlwiO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPD0gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5mcm9tID49IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGN1cnNvciwgZnJvbSwgdG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgfSB3aGlsZSAoY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5NYXRjaCBhIHN5bnRheCBub2RlJ3MgW2hpZ2hsaWdodCBydWxlc10oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpLiBJZlxudGhlcmUncyBhIG1hdGNoLCByZXR1cm4gaXRzIHNldCBvZiB0YWdzLCBhbmQgd2hldGhlciBpdCBpc1xub3BhcXVlICh1c2VzIGEgYCFgKSBvciBhcHBsaWVzIHRvIGFsbCBjaGlsZCBub2RlcyAoYC8uLi5gKS5cbiovXG5mdW5jdGlvbiBnZXRTdHlsZVRhZ3Mobm9kZSkge1xuICAgIGxldCBydWxlID0gbm9kZS50eXBlLnByb3AocnVsZU5vZGVQcm9wKTtcbiAgICB3aGlsZSAocnVsZSAmJiBydWxlLmNvbnRleHQgJiYgIW5vZGUubWF0Y2hDb250ZXh0KHJ1bGUuY29udGV4dCkpXG4gICAgICAgIHJ1bGUgPSBydWxlLm5leHQ7XG4gICAgcmV0dXJuIHJ1bGUgfHwgbnVsbDtcbn1cbmNvbnN0IHQgPSBUYWcuZGVmaW5lO1xuY29uc3QgY29tbWVudCA9IHQoKSwgbmFtZSA9IHQoKSwgdHlwZU5hbWUgPSB0KG5hbWUpLCBwcm9wZXJ0eU5hbWUgPSB0KG5hbWUpLCBsaXRlcmFsID0gdCgpLCBzdHJpbmcgPSB0KGxpdGVyYWwpLCBudW1iZXIgPSB0KGxpdGVyYWwpLCBjb250ZW50ID0gdCgpLCBoZWFkaW5nID0gdChjb250ZW50KSwga2V5d29yZCA9IHQoKSwgb3BlcmF0b3IgPSB0KCksIHB1bmN0dWF0aW9uID0gdCgpLCBicmFja2V0ID0gdChwdW5jdHVhdGlvbiksIG1ldGEgPSB0KCk7XG4vKipcblRoZSBkZWZhdWx0IHNldCBvZiBoaWdobGlnaHRpbmcgW3RhZ3NdKCNoaWdobGlnaHQuVGFnKS5cblxuVGhpcyBjb2xsZWN0aW9uIGlzIGhlYXZpbHkgYmlhc2VkIHRvd2FyZHMgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzLFxuYW5kIG5lY2Vzc2FyaWx5IGluY29tcGxldGUuIEEgZnVsbCBvbnRvbG9neSBvZiBzeW50YWN0aWNcbmNvbnN0cnVjdHMgd291bGQgZmlsbCBhIHN0YWNrIG9mIGJvb2tzLCBhbmQgYmUgaW1wcmFjdGljYWwgdG9cbndyaXRlIHRoZW1lcyBmb3IuIFNvIHRyeSB0byBtYWtlIGRvIHdpdGggdGhpcyBzZXQuIElmIGFsbCBlbHNlXG5mYWlscywgW29wZW4gYW5cbmlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9jb2RlbWlycm9yLm5leHQpIHRvIHByb3Bvc2UgYVxubmV3IHRhZywgb3IgW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSBhIGxvY2FsIGN1c3RvbSB0YWcgZm9yXG55b3VyIHVzZSBjYXNlLlxuXG5Ob3RlIHRoYXQgaXQgaXMgbm90IG9ibGlnYXRvcnkgdG8gYWx3YXlzIGF0dGFjaCB0aGUgbW9zdCBzcGVjaWZpY1xudGFnIHBvc3NpYmxlIHRvIGFuIGVsZW1lbnTigJRpZiB5b3VyIGdyYW1tYXIgY2FuJ3QgZWFzaWx5XG5kaXN0aW5ndWlzaCBhIGNlcnRhaW4gdHlwZSBvZiBlbGVtZW50IChzdWNoIGFzIGEgbG9jYWwgdmFyaWFibGUpLFxuaXQgaXMgb2theSB0byBzdHlsZSBpdCBhcyBpdHMgbW9yZSBnZW5lcmFsIHZhcmlhbnQgKGEgdmFyaWFibGUpLlxuXG5Gb3IgdGFncyB0aGF0IGV4dGVuZCBzb21lIHBhcmVudCB0YWcsIHRoZSBkb2N1bWVudGF0aW9uIGxpbmtzIHRvXG50aGUgcGFyZW50LlxuKi9cbmNvbnN0IHRhZ3MgPSB7XG4gICAgLyoqXG4gICAgQSBjb21tZW50LlxuICAgICovXG4gICAgY29tbWVudCxcbiAgICAvKipcbiAgICBBIGxpbmUgW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICAqL1xuICAgIGxpbmVDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEEgYmxvY2sgW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICAqL1xuICAgIGJsb2NrQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBIGRvY3VtZW50YXRpb24gW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICAqL1xuICAgIGRvY0NvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQW55IGtpbmQgb2YgaWRlbnRpZmllci5cbiAgICAqL1xuICAgIG5hbWUsXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSB2YXJpYWJsZS5cbiAgICAqL1xuICAgIHZhcmlhYmxlTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIHR5cGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIHR5cGVOYW1lOiB0eXBlTmFtZSxcbiAgICAvKipcbiAgICBBIHRhZyBuYW1lIChzdWJ0YWcgb2YgW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSkpLlxuICAgICovXG4gICAgdGFnTmFtZTogdCh0eXBlTmFtZSksXG4gICAgLyoqXG4gICAgQSBwcm9wZXJ0eSBvciBmaWVsZCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgLyoqXG4gICAgQW4gYXR0cmlidXRlIG5hbWUgKHN1YnRhZyBvZiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpKS5cbiAgICAqL1xuICAgIGF0dHJpYnV0ZU5hbWU6IHQocHJvcGVydHlOYW1lKSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIGNsYXNzLlxuICAgICovXG4gICAgY2xhc3NOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbGFiZWwgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIGxhYmVsTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIG5hbWVzcGFjZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgbmFtZXNwYWNlOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgbWFjcm8uXG4gICAgKi9cbiAgICBtYWNyb05hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBsaXRlcmFsIHZhbHVlLlxuICAgICovXG4gICAgbGl0ZXJhbCxcbiAgICAvKipcbiAgICBBIHN0cmluZyBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgc3RyaW5nLFxuICAgIC8qKlxuICAgIEEgZG9jdW1lbnRhdGlvbiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKS5cbiAgICAqL1xuICAgIGRvY1N0cmluZzogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEEgY2hhcmFjdGVyIGxpdGVyYWwgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXG4gICAgKi9cbiAgICBjaGFyYWN0ZXI6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBbiBhdHRyaWJ1dGUgdmFsdWUgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXG4gICAgKi9cbiAgICBhdHRyaWJ1dGVWYWx1ZTogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEEgbnVtYmVyIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBudW1iZXIsXG4gICAgLyoqXG4gICAgQW4gaW50ZWdlciBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgICovXG4gICAgaW50ZWdlcjogdChudW1iZXIpLFxuICAgIC8qKlxuICAgIEEgZmxvYXRpbmctcG9pbnQgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICAqL1xuICAgIGZsb2F0OiB0KG51bWJlciksXG4gICAgLyoqXG4gICAgQSBib29sZWFuIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBib29sOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIFJlZ3VsYXIgZXhwcmVzc2lvbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgcmVnZXhwOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEFuIGVzY2FwZSBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLCBmb3IgZXhhbXBsZSBhXG4gICAgYmFja3NsYXNoIGVzY2FwZSBpbiBhIHN0cmluZy5cbiAgICAqL1xuICAgIGVzY2FwZTogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIGNvbG9yIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBjb2xvcjogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIFVSTCBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgdXJsOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgbGFuZ3VhZ2Uga2V5d29yZC5cbiAgICAqL1xuICAgIGtleXdvcmQsXG4gICAgLyoqXG4gICAgVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIHRoZSBzZWxmIG9yIHRoaXNcbiAgICBvYmplY3QuXG4gICAgKi9cbiAgICBzZWxmOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciBudWxsLlxuICAgICovXG4gICAgbnVsbDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZGVub3Rpbmcgc29tZSBhdG9taWMgdmFsdWUuXG4gICAgKi9cbiAgICBhdG9tOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IHJlcHJlc2VudHMgYSB1bml0LlxuICAgICovXG4gICAgdW5pdDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIG1vZGlmaWVyIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgKi9cbiAgICBtb2RpZmllcjogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBhY3RzIGFzIGFuIG9wZXJhdG9yLlxuICAgICovXG4gICAgb3BlcmF0b3JLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgY29udHJvbC1mbG93IHJlbGF0ZWQgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgICAqL1xuICAgIGNvbnRyb2xLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVmaW5pdGlvbktleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHJlbGF0ZWQgdG8gZGVmaW5pbmcgb3JcbiAgICBpbnRlcmZhY2luZyB3aXRoIG1vZHVsZXMuXG4gICAgKi9cbiAgICBtb2R1bGVLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEFuIG9wZXJhdG9yLlxuICAgICovXG4gICAgb3BlcmF0b3IsXG4gICAgLyoqXG4gICAgQW4gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVyZWZlcmVuY2VzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlcmVmT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIEFyaXRobWV0aWMtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBhcml0aG1ldGljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIExvZ2ljYWwgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgbG9naWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQml0IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGJpdHdpc2VPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQ29tcGFyaXNvbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBjb21wYXJlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IHVwZGF0ZXMgaXRzIG9wZXJhbmQuXG4gICAgKi9cbiAgICB1cGRhdGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFR5cGUtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICB0eXBlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIENvbnRyb2wtZmxvdyBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBjb250cm9sT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFByb2dyYW0gb3IgbWFya3VwIHB1bmN0dWF0aW9uLlxuICAgICovXG4gICAgcHVuY3R1YXRpb24sXG4gICAgLyoqXG4gICAgW1B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pIHRoYXQgc2VwYXJhdGVzXG4gICAgdGhpbmdzLlxuICAgICovXG4gICAgc2VwYXJhdG9yOiB0KHB1bmN0dWF0aW9uKSxcbiAgICAvKipcbiAgICBCcmFja2V0LXN0eWxlIFtwdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKS5cbiAgICAqL1xuICAgIGJyYWNrZXQsXG4gICAgLyoqXG4gICAgQW5nbGUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYDxgIGFuZCBgPmBcbiAgICB0b2tlbnMpLlxuICAgICovXG4gICAgYW5nbGVCcmFja2V0OiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIFNxdWFyZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgW2AgYW5kIGBdYFxuICAgIHRva2VucykuXG4gICAgKi9cbiAgICBzcXVhcmVCcmFja2V0OiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIFBhcmVudGhlc2VzICh1c3VhbGx5IGAoYCBhbmQgYClgIHRva2VucykuIFN1YnRhZyBvZlxuICAgIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgKi9cbiAgICBwYXJlbjogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBCcmFjZXMgKHVzdWFsbHkgYHtgIGFuZCBgfWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICAqL1xuICAgIGJyYWNlOiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIENvbnRlbnQsIGZvciBleGFtcGxlIHBsYWluIHRleHQgaW4gWE1MIG9yIG1hcmt1cCBkb2N1bWVudHMuXG4gICAgKi9cbiAgICBjb250ZW50LFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgaGVhZGluZy5cbiAgICAqL1xuICAgIGhlYWRpbmcsXG4gICAgLyoqXG4gICAgQSBsZXZlbCAxIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMTogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDIgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmcyOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMyBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzM6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA0IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNDogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDUgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc1OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzY6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBwcm9zZSBbY29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHNlcGFyYXRvciAoc3VjaCBhcyBhIGhvcml6b250YWwgcnVsZSkuXG4gICAgKi9cbiAgICBjb250ZW50U2VwYXJhdG9yOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgbGlzdC5cbiAgICAqL1xuICAgIGxpc3Q6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBxdW90ZS5cbiAgICAqL1xuICAgIHF1b3RlOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBlbXBoYXNpemVkLlxuICAgICovXG4gICAgZW1waGFzaXM6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBzdHJvbmcuXG4gICAgKi9cbiAgICBzdHJvbmc6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHBhcnQgb2YgYSBsaW5rLlxuICAgICovXG4gICAgbGluazogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIGFzIGNvZGUgb3JcbiAgICBtb25vc3BhY2UuXG4gICAgKi9cbiAgICBtb25vc3BhY2U6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGhhcyBhIHN0cmlrZS10aHJvdWdoXG4gICAgc3R5bGUuXG4gICAgKi9cbiAgICBzdHJpa2V0aHJvdWdoOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIEluc2VydGVkIHRleHQgaW4gYSBjaGFuZ2UtdHJhY2tpbmcgZm9ybWF0LlxuICAgICovXG4gICAgaW5zZXJ0ZWQ6IHQoKSxcbiAgICAvKipcbiAgICBEZWxldGVkIHRleHQuXG4gICAgKi9cbiAgICBkZWxldGVkOiB0KCksXG4gICAgLyoqXG4gICAgQ2hhbmdlZCB0ZXh0LlxuICAgICovXG4gICAgY2hhbmdlZDogdCgpLFxuICAgIC8qKlxuICAgIEFuIGludmFsaWQgb3IgdW5zeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGludmFsaWQ6IHQoKSxcbiAgICAvKipcbiAgICBNZXRhZGF0YSBvciBtZXRhLWluc3RydWN0aW9uLlxuICAgICovXG4gICAgbWV0YSxcbiAgICAvKipcbiAgICBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFwcGxpZXMgdG8gdGhlIGVudGlyZVxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jdW1lbnRNZXRhOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYW5ub3RhdGVzIG9yIGFkZHNcbiAgICBhdHRyaWJ1dGVzIHRvIGEgZ2l2ZW4gc3ludGFjdGljIGVsZW1lbnQuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gb3IgcHJlcHJvY2Vzc29yIGRpcmVjdGl2ZS4gU3VidGFnIG9mXG4gICAgW21ldGFdKCNoaWdobGlnaHQudGFncy5tZXRhKS5cbiAgICAqL1xuICAgIHByb2Nlc3NpbmdJbnN0cnVjdGlvbjogdChtZXRhKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyB0aGF0IGFcbiAgICBnaXZlbiBlbGVtZW50IGlzIGJlaW5nIGRlZmluZWQuIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCB0aGVcbiAgICB2YXJpb3VzIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdGFncy5cbiAgICAqL1xuICAgIGRlZmluaXRpb246IFRhZy5kZWZpbmVNb2RpZmllcihcImRlZmluaXRpb25cIiksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdFxuICAgIHNvbWV0aGluZyBpcyBjb25zdGFudC4gTW9zdGx5IGV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aFxuICAgIFt2YXJpYWJsZSBuYW1lc10oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkuXG4gICAgKi9cbiAgICBjb25zdGFudDogVGFnLmRlZmluZU1vZGlmaWVyKFwiY29uc3RhbnRcIiksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdXNlZCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgYSBbdmFyaWFibGVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIG9yIFtwcm9wZXJ0eVxuICAgIG5hbWVdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpIGlzIGJlaW5nIGNhbGxlZCBvciBkZWZpbmVkXG4gICAgYXMgYSBmdW5jdGlvbi5cbiAgICAqL1xuICAgIGZ1bmN0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJmdW5jdGlvblwiKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvXG4gICAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdG8gaW5kaWNhdGUgdGhhdCB0aGV5IGJlbG9uZyB0b1xuICAgIHRoZSBsYW5ndWFnZSdzIHN0YW5kYXJkIGVudmlyb25tZW50LlxuICAgICovXG4gICAgc3RhbmRhcmQ6IFRhZy5kZWZpbmVNb2RpZmllcihcInN0YW5kYXJkXCIpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIGEgZ2l2ZW5cbiAgICBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSBpcyBsb2NhbCB0byBzb21lIHNjb3BlLlxuICAgICovXG4gICAgbG9jYWw6IFRhZy5kZWZpbmVNb2RpZmllcihcImxvY2FsXCIpLFxuICAgIC8qKlxuICAgIEEgZ2VuZXJpYyB2YXJpYW50IFttb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXRcbiAgICBjYW4gYmUgdXNlZCB0byB0YWcgbGFuZ3VhZ2Utc3BlY2lmaWMgYWx0ZXJuYXRpdmUgdmFyaWFudHMgb2ZcbiAgICBzb21lIGNvbW1vbiB0YWcuIEl0IGlzIHJlY29tbWVuZGVkIGZvciB0aGVtZXMgdG8gZGVmaW5lIHNwZWNpYWxcbiAgICBmb3JtcyBvZiBhdCBsZWFzdCB0aGUgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykgYW5kXG4gICAgW3ZhcmlhYmxlIG5hbWVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIHRhZ3MsIHNpbmNlIHRob3NlXG4gICAgY29tZSB1cCBhIGxvdC5cbiAgICAqL1xuICAgIHNwZWNpYWw6IFRhZy5kZWZpbmVNb2RpZmllcihcInNwZWNpYWxcIilcbn07XG5mb3IgKGxldCBuYW1lIGluIHRhZ3MpIHtcbiAgICBsZXQgdmFsID0gdGFnc1tuYW1lXTtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgVGFnKVxuICAgICAgICB2YWwubmFtZSA9IG5hbWU7XG59XG4vKipcblRoaXMgaXMgYSBoaWdobGlnaHRlciB0aGF0IGFkZHMgc3RhYmxlLCBwcmVkaWN0YWJsZSBjbGFzc2VzIHRvXG50b2tlbnMsIGZvciBzdHlsaW5nIHdpdGggZXh0ZXJuYWwgQ1NTLlxuXG5UaGUgZm9sbG93aW5nIHRhZ3MgYXJlIG1hcHBlZCB0byB0aGVpciBuYW1lIHByZWZpeGVkIHdpdGggYFwidG9rLVwiYFxuKGZvciBleGFtcGxlIGBcInRvay1jb21tZW50XCJgKTpcblxuKiBbYGxpbmtgXSgjaGlnaGxpZ2h0LnRhZ3MubGluaylcbiogW2BoZWFkaW5nYF0oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpXG4qIFtgZW1waGFzaXNgXSgjaGlnaGxpZ2h0LnRhZ3MuZW1waGFzaXMpXG4qIFtgc3Ryb25nYF0oI2hpZ2hsaWdodC50YWdzLnN0cm9uZylcbiogW2BrZXl3b3JkYF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpXG4qIFtgYXRvbWBdKCNoaWdobGlnaHQudGFncy5hdG9tKVxuKiBbYGJvb2xgXSgjaGlnaGxpZ2h0LnRhZ3MuYm9vbClcbiogW2B1cmxgXSgjaGlnaGxpZ2h0LnRhZ3MudXJsKVxuKiBbYGxhYmVsTmFtZWBdKCNoaWdobGlnaHQudGFncy5sYWJlbE5hbWUpXG4qIFtgaW5zZXJ0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW5zZXJ0ZWQpXG4qIFtgZGVsZXRlZGBdKCNoaWdobGlnaHQudGFncy5kZWxldGVkKVxuKiBbYGxpdGVyYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbClcbiogW2BzdHJpbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuKiBbYG51bWJlcmBdKCNoaWdobGlnaHQudGFncy5udW1iZXIpXG4qIFtgdmFyaWFibGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiogW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSlcbiogW2BuYW1lc3BhY2VgXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZXNwYWNlKVxuKiBbYGNsYXNzTmFtZWBdKCNoaWdobGlnaHQudGFncy5jbGFzc05hbWUpXG4qIFtgbWFjcm9OYW1lYF0oI2hpZ2hsaWdodC50YWdzLm1hY3JvTmFtZSlcbiogW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuKiBbYG9wZXJhdG9yYF0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKVxuKiBbYGNvbW1lbnRgXSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudClcbiogW2BtZXRhYF0oI2hpZ2hsaWdodC50YWdzLm1ldGEpXG4qIFtgcHVuY3R1YXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pXG4qIFtgaW52YWxpZGBdKCNoaWdobGlnaHQudGFncy5pbnZhbGlkKVxuXG5JbiBhZGRpdGlvbiwgdGhlc2UgbWFwcGluZ3MgYXJlIHByb3ZpZGVkOlxuXG4qIFtgcmVnZXhwYF0oI2hpZ2hsaWdodC50YWdzLnJlZ2V4cCksXG4gIFtgZXNjYXBlYF0oI2hpZ2hsaWdodC50YWdzLmVzY2FwZSksIGFuZFxuICBbYHNwZWNpYWxgXSgjaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbClbYChzdHJpbmcpYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbiAgYXJlIG1hcHBlZCB0byBgXCJ0b2stc3RyaW5nMlwiYFxuKiBbYHNwZWNpYWxgXSgjaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbClbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZTJcImBcbiogW2Bsb2NhbGBdKCNoaWdobGlnaHQudGFncy5sb2NhbClbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcImBcbiogW2BkZWZpbml0aW9uYF0oI2hpZ2hsaWdodC50YWdzLmRlZmluaXRpb24pW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUgdG9rLWRlZmluaXRpb25cImBcbiogW2BkZWZpbml0aW9uYF0oI2hpZ2hsaWdodC50YWdzLmRlZmluaXRpb24pW2AocHJvcGVydHlOYW1lKWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4gIHRvIGBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cImBcbiovXG5jb25zdCBjbGFzc0hpZ2hsaWdodGVyID0gdGFnSGlnaGxpZ2h0ZXIoW1xuICAgIHsgdGFnOiB0YWdzLmxpbmssIGNsYXNzOiBcInRvay1saW5rXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLCBjbGFzczogXCJ0b2staGVhZGluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsIGNsYXNzOiBcInRvay1lbXBoYXNpc1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLCBjbGFzczogXCJ0b2stc3Ryb25nXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLCBjbGFzczogXCJ0b2sta2V5d29yZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYXRvbSwgY2xhc3M6IFwidG9rLWF0b21cIiB9LFxuICAgIHsgdGFnOiB0YWdzLmJvb2wsIGNsYXNzOiBcInRvay1ib29sXCIgfSxcbiAgICB7IHRhZzogdGFncy51cmwsIGNsYXNzOiBcInRvay11cmxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxhYmVsTmFtZSwgY2xhc3M6IFwidG9rLWxhYmVsTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW5zZXJ0ZWQsIGNsYXNzOiBcInRvay1pbnNlcnRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVsZXRlZCwgY2xhc3M6IFwidG9rLWRlbGV0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpdGVyYWwsIGNsYXNzOiBcInRvay1saXRlcmFsXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpbmcsIGNsYXNzOiBcInRvay1zdHJpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm51bWJlciwgY2xhc3M6IFwidG9rLW51bWJlclwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIHRhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLCBjbGFzczogXCJ0b2stc3RyaW5nMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudmFyaWFibGVOYW1lLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUyXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudHlwZU5hbWUsIGNsYXNzOiBcInRvay10eXBlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubmFtZXNwYWNlLCBjbGFzczogXCJ0b2stbmFtZXNwYWNlXCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsIGNsYXNzOiBcInRvay1jbGFzc05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1hY3JvTmFtZSwgY2xhc3M6IFwidG9rLW1hY3JvTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHJvcGVydHlOYW1lLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5vcGVyYXRvciwgY2xhc3M6IFwidG9rLW9wZXJhdG9yXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LCBjbGFzczogXCJ0b2stY29tbWVudFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWV0YSwgY2xhc3M6IFwidG9rLW1ldGFcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsIGNsYXNzOiBcInRvay1pbnZhbGlkXCIgfSxcbiAgICB7IHRhZzogdGFncy5wdW5jdHVhdGlvbiwgY2xhc3M6IFwidG9rLXB1bmN0dWF0aW9uXCIgfVxuXSk7XG5cbmV4cG9ydHMuVGFnID0gVGFnO1xuZXhwb3J0cy5jbGFzc0hpZ2hsaWdodGVyID0gY2xhc3NIaWdobGlnaHRlcjtcbmV4cG9ydHMuZ2V0U3R5bGVUYWdzID0gZ2V0U3R5bGVUYWdzO1xuZXhwb3J0cy5oaWdobGlnaHRDb2RlID0gaGlnaGxpZ2h0Q29kZTtcbmV4cG9ydHMuaGlnaGxpZ2h0VHJlZSA9IGhpZ2hsaWdodFRyZWU7XG5leHBvcnRzLnN0eWxlVGFncyA9IHN0eWxlVGFncztcbmV4cG9ydHMudGFnSGlnaGxpZ2h0ZXIgPSB0YWdIaWdobGlnaHRlcjtcbmV4cG9ydHMudGFncyA9IHRhZ3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBsciA9IHJlcXVpcmUoJ0BsZXplci9scicpO1xudmFyIGhpZ2hsaWdodCA9IHJlcXVpcmUoJ0BsZXplci9oaWdobGlnaHQnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCdAbGV6ZXIvY29tbW9uJyk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgc2NyaXB0VGV4dCA9IDU0LFxuICBTdGFydENsb3NlU2NyaXB0VGFnID0gMSxcbiAgc3R5bGVUZXh0ID0gNTUsXG4gIFN0YXJ0Q2xvc2VTdHlsZVRhZyA9IDIsXG4gIHRleHRhcmVhVGV4dCA9IDU2LFxuICBTdGFydENsb3NlVGV4dGFyZWFUYWcgPSAzLFxuICBFbmRUYWcgPSA0LFxuICBTZWxmQ2xvc2luZ0VuZFRhZyA9IDUsXG4gIFN0YXJ0VGFnID0gNixcbiAgU3RhcnRTY3JpcHRUYWcgPSA3LFxuICBTdGFydFN0eWxlVGFnID0gOCxcbiAgU3RhcnRUZXh0YXJlYVRhZyA9IDksXG4gIFN0YXJ0U2VsZkNsb3NpbmdUYWcgPSAxMCxcbiAgU3RhcnRDbG9zZVRhZyA9IDExLFxuICBOb01hdGNoU3RhcnRDbG9zZVRhZyA9IDEyLFxuICBNaXNtYXRjaGVkU3RhcnRDbG9zZVRhZyA9IDEzLFxuICBtaXNzaW5nQ2xvc2VUYWcgPSA1NyxcbiAgSW5jb21wbGV0ZUNsb3NlVGFnID0gMTQsXG4gIGNvbW1lbnRDb250ZW50JDEgPSA1OCxcbiAgRWxlbWVudCA9IDIwLFxuICBUYWdOYW1lID0gMjIsXG4gIEF0dHJpYnV0ZSA9IDIzLFxuICBBdHRyaWJ1dGVOYW1lID0gMjQsXG4gIEF0dHJpYnV0ZVZhbHVlID0gMjYsXG4gIFVucXVvdGVkQXR0cmlidXRlVmFsdWUgPSAyNyxcbiAgU2NyaXB0VGV4dCA9IDI4LFxuICBTdHlsZVRleHQgPSAzMSxcbiAgVGV4dGFyZWFUZXh0ID0gMzQsXG4gIE9wZW5UYWcgPSAzNixcbiAgQ2xvc2VUYWcgPSAzNyxcbiAgRGlhbGVjdF9ub01hdGNoID0gMCxcbiAgRGlhbGVjdF9zZWxmQ2xvc2luZyA9IDE7XG5cbi8qIEhhbmQtd3JpdHRlbiB0b2tlbml6ZXJzIGZvciBIVE1MLiAqL1xuXG5jb25zdCBzZWxmQ2xvc2VycyA9IHtcbiAgYXJlYTogdHJ1ZSwgYmFzZTogdHJ1ZSwgYnI6IHRydWUsIGNvbDogdHJ1ZSwgY29tbWFuZDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsIGZyYW1lOiB0cnVlLCBocjogdHJ1ZSwgaW1nOiB0cnVlLCBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLCBsaW5rOiB0cnVlLCBtZXRhOiB0cnVlLCBwYXJhbTogdHJ1ZSwgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSwgd2JyOiB0cnVlLCBtZW51aXRlbTogdHJ1ZVxufTtcblxuY29uc3QgaW1wbGljaXRseUNsb3NlZCA9IHtcbiAgZGQ6IHRydWUsIGxpOiB0cnVlLCBvcHRncm91cDogdHJ1ZSwgb3B0aW9uOiB0cnVlLCBwOiB0cnVlLFxuICBycDogdHJ1ZSwgcnQ6IHRydWUsIHRib2R5OiB0cnVlLCB0ZDogdHJ1ZSwgdGZvb3Q6IHRydWUsXG4gIHRoOiB0cnVlLCB0cjogdHJ1ZVxufTtcblxuY29uc3QgY2xvc2VPbk9wZW4gPSB7XG4gIGRkOiB7ZGQ6IHRydWUsIGR0OiB0cnVlfSxcbiAgZHQ6IHtkZDogdHJ1ZSwgZHQ6IHRydWV9LFxuICBsaToge2xpOiB0cnVlfSxcbiAgb3B0aW9uOiB7b3B0aW9uOiB0cnVlLCBvcHRncm91cDogdHJ1ZX0sXG4gIG9wdGdyb3VwOiB7b3B0Z3JvdXA6IHRydWV9LFxuICBwOiB7XG4gICAgYWRkcmVzczogdHJ1ZSwgYXJ0aWNsZTogdHJ1ZSwgYXNpZGU6IHRydWUsIGJsb2NrcXVvdGU6IHRydWUsIGRpcjogdHJ1ZSxcbiAgICBkaXY6IHRydWUsIGRsOiB0cnVlLCBmaWVsZHNldDogdHJ1ZSwgZm9vdGVyOiB0cnVlLCBmb3JtOiB0cnVlLFxuICAgIGgxOiB0cnVlLCBoMjogdHJ1ZSwgaDM6IHRydWUsIGg0OiB0cnVlLCBoNTogdHJ1ZSwgaDY6IHRydWUsXG4gICAgaGVhZGVyOiB0cnVlLCBoZ3JvdXA6IHRydWUsIGhyOiB0cnVlLCBtZW51OiB0cnVlLCBuYXY6IHRydWUsIG9sOiB0cnVlLFxuICAgIHA6IHRydWUsIHByZTogdHJ1ZSwgc2VjdGlvbjogdHJ1ZSwgdGFibGU6IHRydWUsIHVsOiB0cnVlXG4gIH0sXG4gIHJwOiB7cnA6IHRydWUsIHJ0OiB0cnVlfSxcbiAgcnQ6IHtycDogdHJ1ZSwgcnQ6IHRydWV9LFxuICB0Ym9keToge3Rib2R5OiB0cnVlLCB0Zm9vdDogdHJ1ZX0sXG4gIHRkOiB7dGQ6IHRydWUsIHRoOiB0cnVlfSxcbiAgdGZvb3Q6IHt0Ym9keTogdHJ1ZX0sXG4gIHRoOiB7dGQ6IHRydWUsIHRoOiB0cnVlfSxcbiAgdGhlYWQ6IHt0Ym9keTogdHJ1ZSwgdGZvb3Q6IHRydWV9LFxuICB0cjoge3RyOiB0cnVlfVxufTtcblxuZnVuY3Rpb24gbmFtZUNoYXIoY2gpIHtcbiAgcmV0dXJuIGNoID09IDQ1IHx8IGNoID09IDQ2IHx8IGNoID09IDU4IHx8IGNoID49IDY1ICYmIGNoIDw9IDkwIHx8IGNoID09IDk1IHx8IGNoID49IDk3ICYmIGNoIDw9IDEyMiB8fCBjaCA+PSAxNjFcbn1cblxuZnVuY3Rpb24gaXNTcGFjZShjaCkge1xuICByZXR1cm4gY2ggPT0gOSB8fCBjaCA9PSAxMCB8fCBjaCA9PSAxMyB8fCBjaCA9PSAzMlxufVxuXG5sZXQgY2FjaGVkTmFtZSA9IG51bGwsIGNhY2hlZElucHV0ID0gbnVsbCwgY2FjaGVkUG9zID0gMDtcbmZ1bmN0aW9uIHRhZ05hbWVBZnRlcihpbnB1dCwgb2Zmc2V0KSB7XG4gIGxldCBwb3MgPSBpbnB1dC5wb3MgKyBvZmZzZXQ7XG4gIGlmIChjYWNoZWRQb3MgPT0gcG9zICYmIGNhY2hlZElucHV0ID09IGlucHV0KSByZXR1cm4gY2FjaGVkTmFtZVxuICBsZXQgbmV4dCA9IGlucHV0LnBlZWsob2Zmc2V0KTtcbiAgd2hpbGUgKGlzU3BhY2UobmV4dCkpIG5leHQgPSBpbnB1dC5wZWVrKCsrb2Zmc2V0KTtcbiAgbGV0IG5hbWUgPSBcIlwiO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKCFuYW1lQ2hhcihuZXh0KSkgYnJlYWtcbiAgICBuYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dCk7XG4gICAgbmV4dCA9IGlucHV0LnBlZWsoKytvZmZzZXQpO1xuICB9XG4gIC8vIFVuZGVmaW5lZCB0byBzaWduYWwgdGhlcmUncyBhIDw/IG9yIDwhLCBudWxsIGZvciBqdXN0IG1pc3NpbmdcbiAgY2FjaGVkSW5wdXQgPSBpbnB1dDsgY2FjaGVkUG9zID0gcG9zO1xuICByZXR1cm4gY2FjaGVkTmFtZSA9IG5hbWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOiBuZXh0ID09IHF1ZXN0aW9uIHx8IG5leHQgPT0gYmFuZyA/IHVuZGVmaW5lZCA6IG51bGxcbn1cblxuY29uc3QgbGVzc1RoYW4gPSA2MCwgZ3JlYXRlclRoYW4gPSA2Miwgc2xhc2ggPSA0NywgcXVlc3Rpb24gPSA2MywgYmFuZyA9IDMzLCBkYXNoID0gNDU7XG5cbmZ1bmN0aW9uIEVsZW1lbnRDb250ZXh0KG5hbWUsIHBhcmVudCkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbn1cblxuY29uc3Qgc3RhcnRUYWdUZXJtcyA9IFtTdGFydFRhZywgU3RhcnRTZWxmQ2xvc2luZ1RhZywgU3RhcnRTY3JpcHRUYWcsIFN0YXJ0U3R5bGVUYWcsIFN0YXJ0VGV4dGFyZWFUYWddO1xuXG5jb25zdCBlbGVtZW50Q29udGV4dCA9IG5ldyBsci5Db250ZXh0VHJhY2tlcih7XG4gIHN0YXJ0OiBudWxsLFxuICBzaGlmdChjb250ZXh0LCB0ZXJtLCBzdGFjaywgaW5wdXQpIHtcbiAgICByZXR1cm4gc3RhcnRUYWdUZXJtcy5pbmRleE9mKHRlcm0pID4gLTEgPyBuZXcgRWxlbWVudENvbnRleHQodGFnTmFtZUFmdGVyKGlucHV0LCAxKSB8fCBcIlwiLCBjb250ZXh0KSA6IGNvbnRleHRcbiAgfSxcbiAgcmVkdWNlKGNvbnRleHQsIHRlcm0pIHtcbiAgICByZXR1cm4gdGVybSA9PSBFbGVtZW50ICYmIGNvbnRleHQgPyBjb250ZXh0LnBhcmVudCA6IGNvbnRleHRcbiAgfSxcbiAgcmV1c2UoY29udGV4dCwgbm9kZSwgc3RhY2ssIGlucHV0KSB7XG4gICAgbGV0IHR5cGUgPSBub2RlLnR5cGUuaWQ7XG4gICAgcmV0dXJuIHR5cGUgPT0gU3RhcnRUYWcgfHwgdHlwZSA9PSBPcGVuVGFnXG4gICAgICA/IG5ldyBFbGVtZW50Q29udGV4dCh0YWdOYW1lQWZ0ZXIoaW5wdXQsIDEpIHx8IFwiXCIsIGNvbnRleHQpIDogY29udGV4dFxuICB9LFxuICBzdHJpY3Q6IGZhbHNlXG59KTtcblxuY29uc3QgdGFnU3RhcnQgPSBuZXcgbHIuRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCAhPSBsZXNzVGhhbikge1xuICAgIC8vIEVuZCBvZiBmaWxlLCBjbG9zZSBhbnkgb3BlbiB0YWdzXG4gICAgaWYgKGlucHV0Lm5leHQgPCAwICYmIHN0YWNrLmNvbnRleHQpIGlucHV0LmFjY2VwdFRva2VuKG1pc3NpbmdDbG9zZVRhZyk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaW5wdXQuYWR2YW5jZSgpO1xuICBsZXQgY2xvc2UgPSBpbnB1dC5uZXh0ID09IHNsYXNoO1xuICBpZiAoY2xvc2UpIGlucHV0LmFkdmFuY2UoKTtcbiAgbGV0IG5hbWUgPSB0YWdOYW1lQWZ0ZXIoaW5wdXQsIDApO1xuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgaWYgKCFuYW1lKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oY2xvc2UgPyBJbmNvbXBsZXRlQ2xvc2VUYWcgOiBTdGFydFRhZylcblxuICBsZXQgcGFyZW50ID0gc3RhY2suY29udGV4dCA/IHN0YWNrLmNvbnRleHQubmFtZSA6IG51bGw7XG4gIGlmIChjbG9zZSkge1xuICAgIGlmIChuYW1lID09IHBhcmVudCkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0Q2xvc2VUYWcpXG4gICAgaWYgKHBhcmVudCAmJiBpbXBsaWNpdGx5Q2xvc2VkW3BhcmVudF0pIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihtaXNzaW5nQ2xvc2VUYWcsIC0yKVxuICAgIGlmIChzdGFjay5kaWFsZWN0RW5hYmxlZChEaWFsZWN0X25vTWF0Y2gpKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oTm9NYXRjaFN0YXJ0Q2xvc2VUYWcpXG4gICAgZm9yIChsZXQgY3ggPSBzdGFjay5jb250ZXh0OyBjeDsgY3ggPSBjeC5wYXJlbnQpIGlmIChjeC5uYW1lID09IG5hbWUpIHJldHVyblxuICAgIGlucHV0LmFjY2VwdFRva2VuKE1pc21hdGNoZWRTdGFydENsb3NlVGFnKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobmFtZSA9PSBcInNjcmlwdFwiKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRTY3JpcHRUYWcpXG4gICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRTdHlsZVRhZylcbiAgICBpZiAobmFtZSA9PSBcInRleHRhcmVhXCIpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFRleHRhcmVhVGFnKVxuICAgIGlmIChzZWxmQ2xvc2Vycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0U2VsZkNsb3NpbmdUYWcpXG4gICAgaWYgKHBhcmVudCAmJiBjbG9zZU9uT3BlbltwYXJlbnRdICYmIGNsb3NlT25PcGVuW3BhcmVudF1bbmFtZV0pIGlucHV0LmFjY2VwdFRva2VuKG1pc3NpbmdDbG9zZVRhZywgLTEpO1xuICAgIGVsc2UgaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRUYWcpO1xuICB9XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBjb21tZW50Q29udGVudCA9IG5ldyBsci5FeHRlcm5hbFRva2VuaXplcihpbnB1dCA9PiB7XG4gIGZvciAobGV0IGRhc2hlcyA9IDAsIGkgPSAwOzsgaSsrKSB7XG4gICAgaWYgKGlucHV0Lm5leHQgPCAwKSB7XG4gICAgICBpZiAoaSkgaW5wdXQuYWNjZXB0VG9rZW4oY29tbWVudENvbnRlbnQkMSk7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5wdXQubmV4dCA9PSBkYXNoKSB7XG4gICAgICBkYXNoZXMrKztcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgPT0gZ3JlYXRlclRoYW4gJiYgZGFzaGVzID49IDIpIHtcbiAgICAgIGlmIChpID49IDMpIGlucHV0LmFjY2VwdFRva2VuKGNvbW1lbnRDb250ZW50JDEsIC0yKTtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIGRhc2hlcyA9IDA7XG4gICAgfVxuICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGluRm9yZWlnbkVsZW1lbnQoY29udGV4dCkge1xuICBmb3IgKDsgY29udGV4dDsgY29udGV4dCA9IGNvbnRleHQucGFyZW50KVxuICAgIGlmIChjb250ZXh0Lm5hbWUgPT0gXCJzdmdcIiB8fCBjb250ZXh0Lm5hbWUgPT0gXCJtYXRoXCIpIHJldHVybiB0cnVlXG4gIHJldHVybiBmYWxzZVxufVxuXG5jb25zdCBlbmRUYWcgPSBuZXcgbHIuRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCA9PSBzbGFzaCAmJiBpbnB1dC5wZWVrKDEpID09IGdyZWF0ZXJUaGFuKSB7XG4gICAgbGV0IHNlbGZDbG9zaW5nID0gc3RhY2suZGlhbGVjdEVuYWJsZWQoRGlhbGVjdF9zZWxmQ2xvc2luZykgfHwgaW5Gb3JlaWduRWxlbWVudChzdGFjay5jb250ZXh0KTtcbiAgICBpbnB1dC5hY2NlcHRUb2tlbihzZWxmQ2xvc2luZyA/IFNlbGZDbG9zaW5nRW5kVGFnIDogRW5kVGFnLCAyKTtcbiAgfSBlbHNlIGlmIChpbnB1dC5uZXh0ID09IGdyZWF0ZXJUaGFuKSB7XG4gICAgaW5wdXQuYWNjZXB0VG9rZW4oRW5kVGFnLCAxKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvbnRlbnRUb2tlbml6ZXIodGFnLCB0ZXh0VG9rZW4sIGVuZFRva2VuKSB7XG4gIGxldCBsYXN0U3RhdGUgPSAyICsgdGFnLmxlbmd0aDtcbiAgcmV0dXJuIG5ldyBsci5FeHRlcm5hbFRva2VuaXplcihpbnB1dCA9PiB7XG4gICAgLy8gc3RhdGUgbWVhbnM6XG4gICAgLy8gLSAwIG5vdGhpbmcgbWF0Y2hlZFxuICAgIC8vIC0gMSAnPCcgbWF0Y2hlZFxuICAgIC8vIC0gMiAnPC8nICsgcG9zc2libHkgd2hpdGVzcGFjZSBtYXRjaGVkXG4gICAgLy8gLSAzLSgxK3RhZy5sZW5ndGgpIHBhcnQgb2YgdGhlIHRhZyBtYXRjaGVkXG4gICAgLy8gLSBsYXN0U3RhdGUgd2hvbGUgdGFnICsgcG9zc2libHkgd2hpdGVzcGFjZSBtYXRjaGVkXG4gICAgZm9yIChsZXQgc3RhdGUgPSAwLCBtYXRjaGVkTGVuID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICAgIGlmIChpbnB1dC5uZXh0IDwgMCkge1xuICAgICAgICBpZiAoaSkgaW5wdXQuYWNjZXB0VG9rZW4odGV4dFRva2VuKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PSAwICYmIGlucHV0Lm5leHQgPT0gbGVzc1RoYW4gfHxcbiAgICAgICAgICBzdGF0ZSA9PSAxICYmIGlucHV0Lm5leHQgPT0gc2xhc2ggfHxcbiAgICAgICAgICBzdGF0ZSA+PSAyICYmIHN0YXRlIDwgbGFzdFN0YXRlICYmIGlucHV0Lm5leHQgPT0gdGFnLmNoYXJDb2RlQXQoc3RhdGUgLSAyKSkge1xuICAgICAgICBzdGF0ZSsrO1xuICAgICAgICBtYXRjaGVkTGVuKys7XG4gICAgICB9IGVsc2UgaWYgKChzdGF0ZSA9PSAyIHx8IHN0YXRlID09IGxhc3RTdGF0ZSkgJiYgaXNTcGFjZShpbnB1dC5uZXh0KSkge1xuICAgICAgICBtYXRjaGVkTGVuKys7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09IGxhc3RTdGF0ZSAmJiBpbnB1dC5uZXh0ID09IGdyZWF0ZXJUaGFuKSB7XG4gICAgICAgIGlmIChpID4gbWF0Y2hlZExlbilcbiAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXh0VG9rZW4sIC1tYXRjaGVkTGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKGVuZFRva2VuLCAtKG1hdGNoZWRMZW4gLSAyKSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKChpbnB1dC5uZXh0ID09IDEwIC8qICdcXG4nICovIHx8IGlucHV0Lm5leHQgPT0gMTMgLyogJ1xccicgKi8pICYmIGkpIHtcbiAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGV4dFRva2VuLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gbWF0Y2hlZExlbiA9IDA7XG4gICAgICB9XG4gICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgfVxuICB9KVxufVxuXG5jb25zdCBzY3JpcHRUb2tlbnMgPSBjb250ZW50VG9rZW5pemVyKFwic2NyaXB0XCIsIHNjcmlwdFRleHQsIFN0YXJ0Q2xvc2VTY3JpcHRUYWcpO1xuXG5jb25zdCBzdHlsZVRva2VucyA9IGNvbnRlbnRUb2tlbml6ZXIoXCJzdHlsZVwiLCBzdHlsZVRleHQsIFN0YXJ0Q2xvc2VTdHlsZVRhZyk7XG5cbmNvbnN0IHRleHRhcmVhVG9rZW5zID0gY29udGVudFRva2VuaXplcihcInRleHRhcmVhXCIsIHRleHRhcmVhVGV4dCwgU3RhcnRDbG9zZVRleHRhcmVhVGFnKTtcblxuY29uc3QgaHRtbEhpZ2hsaWdodGluZyA9IGhpZ2hsaWdodC5zdHlsZVRhZ3Moe1xuICBcIlRleHQgUmF3VGV4dFwiOiBoaWdobGlnaHQudGFncy5jb250ZW50LFxuICBcIlN0YXJ0VGFnIFN0YXJ0Q2xvc2VUYWcgU2VsZkNsb3NpbmdFbmRUYWcgRW5kVGFnXCI6IGhpZ2hsaWdodC50YWdzLmFuZ2xlQnJhY2tldCxcbiAgVGFnTmFtZTogaGlnaGxpZ2h0LnRhZ3MudGFnTmFtZSxcbiAgXCJNaXNtYXRjaGVkQ2xvc2VUYWcvVGFnTmFtZVwiOiBbaGlnaGxpZ2h0LnRhZ3MudGFnTmFtZSwgIGhpZ2hsaWdodC50YWdzLmludmFsaWRdLFxuICBBdHRyaWJ1dGVOYW1lOiBoaWdobGlnaHQudGFncy5hdHRyaWJ1dGVOYW1lLFxuICBcIkF0dHJpYnV0ZVZhbHVlIFVucXVvdGVkQXR0cmlidXRlVmFsdWVcIjogaGlnaGxpZ2h0LnRhZ3MuYXR0cmlidXRlVmFsdWUsXG4gIElzOiBoaWdobGlnaHQudGFncy5kZWZpbml0aW9uT3BlcmF0b3IsXG4gIFwiRW50aXR5UmVmZXJlbmNlIENoYXJhY3RlclJlZmVyZW5jZVwiOiBoaWdobGlnaHQudGFncy5jaGFyYWN0ZXIsXG4gIENvbW1lbnQ6IGhpZ2hsaWdodC50YWdzLmJsb2NrQ29tbWVudCxcbiAgUHJvY2Vzc2luZ0luc3Q6IGhpZ2hsaWdodC50YWdzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbixcbiAgRG9jdHlwZURlY2w6IGhpZ2hsaWdodC50YWdzLmRvY3VtZW50TWV0YVxufSk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgcGFyc2VyID0gbHIuTFJQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxNCxcbiAgc3RhdGVzOiBcIix4T1ZPIXJPT08hV1EjdE8nI0NxTyFdUSN0TycjQ3pPIWJRI3RPJyNDfU8hZ1EjdE8nI0RRTyFsUSN0TycjRFNPIXFPYU8nI0NwTyF8T2JPJyNDcE8jWE9kTycjQ3BPJGVPIXJPJyNDcE9PT2AnI0NwJyNDcE8kbE8kZk8nI0RUTyR0USN0TycjRFZPJHlRI3RPJyNEV09PT2AnI0RrJyNEa09PT2AnI0RZJyNEWVFWTyFyT09PJU9RJnJPLDU5XU8lWlEmck8sNTlmTyVmUSZyTyw1OWlPJXFRJnJPLDU5bE8lfFEmck8sNTluT09PYScjRF4nI0ReTyZYT2FPJyNDeE8mZE9hTyw1OVtPT09iJyNEXycjRF9PJmxPYk8nI0N7TyZ3T2JPLDU5W09PT2QnI0RgJyNEYE8nUE9kTycjRE9PJ1tPZE8sNTlbT09PYCcjRGEnI0RhTydkTyFyTyw1OVtPJ2tRI3RPJyNEUk9PT2AsNTlbLDU5W09PT3AnI0RiJyNEYk8ncE8kZk8sNTlvT09PYCw1OW8sNTlvTyd4USN8Tyw1OXFPJ31RI3xPLDU5ck9PT2AtRTdXLUU3V08oU1Emck8nI0NzT09RVycjRFonI0RaTyhiUSZyTzFHLndPT09hMUcudzFHLndPT09gMUcvWTFHL1lPKG1RJnJPMUcvUU9PT2IxRy9RMUcvUU8oeFEmck8xRy9UT09PZDFHL1QxRy9UTylUUSZyTzFHL1dPT09gMUcvVzFHL1dPKWBRJnJPMUcvWU9PT2EtRTdbLUU3W08pa1EjdE8nI0N5T09PYDFHLnYxRy52T09PYi1FN10tRTddTylwUSN0TycjQ3xPT09kLUU3Xi1FN15PKXVRI3RPJyNEUE9PT2AtRTdfLUU3X08pelEjfE8sNTltT09PcC1FN2AtRTdgT09PYDFHL1oxRy9aT09PYDFHL10xRy9dT09PYDFHL14xRy9eTypQUSxVTyw1OV9PT1FXLUU3WC1FN1hPT09hNyskYzcrJGNPT09gNyskdDcrJHRPT09iNyskbDcrJGxPT09kNyskbzcrJG9PT09gNyskcjcrJHJPKltRI3xPLDU5ZU8qYVEjfE8sNTloTypmUSN8Tyw1OWtPT09gMUcvWDFHL1hPKmtPN1tPJyNDdk8qfE9NaE8nI0N2T09RVzFHLnkxRy55T09PYDFHL1AxRy9QT09PYDFHL1MxRy9TT09PYDFHL1YxRy9WT09PTycjRFsnI0RbTytfTzdbTyw1OWJPT1FXLDU5Yiw1OWJPT09PJyNEXScjRF1PK3BPTWhPLDU5Yk9PT08tRTdZLUU3WU9PUVcxRy58MUcufE9PT08tRTdaLUU3WlwiLFxuICBzdGF0ZURhdGE6IFwiLF1+TyFeT1N+T1VTT1ZQT1dRT1hST1lUT1tdT11bT15eT2BeT2FeT2JeT2NeT3heT3tfTyFkWk9+T2ZhT35PZmJPfk9mY09+T2ZkT35PZmVPfk8hV2ZPUGxQIVpsUH5PIVhpT1FvUCFab1B+TyFZbE9SclAhWnJQfk9VU09WUE9XUU9YUk9ZVE9acU9bXU9dW09eXk9gXk9hXk9iXk9jXk94Xk8hZFpPfk8hWnJPflAjZE8hW3NPIWV1T35PZnZPfk9md09+T1N8T1R9T2h5T35PUyFQT1R9T2h5T35PUyFST1R9T2h5T35PUyFUT1R9T2h5T35PU31PVH1PaHlPfk8hV2ZPUGxYIVpsWH5PUCFXTyFaIVhPfk8hWGlPUW9YIVpvWH5PUSFaTyFaIVhPfk8hWWxPUnJYIVpyWH5PUiFdTyFaIVhPfk8hWiFYT35QI2RPZiFfT35PIVtzTyFlIWFPfk9TIWJPfk9TIWNPfk9pIWRPU2dYVGdYaGdYfk9TIWZPVCFnT2h5T35PUyFoT1QhZ09oeU9+T1MhaU9UIWdPaHlPfk9TIWpPVCFnT2h5T35PUyFnT1QhZ09oeU9+T2Yha09+T2YhbE9+T2YhbU9+T1Mhbk9+T2shcU8hYCFvTyFiIXBPfk9TIXJPfk9TIXNPfk9TIXRPfk9hIXVPYiF1T2MhdU8hYCF3TyFhIXVPfk9hIXhPYiF4T2MheE8hYiF3TyFjIXhPfk9hIXVPYiF1T2MhdU8hYCF7TyFhIXVPfk9hIXhPYiF4T2MheE8hYiF7TyFjIXhPfk9UfmJhYyFkeHshZH5cIixcbiAgZ290bzogXCIlcCFgUFBQUFBQUFBQUFBQUFBQUFBQUFAhYSFnUCFtUFAheVAhfCNQI1MjWSNdI2AjZiNpI2wjciN4IWFQIWEhYVAkTyRVJGwkciR4JU8lVSVbJWJQUFBQUFBQUCVoWF5PWGBwWFVPWGBwZXphYmNkZXshTyFRIVMhVVIhcSFkUmhVUiFYaFhWT1hgcFJrVlIhWGtYV09YYHBSbldSIVhuWFhPWGBwUXJYUiFYcFhZT1hgcFFgT1J4YFF7YVEhT2JRIVFjUSFTZFEhVWVaIWV7IU8hUSFTIVVRIXYhb1IheiF2USF5IXBSIXwheVFnVVIhVmdRalZSIVlqUW1XUiFbbVFwWFIhXnBRdFpSIWB0U19PYFRvWHBcIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBTdGFydENsb3NlVGFnIFN0YXJ0Q2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBFbmRUYWcgU2VsZkNsb3NpbmdFbmRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRDbG9zZVRhZyBTdGFydENsb3NlVGFnIFN0YXJ0Q2xvc2VUYWcgSW5jb21wbGV0ZUNsb3NlVGFnIERvY3VtZW50IFRleHQgRW50aXR5UmVmZXJlbmNlIENoYXJhY3RlclJlZmVyZW5jZSBJbnZhbGlkRW50aXR5IEVsZW1lbnQgT3BlblRhZyBUYWdOYW1lIEF0dHJpYnV0ZSBBdHRyaWJ1dGVOYW1lIElzIEF0dHJpYnV0ZVZhbHVlIFVucXVvdGVkQXR0cmlidXRlVmFsdWUgU2NyaXB0VGV4dCBDbG9zZVRhZyBPcGVuVGFnIFN0eWxlVGV4dCBDbG9zZVRhZyBPcGVuVGFnIFRleHRhcmVhVGV4dCBDbG9zZVRhZyBPcGVuVGFnIENsb3NlVGFnIFNlbGZDbG9zaW5nVGFnIENvbW1lbnQgUHJvY2Vzc2luZ0luc3QgTWlzbWF0Y2hlZENsb3NlVGFnIENsb3NlVGFnIERvY3R5cGVEZWNsXCIsXG4gIG1heFRlcm06IDY3LFxuICBjb250ZXh0OiBlbGVtZW50Q29udGV4dCxcbiAgbm9kZVByb3BzOiBbXG4gICAgW1wiY2xvc2VkQnlcIiwgLTEwLDEsMiwzLDcsOCw5LDEwLDExLDEyLDEzLFwiRW5kVGFnXCIsNixcIkVuZFRhZyBTZWxmQ2xvc2luZ0VuZFRhZ1wiLC00LDIxLDMwLDMzLDM2LFwiQ2xvc2VUYWdcIl0sXG4gICAgW1wib3BlbmVkQnlcIiwgNCxcIlN0YXJ0VGFnIFN0YXJ0Q2xvc2VUYWdcIiw1LFwiU3RhcnRUYWdcIiwtNCwyOSwzMiwzNSwzNyxcIk9wZW5UYWdcIl0sXG4gICAgW1wiZ3JvdXBcIiwgLTksMTQsMTcsMTgsMTksMjAsMzksNDAsNDEsNDIsXCJFbnRpdHlcIiwxNixcIkVudGl0eSBUZXh0Q29udGVudFwiLC0zLDI4LDMxLDM0LFwiVGV4dENvbnRlbnQgRW50aXR5XCJdLFxuICAgIFtcImlzb2xhdGVcIiwgLTExLDIxLDI5LDMwLDMyLDMzLDM1LDM2LDM3LDM4LDQxLDQyLFwibHRyXCIsLTMsMjYsMjcsMzksXCJcIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtodG1sSGlnaGxpZ2h0aW5nXSxcbiAgc2tpcHBlZE5vZGVzOiBbMF0sXG4gIHJlcGVhdE5vZGVDb3VudDogOSxcbiAgdG9rZW5EYXRhOiBcIiE8cCFhUiFZT1gkcVhZLFFZWixRWlskcVtdJlhdXixRXnAkcXBxLFFxci1fcnMzX3N2LV92dzN9d3hIWXh9LV99IU9IeyFPIVAtXyFQIVEkcSFRIVstXyFbIV1NeiFdIV4tXyFeIV8hJFMhXyFgITt4IWAhYSZYIWEhYy1fIWMhfU16IX0jUi1fI1IjU016I1MjVDFrI1Qjb016I28jcy1fI3MkZiRxJGYlVy1fJVclb016JW8lcC1fJXAmYU16JmEmYi1fJmIxcE16MXA0VS1fNFU0ZE16NGQ0ZS1fNGUkSVNNeiRJUyRJYC1fJElgJEliTXokSWIkS2gtXyRLaCUjdE16JSN0Ji94LV8mL3gmRXRNeiZFdCZGVi1fJkZWOydTTXo7J1M7OmohI3w7Omo7PWAzWDwlbD8mci1fPyZyP0FoTXo/QWg/QlkkcT9CWT9Nbk16P01uTyRxIVokfGNgUGtXIWFgIWNwT1gkcVhaJlhaWyRxW14mWF5wJHFwcSZYcXIkcXJzJn1zdiRxdncrUHd4KHR4IV4kcSFeIV8qViFfIWEmWCFhI1MkcSNTI1QmWCNUOydTJHE7J1M7PWArejwlbE8kcSFSJmJYYFAhYWAhY3BPciZYcnMmfXN2Jlh3eCh0eCFeJlghXiFfKlYhXzsnUyZYOydTOz1gKnk8JWxPJlhxJ1VWYFAhY3BPdiZ9d3gna3ghXiZ9IV4hXyhWIV87J1MmfTsnUzs9YChuPCVsTyZ9UCdwVGBQT3Yna3chXidrIV87J1MnazsnUzs9YChQPCVsTydrUChTUDs9YDwlbCdrcChbUyFjcE92KFZ4OydTKFY7J1M7PWAoaDwlbE8oVnAoa1A7PWA8JWwoVnEocVA7PWA8JWwmfWEoe1dgUCFhYE9yKHRycydrc3YodHchXih0IV4hXyllIV87J1ModDsnUzs9YCpQPCVsTyh0YClqVCFhYE9yKWVzdilldzsnUyllOydTOz1gKXk8JWxPKWVgKXxQOz1gPCVsKWVhKlNQOz1gPCVsKHQhUSpeViFhYCFjcE9yKlZycyhWc3YqVnd4KWV4OydTKlY7J1M7PWAqczwlbE8qViFRKnZQOz1gPCVsKlYhUip8UDs9YDwlbCZYVytVWWtXT1grUFpbK1BecCtQcXIrUHN3K1B4IV4rUCFhI1MrUCNUOydTK1A7J1M7PWArdDwlbE8rUFcrd1A7PWA8JWwrUCFaK31QOz1gPCVsJHEhYSxdYGBQIWFgIWNwIV5eT1gmWFhZLFFZWixRWl0mWF1eLFFecCZYcHEsUXFyJlhycyZ9c3YmWHd4KHR4IV4mWCFeIV8qViFfOydTJlg7J1M7PWAqeTwlbE8mWCFfLWxqaFNgUGtXIWFgIWNwT1gkcVhaJlhaWyRxW14mWF5wJHFwcSZYcXItX3JzJn1zdi1fdncvXnd4KHR4IVAtXyFQIVEkcSFRIV4tXyFeIV8qViFfIWEmWCFhI1MtXyNTI1QxayNUI3MtXyNzJGYkcSRmOydTLV87J1M7PWAzWDwlbD9BaC1fP0FoP0JZJHE/Qlk/TW4tXz9Nbk8kcVsvZWJoU2tXT1grUFpbK1BecCtQcXIvXnN3L154IVAvXiFQIVErUCFRIV4vXiFhI1MvXiNTI1QwbSNUI3MvXiNzJGYrUCRmOydTL147J1M7PWAxZTwlbD9BaC9eP0FoP0JZK1A/Qlk/TW4vXj9Nbk8rUFMwclhoU3FyMG1zdzBteCFQMG0hUSFeMG0hYSNzMG0kZjsnUzBtOydTOz1gMV88JWw/QWgwbT9CWT9NbjBtUzFiUDs9YDwlbDBtWzFoUDs9YDwlbC9eIVYxdmNoU2BQIWFgIWNwT3EmWHFyMWtycyZ9c3Yxa3Z3MG13eCh0eCFQMWshUCFRJlghUSFeMWshXiFfKlYhXyFhJlghYSNzMWsjcyRmJlgkZjsnUzFrOydTOz1gM1I8JWw/QWgxaz9BaD9CWSZYP0JZP01uMWs/TW5PJlghVjNVUDs9YDwlbDFrIV8zW1A7PWA8JWwtXyFaM2hWIWBoYFAhY3BPdiZ9d3gna3ghXiZ9IV4hXyhWIV87J1MmfTsnUzs9YChuPCVsTyZ9IV80V2loU2tXYyFST1g1dVhaN1NaWzV1W143U15wNXVxcjh0cnM3U3N0Pl10dzh0d3g3U3ghUDh0IVAhUTV1IVEhXTh0IV0hXi9eIV4hYTdTIWEjUzh0I1MjVDt7I1Qjczh0I3MkZjV1JGY7J1M4dDsnUzs9YD5WPCVsP0FoOHQ/QWg/Qlk1dT9CWT9Nbjh0P01uTzV1IVo1emJrV09YNXVYWjdTWls1dVteN1NecDV1cXI1dXJzN1NzdCtQdHc1dXd4N1N4IV01dSFdIV43dyFeIWE3UyFhI1M1dSNTI1Q3UyNUOydTNXU7J1M7PWA4bjwlbE81dSFSN1ZWT3A3U3FzN1N0IV03UyFdIV43bCFeOydTN1M7J1M7PWA3cTwlbE83UyFSN3FPYSFSIVI3dFA7PWA8JWw3UyFaOE9Za1dhIVJPWCtQWlsrUF5wK1BxcitQc3crUHghXitQIWEjUytQI1Q7J1MrUDsnUzs9YCt0PCVsTytQIVo4cVA7PWA8JWw1dSFfOHtpaFNrV09YNXVYWjdTWls1dVteN1NecDV1cXI4dHJzN1NzdC9edHc4dHd4N1N4IVA4dCFQIVE1dSFRIV04dCFdIV46aiFeIWE3UyFhI1M4dCNTI1Q7eyNUI3M4dCNzJGY1dSRmOydTOHQ7J1M7PWA+VjwlbD9BaDh0P0FoP0JZNXU/Qlk/TW44dD9Nbk81dSFfOnNiaFNrV2EhUk9YK1BaWytQXnArUHFyL15zdy9eeCFQL14hUCFRK1AhUSFeL14hYSNTL14jUyNUMG0jVCNzL14jcyRmK1AkZjsnUy9eOydTOz1gMWU8JWw/QWgvXj9BaD9CWStQP0JZP01uL14/TW5PK1AhVjxRY2hTT3A3U3FyO3tyczdTc3QwbXR3O3t3eDdTeCFQO3shUCFRN1MhUSFdO3shXSFePV0hXiFhN1MhYSNzO3sjcyRmN1MkZjsnUzt7OydTOz1gPlA8JWw/QWg7ez9BaD9CWTdTP0JZP01uO3s/TW5PN1MhVj1kWGhTYSFScXIwbXN3MG14IVAwbSFRIV4wbSFhI3MwbSRmOydTMG07J1M7PWAxXzwlbD9BaDBtP0JZP01uMG0hVj5TUDs9YDwlbDt7IV8+WVA7PWA8JWw4dCFfPmRoaFNrV09YQE9YWkFZWltAT1teQVlecEBPcXJCd3JzQVlzd0J3d3hBWXghUEJ3IVAhUUBPIVEhXUJ3IV0hXi9eIV4hYUFZIWEjU0J3I1MjVEV7I1Qjc0J3I3MkZkBPJGY7J1NCdzsnUzs9YEhTPCVsP0FoQnc/QWg/QllATz9CWT9NbkJ3P01uT0BPIVpAVGFrV09YQE9YWkFZWltAT1teQVlecEBPcXJAT3JzQVlzd0BPd3hBWXghXUBPIV0hXkF6IV4hYUFZIWEjU0BPI1MjVEFZI1Q7J1NATzsnUzs9YEJxPCVsT0BPIVJBXVVPcEFZcSFdQVkhXSFeQW8hXjsnU0FZOydTOz1gQXQ8JWxPQVkhUkF0T2IhUiFSQXdQOz1gPCVsQVkhWkJSWWtXYiFST1grUFpbK1BecCtQcXIrUHN3K1B4IV4rUCFhI1MrUCNUOydTK1A7J1M7PWArdDwlbE8rUCFaQnRQOz1gPCVsQE8hX0NPaGhTa1dPWEBPWFpBWVpbQE9bXkFZXnBAT3FyQndyc0FZc3dCd3d4QVl4IVBCdyFQIVFATyFRIV1CdyFdIV5EaiFeIWFBWSFhI1NCdyNTI1RFeyNUI3NCdyNzJGZATyRmOydTQnc7J1M7PWBIUzwlbD9BaEJ3P0FoP0JZQE8/Qlk/TW5Cdz9Nbk9ATyFfRHNiaFNrV2IhUk9YK1BaWytQXnArUHFyL15zdy9eeCFQL14hUCFRK1AhUSFeL14hYSNTL14jUyNUMG0jVCNzL14jcyRmK1AkZjsnUy9eOydTOz1gMWU8JWw/QWgvXj9BaD9CWStQP0JZP01uL14/TW5PK1AhVkZRYmhTT3BBWXFyRXtyc0FZc3dFe3d4QVl4IVBFeyFQIVFBWSFRIV1FeyFdIV5HWSFeIWFBWSFhI3NFeyNzJGZBWSRmOydTRXs7J1M7PWBHfDwlbD9BaEV7P0FoP0JZQVk/Qlk/TW5Fez9Nbk9BWSFWR2FYaFNiIVJxcjBtc3cwbXghUDBtIVEhXjBtIWEjczBtJGY7J1MwbTsnUzs9YDFfPCVsP0FoMG0/Qlk/TW4wbSFWSFBQOz1gPCVsRXshX0hWUDs9YDwlbEJ3IVpIY1chYnhgUCFhYE9yKHRycydrc3YodHchXih0IV4hXyllIV87J1ModDsnUzs9YCpQPCVsTyh0IWFJWWxoU2BQa1chYWAhY3BPWCRxWFomWFpbJHFbXiZYXnAkcXBxJlhxci1fcnMmfXN2LV92dy9ed3godHh9LV99IU9LUSFPIVAtXyFQIVEkcSFRIV4tXyFeIV8qViFfIWEmWCFhI1MtXyNTI1QxayNUI3MtXyNzJGYkcSRmOydTLV87J1M7PWAzWDwlbD9BaC1fP0FoP0JZJHE/Qlk/TW4tXz9Nbk8kcSFhS19raFNgUGtXIWFgIWNwT1gkcVhaJlhaWyRxW14mWF5wJHFwcSZYcXItX3JzJn1zdi1fdncvXnd4KHR4IVAtXyFQIVEkcSFRIV4tXyFeIV8qViFfIWAmWCFgIWFNUyFhI1MtXyNTI1QxayNUI3MtXyNzJGYkcSRmOydTLV87J1M7PWAzWDwlbD9BaC1fP0FoP0JZJHE/Qlk/TW4tXz9Nbk8kcSFUTV9YYFAhYWAhY3AhZVFPciZYcnMmfXN2Jlh3eCh0eCFeJlghXiFfKlYhXzsnUyZYOydTOz1gKnk8JWxPJlghYU5aIVpoU2ZRYFBrVyFhYCFjcE9YJHFYWiZYWlskcVteJlhecCRxcHEmWHFyLV9ycyZ9c3YtX3Z3L153eCh0eH0tX30hT016IU8hUE16IVAhUSRxIVEhW016IVshXU16IV0hXi1fIV4hXypWIV8hYSZYIWEhYy1fIWMhfU16IX0jUi1fI1IjU016I1MjVDFrI1Qjb016I28jcy1fI3MkZiRxJGYkfS1fJH0lT016JU8lVy1fJVclb016JW8lcC1fJXAmYU16JmEmYi1fJmIxcE16MXA0VU16NFU0ZE16NGQ0ZS1fNGUkSVNNeiRJUyRJYC1fJElgJEliTXokSWIkSmUtXyRKZSRKZ016JEpnJEtoLV8kS2glI3RNeiUjdCYveC1fJi94JkV0TXomRXQmRlYtXyZGVjsnU016OydTOzpqISN8OzpqOz1gM1g8JWw/JnItXz8mcj9BaE16P0FoP0JZJHE/Qlk/TW5Nej9Nbk8kcSFhISRQUDs9YDwlbE16IVIhJFpZIWFgIWNwT3EqVnFyISR5cnMoVnN2KlZ3eClleCFhKlYhYSFiITR0IWI7J1MqVjsnUzs9YCpzPCVsTypWIVIhJVFdIWFgIWNwT3IqVnJzKFZzdipWd3gpZXh9KlZ9IU8hJXkhTyFmKlYhZiFnISddIWcjVypWI1cjWCEwYCNYOydTKlY7J1M7PWAqczwlbE8qViFSISZRWCFhYCFjcE9yKlZycyhWc3YqVnd4KWV4fSpWfSFPISZtIU87J1MqVjsnUzs9YCpzPCVsTypWIVIhJnZWIWFgIWNwIWRQT3IqVnJzKFZzdipWd3gpZXg7J1MqVjsnUzs9YCpzPCVsTypWIVIhJ2RYIWFgIWNwT3IqVnJzKFZzdipWd3gpZXghcSpWIXEhciEoUCFyOydTKlY7J1M7PWAqczwlbE8qViFSIShXWCFhYCFjcE9yKlZycyhWc3YqVnd4KWV4IWUqViFlIWYhKHMhZjsnUypWOydTOz1gKnM8JWxPKlYhUiEoelghYWAhY3BPcipWcnMoVnN2KlZ3eClleCF2KlYhdiF3ISlnIXc7J1MqVjsnUzs9YCpzPCVsTypWIVIhKW5YIWFgIWNwT3IqVnJzKFZzdipWd3gpZXgheypWIXshfCEqWiF8OydTKlY7J1M7PWAqczwlbE8qViFSISpiWCFhYCFjcE9yKlZycyhWc3YqVnd4KWV4IXIqViFyIXMhKn0hczsnUypWOydTOz1gKnM8JWxPKlYhUiErVVghYWAhY3BPcipWcnMoVnN2KlZ3eClleCFnKlYhZyFoIStxIWg7J1MqVjsnUzs9YCpzPCVsTypWIVIhK3hZIWFgIWNwT3IhK3FycyEsaHN2IStxdnchLVN3eCEuW3ghYCErcSFgIWEhL2ohYTsnUyErcTsnUzs9YCEwWTwlbE8hK3FxISxtViFjcE92ISxodnghLVN4IWAhLGghYCFhIS1xIWE7J1MhLGg7J1M7PWAhLlU8JWxPISxoUCEtVlRPIWAhLVMhYCFhIS1mIWE7J1MhLVM7J1M7PWAhLWs8JWxPIS1TUCEta097UFAhLW5QOz1gPCVsIS1TcSEteFMhY3B7UE92KFZ4OydTKFY7J1M7PWAoaDwlbE8oVnEhLlhQOz1gPCVsISxoYSEuYVghYWBPciEuW3JzIS1Tc3YhLlt2dyEtU3chYCEuWyFgIWEhLnwhYTsnUyEuWzsnUzs9YCEvZDwlbE8hLlthIS9UVCFhYHtQT3IpZXN2KWV3OydTKWU7J1M7PWApeTwlbE8pZWEhL2dQOz1gPCVsIS5bIVIhL3NWIWFgIWNwe1BPcipWcnMoVnN2KlZ3eClleDsnUypWOydTOz1gKnM8JWxPKlYhUiEwXVA7PWA8JWwhK3EhUiEwZ1ghYWAhY3BPcipWcnMoVnN2KlZ3eClleCNjKlYjYyNkITFTI2Q7J1MqVjsnUzs9YCpzPCVsTypWIVIhMVpYIWFgIWNwT3IqVnJzKFZzdipWd3gpZXgjVipWI1YjVyExdiNXOydTKlY7J1M7PWAqczwlbE8qViFSITF9WCFhYCFjcE9yKlZycyhWc3YqVnd4KWV4I2gqViNoI2khMmojaTsnUypWOydTOz1gKnM8JWxPKlYhUiEycVghYWAhY3BPcipWcnMoVnN2KlZ3eClleCNtKlYjbSNuITNeI247J1MqVjsnUzs9YCpzPCVsTypWIVIhM2VYIWFgIWNwT3IqVnJzKFZzdipWd3gpZXgjZCpWI2QjZSE0USNlOydTKlY7J1M7PWAqczwlbE8qViFSITRYWCFhYCFjcE9yKlZycyhWc3YqVnd4KWV4I1gqViNYI1khK3EjWTsnUypWOydTOz1gKnM8JWxPKlYhUiE0e1khYWAhY3BPciE0dHJzITVrc3YhNHR2dyE2Vnd4IThdeCFhITR0IWEhYiE6XSFiOydTITR0OydTOz1gITtyPCVsTyE0dHEhNXBWIWNwT3YhNWt2eCE2VnghYSE1ayFhIWIhN1chYjsnUyE1azsnUzs9YCE4VjwlbE8hNWtQITZZVE8hYSE2ViFhIWIhNmkhYjsnUyE2VjsnUzs9YCE3UTwlbE8hNlZQITZsVE8hYCE2ViFgIWEhNnshYTsnUyE2VjsnUzs9YCE3UTwlbE8hNlZQITdRT3hQUCE3VFA7PWA8JWwhNlZxITddViFjcE92ITVrdnghNlZ4IWAhNWshYCFhITdyIWE7J1MhNWs7J1M7PWAhOFY8JWxPITVrcSE3eVMhY3B4UE92KFZ4OydTKFY7J1M7PWAoaDwlbE8oVnEhOFlQOz1gPCVsITVrYSE4YlghYWBPciE4XXJzITZWc3YhOF12dyE2VnchYSE4XSFhIWIhOH0hYjsnUyE4XTsnUzs9YCE6VjwlbE8hOF1hITlTWCFhYE9yIThdcnMhNlZzdiE4XXZ3ITZWdyFgIThdIWAhYSE5byFhOydTIThdOydTOz1gITpWPCVsTyE4XWEhOXZUIWFgeFBPcillc3YpZXc7J1MpZTsnUzs9YCl5PCVsTyllYSE6WVA7PWA8JWwhOF0hUiE6ZFkhYWAhY3BPciE0dHJzITVrc3YhNHR2dyE2Vnd4IThdeCFgITR0IWAhYSE7UyFhOydTITR0OydTOz1gITtyPCVsTyE0dCFSITtdViFhYCFjcHhQT3IqVnJzKFZzdipWd3gpZXg7J1MqVjsnUzs9YCpzPCVsTypWIVIhO3VQOz1gPCVsITR0IVYhPFRYaVNgUCFhYCFjcE9yJlhycyZ9c3YmWHd4KHR4IV4mWCFeIV8qViFfOydTJlg7J1M7PWAqeTwlbE8mWFwiLFxuICB0b2tlbml6ZXJzOiBbc2NyaXB0VG9rZW5zLCBzdHlsZVRva2VucywgdGV4dGFyZWFUb2tlbnMsIGVuZFRhZywgdGFnU3RhcnQsIGNvbW1lbnRDb250ZW50LCAwLCAxLCAyLCAzLCA0LCA1XSxcbiAgdG9wUnVsZXM6IHtcIkRvY3VtZW50XCI6WzAsMTVdfSxcbiAgZGlhbGVjdHM6IHtub01hdGNoOiAwLCBzZWxmQ2xvc2luZzogNTA5fSxcbiAgdG9rZW5QcmVjOiA1MTFcbn0pO1xuXG5mdW5jdGlvbiBnZXRBdHRycyhvcGVuVGFnLCBpbnB1dCkge1xuICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGxldCBhdHQgb2Ygb3BlblRhZy5nZXRDaGlsZHJlbihBdHRyaWJ1dGUpKSB7XG4gICAgbGV0IG5hbWUgPSBhdHQuZ2V0Q2hpbGQoQXR0cmlidXRlTmFtZSksIHZhbHVlID0gYXR0LmdldENoaWxkKEF0dHJpYnV0ZVZhbHVlKSB8fCBhdHQuZ2V0Q2hpbGQoVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSk7XG4gICAgaWYgKG5hbWUpIGF0dHJzW2lucHV0LnJlYWQobmFtZS5mcm9tLCBuYW1lLnRvKV0gPVxuICAgICAgIXZhbHVlID8gXCJcIiA6IHZhbHVlLnR5cGUuaWQgPT0gQXR0cmlidXRlVmFsdWUgPyBpbnB1dC5yZWFkKHZhbHVlLmZyb20gKyAxLCB2YWx1ZS50byAtIDEpIDogaW5wdXQucmVhZCh2YWx1ZS5mcm9tLCB2YWx1ZS50byk7XG4gIH1cbiAgcmV0dXJuIGF0dHJzXG59XG5cbmZ1bmN0aW9uIGZpbmRUYWdOYW1lKG9wZW5UYWcsIGlucHV0KSB7XG4gIGxldCB0YWdOYW1lTm9kZSA9IG9wZW5UYWcuZ2V0Q2hpbGQoVGFnTmFtZSk7XG4gIHJldHVybiB0YWdOYW1lTm9kZSA/IGlucHV0LnJlYWQodGFnTmFtZU5vZGUuZnJvbSwgdGFnTmFtZU5vZGUudG8pIDogXCIgXCJcbn1cblxuZnVuY3Rpb24gbWF5YmVOZXN0KG5vZGUsIGlucHV0LCB0YWdzKSB7XG4gIGxldCBhdHRycztcbiAgZm9yIChsZXQgdGFnIG9mIHRhZ3MpIHtcbiAgICBpZiAoIXRhZy5hdHRycyB8fCB0YWcuYXR0cnMoYXR0cnMgfHwgKGF0dHJzID0gZ2V0QXR0cnMobm9kZS5ub2RlLnBhcmVudC5maXJzdENoaWxkLCBpbnB1dCkpKSlcbiAgICAgIHJldHVybiB7cGFyc2VyOiB0YWcucGFyc2VyfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8vIHRhZ3M/OiB7XG4vLyAgIHRhZzogc3RyaW5nLFxuLy8gICBhdHRycz86ICh7W2F0dHI6IHN0cmluZ106IHN0cmluZ30pID0+IGJvb2xlYW4sXG4vLyAgIHBhcnNlcjogUGFyc2VyXG4vLyB9W11cbi8vIGF0dHJpYnV0ZXM/OiB7XG4vLyAgIG5hbWU6IHN0cmluZyxcbi8vICAgdGFnTmFtZT86IHN0cmluZyxcbi8vICAgcGFyc2VyOiBQYXJzZXJcbi8vIH1bXVxuIFxuZnVuY3Rpb24gY29uZmlndXJlTmVzdGluZyh0YWdzID0gW10sIGF0dHJpYnV0ZXMgPSBbXSkge1xuICBsZXQgc2NyaXB0ID0gW10sIHN0eWxlID0gW10sIHRleHRhcmVhID0gW10sIG90aGVyID0gW107XG4gIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgbGV0IGFycmF5ID0gdGFnLnRhZyA9PSBcInNjcmlwdFwiID8gc2NyaXB0IDogdGFnLnRhZyA9PSBcInN0eWxlXCIgPyBzdHlsZSA6IHRhZy50YWcgPT0gXCJ0ZXh0YXJlYVwiID8gdGV4dGFyZWEgOiBvdGhlcjtcbiAgICBhcnJheS5wdXNoKHRhZyk7XG4gIH1cbiAgbGV0IGF0dHJzID0gYXR0cmlidXRlcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbnVsbDtcbiAgZm9yIChsZXQgYXR0ciBvZiBhdHRyaWJ1dGVzKSAoYXR0cnNbYXR0ci5uYW1lXSB8fCAoYXR0cnNbYXR0ci5uYW1lXSA9IFtdKSkucHVzaChhdHRyKTtcblxuICByZXR1cm4gY29tbW9uLnBhcnNlTWl4ZWQoKG5vZGUsIGlucHV0KSA9PiB7XG4gICAgbGV0IGlkID0gbm9kZS50eXBlLmlkO1xuICAgIGlmIChpZCA9PSBTY3JpcHRUZXh0KSByZXR1cm4gbWF5YmVOZXN0KG5vZGUsIGlucHV0LCBzY3JpcHQpXG4gICAgaWYgKGlkID09IFN0eWxlVGV4dCkgcmV0dXJuIG1heWJlTmVzdChub2RlLCBpbnB1dCwgc3R5bGUpXG4gICAgaWYgKGlkID09IFRleHRhcmVhVGV4dCkgcmV0dXJuIG1heWJlTmVzdChub2RlLCBpbnB1dCwgdGV4dGFyZWEpXG5cbiAgICBpZiAoaWQgPT0gRWxlbWVudCAmJiBvdGhlci5sZW5ndGgpIHtcbiAgICAgIGxldCBuID0gbm9kZS5ub2RlLCBvcGVuID0gbi5maXJzdENoaWxkLCB0YWdOYW1lID0gb3BlbiAmJiBmaW5kVGFnTmFtZShvcGVuLCBpbnB1dCksIGF0dHJzO1xuICAgICAgaWYgKHRhZ05hbWUpIGZvciAobGV0IHRhZyBvZiBvdGhlcikge1xuICAgICAgICBpZiAodGFnLnRhZyA9PSB0YWdOYW1lICYmICghdGFnLmF0dHJzIHx8IHRhZy5hdHRycyhhdHRycyB8fCAoYXR0cnMgPSBnZXRBdHRycyhvcGVuLCBpbnB1dCkpKSkpIHtcbiAgICAgICAgICBsZXQgY2xvc2UgPSBuLmxhc3RDaGlsZDtcbiAgICAgICAgICBsZXQgdG8gPSBjbG9zZS50eXBlLmlkID09IENsb3NlVGFnID8gY2xvc2UuZnJvbSA6IG4udG87XG4gICAgICAgICAgaWYgKHRvID4gb3Blbi50bylcbiAgICAgICAgICAgIHJldHVybiB7cGFyc2VyOiB0YWcucGFyc2VyLCBvdmVybGF5OiBbe2Zyb206IG9wZW4udG8sIHRvfV19XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXR0cnMgJiYgaWQgPT0gQXR0cmlidXRlKSB7XG4gICAgICBsZXQgbiA9IG5vZGUubm9kZSwgbmFtZU5vZGU7XG4gICAgICBpZiAobmFtZU5vZGUgPSBuLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBhdHRyc1tpbnB1dC5yZWFkKG5hbWVOb2RlLmZyb20sIG5hbWVOb2RlLnRvKV07XG4gICAgICAgIGlmIChtYXRjaGVzKSBmb3IgKGxldCBhdHRyIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICBpZiAoYXR0ci50YWdOYW1lICYmIGF0dHIudGFnTmFtZSAhPSBmaW5kVGFnTmFtZShuLnBhcmVudCwgaW5wdXQpKSBjb250aW51ZVxuICAgICAgICAgIGxldCB2YWx1ZSA9IG4ubGFzdENoaWxkO1xuICAgICAgICAgIGlmICh2YWx1ZS50eXBlLmlkID09IEF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHZhbHVlLmZyb20gKyAxO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB2YWx1ZS5sYXN0Q2hpbGQsIHRvID0gdmFsdWUudG8gLSAobGFzdCAmJiBsYXN0LmlzRXJyb3IgPyAwIDogMSk7XG4gICAgICAgICAgICBpZiAodG8gPiBmcm9tKSByZXR1cm4ge3BhcnNlcjogYXR0ci5wYXJzZXIsIG92ZXJsYXk6IFt7ZnJvbSwgdG99XX1cbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUuaWQgPT0gVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtwYXJzZXI6IGF0dHIucGFyc2VyLCBvdmVybGF5OiBbe2Zyb206IHZhbHVlLmZyb20sIHRvOiB2YWx1ZS50b31dfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9KVxufVxuXG5leHBvcnRzLmNvbmZpZ3VyZU5lc3RpbmcgPSBjb25maWd1cmVOZXN0aW5nO1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBsciA9IHJlcXVpcmUoJ0BsZXplci9scicpO1xudmFyIGhpZ2hsaWdodCA9IHJlcXVpcmUoJ0BsZXplci9oaWdobGlnaHQnKTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBub1NlbWkgPSAzMTQsXG4gIG5vU2VtaVR5cGUgPSAzMTUsXG4gIGluY2RlYyA9IDEsXG4gIGluY2RlY1ByZWZpeCA9IDIsXG4gIHF1ZXN0aW9uRG90ID0gMyxcbiAgSlNYU3RhcnRUYWcgPSA0LFxuICBpbnNlcnRTZW1pID0gMzE2LFxuICBzcGFjZXMgPSAzMTgsXG4gIG5ld2xpbmUgPSAzMTksXG4gIExpbmVDb21tZW50ID0gNSxcbiAgQmxvY2tDb21tZW50ID0gNixcbiAgRGlhbGVjdF9qc3ggPSAwO1xuXG4vKiBIYW5kLXdyaXR0ZW4gdG9rZW5pemVycyBmb3IgSmF2YVNjcmlwdCB0b2tlbnMgdGhhdCBjYW4ndCBiZVxuICAgZXhwcmVzc2VkIGJ5IGxlemVyJ3MgYnVpbHQtaW4gdG9rZW5pemVyLiAqL1xuXG5jb25zdCBzcGFjZSA9IFs5LCAxMCwgMTEsIDEyLCAxMywgMzIsIDEzMywgMTYwLCA1NzYwLCA4MTkyLCA4MTkzLCA4MTk0LCA4MTk1LCA4MTk2LCA4MTk3LCA4MTk4LCA4MTk5LCA4MjAwLFxuICAgICAgICAgICAgICAgODIwMSwgODIwMiwgODIzMiwgODIzMywgODIzOSwgODI4NywgMTIyODhdO1xuXG5jb25zdCBicmFjZVIgPSAxMjUsIHNlbWljb2xvbiA9IDU5LCBzbGFzaCA9IDQ3LCBzdGFyID0gNDIsIHBsdXMgPSA0MywgbWludXMgPSA0NSwgbHQgPSA2MCwgY29tbWEgPSA0NCxcbiAgICAgIHF1ZXN0aW9uID0gNjMsIGRvdCA9IDQ2LCBicmFja2V0TCA9IDkxO1xuXG5jb25zdCB0cmFja05ld2xpbmUgPSBuZXcgbHIuQ29udGV4dFRyYWNrZXIoe1xuICBzdGFydDogZmFsc2UsXG4gIHNoaWZ0KGNvbnRleHQsIHRlcm0pIHtcbiAgICByZXR1cm4gdGVybSA9PSBMaW5lQ29tbWVudCB8fCB0ZXJtID09IEJsb2NrQ29tbWVudCB8fCB0ZXJtID09IHNwYWNlcyA/IGNvbnRleHQgOiB0ZXJtID09IG5ld2xpbmVcbiAgfSxcbiAgc3RyaWN0OiBmYWxzZVxufSk7XG5cbmNvbnN0IGluc2VydFNlbWljb2xvbiA9IG5ldyBsci5FeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGxldCB7bmV4dH0gPSBpbnB1dDtcbiAgaWYgKG5leHQgPT0gYnJhY2VSIHx8IG5leHQgPT0gLTEgfHwgc3RhY2suY29udGV4dClcbiAgICBpbnB1dC5hY2NlcHRUb2tlbihpbnNlcnRTZW1pKTtcbn0sIHtjb250ZXh0dWFsOiB0cnVlLCBmYWxsYmFjazogdHJ1ZX0pO1xuXG5jb25zdCBub1NlbWljb2xvbiA9IG5ldyBsci5FeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGxldCB7bmV4dH0gPSBpbnB1dCwgYWZ0ZXI7XG4gIGlmIChzcGFjZS5pbmRleE9mKG5leHQpID4gLTEpIHJldHVyblxuICBpZiAobmV4dCA9PSBzbGFzaCAmJiAoKGFmdGVyID0gaW5wdXQucGVlaygxKSkgPT0gc2xhc2ggfHwgYWZ0ZXIgPT0gc3RhcikpIHJldHVyblxuICBpZiAobmV4dCAhPSBicmFjZVIgJiYgbmV4dCAhPSBzZW1pY29sb24gJiYgbmV4dCAhPSAtMSAmJiAhc3RhY2suY29udGV4dClcbiAgICBpbnB1dC5hY2NlcHRUb2tlbihub1NlbWkpO1xufSwge2NvbnRleHR1YWw6IHRydWV9KTtcblxuY29uc3Qgbm9TZW1pY29sb25UeXBlID0gbmV3IGxyLkV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgaWYgKGlucHV0Lm5leHQgPT0gYnJhY2tldEwgJiYgIXN0YWNrLmNvbnRleHQpIGlucHV0LmFjY2VwdFRva2VuKG5vU2VtaVR5cGUpO1xufSwge2NvbnRleHR1YWw6IHRydWV9KTtcblxuY29uc3Qgb3BlcmF0b3JUb2tlbiA9IG5ldyBsci5FeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGxldCB7bmV4dH0gPSBpbnB1dDtcbiAgaWYgKG5leHQgPT0gcGx1cyB8fCBuZXh0ID09IG1pbnVzKSB7XG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgIGlmIChuZXh0ID09IGlucHV0Lm5leHQpIHtcbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIGxldCBtYXlQb3N0Zml4ID0gIXN0YWNrLmNvbnRleHQgJiYgc3RhY2suY2FuU2hpZnQoaW5jZGVjKTtcbiAgICAgIGlucHV0LmFjY2VwdFRva2VuKG1heVBvc3RmaXggPyBpbmNkZWMgOiBpbmNkZWNQcmVmaXgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChuZXh0ID09IHF1ZXN0aW9uICYmIGlucHV0LnBlZWsoMSkgPT0gZG90KSB7XG4gICAgaW5wdXQuYWR2YW5jZSgpOyBpbnB1dC5hZHZhbmNlKCk7XG4gICAgaWYgKGlucHV0Lm5leHQgPCA0OCB8fCBpbnB1dC5uZXh0ID4gNTcpIC8vIE5vIGRpZ2l0IGFmdGVyXG4gICAgICBpbnB1dC5hY2NlcHRUb2tlbihxdWVzdGlvbkRvdCk7XG4gIH1cbn0sIHtjb250ZXh0dWFsOiB0cnVlfSk7XG5cbmZ1bmN0aW9uIGlkZW50aWZpZXJDaGFyKGNoLCBzdGFydCkge1xuICByZXR1cm4gY2ggPj0gNjUgJiYgY2ggPD0gOTAgfHwgY2ggPj0gOTcgJiYgY2ggPD0gMTIyIHx8IGNoID09IDk1IHx8IGNoID49IDE5MiB8fFxuICAgICFzdGFydCAmJiBjaCA+PSA0OCAmJiBjaCA8PSA1N1xufVxuXG5jb25zdCBqc3ggPSBuZXcgbHIuRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCAhPSBsdCB8fCAhc3RhY2suZGlhbGVjdEVuYWJsZWQoRGlhbGVjdF9qc3gpKSByZXR1cm5cbiAgaW5wdXQuYWR2YW5jZSgpO1xuICBpZiAoaW5wdXQubmV4dCA9PSBzbGFzaCkgcmV0dXJuXG4gIC8vIFNjYW4gZm9yIGFuIGlkZW50aWZpZXIgZm9sbG93ZWQgYnkgYSBjb21tYSBvciAnZXh0ZW5kcycsIGRvbid0XG4gIC8vIHRyZWF0IHRoaXMgYXMgYSBzdGFydCB0YWcgaWYgcHJlc2VudC5cbiAgbGV0IGJhY2sgPSAwO1xuICB3aGlsZSAoc3BhY2UuaW5kZXhPZihpbnB1dC5uZXh0KSA+IC0xKSB7IGlucHV0LmFkdmFuY2UoKTsgYmFjaysrOyB9XG4gIGlmIChpZGVudGlmaWVyQ2hhcihpbnB1dC5uZXh0LCB0cnVlKSkge1xuICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICBiYWNrKys7XG4gICAgd2hpbGUgKGlkZW50aWZpZXJDaGFyKGlucHV0Lm5leHQsIGZhbHNlKSkgeyBpbnB1dC5hZHZhbmNlKCk7IGJhY2srKzsgfVxuICAgIHdoaWxlIChzcGFjZS5pbmRleE9mKGlucHV0Lm5leHQpID4gLTEpIHsgaW5wdXQuYWR2YW5jZSgpOyBiYWNrKys7IH1cbiAgICBpZiAoaW5wdXQubmV4dCA9PSBjb21tYSkgcmV0dXJuXG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgIGlmIChpID09IDcpIHtcbiAgICAgICAgaWYgKCFpZGVudGlmaWVyQ2hhcihpbnB1dC5uZXh0LCB0cnVlKSkgcmV0dXJuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaW5wdXQubmV4dCAhPSBcImV4dGVuZHNcIi5jaGFyQ29kZUF0KGkpKSBicmVha1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgYmFjaysrO1xuICAgIH1cbiAgfVxuICBpbnB1dC5hY2NlcHRUb2tlbihKU1hTdGFydFRhZywgLWJhY2spO1xufSk7XG5cbmNvbnN0IGpzSGlnaGxpZ2h0ID0gaGlnaGxpZ2h0LnN0eWxlVGFncyh7XG4gIFwiZ2V0IHNldCBhc3luYyBzdGF0aWNcIjogaGlnaGxpZ2h0LnRhZ3MubW9kaWZpZXIsXG4gIFwiZm9yIHdoaWxlIGRvIGlmIGVsc2Ugc3dpdGNoIHRyeSBjYXRjaCBmaW5hbGx5IHJldHVybiB0aHJvdyBicmVhayBjb250aW51ZSBkZWZhdWx0IGNhc2VcIjogaGlnaGxpZ2h0LnRhZ3MuY29udHJvbEtleXdvcmQsXG4gIFwiaW4gb2YgYXdhaXQgeWllbGQgdm9pZCB0eXBlb2YgZGVsZXRlIGluc3RhbmNlb2ZcIjogaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuICBcImxldCB2YXIgY29uc3QgdXNpbmcgZnVuY3Rpb24gY2xhc3MgZXh0ZW5kc1wiOiBoaWdobGlnaHQudGFncy5kZWZpbml0aW9uS2V5d29yZCxcbiAgXCJpbXBvcnQgZXhwb3J0IGZyb21cIjogaGlnaGxpZ2h0LnRhZ3MubW9kdWxlS2V5d29yZCxcbiAgXCJ3aXRoIGRlYnVnZ2VyIGFzIG5ld1wiOiBoaWdobGlnaHQudGFncy5rZXl3b3JkLFxuICBUZW1wbGF0ZVN0cmluZzogaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbChoaWdobGlnaHQudGFncy5zdHJpbmcpLFxuICBzdXBlcjogaGlnaGxpZ2h0LnRhZ3MuYXRvbSxcbiAgQm9vbGVhbkxpdGVyYWw6IGhpZ2hsaWdodC50YWdzLmJvb2wsXG4gIHRoaXM6IGhpZ2hsaWdodC50YWdzLnNlbGYsXG4gIG51bGw6IGhpZ2hsaWdodC50YWdzLm51bGwsXG4gIFN0YXI6IGhpZ2hsaWdodC50YWdzLm1vZGlmaWVyLFxuICBWYXJpYWJsZU5hbWU6IGhpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSxcbiAgXCJDYWxsRXhwcmVzc2lvbi9WYXJpYWJsZU5hbWUgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uL1ZhcmlhYmxlTmFtZVwiOiBoaWdobGlnaHQudGFncy5mdW5jdGlvbihoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpLFxuICBWYXJpYWJsZURlZmluaXRpb246IGhpZ2hsaWdodC50YWdzLmRlZmluaXRpb24oaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSxcbiAgTGFiZWw6IGhpZ2hsaWdodC50YWdzLmxhYmVsTmFtZSxcbiAgUHJvcGVydHlOYW1lOiBoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUsXG4gIFByaXZhdGVQcm9wZXJ0eU5hbWU6IGhpZ2hsaWdodC50YWdzLnNwZWNpYWwoaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSxcbiAgXCJDYWxsRXhwcmVzc2lvbi9NZW1iZXJFeHByZXNzaW9uL1Byb3BlcnR5TmFtZVwiOiBoaWdobGlnaHQudGFncy5mdW5jdGlvbihoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpLFxuICBcIkZ1bmN0aW9uRGVjbGFyYXRpb24vVmFyaWFibGVEZWZpbml0aW9uXCI6IGhpZ2hsaWdodC50YWdzLmZ1bmN0aW9uKGhpZ2hsaWdodC50YWdzLmRlZmluaXRpb24oaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSksXG4gIFwiQ2xhc3NEZWNsYXJhdGlvbi9WYXJpYWJsZURlZmluaXRpb25cIjogaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbihoaWdobGlnaHQudGFncy5jbGFzc05hbWUpLFxuICBcIk5ld0V4cHJlc3Npb24vVmFyaWFibGVOYW1lXCI6IGhpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSxcbiAgUHJvcGVydHlEZWZpbml0aW9uOiBoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKGhpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSksXG4gIFByaXZhdGVQcm9wZXJ0eURlZmluaXRpb246IGhpZ2hsaWdodC50YWdzLmRlZmluaXRpb24oaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbChoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpKSxcbiAgVXBkYXRlT3A6IGhpZ2hsaWdodC50YWdzLnVwZGF0ZU9wZXJhdG9yLFxuICBcIkxpbmVDb21tZW50IEhhc2hiYW5nXCI6IGhpZ2hsaWdodC50YWdzLmxpbmVDb21tZW50LFxuICBCbG9ja0NvbW1lbnQ6IGhpZ2hsaWdodC50YWdzLmJsb2NrQ29tbWVudCxcbiAgTnVtYmVyOiBoaWdobGlnaHQudGFncy5udW1iZXIsXG4gIFN0cmluZzogaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nLFxuICBFc2NhcGU6IGhpZ2hsaWdodC50YWdzLmVzY2FwZSxcbiAgQXJpdGhPcDogaGlnaGxpZ2h0LnRhZ3MuYXJpdGhtZXRpY09wZXJhdG9yLFxuICBMb2dpY09wOiBoaWdobGlnaHQudGFncy5sb2dpY09wZXJhdG9yLFxuICBCaXRPcDogaGlnaGxpZ2h0LnRhZ3MuYml0d2lzZU9wZXJhdG9yLFxuICBDb21wYXJlT3A6IGhpZ2hsaWdodC50YWdzLmNvbXBhcmVPcGVyYXRvcixcbiAgUmVnRXhwOiBoaWdobGlnaHQudGFncy5yZWdleHAsXG4gIEVxdWFsczogaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbk9wZXJhdG9yLFxuICBBcnJvdzogaGlnaGxpZ2h0LnRhZ3MuZnVuY3Rpb24oaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pLFxuICBcIjogU3ByZWFkXCI6IGhpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uLFxuICBcIiggKVwiOiBoaWdobGlnaHQudGFncy5wYXJlbixcbiAgXCJbIF1cIjogaGlnaGxpZ2h0LnRhZ3Muc3F1YXJlQnJhY2tldCxcbiAgXCJ7IH1cIjogaGlnaGxpZ2h0LnRhZ3MuYnJhY2UsXG4gIFwiSW50ZXJwb2xhdGlvblN0YXJ0IEludGVycG9sYXRpb25FbmRcIjogaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbChoaWdobGlnaHQudGFncy5icmFjZSksXG4gIFwiLlwiOiBoaWdobGlnaHQudGFncy5kZXJlZk9wZXJhdG9yLFxuICBcIiwgO1wiOiBoaWdobGlnaHQudGFncy5zZXBhcmF0b3IsXG4gIFwiQFwiOiBoaWdobGlnaHQudGFncy5tZXRhLFxuXG4gIFR5cGVOYW1lOiBoaWdobGlnaHQudGFncy50eXBlTmFtZSxcbiAgVHlwZURlZmluaXRpb246IGhpZ2hsaWdodC50YWdzLmRlZmluaXRpb24oaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpLFxuICBcInR5cGUgZW51bSBpbnRlcmZhY2UgaW1wbGVtZW50cyBuYW1lc3BhY2UgbW9kdWxlIGRlY2xhcmVcIjogaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiYWJzdHJhY3QgZ2xvYmFsIFByaXZhY3kgcmVhZG9ubHkgb3ZlcnJpZGVcIjogaGlnaGxpZ2h0LnRhZ3MubW9kaWZpZXIsXG4gIFwiaXMga2V5b2YgdW5pcXVlIGluZmVyIGFzc2VydHNcIjogaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuXG4gIEpTWEF0dHJpYnV0ZVZhbHVlOiBoaWdobGlnaHQudGFncy5hdHRyaWJ1dGVWYWx1ZSxcbiAgSlNYVGV4dDogaGlnaGxpZ2h0LnRhZ3MuY29udGVudCxcbiAgXCJKU1hTdGFydFRhZyBKU1hTdGFydENsb3NlVGFnIEpTWFNlbGZDbG9zZUVuZFRhZyBKU1hFbmRUYWdcIjogaGlnaGxpZ2h0LnRhZ3MuYW5nbGVCcmFja2V0LFxuICBcIkpTWElkZW50aWZpZXIgSlNYTmFtZVNwYWNlZE5hbWVcIjogaGlnaGxpZ2h0LnRhZ3MudGFnTmFtZSxcbiAgXCJKU1hBdHRyaWJ1dGUvSlNYSWRlbnRpZmllciBKU1hBdHRyaWJ1dGUvSlNYTmFtZVNwYWNlZE5hbWVcIjogaGlnaGxpZ2h0LnRhZ3MuYXR0cmlidXRlTmFtZSxcbiAgXCJKU1hCdWlsdGluL0pTWElkZW50aWZpZXJcIjogaGlnaGxpZ2h0LnRhZ3Muc3RhbmRhcmQoaGlnaGxpZ2h0LnRhZ3MudGFnTmFtZSlcbn0pO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNwZWNfaWRlbnRpZmllciA9IHtfX3Byb3RvX186bnVsbCxleHBvcnQ6MjAsIGFzOjI1LCBmcm9tOjMzLCBkZWZhdWx0OjM2LCBhc3luYzo0MSwgZnVuY3Rpb246NDIsIGNvbnN0OjUyLCBleHRlbmRzOjU2LCB0aGlzOjYwLCB0cnVlOjY4LCBmYWxzZTo2OCwgbnVsbDo4MCwgdm9pZDo4NCwgdHlwZW9mOjg4LCBzdXBlcjoxMDQsIG5ldzoxMzgsIGRlbGV0ZToxNTAsIHlpZWxkOjE1OSwgYXdhaXQ6MTYzLCBjbGFzczoxNjgsIHB1YmxpYzoyMzEsIHByaXZhdGU6MjMxLCBwcm90ZWN0ZWQ6MjMxLCByZWFkb25seToyMzMsIGluc3RhbmNlb2Y6MjUyLCBzYXRpc2ZpZXM6MjU1LCBpbjoyNTYsIGltcG9ydDoyOTAsIGtleW9mOjM0NywgdW5pcXVlOjM1MSwgaW5mZXI6MzU3LCBhc3NlcnRzOjM5MywgaXM6Mzk1LCBhYnN0cmFjdDo0MTUsIGltcGxlbWVudHM6NDE3LCB0eXBlOjQxOSwgbGV0OjQyMiwgdmFyOjQyNCwgdXNpbmc6NDI3LCBpbnRlcmZhY2U6NDMzLCBlbnVtOjQzNywgbmFtZXNwYWNlOjQ0MywgbW9kdWxlOjQ0NSwgZGVjbGFyZTo0NDksIGdsb2JhbDo0NTMsIGZvcjo0NzIsIG9mOjQ4MSwgd2hpbGU6NDg0LCB3aXRoOjQ4OCwgZG86NDkyLCBpZjo0OTYsIGVsc2U6NDk4LCBzd2l0Y2g6NTAyLCBjYXNlOjUwOCwgdHJ5OjUxNCwgY2F0Y2g6NTE4LCBmaW5hbGx5OjUyMiwgcmV0dXJuOjUyNiwgdGhyb3c6NTMwLCBicmVhazo1MzQsIGNvbnRpbnVlOjUzOCwgZGVidWdnZXI6NTQyfTtcbmNvbnN0IHNwZWNfd29yZCA9IHtfX3Byb3RvX186bnVsbCxhc3luYzoxMjUsIGdldDoxMjcsIHNldDoxMjksIGRlY2xhcmU6MTkxLCBwdWJsaWM6MTkzLCBwcml2YXRlOjE5MywgcHJvdGVjdGVkOjE5Mywgc3RhdGljOjE5NSwgYWJzdHJhY3Q6MTk3LCBvdmVycmlkZToxOTksIHJlYWRvbmx5OjIwNSwgYWNjZXNzb3I6MjA3LCBuZXc6Mzk5fTtcbmNvbnN0IHNwZWNfTGVzc1RoYW4gPSB7X19wcm90b19fOm51bGwsXCI8XCI6MTg5fTtcbmNvbnN0IHBhcnNlciA9IGxyLkxSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIkRU9RJVRRbE9PTyVbUWxPT08nX1FwT09QKGxPYE9PTyp6USEwTXhPJyNDaU8rUk8jdE8nI0NqTythTyZqTycjQ2pPK29PI0BJdE8nI0RfTy5RUWxPJyNEZU8uYlFsTycjRHBPJVtRbE8nI0R4TzBmUWxPJyNFUU9PUSEwTGYnI0VZJyNFWU8xUFFgTycjRVZPT1FPJyNFbicjRW5PT1FPJyNJaicjSWpPMVhRYE8nI0dyTzFkUWBPJyNFbU8xaVFgTycjRW1PM2hRITBNeE8nI0pwTzZbUSEwTXhPJyNKcU82dVFgTycjRltPNnpRLFVPJyNGc09PUSEwTGYnI0ZlJyNGZU83Vk83ZE8nI0ZlTzdlUU1oTycjRntPOVVRYE8nI0Z6T09RITBMZicjSnEnI0pxT09RITBMYicjSnAnI0pwTzlaUWBPJyNHdk9PUVsnI0tdJyNLXU85ZlFgTycjSVdPOWtRITBMck8nI0lYT09RWycjSl4nI0peT09RWycjSV0nI0ldUWBRbE9PUWBRbE9PTzlzUSFMXk8nI0R0Tzl6UWxPJyNEfE86UlFsTycjRU9POWFRYE8nI0dyTzpZUU1oTycjQ29POmhRYE8nI0VsTzpzUWBPJyNFd086eFFNaE8nI0ZkTztnUWBPJyNHck9PUU8nI0teJyNLXk87bFFgTycjS15PO3pRYE8nI0d6Tzt6UWBPJyNHe087elFgTycjR31POWFRYE8nI0hRTzxxUWBPJyNIVE8+WVFgTycjQ2VPPmpRYE8nI0hhTz5yUWBPJyNIZ08+clFgTycjSGlPYFFsTycjSGtPPnJRYE8nI0htTz5yUWBPJyNIcE8+d1FgTycjSHZPPnxRITBMc08nI0h8TyVbUWxPJyNJT08/WFEhMExzTycjSVFPP2RRITBMc08nI0lTTzlrUSEwTHJPJyNJVU8/b1EhME14TycjQ2lPQHFRcE8nI0RqUU9RYE9PTyVbUWxPJyNFT09BWFFgTycjRVJPOllRTWhPJyNFbE9BZFFgTycjRWxPQW9RIWJPJyNGZE9PUVsnI0NnJyNDZ09PUSEwTGInI0RvJyNEb09PUSEwTGInI0p0JyNKdE8lW1FsTycjSnRPT1FPJyNKdycjSndPT1FPJyNJZicjSWZPQm9RcE8nI0VlT09RITBMYicjRWQnI0VkT09RITBMYicjSnsnI0p7T0NrUSEwTVNPJyNFZU9DdVFwTycjRVVPT1FPJyNKdicjSnZPRFpRcE8nI0p3T0VoUXBPJyNFVU9DdVFwTycjRWVQRXVPJjJEak8nI0NiUE9PTylDRHspQ0R7T09PTycjSV4nI0leT0ZRTyN0Tyw1OVVPT1EhMExoLDU5VSw1OVVPT09PJyNJXycjSV9PRmBPJmpPLDU5VU9GblEhTF5PJyNEYU9PT08nI0lhJyNJYU9GdU8jQEl0Tyw1OXlPT1EhMExmLDU5eSw1OXlPR1RRbE8nI0liT0doUWBPJyNKck9JZ1EhZk8nI0pyTyt9UWxPJyNKck9JblFgTyw1OlBPSlVRYE8nI0VuT0pjUWBPJyNLUk9KblFgTycjS1FPSm5RYE8nI0tRT0p2UWBPLDU7W09Ke1FgTycjS1BPT1EhMExuLDU6Wyw1OltPS1NRbE8sNTpbT01RUSEwTXhPLDU6ZE9NcVFgTyw1OmxPTltRITBMck8nI0tPT05jUWBPJyNKfU85WlFgTycjSn1PTndRYE8nI0p9TyEgUFFgTyw1O1pPISBVUWBPJyNKfU8hI1pRIWZPJyNKcU9PUSEwTGgnI0NpJyNDaU8lW1FsTycjRVFPISN5USFmTyw1OnFPT1FTJyNKeCcjSnhPT1FPLUU8aC1FPGhPOWFRYE8sNT1eTyEkYVFgTyw1PV5PISRmUWxPLDU7WE8hJmlRTWhPJyNFaU8hKFNRYE8sNTtYTyEoWFFsTycjRHdPIShjUXBPLDU7Yk8hKGtRcE8sNTtiTyVbUWxPLDU7Yk9PUVsnI0ZTJyNGU09PUVsnI0ZVJyNGVU8lW1FsTyw1O2NPJVtRbE8sNTtjTyVbUWxPLDU7Y08lW1FsTyw1O2NPJVtRbE8sNTtjTyVbUWxPLDU7Y08lW1FsTyw1O2NPJVtRbE8sNTtjTyVbUWxPLDU7Y08lW1FsTyw1O2NPT1FbJyNGWScjRllPISh5UWxPLDU7c09PUSEwTGYsNTt4LDU7eE9PUSEwTGYsNTt5LDU7eU9PUSEwTGYsNTt7LDU7e08lW1FsTycjSW5PISp8USEwTHJPLDU8aE8lW1FsTyw1O2NPISZpUU1oTyw1O2NPIStrUU1oTyw1O2NPIS1dUU1oTycjRVtPJVtRbE8sNTt2T09RITBMZiw1O3osNTt6TyEtZFEsVU8nI0ZpTyEuYVEsVU8nI0tWTyEte1EsVU8nI0tWTyEuaFEsVU8nI0tWT09RTycjS1YnI0tWTyEufFEsVU8sNTxST09PVyw1PF8sNTxfTyEvX1FsTycjRnVPT09XJyNJbScjSW1PN1ZPN2RPLDU8UE8hL2ZRLFVPJyNGd09PUSEwTGYsNTxQLDU8UE8hMFZRJElVTycjQ3dPT1EhMExoJyNDeycjQ3tPITBqTyNASXRPJyNEUE8hMVdRTWpPLDU8ZE8hMV9RYE8sNTxnTyEyelEoQ1dPJyNHV08hM1hRYE8nI0dYTyEzXlFgTycjR1hPITR8UShDV08nI0ddTyE2UlFwTycjR2FPT1FPJyNHbScjR21PIStyUU1oTycjR2xPT1FPJyNHbycjR29PIStyUU1oTycjR25PITZ0USRJVU8nI0pqT09RITBMaCcjSmonI0pqTyE3T1FgTycjSmlPITdeUWBPJyNKaE8hN2ZRYE8nI0N1T09RITBMaCcjQ3knI0N5TyE3cVFgTycjQ3tPT1EhMExoJyNEVCcjRFRPT1EhMExoJyNEVicjRFZPMVNRYE8nI0RYTyErclFNaE8nI0dPTyErclFNaE8nI0dRTyE3dlFgTycjR1NPITd7UWBPJyNHVE8hM15RYE8nI0daTyErclFNaE8nI0dgTzt6UWBPJyNKaU8hOFFRYE8nI0VvTyE4b1FgTyw1PGZPT1EhMExiJyNDcicjQ3JPITh3UWBPJyNFcE8hOXFRcE8nI0VxT09RITBMYicjS1AnI0tQTyE5eFEhMExyTycjS19POWtRITBMck8sNT1iT2BRbE8sNT5yT09RWycjSmYnI0pmT09RWyw1PnMsNT5zT09RWy1FPFotRTxaTyE7d1EhME14Tyw1OmBPITlsUXBPLDU6Xk8hPmJRITBNeE8sNTpoTyVbUWxPLDU6aE8hQHhRITBNeE8sNTpqT09RTyw1QHgsNUB4TyFBaVFNaE8sNT1eTyFBd1EhMExyTycjSmdPOVVRYE8nI0pnTyFCWVEhMExyTyw1OVpPIUJlUXBPLDU5Wk8hQm1RTWhPLDU5Wk86WVFNaE8sNTlaTyFCeFFgTyw1O1hPIUNRUWBPJyNIYE8hQ2ZRYE8nI0tiTyVbUWxPLDU7fE8hOWxRcE8sNTxPTyFDblFgTyw1PXlPIUNzUWBPLDU9eU8hQ3hRYE8sNT15TzlrUSEwTHJPLDU9eU87elFgTyw1PWlPT1FPJyNDdycjQ3dPIURXUXBPLDU9Zk8hRGBRTWhPLDU9Z08hRGtRYE8sNT1pTyFEcFEhYk8sNT1sTyFEeFFgTycjS15PPndRYE8nI0hWTzlhUWBPJyNIWE8hRH1RYE8nI0hYTzpZUU1oTycjSFpPIUVTUWBPJyNIWk9PUVssNT1vLDU9b08hRVhRYE8nI0hbTyFFalFgTycjQ29PIUVvUWBPLDU5UE8hRXlRYE8sNTlQTyFIT1FsTyw1OVBPT1FbLDU5UCw1OVBPIUhgUSEwTHJPLDU5UE8lW1FsTyw1OVBPIUprUWxPJyNIY09PUVsnI0hkJyNIZE9PUVsnI0hlJyNIZU9gUWxPLDU9e08hS1JRYE8sNT17T2BRbE8sNT5ST2BRbE8sNT5UTyFLV1FgTyw1PlZPYFFsTyw1PlhPIUtdUWBPLDU+W08hS2JRbE8sNT5iT09RWyw1PmgsNT5oTyVbUWxPLDU+aE85a1EhMExyTyw1PmpPT1FbLDU+bCw1PmxPIyBsUWBPLDU+bE9PUVssNT5uLDU+bk8jIGxRYE8sNT5uT09RWyw1PnAsNT5wTyMhWVFwTycjRF1PJVtRbE8nI0p0TyMhe1FwTycjSnRPIyNWUXBPJyNEa08jI2hRcE8nI0RrTyMleVFsTycjRGtPIyZRUWBPJyNKc08jJllRYE8sNTpVTyMmX1FgTycjRXJPIyZtUWBPJyNLU08jJnVRYE8sNTtdTyMmelFwTycjRGtPIydYUXBPJyNFVE9PUSEwTGYsNTptLDU6bU8lW1FsTyw1Om1PIydgUWBPLDU6bU8+d1FgTyw1O1dPIUJlUXBPLDU7V08hQm1RTWhPLDU7V086WVFNaE8sNTtXTyMnaFFgTyw1QGBPIydtUTA3ZE8sNTpxT09RTy1FPGQtRTxkTyMoc1EhME1TTyw1O1BPQ3VRcE8sNTpwTyMofVFwTyw1OnBPQ3VRcE8sNTtQTyFCWVEhMExyTyw1OnBPT1EhMExiJyNFaCcjRWhPT1FPLDU7UCw1O1BPJVtRbE8sNTtQTyMpW1EhMExyTyw1O1BPIylnUSEwTHJPLDU7UE8hQmVRcE8sNTpwT09RTyw1O1YsNTtWTyMpdVEhMExyTyw1O1BQT09PJyNJWycjSVtQIypaTyYyRGpPLDU4fFBPT08sNTh8LDU4fE9PT08tRTxbLUU8W09PUSEwTGgxRy5wMUcucE9PT08tRTxdLUU8XU9PT08sNTl7LDU5e08jKmZRIWJPLDU5e09PT08tRTxfLUU8X09PUSEwTGYxRy9lMUcvZU8jKmtRIWZPLDU+fE8rfVFsTyw1PnxPT1FPLDU/Uyw1P1NPIyp1UWxPJyNJYk9PUU8tRTxgLUU8YE8jK1NRYE8sNUBeTyMrW1EhZk8sNUBeTyMrY1FgTyw1QGxPT1EhMExmMUcvazFHL2tPJVtRbE8sNUBtTyMra1FgTycjSWhPT1FPLUU8Zi1FPGZPIytjUWBPLDVAbE9PUSEwTGIxRzB2MUcwdk9PUSEwTG4xRy92MUcvdk9PUSEwTG4xRzBXMUcwV08lW1FsTyw1QGpPIyxQUSEwTHJPLDVAak8jLGJRITBMck8sNUBqTyMsaVFgTyw1QGlPOVpRYE8sNUBpTyMscVFgTyw1QGlPIy1QUWBPJyNJa08jLGlRYE8sNUBpT09RITBMYjFHMHUxRzB1TyEoY1FwTyw1OnNPIShuUXBPLDU6c09PUVMsNTp1LDU6dU8jLXFRZE8sNTp1TyMteVFNaE8xRzJ4TzlhUWBPMUcyeE9PUSEwTGYxRzBzMUcwc08jLlhRITBNeE8xRzBzTyMvXlEhME12Tyw1O1RPT1EhMExoJyNHVicjR1ZPIy96USEwTXpPJyNKak8hJGZRbE8xRzBzTyMyVlEhZk8nI0p1TyVbUWxPJyNKdU8jMmFRYE8sNTpjT09RITBMaCcjRF0nI0RdT09RITBMZjFHMHwxRzB8TyVbUWxPMUcwfE9PUSEwTGYxRzFlMUcxZU8jMmZRYE8xRzB8TyM0elEhME14TzFHMH1PIzVSUSEwTXhPMUcwfU8jN2lRITBNeE8xRzB9TyM3cFEhME14TzFHMH1PIzpXUSEwTXhPMUcwfU8jPG5RITBNeE8xRzB9TyM8dVEhME14TzFHMH1PIzx8USEwTXhPMUcwfU8jP2RRITBNeE8xRzB9TyM/a1EhME14TzFHMH1PI0F4UT9NdE8nI0NpTyNDc1E/TXRPMUcxX08jQ3pRP010TycjSnFPI0RfUSEwTXhPLDU/WU9PUSEwTGItRTxsLUU8bE8jRmxRITBNeE8xRzB9TyNHaVEhME16TzFHMH1PT1EhMExmMUcwfTFHMH1PI0hsUU1qTycjSnpPI0h2UWBPLDU6dk8jSHtRITBNeE8xRzFiTyNJb1EsVU8sNTxWTyNJd1EsVU8sNTxXTyNKUFEsVU8nI0ZuTyNKaFFgTycjRm1PT1FPJyNLVycjS1dPT1FPJyNJbCcjSWxPI0ptUSxVTzFHMW1PT1EhMExmMUcxbTFHMW1PT09XMUcxeDFHMXhPI0tPUT9NdE8nI0pwTyNLWVFgTyw1PGFPISh5UWxPLDU8YU9PT1ctRTxrLUU8a09PUSEwTGYxRzFrMUcxa08jS19RcE8nI0tWT09RITBMZiw1PGMsNTxjTyNLZ1FwTyw1PGNPI0tsUU1oTycjRFJPT09PJyNJYCcjSWBPI0tzTyNASXRPLDU5a09PUSEwTGgsNTlrLDU5a08lW1FsTzFHMk9PITd7UWBPJyNJcE8jTE9RYE8sNTx5T09RITBMaCw1PHYsNTx2TyErclFNaE8nI0lzTyNMbFFNak8sNT1XTyErclFNaE8nI0l1TyNNX1FNak8sNT1ZTyEmaVFNaE8sNT1bT09RTzFHMlIxRzJSTyNNaVEhZE8nI0NyTyNNfFEoQ1dPJyNFcE8kIFJRcE8nI0dhTyQgaVEhZE8sNTxyTyQgcFFgTycjS1lPOVpRYE8nI0tZTyQhT1FgTyw1PHRPIStyUU1oTyw1PHNPJCFUUWBPJyNHWU8kIWZRYE8sNTxzTyQha1EhZE8nI0dWTyQheFEhZE8nI0taTyQjU1FgTycjS1pPISZpUU1oTycjS1pPJCNYUWBPLDU8d08kI15RbE8nI0p0TyQjaFFwTycjR2JPIyNoUXBPJyNHYk8kI3lRYE8nI0dmTyEzXlFgTycjR2pPJCRPUSEwTHJPJyNJck8kJFpRcE8sNTx7T09RITBMcCw1PHssNTx7TyQkYlFwTycjR2JPJCRvUXBPJyNHY08kJVFRcE8nI0djTyQlVlFNak8sNT1XTyQlZ1FNak8sNT1ZT09RITBMaCw1PV0sNT1dTyErclFNaE8sNUBUTyErclFNaE8sNUBUTyQld1FgTycjSXdPJCZWUWBPLDVAU08kJl9RYE8sNTlhT09RITBMaCw1OWcsNTlnTyQnVVEkSVlPLDU5c09PUSEwTGgnI0puJyNKbk8kJ3dRTWpPLDU8ak8kKGpRTWpPLDU8bE9AaVFgTyw1PG5PT1EhMExoLDU8byw1PG9PJCh0UWBPLDU8dU8kKHlRTWpPLDU8ek8kKVpRYE8sNUBUTyQpaVFgTycjSn1PISRmUWxPMUcyUU8kKW5RYE8xRzJRTzlaUWBPJyNLUU85WlFgTycjRXJPJVtRbE8nI0VyTzlaUWBPJyNJeU8kKXNRITBMck8sNUB5T09RWzFHMnwxRzJ8T09RWzFHNF4xRzReT09RITBMZjFHL3oxRy96T09RITBMZjFHL3gxRy94TyQrdVEhME14TzFHMFNPT1FbMUcyeDFHMnhPISZpUU1oTzFHMnhPJVtRbE8xRzJ4TyMtfFFgTzFHMnhPJC15UU1oTycjRWlPT1EhMExiLDVAUiw1QFJPJC5XUSEwTHJPLDVAUk9PUVsxRy51MUcudU8hQllRITBMck8xRy51TyFCZVFwTzFHLnVPIUJtUU1oTzFHLnVPJC5pUWBPMUcwc08kLm5RYE8nI0NpTyQueVFgTycjS2NPJC9SUWBPLDU9ek8kL1dRYE8nI0tjTyQvXVFgTycjS2NPJC9rUWBPJyNKUE8kL3lRYE8sNUB8TyQwUlEhZk8xRzFoT09RITBMZjFHMWoxRzFqTzlhUWBPMUczZU9AaVFgTzFHM2VPJDBZUWBPMUczZU8kMF9RYE8xRzNlT09RWzFHM2UxRzNlTyFEa1FgTzFHM1RPISZpUU1oTzFHM1FPJDBkUWBPMUczUU9PUVsxRzNSMUczUk8hJmlRTWhPMUczUk8kMGlRYE8xRzNSTyQwcVFwTycjSFBPT1FbMUczVDFHM1RPITV8UXBPJyNJe08hRHBRIWJPMUczV09PUVsxRzNXMUczV09PUVssNT1xLDU9cU8kMHlRTWhPLDU9c085YVFgTyw1PXNPJCN5UWBPLDU9dU85VVFgTyw1PXVPIUJlUXBPLDU9dU8hQm1RTWhPLDU9dU86WVFNaE8sNT11TyQxWFFgTycjS2FPJDFkUWBPLDU9dk9PUVsxRy5rMUcua08kMWlRITBMck8xRy5rT0BpUWBPMUcua08kMXRRYE8xRy5rTzlrUSEwTHJPMUcua08kM3xRIWZPLDVBT08kNFpRYE8sNUFPTzlaUWBPLDVBT08kNGZRbE8sNT19TyQ0bVFgTyw1PX1PT1FbMUczZzFHM2dPYFFsTzFHM2dPT1FbMUczbTFHM21PT1FbMUczbzFHM29PPnJRYE8xRzNxTyQ0clFsTzFHM3NPJDh2UWxPJyNIck9PUVsxRzN2MUczdk8kOVRRYE8nI0h4Tz53UWBPJyNIek9PUVsxRzN8MUczfE8kOV1RbE8xRzN8TzlrUSEwTHJPMUc0U09PUVsxRzRVMUc0VU9PUSEwTGInI0deJyNHXk85a1EhMExyTzFHNFdPOWtRITBMck8xRzRZTyQ9ZFFgTyw1QGBPISh5UWxPLDU7Xk85WlFgTyw1O15PPndRYE8sNTpWTyEoeVFsTyw1OlZPIUJlUXBPLDU6Vk8kPWlRP010Tyw1OlZPT1FPLDU7Xiw1O15PJD1zUXBPJyNJY08kPlpRYE8sNUBfT09RITBMZjFHL3AxRy9wTyQ+Y1FwTycjSWlPJD5tUWBPLDVAbk9PUSEwTGIxRzB3MUcwd08jI2hRcE8sNTpWT09RTycjSWUnI0llTyQ+dVFwTyw1Om9PT1EhMExuLDU6byw1Om9PIydjUWBPMUcwWE9PUSEwTGYxRzBYMUcwWE8lW1FsTzFHMFhPT1EhMExmMUcwcjFHMHJPPndRYE8xRzByTyFCZVFwTzFHMHJPIUJtUU1oTzFHMHJPT1EhMExiMUc1ejFHNXpPIUJZUSEwTHJPMUcwW09PUU8xRzBrMUcwa08lW1FsTzFHMGtPJD58USEwTHJPMUcwa08kP1hRITBMck8xRzBrTyFCZVFwTzFHMFtPQ3VRcE8xRzBbTyQ/Z1EhMExyTzFHMGtPT1FPMUcwWzFHMFtPJD97USEwTXhPMUcwa1BPT08tRTxZLUU8WVBPT08xRy5oMUcuaE9PT08xRy9nMUcvZ08kQFZRIWJPLDU8aE8kQF9RIWZPMUc0aE9PUU8xRzRuMUc0bk8lW1FsTyw1PnxPJEBpUWBPMUc1eE8kQHFRYE8xRzZXTyRAeVEhZk8xRzZYTzlaUWBPLDU/U08kQVRRITBNeE8xRzZVTyVbUWxPMUc2VU8kQWVRITBMck8xRzZVTyRBdlFgTzFHNlRPJEF2UWBPMUc2VE85WlFgTzFHNlRPJEJPUWBPLDU/Vk85WlFgTyw1P1ZPT1FPLDU/Viw1P1ZPJEJkUWBPLDU/Vk8kKWlRYE8sNT9WT09RTy1FPGktRTxpT09RUzFHMF8xRzBfT09RUzFHMGExRzBhTyMtdFFgTzFHMGFPT1FbNysoZDcrKGRPISZpUU1oTzcrKGRPJVtRbE83KyhkTyRCclFgTzcrKGRPJEJ9UU1oTzcrKGRPJENdUSEwTXpPLDU9V08kRWhRITBNek8sNT1ZTyRHc1EhME16Tyw1PVdPJEpVUSEwTXpPLDU9WU8kTGdRITBNek8sNTlzTyRObFEhME16Tyw1PGpPJSF3USEwTXpPLDU8bE8lJVNRITBNek8sNTx6T09RITBMZjcrJl83KyZfTyUnZVEhME14TzcrJl9PJShYUWxPJyNJZE8lKGZRYE8sNUBhTyUoblEhZk8sNUBhT09RITBMZjFHL30xRy99TyUoeFFgTzcrJmhPT1EhMExmNysmaDcrJmhPJSh9UT9NdE8sNTpkTyVbUWxPNysmeU8lKVhRP010Tyw1OmBPJSlmUT9NdE8sNTpoTyUpcFE/TXRPLDU6ak8lKXpRTWhPJyNJZ08lKlVRYE8sNUBmT09RITBMaDFHMGIxRzBiT09RTzFHMXExRzFxT09RTzFHMXIxRzFyTyUqXlEhak8sNTxZTyEoeVFsTyw1PFhPT1FPLUU8ai1FPGpPT1EhMExmNysnWDcrJ1hPT09XNysnZDcrJ2RPT09XMUcxezFHMXtPJSppUWBPMUcxe09PUSEwTGYxRzF9MUcxfU9PT08sNTltLDU5bU8lKm5RIWRPLDU5bU9PT08tRTxeLUU8Xk9PUSEwTGgxRy9WMUcvVk8lKnVRITBNeE83KydqT09RITBMaCw1P1ssNT9bTyUraVFNaE8xRzJlUCUrcFFgTycjSXBQT1EhMExoLUU8bi1FPG5PJSxeUU1qTyw1P19PT1EhMExoLUU8cS1FPHFPJS1QUU1qTyw1P2FPT1EhMExoLUU8cy1FPHNPJS1aUSFkTzFHMnZPJS1iUSFkTycjQ3JPJS14UU1oTycjS1FPJCNeUWxPJyNKdE9PUSEwTGgxRzJeMUcyXk8lLlBRYE8nI0lvTyUuZVFgTyw1QHRPJS5lUWBPLDVAdE8lLm1RYE8sNUB0TyUueFFgTyw1QHRPT1FPMUcyYDFHMmBPJS9XUU1qTzFHMl9PIStyUU1oTzFHMl9PJS9oUShDV08nI0lxTyUvdVFgTyw1QHVPISZpUU1oTyw1QHVPJS99USFkTyw1QHVPT1EhMExoMUcyYzFHMmNPJTJfUSFmTycjQ2lPJTJpUWBPLDU9T09PUSEwTGIsNTx8LDU8fE8lMnFRcE8sNTx8T09RITBMYiw1PH0sNTx9T0NmUWBPLDU8fE8lMnxRcE8sNTx8T09RITBMYiw1PVEsNT1RTyQpaVFgTyw1PVVPT1FPLDU/Xiw1P15PT1FPLUU8cC1FPHBPT1EhMExwMUcyZzFHMmdPIyNoUXBPLDU8fE8kI15RbE8sNT1PTyUzW1FgTyw1PH1PJTNnUXBPLDU8fU8hK3JRTWhPJyNJc08lNGFRTWpPMUcyck8hK3JRTWhPJyNJdU8lNVNRTWpPMUcydE8lNV5RTWpPMUc1b08lNWhRTWpPMUc1b09PUU8sNT9jLDU/Y09PUU8tRTx1LUU8dU9PUU8xRy57MUcue08hOWxRcE8sNTl1TyVbUWxPLDU5dU9PUSEwTGgsNTxpLDU8aU8lNXVRYE8xRzJZTyErclFNaE8xRzJhTyErclFNaE8xRzVvTyErclFNaE8xRzVvTyU1elEhME14TzcrJ2xPT1EhMExmNysnbDcrJ2xPISRmUWxPNysnbE8lNm5RYE8sNTteT09RITBMYiw1P2UsNT9lT09RITBMYi1FPHctRTx3TyU2c1EhZE8nI0tbTyMnY1FgTzcrKGRPNFVRIWZPNysoZE8kQnVRYE83KyhkTyU2fVEhME12TycjQ2lPJTduUSEwTHJPLDU9Uk8lOFBRITBNdk8sNT1STyU4ZFFgTyw1PVJPT1EhMExiMUc1bTFHNW1PT1FbNyskYTcrJGFPIUJZUSEwTHJPNyskYU8hQmVRcE83KyRhTyEkZlFsTzcrJl9PJThsUWBPJyNKT08lOVRRYE8sNUB9T09RTzFHM2YxRzNmTzlhUWBPLDVAfU8lOVRRYE8sNUB9TyU5XVFgTyw1QH1PT1FPLDU/ayw1P2tPT1FPLUU8fS1FPH1PT1EhMExmNysnUzcrJ1NPJTliUWBPNyspUE85a1EhMExyTzcrKVBPOWFRYE83KylQT0BpUWBPNyspUE9PUVs3KyhvNysob08lOWdRITBNdk83KyhsTyEmaVFNaE83KyhsTyFEZlFgTzcrKG1PT1FbNysobTcrKG1PISZpUU1oTzcrKG1PJTlxUWBPJyNLYE8lOXxRYE8sNT1rT09RTyw1P2csNT9nT09RTy1FPHktRTx5T09RWzcrKHI3KyhyTyU7YFFwTycjSFlPT1FbMUczXzFHM19PISZpUU1oTzFHM19PJVtRbE8xRzNfTyU7Z1FgTzFHM19PJTtyUU1oTzFHM19POWtRITBMck8xRzNhTyQjeVFgTzFHM2FPOVVRYE8xRzNhTyFCZVFwTzFHM2FPIUJtUU1oTzFHM2FPJTxRUWBPJyNJfU8lPGZRYE8sNUB7TyU8blFwTyw1QHtPT1EhMExiMUczYjFHM2JPT1FbNyskVjcrJFZPQGlRYE83KyRWTzlrUSEwTHJPNyskVk8lPHlRYE83KyRWTyVbUWxPMUc2ak8lW1FsTzFHNmtPJT1PUSEwTHJPMUc2ak8lPVlRbE8xRzNpTyU9YVFgTzFHM2lPJT1mUWxPMUczaU9PUVs3KylSNyspUk85a1EhMExyTzcrKV1PYFFsTzcrKV9PT1FbJyNLZicjS2ZPT1FbJyNKUScjSlFPJT1tUWxPLDU+Xk9PUVssNT5eLDU+Xk8lW1FsTycjSHNPJT16UWBPJyNIdU9PUVssNT5kLDU+ZE85WlFgTyw1PmRPT1FbLDU+Ziw1PmZPT1FbNyspaDcrKWhPT1FbNyspbjcrKW5PT1FbNyspcjcrKXJPT1FbNyspdDcrKXRPJT5QUXBPMUc1ek8lPmtRP010TzFHMHhPJT51UWBPMUcweE9PUU8xRy9xMUcvcU8lP1FRP010TzFHL3FPPndRYE8xRy9xTyEoeVFsTycjRGtPT1FPLDU+fSw1Pn1PT1FPLUU8YS1FPGFPT1FPLDU/VCw1P1RPT1FPLUU8Zy1FPGdPIUJlUXBPMUcvcU9PUU8tRTxjLUU8Y09PUSEwTG4xRzBaMUcwWk9PUSEwTGY3KyVzNyslc08jJ2NRYE83KyVzT09RITBMZjcrJl43KyZeTz53UWBPNysmXk8hQmVRcE83KyZeT09RTzcrJXY3KyV2TyQ/e1EhME14TzcrJlZPT1FPNysmVjcrJlZPJVtRbE83KyZWTyU/W1EhMExyTzcrJlZPIUJZUSEwTHJPNysldk8hQmVRcE83KyV2TyU/Z1EhMExyTzcrJlZPJT91USEwTXhPNysrcE8lW1FsTzcrK3BPJUBWUWBPNysrb08lQFZRYE83KytvT09RTzFHNHExRzRxTzlaUWBPMUc0cU8lQF9RYE8xRzRxT09RUzcrJXs3KyV7TyMnY1FgTzw8TE9PNFVRIWZPPDxMT08lQG1RYE88PExPT09RWzw8TE88PExPTyEmaVFNaE88PExPTyVbUWxPPDxMT08lQHVRYE88PExPTyVBUVEhME16Tyw1P19PJUNdUSEwTXpPLDU/YU8lRWhRITBNek8xRzJfTyVHeVEhME16TzFHMnJPJUpVUSEwTXpPMUcydE8lTGFRIWZPLDU/T08lW1FsTyw1P09PT1FPLUU8Yi1FPGJPJUxrUWBPMUc1e09PUSEwTGY8PEpTPDxKU08lTHNRP010TzFHMHNPJU56UT9NdE8xRzB9TyYgUlE/TXRPMUcwfU8mI1NRP010TzFHMH1PJiNaUT9NdE8xRzB9TyYlW1E/TXRPMUcwfU8mJ11RP010TzFHMH1PJidkUT9NdE8xRzB9TyYna1E/TXRPMUcwfU8mKWxRP010TzFHMH1PJilzUT9NdE8xRzB9TyYpelEhME14Tzw8SmVPJityUT9NdE8xRzB9TyYsb1E/TXZPMUcwfU8mLXJRP012TycjSmpPJi94UT9NdE8xRzFiTyYwVlE/TXRPMUcwU08mMGFRTWpPLDU/Uk9PUU8tRTxlLUU8ZU8hKHlRbE8nI0ZwT09RTycjS1gnI0tYT09RTzFHMXQxRzF0TyYwa1FgTzFHMXNPJjBwUT9NdE8sNT9ZT09PVzcrJ2c3KydnT09PTzFHL1gxRy9YTyYwelEhZE8xRzR2T09RITBMaDcrKFA3KyhQUCEmaVFNaE8sNT9bTyErclFNaE83KyhiTyYxUlFgTyw1P1pPOVpRYE8sNT9aT09RTy1FPG0tRTxtTyYxYVFgTzFHNmBPJjFhUWBPMUc2YE8mMWlRYE8xRzZgTyYxdFFNak83Kyd5TyYyVVEhZE8sNT9dTyYyYFFgTyw1P11PISZpUU1oTyw1P11PT1FPLUU8by1FPG9PJjJlUSFkTzFHNmFPJjJvUWBPMUc2YU8mMndRYE8xRzJqTyEmaVFNaE8xRzJqT09RITBMYjFHMmgxRzJoT09RITBMYjFHMmkxRzJpTyUycVFwTzFHMmhPIUJlUXBPMUcyaE9DZlFgTzFHMmhPT1EhMExiMUcycDFHMnBPJjJ8UXBPMUcyaE8mM1tRYE8xRzJqTyQpaVFgTzFHMmlPQ2ZRYE8xRzJpTyQjXlFsTzFHMmpPJjNkUWBPMUcyaU8mNFdRTWpPLDU/X09PUSEwTGgtRTxyLUU8ck8mNHlRTWpPLDU/YU9PUSEwTGgtRTx0LUU8dE8hK3JRTWhPNysrWk9PUSEwTGgxRy9hMUcvYU8mNVRRYE8xRy9hT09RITBMaDcrJ3Q3Kyd0TyY1WVFNak83Kyd7TyY1alFNak83KytaTyY1dFFNak83KytaTyY2UlEhME14Tzw8S1dPT1EhMExmPDxLVzw8S1dPJjZ1UWBPMUcweE8hJmlRTWhPJyNJeE8mNnpRYE8sNUB2TyY4fFEhZk88PExPTyEmaVFNaE8xRzJtTyY5VFEhMExyTzFHMm1PT1FbPDxHezw8R3tPIUJZUSEwTHJPPDxHe08mOWZRITBNeE88PEl5T09RITBMZjw8SXk8PEl5T09RTyw1P2osNT9qTyY6WVFgTyw1P2pPJjpfUWBPLDU/ak9PUU8tRTx8LUU8fE8mOm1RYE8xRzZpTyY6bVFgTzFHNmlPOWFRYE8xRzZpT0BpUWBPPDxMa09PUVs8PExrPDxMa08mOnVRYE88PExrTzlrUSEwTHJPPDxMa09PUVs8PExXPDxMV08lOWdRITBNdk88PExXT09RWzw8TFg8PExYTyFEZlFgTzw8TFhPJjp6UXBPJyNJek8mO1ZRYE8sNUB6TyEoeVFsTyw1QHpPT1FbMUczVjFHM1ZPT1FPJyNJfCcjSXxPOWtRITBMck8nI0l8TyY7X1FwTyw1PXRPT1FbLDU9dCw1PXRPJjtmUXBPJyNFZU8mO21RcE8nI0dkTyY7clFgTzcrKHlPJjt3UWBPNysoeU9PUVs3Kyh5NysoeU8hJmlRTWhPNysoeU8lW1FsTzcrKHlPJjxQUWBPNysoeU9PUVs3Kyh7Nysoe085a1EhMExyTzcrKHtPJCN5UWBPNysoe085VVFgTzcrKHtPIUJlUXBPNysoe08mPFtRYE8sNT9pT09RTy1FPHstRTx7T09RTycjSF0nI0hdTyY8Z1FgTzFHNmdPOWtRITBMck88PEdxT09RWzw8R3E8PEdxT0BpUWBPPDxHcU8mPG9RYE83KyxVTyY8dFFgTzcrLFZPJVtRbE83KyxVTyVbUWxPNyssVk9PUVs3KylUNyspVE8mPHlRYE83KylUTyY9T1FsTzcrKVRPJj1WUWBPNyspVE9PUVs8PEx3PDxMd09PUVs8PEx5PDxMeU9PUVstRT1PLUU9T09PUVsxRzN4MUczeE8mPVtRYE8sNT5fT09RWyw1PmEsNT5hTyY9YVFgTzFHNE9POVpRYE83KyZkTyEoeVFsTzcrJmRPT1FPNyslXTcrJV1PJj1mUT9NdE8xRzZYTz53UWBPNyslXU9PUSEwTGY8PElfPDxJX09PUSEwTGY8PEl4PDxJeE8+d1FgTzw8SXhPT1FPPDxJcTw8SXFPJD97USEwTXhPPDxJcU8lW1FsTzw8SXFPT1FPPDxJYjw8SWJPIUJZUSEwTHJPPDxJYk8mPXBRITBMck88PElxTyY9e1EhME14Tzw9IFtPJj5dUWBPPD0gWk9PUU83KypdNysqXU85WlFgTzcrKl1PT1FbQU5BakFOQWpPJj5lUSFmT0FOQWpPISZpUU1oT0FOQWpPIydjUWBPQU5Bak80VVEhZk9BTkFqTyY+bFFgT0FOQWpPJVtRbE9BTkFqTyY+dFEhME16TzcrJ3lPJkFWUSEwTXpPLDU/X08mQ2JRITBNek8sNT9hTyZFbVEhME16TzcrJ3tPJkhPUSFmTzFHNGpPJkhZUT9NdE83KyZfTyZKXlE/TXZPLDU9V08mTGVRP012Tyw1PVlPJkx1UT9Ndk8sNT1XTyZNVlE/TXZPLDU9WU8mTWdRP012Tyw1OXNPJyBtUT9Ndk8sNTxqTycjcFE/TXZPLDU8bE8nJlVRP012Tyw1PHpPJyd6UT9NdE83KydqTycoWFE/TXRPNysnbE8nKGZRYE8sNTxbT09RTzcrJ183KydfT09RITBMaDcrKmI3KypiTycoa1FNak88PEt8T09RTzFHNHUxRzR1TycoclFgTzFHNHVPJyh9UWBPMUc0dU8nKV1RYE83Kyt6TycpXVFgTzcrK3pPISZpUU1oTzFHNHdPJyllUSFkTzFHNHdPJylvUWBPNysre08nKXdRYE83KyhVTycqU1EhZE83KyhVT09RITBMYjcrKFM3KyhTT09RITBMYjcrKFQ3KyhUTyFCZVFwTzcrKFNPQ2ZRYE83KyhTTycqXlFgTzcrKFVPISZpUU1oTzcrKFVPJClpUWBPNysoVE8nKmNRYE83KyhVT0NmUWBPNysoVE8nKmtRTWpPPDxOdU9PUSEwTGg3KyR7Nyske08hK3JRTWhPPDxOdU8nKnVRIWRPLDU/ZE9PUU8tRTx2LUU8dk8nK1BRITBNdk83KyhYTyEmaVFNaE83KyhYT09RW0FOPWdBTj1nTzlhUWBPMUc1VU9PUU8xRzVVMUc1VU8nK2FRYE8xRzVVTycrZlFgTzcrLFRPJytmUWBPNyssVE85a1EhMExyT0FOQlZPQGlRYE9BTkJWT09RW0FOQlZBTkJWT09RW0FOQXJBTkFyT09RW0FOQXNBTkFzTycrblFgTyw1P2ZPT1FPLUU8eC1FPHhPJyt5UT9NdE8xRzZmT09RTyw1P2gsNT9oT09RTy1FPHotRTx6T09RWzFHM2AxRzNgTycsVFFgTyw1PU9PT1FbPDxMZTw8TGVPISZpUU1oTzw8TGVPJjtyUWBPPDxMZU8nLFlRYE88PExlTyVbUWxPPDxMZU9PUVs8PExnPDxMZ085a1EhMExyTzw8TGdPJCN5UWBPPDxMZ085VVFgTzw8TGdPJyxiUXBPMUc1VE8nLG1RYE83KyxST09RW0FOPV1BTj1dTzlrUSEwTHJPQU49XU9PUVs8PSBwPD0gcE9PUVs8PSBxPD0gcU8nLHVRYE88PSBwTycselFgTzw9IHFPT1FbPDxMbzw8TG9PJy1QUWBPPDxMb08nLVVRbE88PExvT09RWzFHM3kxRzN5Tz53UWBPNyspak8nLV1RYE88PEpPTyctaFE/TXRPPDxKT09PUU88PEh3PDxId09PUSEwTGZBTj9kQU4/ZE9PUU9BTj9dQU4/XU8kP3tRITBNeE9BTj9dT09RT0FOPnxBTj58TyVbUWxPQU4/XU9PUU88PE13PDxNd09PUVtHMjdVRzI3VU8hJmlRTWhPRzI3VU8jJ2NRYE9HMjdVTyctclEhZk9HMjdVTzRVUSFmT0cyN1VPJy15UWBPRzI3VU8nLlJRP010Tzw8SmVPJy5gUT9Ndk8xRzJfTycwVVE/TXZPLDU/X08nMlhRP012Tyw1P2FPJzRbUT9Ndk8xRzJyTyc2X1E/TXZPMUcydE8nOGJRP010Tzw8S1dPJzhvUT9NdE88PEl5T09RTzFHMXYxRzF2TyErclFNaE9BTkFoT09RTzcrKmE3KyphTyc4fFFgTzcrKmFPJzlYUWBPPD0gZk8nOWFRIWRPNysqY09PUSEwTGI8PEtwPDxLcE8kKWlRYE88PEtwT0NmUWBPPDxLcE8nOWtRYE88PEtwTyEmaVFNaE88PEtwT09RITBMYjw8S248PEtuTyFCZVFwTzw8S25PJzl2USFkTzw8S3BPT1EhMExiPDxLbzw8S29PJzpRUWBPPDxLcE8hJmlRTWhPPDxLcE8kKWlRYE88PEtvTyc6VlFNak9BTkRhTyc6YVEhME12Tzw8S3NPT1FPNysqcDcrKnBPOWFRYE83KypwTyc6cVFgTzw9IG9PT1FbRzI3cUcyN3FPOWtRITBMck9HMjdxTyEoeVFsTzFHNVFPJzp5UWBPNyssUU8nO1JRYE8xRzJqTyY7clFgT0FOQlBPT1FbQU5CUEFOQlBPISZpUU1oT0FOQlBPJztXUWBPQU5CUE9PUVtBTkJSQU5CUk85a1EhMExyT0FOQlJPJCN5UWBPQU5CUk9PUU8nI0heJyNIXk9PUU83KypvNysqb09PUVtHMjJ3RzIyd09PUVtBTkVbQU5FW09PUVtBTkVdQU5FXU9PUVtBTkJaQU5CWk8nO2BRYE9BTkJaT09RWzw8TVU8PE1VTyEoeVFsT0FOP2pPT1FPRzI0d0cyNHdPJD97USEwTXhPRzI0d08jJ2NRYE9MRCxwT09RW0xELHBMRCxwTyEmaVFNaE9MRCxwTyc7ZVEhZk9MRCxwTyc7bFE/TXZPNysneU8nPWJRP012Tyw1P19PJz9lUT9Ndk8sNT9hTydBaFE/TXZPNysne08nQ15RTWpPRzI3U09PUU88PE17PDxNe09PUSEwTGJBTkFbQU5BW08kKWlRYE9BTkFbT0NmUWBPQU5BW08nQ25RIWRPQU5BW09PUSEwTGJBTkFZQU5BWU8nQ3VRYE9BTkFbTyEmaVFNaE9BTkFbTydEUVEhZE9BTkFbT09RITBMYkFOQVpBTkFaT09RTzw8Tls8PE5bT09RW0xELV1MRC1dTydEW1E/TXRPNysqbE9PUU8nI0dlJyNHZU9PUVtHMjdrRzI3a08mO3JRYE9HMjdrTyEmaVFNaE9HMjdrT09RW0cyN21HMjdtTzlrUSEwTHJPRzI3bU9PUVtHMjd1RzI3dU8nRGZRP010T0cyNVVPT1FPTEQqY0xEKmNPT1FbISQoIVshJCghW08jJ2NRYE8hJCghW08hJmlRTWhPISQoIVtPJ0RwUSEwTXpPRzI3U09PUSEwTGJHMjZ2RzI2dk8kKWlRYE9HMjZ2TydHUlFgT0cyNnZPQ2ZRYE9HMjZ2TydHXlEhZE9HMjZ2TyEmaVFNaE9HMjZ2T09RW0xELVZMRC1WTyY7clFgT0xELVZPT1FbTEQtWExELVhPT1FbISk5RXYhKTlFdk8jJ2NRYE8hKTlFdk9PUSEwTGJMRCxiTEQsYk8kKWlRYE9MRCxiT0NmUWBPTEQsYk8nR2VRYE9MRCxiTydHcFEhZE9MRCxiT09RWyEkKCFxISQoIXFPT1FbIS5LO2IhLks7Yk8nR3dRP012T0cyN1NPT1EhMExiISQoIHwhJCggfE8kKWlRYE8hJCggfE9DZlFgTyEkKCB8TydJbVFgTyEkKCB8T09RITBMYiEpOUVoISk5RWhPJClpUWBPISk5RWhPQ2ZRYE8hKTlFaE9PUSEwTGIhLks7UyEuSztTTyQpaVFgTyEuSztTT09RITBMYiE0LzBuITQvMG5PISh5UWxPJyNEeE8xUFFgTycjRVZPJ0l4USFmTycjSnBPJ0pQUSFMXk8nI0R0TydKV1FsTycjRHxPJ0pfUSFmTycjQ2lPJ0x1USFmTycjQ2lPISh5UWxPJyNFT08nTVZRbE8sNTtYTyEoeVFsTyw1O2NPISh5UWxPLDU7Y08hKHlRbE8sNTtjTyEoeVFsTyw1O2NPISh5UWxPLDU7Y08hKHlRbE8sNTtjTyEoeVFsTyw1O2NPISh5UWxPLDU7Y08hKHlRbE8sNTtjTyEoeVFsTyw1O2NPISh5UWxPJyNJbk8oIFlRYE8sNTxoTyEoeVFsTyw1O2NPKCBiUU1oTyw1O2NPKCF7UU1oTyw1O2NPISh5UWxPLDU7dk8hJmlRTWhPJyNHbE8oIGJRTWhPJyNHbE8hJmlRTWhPJyNHbk8oIGJRTWhPJyNHbk8xU1FgTycjRFhPMVNRYE8nI0RYTyEmaVFNaE8nI0dPTyggYlFNaE8nI0dPTyEmaVFNaE8nI0dRTyggYlFNaE8nI0dRTyEmaVFNaE8nI0dgTyggYlFNaE8nI0dgTyEoeVFsTyw1OmhPKCNTUXBPJyNEXU8oI15RcE8nI0p0TyEoeVFsTyw1QG1PJ01WUWxPMUcwc08oI2hRP010TycjQ2lPISh5UWxPMUcyT08hJmlRTWhPJyNJc08oIGJRTWhPJyNJc08hJmlRTWhPJyNJdU8oIGJRTWhPJyNJdU8oI3JRIWRPJyNDck8hJmlRTWhPLDU8c08oIGJRTWhPLDU8c08nTVZRbE8xRzJRTyEoeVFsTzcrJnlPISZpUU1oTzFHMl9PKCBiUU1oTzFHMl9PISZpUU1oTycjSXNPKCBiUU1oTycjSXNPISZpUU1oTycjSXVPKCBiUU1oTycjSXVPISZpUU1oTzFHMmFPKCBiUU1oTzFHMmFPJ01WUWxPNysnbE8nTVZRbE83KyZfTyEmaVFNaE9BTkFoTyggYlFNaE9BTkFoTygkVlFgTycjRW1PKCRbUWBPJyNFbU8oJGRRYE8nI0ZbTygkaVFgTycjRXdPKCRuUWBPJyNLUk8oJHlRYE8nI0tQTyglVVFgTyw1O1hPKCVaUU1qTyw1PGRPKCViUWBPJyNHWE8oJWdRYE8nI0dYTyglbFFgTyw1PGZPKCV0UWBPLDU7WE8oJXxRP010TzFHMV9PKCZUUWBPLDU8c08oJllRYE8sNTxzTygmX1FgTyw1PHVPKCZkUWBPLDU8dU8oJmlRYE8xRzJRTygmblFgTzFHMHNPKCZzUU1qTzw8S3xPKCZ6UU1qTzw8S3xPN2VRTWhPJyNGe085VVFgTycjRnpPQWRRYE8nI0VsTyEoeVFsTyw1O3NPITNeUWBPJyNHWE8hM15RYE8nI0dYTyEzXlFgTycjR1pPITNeUWBPJyNHWk8hK3JRTWhPNysoYk8hK3JRTWhPNysoYk8lLVpRIWRPMUcydk8lLVpRIWRPMUcydk8hJmlRTWhPLDU9W08hJmlRTWhPLDU9W1wiLFxuICBzdGF0ZURhdGE6IFwiKChQfk8nek9TJ3tPU1RPUyd8UlF+T1BZT1FZT1NmT1khVk9hcU9kek9leU9qIVBPbmtPcFlPcWtPcmtPeGtPellPfFlPIVFXTyFVa08hVmtPIV1YTyFndU8halpPIW1ZTyFuWU8hb1lPIXF2TyFzd08hdnhPIXpdTyRWfE8kbWlPJWd9TyVpIVFPJWshT08lbCFPTyVtIU9PJXAhUk8lciFTTyV1IVRPJXYhVE8leCFVTyZVIVdPJlshWE8mXiFZTyZgIVpPJmIhW08mZSFdTyZrIV5PJnEhX08mcyFgTyZ1IWFPJnchYk8meSFjTyhSU08oVFRPKFdVTyhfVk8obVtPfk9XdE9+UGBPUFlPUVlPU2ZPZCFqT2UhaU9ua09wWU9xa09ya094a096WU98WU8hUVdPIVVrTyFWa08hXSFlTyFndU8halpPIW1ZTyFuWU8hb1lPIXF2TyFzIWdPIXYhaE8kViFrTyRtaU8oUiFkTyhUVE8oV1VPKF9WTyhtW09+T2Ehd09xIW5PIVEhb08hYCF5TyFhIXZPIWIhdk8hejt3TyNSIXBPI1MhcE8jVCF4TyNVIXBPI1YhcE8jWSF6TyNaIXpPKFMhbE8oVFRPKFdVTyhjIW1PKG0hc09+Tyd8IXtPfk9QXVhSXVhbXVhhXVhwXVghT11YIVFdWCFaXVghal1YIW5dWCNQXVgjUV1YI15dWCNpZlgjbF1YI21dWCNuXVgjb11YI3BdWCNxXVgjcl1YI3NdWCN0XVgjdV1YI3ddWCN5XVgjel1YJFBdWCd4XVgoX11YKHBdWCh3XVgoeF1Yfk8hZSVRWH5QKHFPXyF9TyhUI1BPKFUhfU8oViNQT35PXyNRTyhWI1BPKFcjUE8oWCNRT35PdiNTTyFTI1RPKGAjVE8oYSNWT35PUFlPUVlPU2ZPZCFqT2UhaU9ua09wWU9xa09ya094a096WU98WU8hUVdPIVVrTyFWa08hXSFlTyFndU8halpPIW1ZTyFuWU8hb1lPIXF2TyFzIWdPIXYhaE8kViFrTyRtaU8oUjt7TyhUVE8oV1VPKF9WTyhtW09+TyFZI1pPIVojV08hVyhmUCFXKHRQflArfU8hWyNjT35QYE9QWU9RWU9TZk9kIWpPZSFpT3BZT3FrT3JrT3hrT3pZT3xZTyFRV08hVWtPIVZrTyFdIWVPIWd1TyFqWk8hbVlPIW5ZTyFvWU8hcXZPIXMhZ08hdiFoTyRWIWtPJG1pTyhUVE8oV1VPKF9WTyhtW09+T24jbU8hWSNpTyF6XU8jZyNsTyNoI2lPKFI7fE8haShxUH5QLmlPIWojb08oUiNuT35PIXYjc08hel1PJWcjdE9+TyNpI3VPfk8hZSN2TyNpI3VPfk9QJFtPUiN6T1skY09wJGFPIU8jeU8hUSN7TyFaJF9PIWojeE8hbiRbTyNQJFJPI2wkT08jbSRQTyNuJFBPI28kUE8jcCRRTyNxJFJPI3IkUk8jcyRiTyN0JFJPI3UkU08jdyRVTyN5JFdPI3okWE8oX1ZPKHAkWU8odyN8Tyh4I31Pfk9hKGRYJ3goZFgndShkWCFpKGRYIVcoZFghXShkWCVoKGRYIWUoZFh+UDFxTyNRJGRPI14kZU8kUCRlT1AoZVhSKGVYWyhlWHAoZVghTyhlWCFRKGVYIVooZVghaihlWCFuKGVYI1AoZVgjbChlWCNtKGVYI24oZVgjbyhlWCNwKGVYI3EoZVgjcihlWCNzKGVYI3QoZVgjdShlWCN3KGVYI3koZVgjeihlWChfKGVYKHAoZVgodyhlWCh4KGVYIV0oZVglaChlWH5PYShlWCd4KGVYJ3UoZVghVyhlWCFpKGVYdChlWCFlKGVYflA0VU8jXiRlT35PJFskaE8kXiRnTyRlJG1Pfk9TZk8hXSRuTyRoJG9PJGokcU9+T2glVk9qJWNPbiVXT3AlWE9xJHRPciR0T3glWU96JVpPfCVbTyFRJHtPIV0kfE8hZyVhTyFqJHhPI2glYk8kViVfTyRzJV1PJHUlXk8keCVgTyhSJHNPKFRUTyhXVU8oXyR1Tyh3JH1PKHglUE9nKFtQfk8haiVkT35PIVElZ08hXSVoTyhSJWZPfk8hZSVsT35PYSVtTyd4JW1Pfk8hTyVxT35QJVtPKFMhbE9+UCVbTyVtJXVPflAlW09oJVZPIWolZE8oUiVmTyhTIWxPfk9lJXxPIWolZE8oUiVmT35PI3QkUk9+TyFPJlJPIV0mT08haiZRTyVpJlVPKFIlZk8oUyFsTyhUVE8oV1VPYClVUH5PIXYjc09+TyVyJldPIVEpUVghXSlRWChSKVFYfk8oUiZYT35PaiFQTyFzJl5PJWkhUU8layFPTyVsIU9PJW0hT08lcCFSTyVyIVNPJXUhVE8ldiFUT35PZCZjT2UmYk8hdiZgTyVnJmFPJXomX09+UDxQT2QmZk9leU9qIVBPIV0mZU8hcyZeTyF2eE8hel1PJWd9TyVrIU9PJWwhT08lbSFPTyVwIVJPJXIhU08ldSFUTyV2IVRPJXghVU9+T2ImaU8jXiZsTyVpJmdPKFMhbE9+UD1VTyFqJm1PIXMmcU9+TyFqI29Pfk8hXVhPfk9hJW1PJ3YmeU8neCVtT35PYSVtTyd2JnxPJ3glbU9+T2ElbU8ndidPTyd4JW1Pfk8ndV1YIVddWHRdWCFpXVgmWV1YIV1dWCVoXVghZV1YflAocU8hYCddTyFhJ1VPIWInVU8oUyFsTyhUVE8oV1VPfk9xJ1NPIVEnUk8hWSdWTyhjJ1FPIVsoZ1AhWyh2UH5QQF1PbCdgTyFdJ15PKFIlZk9+T2UnZU8haiVkTyhSJWZPfk8hTyZSTyFqJlFPfk9xIW5PIVEhb08hejt3TyNSIXBPI1MhcE8jVSFwTyNWIXBPKFMhbE8oVFRPKFdVTyhjIW1PKG0hc09+TyFgJ2tPIWEnak8hYidqTyNUIXBPI1knbE8jWidsT35QQXdPYSVtT2glVk8hZSN2TyFqJWRPJ3glbU8ocCduT35PIW4nck8jXidwT35QQ1ZPcSFuTyFRIW9PKFRUTyhXVU8oYyFtTyhtIXNPfk8hXVhPcShrWCFRKGtYIWAoa1ghYShrWCFiKGtYIXooa1gjUihrWCNTKGtYI1Qoa1gjVShrWCNWKGtYI1koa1gjWihrWChTKGtYKFQoa1goVyhrWChjKGtYKG0oa1h+TyFhJ2pPIWInak8oUyFsT35QQ3VPJ30ndk8oTyd2TyhQJ3hPfk9fIX1PKFQnek8oVSF9TyhWJ3pPfk9fI1FPKFYnek8oVyd6TyhYI1FPfk90J3xPflAlW092I1NPIVMjVE8oYCNUTyhhKFBPfk8hWShSTyFXJ1VYIVcnW1ghWidVWCFaJ1tYflArfU8hWihUTyFXKGZYfk9QJFtPUiN6T1skY09wJGFPIU8jeU8hUSN7TyFaKFRPIWojeE8hbiRbTyNQJFJPI2wkT08jbSRQTyNuJFBPI28kUE8jcCRRTyNxJFJPI3IkUk8jcyRiTyN0JFJPI3UkU08jdyRVTyN5JFdPI3okWE8oX1ZPKHAkWU8odyN8Tyh4I31Pfk8hVyhmWH5QR3BPIVcoWU9+TyFXKHNYIVooc1ghZShzWCFpKHNYKHAoc1h+TyNeKHNYI2kjYlghWyhzWH5QSXNPI14oWk8hVyh1WCFaKHVYfk8hWihbTyFXKHRYfk8hVyhfT35PI14kZU9+UElzTyFbKGBPflBgT1Ijek8hTyN5TyFRI3tPIWojeE8oX1ZPUCFsYVshbGFwIWxhIVohbGEhbiFsYSNQIWxhI2whbGEjbSFsYSNuIWxhI28hbGEjcCFsYSNxIWxhI3IhbGEjcyFsYSN0IWxhI3UhbGEjdyFsYSN5IWxhI3ohbGEocCFsYSh3IWxhKHghbGF+T2EhbGEneCFsYSd1IWxhIVchbGEhaSFsYXQhbGEhXSFsYSVoIWxhIWUhbGF+UEtaTyFpKGFPfk8hZSN2TyNeKGJPKHAnbk8hWihyWGEoclgneChyWH5PIWkoclh+UE12TyFRJWdPIV0laE8hel1PI2coZ08jaChmTyhSJWZPfk8hWihoTyFpKHFYfk8haShqT35PIVElZ08hXSVoTyNoKGZPKFIlZk9+T1AoZVhSKGVYWyhlWHAoZVghTyhlWCFRKGVYIVooZVghaihlWCFuKGVYI1AoZVgjbChlWCNtKGVYI24oZVgjbyhlWCNwKGVYI3EoZVgjcihlWCNzKGVYI3QoZVgjdShlWCN3KGVYI3koZVgjeihlWChfKGVYKHAoZVgodyhlWCh4KGVYfk8hZSN2TyFpKGVYflAhIGRPUihsTyFPKGtPIWojeE8jUSRkTyF6IXlhIVEheWF+TyF2IXlhJWcheWEhXSF5YSNnIXlhI2gheWEoUiF5YX5QISNlTyF2KHBPfk9QWU9RWU9TZk9kIWpPZSFpT25rT3BZT3FrT3JrT3hrT3pZT3xZTyFRV08hVWtPIVZrTyFdWE8hZ3VPIWpaTyFtWU8hbllPIW9ZTyFxdk8hcyFnTyF2IWhPJFYha08kbWlPKFIhZE8oVFRPKFdVTyhfVk8obVtPfk9oJVZPbiVXT3AlWE9xJHRPciR0T3glWU96JVpPfDxlTyFRJHtPIV0kfE8hZz12TyFqJHhPI2g8a08kViVfTyRzPGdPJHU8aU8keCVgTyhSKHRPKFRUTyhXVU8oXyR1Tyh3JH1PKHglUE9+TyNpKHZPfk8hWSh4TyFpKGlQflAlW08oYyh6TyhtW09+TyFRKHxPIWojeE8oYyh6TyhtW09+T1A7dk9RO3ZPU2ZPZD1yT2UhaU9ua09wO3ZPcWtPcmtPeGtPejt2T3w7dk8hUVdPIVVrTyFWa08hXSFlTyFnO3lPIWpaTyFtO3ZPIW47dk8hbzt2TyFxO3pPIXM7fU8hdiFoTyRWIWtPJG09cE8oUilaTyhUVE8oV1VPKF9WTyhtW09+TyFaJF9PYSRwYSd4JHBhJ3UkcGEhaSRwYSFXJHBhIV0kcGElaCRwYSFlJHBhfk9qKWJPflAhJmlPaCVWT24lV09wJVhPcSR0T3IkdE94JVlPeiVaT3wlW08hUSR7TyFdJHxPIWclYU8haiR4TyNoJWJPJFYlX08kcyVdTyR1JV5PJHglYE8oUih0TyhUVE8oV1VPKF8kdU8odyR9Tyh4JVBPfk9nKG5QflAhK3JPIU8pZ08hZSlmTyFdJF1YJFkkXVgkWyRdWCReJF1YJGUkXVh+TyFlKWZPIV0oeVgkWSh5WCRbKHlYJF4oeVgkZSh5WH5PIU8pZ09+UCEte08hTylnTyFdKHlYJFkoeVgkWyh5WCReKHlYJGUoeVh+TyFdKWlPJFkpbU8kWyloTyReKWhPJGUpbk9+TyFZKXFPflAhKHlPJFskaE8kXiRnTyRlKXVPfk9sJHlYIU8keVgjUSR5WCd3JHlYKHckeVgoeCR5WH5PZ2tYZyR5WGxrWCFaa1gjXmtYflAhL3FPdil3TyhgKXhPKGEpek9+T2wqVE8hTyl8Tyd3KX1PKHckfU8oeCVQT35PZyl7T35QITB1T2cqVU9+T2glVk9uJVdPcCVYT3EkdE9yJHRPeCVZT3olWk98PGVPIVEqV08hXSpYTyFnPXZPIWokeE8jaDxrTyRWJV9PJHM8Z08kdTxpTyR4JWBPKFRUTyhXVU8oXyR1Tyh3JH1PKHglUE9+TyFZKltPKFIqVk8haSh8UH5QITFkTyNpKl5Pfk8haipfT35PaCVWT24lV09wJVhPcSR0T3IkdE94JVlPeiVaT3w8ZU8hUSR7TyFdJHxPIWc9dk8haiR4TyNoPGtPJFYlX08kczxnTyR1PGlPJHglYE8oUiphTyhUVE8oV1VPKF8kdU8odyR9Tyh4JVBPfk8hWSpkTyFXKH1QflAhM2NPcCpwT3Ehbk8hUSpmTyFgKm5PIWEqaE8hYipoTyFqKl9PI1kqb08lXypqTyhTIWxPKFRUTyhXVU8oYyFtT35PIVsqbU9+UCE1V08jUSRkT2woXlghTyheWCd3KF5YKHcoXlgoeCheWCFaKF5YI14oXlh+T2coXlgjfSheWH5QITZZT2wqdU8jXip0T2coXVghWihdWH5PIVoqdk9nKFtYfk9qJWNPKFImWE9nKFtQfk9xKnlPfk8haitPT35PKFIodE9+T24rVE8hUSVnTyFZI2lPIV0laE8hel1PI2cjbE8jaCNpTyhSJWZPIWkocVB+TyFlI3ZPI2krVU9+TyFRJWdPIVkrV08hWihbTyFdJWhPKFIlZk8hVyh0UH5PcSdZTyFRK1lPIVkrWE8oVFRPKFdVTyhjKHpPfk8hWyh2UH5QITldTyFaK1pPYSlSWCd4KVJYfk9QJFtPUiN6T1skY09wJGFPIU8jeU8hUSN7TyFqI3hPIW4kW08jUCRSTyNsJE9PI20kUE8jbiRQTyNvJFBPI3AkUU8jcSRSTyNyJFJPI3MkYk8jdCRSTyN1JFNPI3ckVU8jeSRXTyN6JFhPKF9WTyhwJFlPKHcjfE8oeCN9T35PYSFoYSFaIWhhJ3ghaGEndSFoYSFXIWhhIWkhaGF0IWhhIV0haGElaCFoYSFlIWhhflAhOlRPUiN6TyFPI3lPIVEje08haiN4TyhfVk9QIXBhWyFwYXAhcGEhWiFwYSFuIXBhI1AhcGEjbCFwYSNtIXBhI24hcGEjbyFwYSNwIXBhI3EhcGEjciFwYSNzIXBhI3QhcGEjdSFwYSN3IXBhI3khcGEjeiFwYShwIXBhKHchcGEoeCFwYX5PYSFwYSd4IXBhJ3UhcGEhVyFwYSFpIXBhdCFwYSFdIXBhJWghcGEhZSFwYX5QITxrT1Ijek8hTyN5TyFRI3tPIWojeE8oX1ZPUCFyYVshcmFwIXJhIVohcmEhbiFyYSNQIXJhI2whcmEjbSFyYSNuIXJhI28hcmEjcCFyYSNxIXJhI3IhcmEjcyFyYSN0IXJhI3UhcmEjdyFyYSN5IXJhI3ohcmEocCFyYSh3IXJhKHghcmF+T2EhcmEneCFyYSd1IXJhIVchcmEhaSFyYXQhcmEhXSFyYSVoIXJhIWUhcmF+UCE/Uk9oJVZPbCtkTyFdJ15PJWgrY09+TyFlK2ZPYShaWCFdKFpYJ3goWlghWihaWH5PYSVtTyFdWE8neCVtT35PaCVWTyFqJWRPfk9oJVZPIWolZE8oUiVmT35PIWUjdk8jaSh2T35PYitxTyVpK3JPKFIrbk8oVFRPKFdVTyFbKVZQfk8hWitzT2ApVVh+T1srd09+T2AreE9+TyFdJk9PKFIlZk8oUyFsT2ApVVB+T2glVk8jXit9T35PaCVWT2wsUU8hXSR8T35PIV0sU09+TyFPLFVPIV1YT35PJW0ldU9+TyF2LFpPfk9lLGBPfk9iLGFPKFIjbk8oVFRPKFdVTyFbKVRQfk9lJXxPfk8laSFRTyhSJlhPflA9VU9bLGZPYCxlT35PUFlPUVlPU2ZPZHpPZXlPbmtPcFlPcWtPcmtPeGtPellPfFlPIVFXTyFVa08hVmtPIWd1TyFqWk8hbVlPIW5ZTyFvWU8hcXZPIXZ4TyF6XU8kbWlPJWd9TyhUVE8oV1VPKF9WTyhtW09+TyFdIWVPIXMhZ08kViFrTyhSIWRPflAhRlJPYCxlT2ElbU8neCVtT35PUFlPUVlPU2ZPZCFqT2UhaU9ua09wWU9xa09ya094a096WU98WU8hUVdPIVVrTyFWa08hXSFlTyFndU8halpPIW1ZTyFuWU8hb1lPIXF2TyF2IWhPJFYha08kbWlPKFIhZE8oVFRPKFdVTyhfVk8obVtPfk9hLGtPaiFPTyFzd08layFPTyVsIU9PJW0hT09+UCFIa08haiZtT35PJlsscU9+TyFdLHNPfk8mbSx1TyZvLHZPUCZqYVEmamFTJmphWSZqYWEmamFkJmphZSZqYWomamFuJmphcCZqYXEmamFyJmpheCZqYXomamF8JmphIVEmamEhVSZqYSFWJmphIV0mamEhZyZqYSFqJmphIW0mamEhbiZqYSFvJmphIXEmamEhcyZqYSF2JmphIXomamEkViZqYSRtJmphJWcmamElaSZqYSVrJmphJWwmamElbSZqYSVwJmphJXImamEldSZqYSV2JmphJXgmamEmVSZqYSZbJmphJl4mamEmYCZqYSZiJmphJmUmamEmayZqYSZxJmphJnMmamEmdSZqYSZ3JmphJnkmamEndSZqYShSJmphKFQmamEoVyZqYShfJmphKG0mamEhWyZqYSZjJmphYiZqYSZoJmphfk8oUix7T35PaCFjWCFaIVBYIVshUFghZSFQWCFlIWNYIWohY1gjXiFQWH5PIVohY1ghWyFjWH5QIyBxTyFlLVFPI14tUE9oKGhYIVojZlghWyNmWCFlKGhYIWooaFh+TyFaKGhYIVsoaFh+UCMhZE9oJVZPIWUtU08haiVkTyFaIV9YIVshX1h+T3Ehbk8hUSFvTyhUVE8oV1VPKGMhbU9+T1A7dk9RO3ZPU2ZPZD1yT2UhaU9ua09wO3ZPcWtPcmtPeGtPejt2T3w7dk8hUVdPIVVrTyFWa08hXSFlTyFnO3lPIWpaTyFtO3ZPIW47dk8hbzt2TyFxO3pPIXM7fU8hdiFoTyRWIWtPJG09cE8oVFRPKFdVTyhfVk8obVtPfk8oUjxyT35QIyN5TyFaLVdPIVsoZ1h+TyFbLVlPfk8hZS1RTyNeLVBPIVojZlghWyNmWH5PIVotWk8hWyh2WH5PIVstXU9+TyFhLV5PIWItXk8oUyFsT35QIyNoTyFbLWFPflAnX09sLWRPIV0nXk9+TyFXLWlPfk9xIXlhIWAheWEhYSF5YSFiIXlhI1IheWEjUyF5YSNUIXlhI1UheWEjViF5YSNZIXlhI1oheWEoUyF5YShUIXlhKFcheWEoYyF5YShtIXlhflAhI2VPIW4tbk8jXi1sT35QQ1ZPIWEtcE8hYi1wTyhTIWxPflBDdU9hJW1PI14tbE8neCVtT35PYSVtTyFlI3ZPI14tbE8neCVtT35PYSVtTyFlI3ZPIW4tbk8jXi1sTyd4JW1PKHAnbk9+Tyd9J3ZPKE8ndk8oUC11T35PdC12T35PIVcnVWEhWidVYX5QITpUTyFZLXpPIVcnVVghWidVWH5QJVtPIVooVE8hVyhmYX5PIVcoZmF+UEdwTyFaKFtPIVcodGF+TyFRJWdPIVkuT08hXSVoTyhSJWZPIVcnW1ghWidbWH5PI14uUU8hWihyYSFpKHJhYShyYSd4KHJhfk8hZSN2T35QIyxQTyFaKGhPIWkocWF+TyFRJWdPIV0laE8jaC5VTyhSJWZPfk9uLlpPIVElZ08hWS5XTyFdJWhPIXpdTyNnLllPI2guV08oUiVmTyFaJ19YIWknX1h+T1IuX08haiN4T35PaCVWT2wuYk8hXSdeTyVoLmFPfk9hI2FpIVojYWkneCNhaSd1I2FpIVcjYWkhaSNhaXQjYWkhXSNhaSVoI2FpIWUjYWl+UCE6VE9sPXxPIU8pfE8ndyl9Tyh3JH1PKHglUE9+TyNpI11hYSNdYSNeI11hJ3gjXWEhWiNdYSFpI11hIV0jXWEhVyNdYX5QIy57TyNpKF5YUCheWFIoXlhbKF5YYSheWHAoXlghUSheWCFqKF5YIW4oXlgjUCheWCNsKF5YI20oXlgjbiheWCNvKF5YI3AoXlgjcSheWCNyKF5YI3MoXlgjdCheWCN1KF5YI3coXlgjeSheWCN6KF5YJ3goXlgoXyheWChwKF5YIWkoXlghVyheWCd1KF5YdCheWCFdKF5YJWgoXlghZSheWH5QITZZTyFaLm9PIWkoaVh+UCE6VE8haS5yT35PIVcudE9+T1AkW09SI3pPIU8jeU8hUSN7TyFqI3hPIW4kW08oX1ZPWyNraWEja2lwI2tpIVoja2kjUCNraSNtI2tpI24ja2kjbyNraSNwI2tpI3Eja2kjciNraSNzI2tpI3Qja2kjdSNraSN3I2tpI3kja2kjeiNraSd4I2tpKHAja2kodyNraSh4I2tpJ3Uja2khVyNraSFpI2tpdCNraSFdI2tpJWgja2khZSNraX5PI2wja2l+UCMya08jbCRPT35QIzJrT1AkW09SI3pPcCRhTyFPI3lPIVEje08haiN4TyFuJFtPI2wkT08jbSRQTyNuJFBPI28kUE8oX1ZPWyNraWEja2khWiNraSNQI2tpI3Eja2kjciNraSNzI2tpI3Qja2kjdSNraSN3I2tpI3kja2kjeiNraSd4I2tpKHAja2kodyNraSh4I2tpJ3Uja2khVyNraSFpI2tpdCNraSFdI2tpJWgja2khZSNraX5PI3Aja2l+UCM1WU8jcCRRT35QIzVZT1AkW09SI3pPWyRjT3AkYU8hTyN5TyFRI3tPIWojeE8hbiRbTyNQJFJPI2wkT08jbSRQTyNuJFBPI28kUE8jcCRRTyNxJFJPI3IkUk8jcyRiTyN0JFJPKF9WT2Eja2khWiNraSN3I2tpI3kja2kjeiNraSd4I2tpKHAja2kodyNraSh4I2tpJ3Uja2khVyNraSFpI2tpdCNraSFdI2tpJWgja2khZSNraX5PI3Uja2l+UCM3d09QJFtPUiN6T1skY09wJGFPIU8jeU8hUSN7TyFqI3hPIW4kW08jUCRSTyNsJE9PI20kUE8jbiRQTyNvJFBPI3AkUU8jcSRSTyNyJFJPI3MkYk8jdCRSTyN1JFNPKF9WTyh4I31PYSNraSFaI2tpI3kja2kjeiNraSd4I2tpKHAja2kodyNraSd1I2tpIVcja2khaSNraXQja2khXSNraSVoI2tpIWUja2l+TyN3JFVPflAjOl9PI3cja2l+UCM6X08jdSRTT35QIzd3T1AkW09SI3pPWyRjT3AkYU8hTyN5TyFRI3tPIWojeE8hbiRbTyNQJFJPI2wkT08jbSRQTyNuJFBPI28kUE8jcCRRTyNxJFJPI3IkUk8jcyRiTyN0JFJPI3UkU08jdyRVTyhfVk8odyN8Tyh4I31PYSNraSFaI2tpI3oja2kneCNraShwI2tpJ3Uja2khVyNraSFpI2tpdCNraSFdI2tpJWgja2khZSNraX5PI3kja2l+UCM9VE8jeSRXT35QIz1UT1BdWFJdWFtdWHBdWCFPXVghUV1YIWpdWCFuXVgjUF1YI1FdWCNeXVgjaWZYI2xdWCNtXVgjbl1YI29dWCNwXVgjcV1YI3JdWCNzXVgjdF1YI3VdWCN3XVgjeV1YI3pdWCRQXVgoX11YKHBdWCh3XVgoeF1YIVpdWCFbXVh+TyN9XVh+UCM/ck9QJFtPUiN6T1s8X09wPF1PIU8jeU8hUSN7TyFqI3hPIW4kW08jUDxTTyNsPFBPI208UU8jbjxRTyNvPFFPI3A8Uk8jcTxTTyNyPFNPI3M8Xk8jdDxTTyN1PFRPI3c8Vk8jeTxYTyN6PFlPKF9WTyhwJFlPKHcjfE8oeCN9T35PI30udk9+UCNCUE8jUSRkTyNePGBPJFA8YE8jfShlWCFbKGVYflAhIGRPYSdiYSFaJ2JhJ3gnYmEndSdiYSFpJ2JhIVcnYmF0J2JhIV0nYmElaCdiYSFlJ2JhflAhOlRPWyNraWEja2lwI2tpIVoja2kjUCNraSNwI2tpI3Eja2kjciNraSNzI2tpI3Qja2kjdSNraSN3I2tpI3kja2kjeiNraSd4I2tpKHAja2kndSNraSFXI2tpIWkja2l0I2tpIV0ja2klaCNraSFlI2tpfk9QJFtPUiN6TyFPI3lPIVEje08haiN4TyFuJFtPI2wkT08jbSRQTyNuJFBPI28kUE8oX1ZPKHcja2koeCNraX5QI0VST2w9fE8hTyl8Tyd3KX1PKHckfU8oeCVQT1Aja2lSI2tpIVEja2khaiNraSFuI2tpI2wja2kjbSNraSNuI2tpI28ja2koXyNraX5QI0VSTyFaLnpPZyhuWH5QITB1T2cufE9+T2EkT2khWiRPaSd4JE9pJ3UkT2khVyRPaSFpJE9pdCRPaSFdJE9pJWgkT2khZSRPaX5QITpUTyRbLn1PJF4ufU9+TyRbL09PJF4vT09+TyFlKWZPI14vUE8hXSRiWCRZJGJYJFskYlgkXiRiWCRlJGJYfk8hWS9RT35PIV0paU8kWS9TTyRbKWhPJF4paE8kZS9UT35PIVo8Wk8hWyhkWH5QI0JQTyFbL1VPfk8hZSlmTyRlKHlYfk8kZS9XT35PdC9YT35QISZpT3Ypd08oYCl4TyhhL1tPfk8hUS9fT35PKHckfU9sJWBhIU8lYGEndyVgYSh4JWBhIVolYGEjXiVgYX5PZyVgYSN9JWBhflAjTFRPKHglUE9sJWJhIU8lYmEndyViYSh3JWJhIVolYmEjXiViYX5PZyViYSN9JWJhflAjTHZPIVpmWCFlZlghaWZYIWkkeVgocGZYflAhL3FPIVkvaE8hWihbTyhSL2dPIVcodFAhVyh9UH5QITFkT3AqcE8hYCpuTyFhKmhPIWIqaE8haipfTyNZKm9PJV8qak8oUyFsTyhUVE8oV1VPfk9xPG9PIVEvaU8hWStYTyFbKm1PKGM8bk8hWyh2UH5QI05hTyFpL2pPflAjLntPIVova08hZSN2TyhwJ25PIWkofFh+TyFpL3BPfk8hUSVnTyFZKltPIV0laE8oUiVmTyFpKHxQfk8jaS9yT35PIVckeVghWiR5WCFlJVFYflAhL3FPIVovc08hVyh9WH5QIy57TyFlL3VPfk8hVy93T35PbmtPKFIveE9+UC5pT2glVk9wL31PIWUjdk8haiVkTyhwJ25Pfk8hZStmT35PYSVtTyFaMFJPJ3glbU9+TyFbMFRPflAhNVdPIWEwVU8hYjBVTyhTIWxPflAjI2hPcSFuTyFRMFZPKFRUTyhXVU8oYyFtT35PI1kwWE9+T2clYGEhWiVgYSNeJWBhI30lYGF+UCEwdU9nJWJhIVolYmEjXiViYSN9JWJhflAhMHVPaiVjTyhSJlhPZydrWCFaJ2tYfk8hWip2T2coW2F+T2cwYk9+T1IwY08hTzBjTyFRMGRPI1EkZE9se2End3thKHd7YSh4e2EhWnthI157YX5PZ3thI317YX5QJCZkTyFPKXxPJ3cpfU9sJHJhKHckcmEoeCRyYSFaJHJhI14kcmF+T2ckcmEjfSRyYX5QJCdgTyFPKXxPJ3cpfU9sJHRhKHckdGEoeCR0YSFaJHRhI14kdGF+T2ckdGEjfSR0YX5QJChSTyNpMGdPfk9nJVNhIVolU2EjXiVTYSN9JVNhflAhMHVPbDBpTyNeMGhPZyhdYSFaKF1hfk8hZSN2T35PI2kwbE9+TyFaK1pPYSlSYSd4KVJhfk9SI3pPIU8jeU8hUSN7TyFqI3hPKF9WT1AhcGlbIXBpcCFwaSFaIXBpIW4hcGkjUCFwaSNsIXBpI20hcGkjbiFwaSNvIXBpI3AhcGkjcSFwaSNyIXBpI3MhcGkjdCFwaSN1IXBpI3chcGkjeSFwaSN6IXBpKHAhcGkodyFwaSh4IXBpfk9hIXBpJ3ghcGkndSFwaSFXIXBpIWkhcGl0IXBpIV0hcGklaCFwaSFlIXBpflAkKk9PaCVWT3AlWE9xJHRPciR0T3glWU96JVpPfDxlTyFRJHtPIV0kfE8hZz12TyFqJHhPI2g8a08kViVfTyRzPGdPJHU8aU8keCVgTyhUVE8oV1VPKF8kdU8odyR9Tyh4JVBPfk9uMHZPJVswd08oUjB0T35QJCxmTyFlK2ZPYShaYSFdKFphJ3goWmEhWihaYX5PI2kwfE9+T1tdWCFaZlghW2ZYfk8hWjB9TyFbKVZYfk8hWzFQT35PWzFRT35PYjFTTyhSK25PKFRUTyhXVU9+TyFdJk9PKFIlZk9gJ3NYIVonc1h+TyFaK3NPYClVYX5PIWkxVk9+UCE6VE9bMVlPfk9gMVpPfk8jXjFeT35PbDFhTyFdJHxPfk8oYyh6TyFbKVNQfk9oJVZPbDFqTyFdMWdPJWgxaU9+T1sxdE8hWjFyTyFbKVRYfk8hWzF1T35PYDF3T2ElbU8neCVtT35PKFIjbk8oVFRPKFdVT35PI1EkZE8jXiRlTyRQJGVPUChlWFIoZVhbKGVYcChlWCFPKGVYIVEoZVghWihlWCFqKGVYIW4oZVgjUChlWCNsKGVYI20oZVgjbihlWCNvKGVYI3AoZVgjcShlWCNyKGVYI3MoZVgjdShlWCN3KGVYI3koZVgjeihlWChfKGVYKHAoZVgodyhlWCh4KGVYfk8jdDF6TyZZMXtPYShlWH5QJDJQTyNeJGVPI3Qxek8mWTF7T35PYTF9T35QJVtPYTJQT35PJmMyU09QJmFpUSZhaVMmYWlZJmFpYSZhaWQmYWllJmFpaiZhaW4mYWlwJmFpcSZhaXImYWl4JmFpeiZhaXwmYWkhUSZhaSFVJmFpIVYmYWkhXSZhaSFnJmFpIWomYWkhbSZhaSFuJmFpIW8mYWkhcSZhaSFzJmFpIXYmYWkheiZhaSRWJmFpJG0mYWklZyZhaSVpJmFpJWsmYWklbCZhaSVtJmFpJXAmYWklciZhaSV1JmFpJXYmYWkleCZhaSZVJmFpJlsmYWkmXiZhaSZgJmFpJmImYWkmZSZhaSZrJmFpJnEmYWkmcyZhaSZ1JmFpJncmYWkmeSZhaSd1JmFpKFImYWkoVCZhaShXJmFpKF8mYWkobSZhaSFbJmFpYiZhaSZoJmFpfk9iMllPIVsyV08maDJYT35QYE8hXVhPIWoyW09+TyZvLHZPUCZqaVEmamlTJmppWSZqaWEmamlkJmppZSZqaWomamluJmppcCZqaXEmamlyJmppeCZqaXomaml8JmppIVEmamkhVSZqaSFWJmppIV0mamkhZyZqaSFqJmppIW0mamkhbiZqaSFvJmppIXEmamkhcyZqaSF2JmppIXomamkkViZqaSRtJmppJWcmamklaSZqaSVrJmppJWwmamklbSZqaSVwJmppJXImamkldSZqaSV2JmppJXgmamkmVSZqaSZbJmppJl4mamkmYCZqaSZiJmppJmUmamkmayZqaSZxJmppJnMmamkmdSZqaSZ3JmppJnkmamkndSZqaShSJmppKFQmamkoVyZqaShfJmppKG0mamkhWyZqaSZjJmppYiZqaSZoJmppfk8hVzJiT35PIVohX2EhWyFfYX5QI0JQT3Ehbk8hUSFvTyFZMmhPKGMhbU8hWidWWCFbJ1ZYflBAXU8hWi1XTyFbKGdhfk8hWiddWCFbJ11YflAhOV1PIVotWk8hWyh2YX5PIVsyb09+UCdfT2ElbU8jXjJ4Tyd4JW1Pfk9hJW1PIWUjdk8jXjJ4Tyd4JW1Pfk9hJW1PIWUjdk8hbjJ8TyNeMnhPJ3glbU8ocCduT35PYSVtTyd4JW1PflAhOlRPIVokX090JHBhfk8hVydVaSFaJ1VpflAhOlRPIVooVE8hVyhmaX5PIVooW08hVyh0aX5PIVcodWkhWih1aX5QITpUTyFaKHJpIWkocmlhKHJpJ3gocml+UCE6VE8jXjNPTyFaKHJpIWkocmlhKHJpJ3gocml+TyFaKGhPIWkocWl+TyFRJWdPIV0laE8hel1PI2czVE8jaDNTTyhSJWZPfk8hUSVnTyFdJWhPI2gzU08oUiVmT35PbDNbTyFdJ15PJWgzWk9+T2glVk9sM1tPIV0nXk8laDNaT35PI2klYGFQJWBhUiVgYVslYGFhJWBhcCVgYSFRJWBhIWolYGEhbiVgYSNQJWBhI2wlYGEjbSVgYSNuJWBhI28lYGEjcCVgYSNxJWBhI3IlYGEjcyVgYSN0JWBhI3UlYGEjdyVgYSN5JWBhI3olYGEneCVgYShfJWBhKHAlYGEhaSVgYSFXJWBhJ3UlYGF0JWBhIV0lYGElaCVgYSFlJWBhflAjTFRPI2klYmFQJWJhUiViYVslYmFhJWJhcCViYSFRJWJhIWolYmEhbiViYSNQJWJhI2wlYmEjbSViYSNuJWJhI28lYmEjcCViYSNxJWJhI3IlYmEjcyViYSN0JWJhI3UlYmEjdyViYSN5JWJhI3olYmEneCViYShfJWJhKHAlYmEhaSViYSFXJWJhJ3UlYmF0JWJhIV0lYmElaCViYSFlJWJhflAjTHZPI2klYGFQJWBhUiVgYVslYGFhJWBhcCVgYSFRJWBhIVolYGEhaiVgYSFuJWBhI1AlYGEjbCVgYSNtJWBhI24lYGEjbyVgYSNwJWBhI3ElYGEjciVgYSNzJWBhI3QlYGEjdSVgYSN3JWBhI3klYGEjeiVgYSd4JWBhKF8lYGEocCVgYSFpJWBhIVclYGEndSVgYSNeJWBhdCVgYSFdJWBhJWglYGEhZSVgYX5QIy57TyNpJWJhUCViYVIlYmFbJWJhYSViYXAlYmEhUSViYSFaJWJhIWolYmEhbiViYSNQJWJhI2wlYmEjbSViYSNuJWJhI28lYmEjcCViYSNxJWJhI3IlYmEjcyViYSN0JWJhI3UlYmEjdyViYSN5JWJhI3olYmEneCViYShfJWJhKHAlYmEhaSViYSFXJWJhJ3UlYmEjXiViYXQlYmEhXSViYSVoJWJhIWUlYmF+UCMue08jaXthUHthW3thYXthcHthIWp7YSFue2EjUHthI2x7YSNte2EjbnthI297YSNwe2EjcXthI3J7YSNze2EjdHthI3V7YSN3e2EjeXthI3p7YSd4e2EoX3thKHB7YSFpe2EhV3thJ3V7YXR7YSFde2ElaHthIWV7YX5QJCZkTyNpJHJhUCRyYVIkcmFbJHJhYSRyYXAkcmEhUSRyYSFqJHJhIW4kcmEjUCRyYSNsJHJhI20kcmEjbiRyYSNvJHJhI3AkcmEjcSRyYSNyJHJhI3MkcmEjdCRyYSN1JHJhI3ckcmEjeSRyYSN6JHJhJ3gkcmEoXyRyYShwJHJhIWkkcmEhVyRyYSd1JHJhdCRyYSFdJHJhJWgkcmEhZSRyYX5QJCdgTyNpJHRhUCR0YVIkdGFbJHRhYSR0YXAkdGEhUSR0YSFqJHRhIW4kdGEjUCR0YSNsJHRhI20kdGEjbiR0YSNvJHRhI3AkdGEjcSR0YSNyJHRhI3MkdGEjdCR0YSN1JHRhI3ckdGEjeSR0YSN6JHRhJ3gkdGEoXyR0YShwJHRhIWkkdGEhVyR0YSd1JHRhdCR0YSFdJHRhJWgkdGEhZSR0YX5QJChSTyNpJVNhUCVTYVIlU2FbJVNhYSVTYXAlU2EhUSVTYSFaJVNhIWolU2EhbiVTYSNQJVNhI2wlU2EjbSVTYSNuJVNhI28lU2EjcCVTYSNxJVNhI3IlU2EjcyVTYSN0JVNhI3UlU2EjdyVTYSN5JVNhI3olU2EneCVTYShfJVNhKHAlU2EhaSVTYSFXJVNhJ3UlU2EjXiVTYXQlU2EhXSVTYSVoJVNhIWUlU2F+UCMue09hI2FxIVojYXEneCNhcSd1I2FxIVcjYXEhaSNhcXQjYXEhXSNhcSVoI2FxIWUjYXF+UCE6VE8hWTNkTyFaJ1dYIWknV1h+UCVbTyFaLm9PIWkoaWF+TyFaLm9PIWkoaWF+UCE6VE8hVzNnT35PI30hbGEhWyFsYX5QS1pPI30haGEhWiFoYSFbIWhhflAjQlBPI30hcGEhWyFwYX5QITxrTyN9IXJhIVshcmF+UCE/Uk9nJ1pYIVonWlh+UCErck8hWi56T2cobmF+T1NmTyFdM3tPJGMzfE9+TyFbNFFPfk90NFJPflAjLntPYSRscSFaJGxxJ3gkbHEndSRscSFXJGxxIWkkbHF0JGxxIV0kbHElaCRscSFlJGxxflAhOlRPIVc0VE9+UCEmaU8hUTRVT35PIU8pfE8ndyl9Tyh4JVBPbCdnYSh3J2dhIVonZ2EjXidnYX5PZydnYSN9J2dhflAlK3VPIU8pfE8ndyl9T2wnaWEodydpYSh4J2lhIVonaWEjXidpYX5PZydpYSN9J2lhflAlLGhPKHAkWU9+UCMue08hV2ZYIVckeVghWmZYIVokeVghZSVRWCNeZlh+UCEvcU8oUjx4T35QITFkTyFRJWdPIVk0WE8hXSVoTyhSJWZPIVonY1ghaSdjWH5PIVova08haSh8YX5PIVova08hZSN2TyFpKHxhfk8hWi9rTyFlI3ZPKHAnbk8haSh8YX5PZyR7aSFaJHtpI14ke2kjfSR7aX5QITB1TyFZNGFPIVcnZVghWidlWH5QITNjTyFaL3NPIVcofWF+TyFaL3NPIVcofWF+UCMue09QXVhSXVhbXVhwXVghT11YIVFdWCFXXVghWl1YIWpdWCFuXVgjUF1YI1FdWCNeXVgjaWZYI2xdWCNtXVgjbl1YI29dWCNwXVgjcV1YI3JdWCNzXVgjdF1YI3VdWCN3XVgjeV1YI3pdWCRQXVgoX11YKHBdWCh3XVgoeF1Yfk8hZSVYWCN0JVhYflAlMFhPIWUjdk8jdDRmT35PaCVWTyFlI3ZPIWolZE9+T2glVk9wNGtPIWolZE8ocCduT35PcDRwTyFlI3ZPKHAnbk9+T3Ehbk8hUTRxTyhUVE8oV1VPKGMhbU9+Tyh3JH1PbCVgaSFPJWBpJ3clYGkoeCVgaSFaJWBpI14lYGl+T2clYGkjfSVgaX5QJTN4Tyh4JVBPbCViaSFPJWJpJ3clYmkodyViaSFaJWJpI14lYml+T2clYmkjfSViaX5QJTRrT2coXWkhWihdaX5QITB1TyNeNHdPZyhdaSFaKF1pflAhMHVPIWk0ek9+T2EkbnEhWiRucSd4JG5xJ3UkbnEhVyRucSFpJG5xdCRucSFdJG5xJWgkbnEhZSRucX5QITpUTyFXNVFPfk8hWjVSTyFdKU9YflAjLntPYV1YYSR5WCFdXVghXSR5WCVdXVgneF1YJ3gkeVghWl1YIVokeVh+UCEvcU8lXTVVT2ElWmEhXSVaYSd4JVphIVolWmF+T2xtWCFPbVgnd21YKHdtWCh4bVh+UCU3bk9uNVZPKFIjbk9+T2I1XU8laTVeTyhSK25PKFRUTyhXVU8hWidyWCFbJ3JYfk8hWjB9TyFbKVZhfk9bNWJPfk9gNWNPfk9hJW1PJ3glbU9+UCMue08hWjVrTyNeNW1PIVspU1h+TyFbNW5Pfk9wNXRPcSFuTyFRKmZPIWAheU8hYSF2TyFiIXZPIXo7d08jUiFwTyNTIXBPI1QhcE8jVSFwTyNWIXBPI1k1c08jWiF6TyhTIWxPKFRUTyhXVU8oYyFtTyhtIXNPfk8hWzVyT35QJTpST2w1eU8hXTFnTyVoNXhPfk9oJVZPbDV5TyFdMWdPJWg1eE9+T2I2UU8oUiNuTyhUVE8oV1VPIVoncVghWydxWH5PIVoxck8hWylUYX5PKFRUTyhXVU8oYzZTT35PYDZXT35PI3Q2Wk8mWTZbT35QTXZPIWk2XU9+UCVbT2E2X09+T2E2X09+UCVbT2IyWU8hWzZkTyZoMlhPflBgTyFlNmZPfk8hZTZoT2goaGkhWihoaSFbKGhpIWUoaGkhaihoaXAoaGkocChoaX5PIVojZmkhWyNmaX5QI0JQTyNeNmlPIVojZmkhWyNmaX5PIVohX2khWyFfaX5QI0JQT2ElbU8jXjZyTyd4JW1Pfk9hJW1PIWUjdk8jXjZyTyd4JW1Pfk8hWihycSFpKHJxYShycSd4KHJxflAhOlRPIVooaE8haShxcX5PIVElZ08hXSVoTyNoNnlPKFIlZk9+TyFdJ15PJWg2fE9+T2w3UU8hXSdeTyVoNnxPfk8jaSdnYVAnZ2FSJ2dhWydnYWEnZ2FwJ2dhIVEnZ2EhaidnYSFuJ2dhI1AnZ2EjbCdnYSNtJ2dhI24nZ2EjbydnYSNwJ2dhI3EnZ2EjcidnYSNzJ2dhI3QnZ2EjdSdnYSN3J2dhI3knZ2EjeidnYSd4J2dhKF8nZ2EocCdnYSFpJ2dhIVcnZ2EndSdnYXQnZ2EhXSdnYSVoJ2dhIWUnZ2F+UCUrdU8jaSdpYVAnaWFSJ2lhWydpYWEnaWFwJ2lhIVEnaWEhaidpYSFuJ2lhI1AnaWEjbCdpYSNtJ2lhI24naWEjbydpYSNwJ2lhI3EnaWEjcidpYSNzJ2lhI3QnaWEjdSdpYSN3J2lhI3knaWEjeidpYSd4J2lhKF8naWEocCdpYSFpJ2lhIVcnaWEndSdpYXQnaWEhXSdpYSVoJ2lhIWUnaWF+UCUsaE8jaSR7aVAke2lSJHtpWyR7aWEke2lwJHtpIVEke2khWiR7aSFqJHtpIW4ke2kjUCR7aSNsJHtpI20ke2kjbiR7aSNvJHtpI3Ake2kjcSR7aSNyJHtpI3Mke2kjdCR7aSN1JHtpI3cke2kjeSR7aSN6JHtpJ3gke2koXyR7aShwJHtpIWkke2khVyR7aSd1JHtpI14ke2l0JHtpIV0ke2klaCR7aSFlJHtpflAjLntPI2klYGlQJWBpUiVgaVslYGlhJWBpcCVgaSFRJWBpIWolYGkhbiVgaSNQJWBpI2wlYGkjbSVgaSNuJWBpI28lYGkjcCVgaSNxJWBpI3IlYGkjcyVgaSN0JWBpI3UlYGkjdyVgaSN5JWBpI3olYGkneCVgaShfJWBpKHAlYGkhaSVgaSFXJWBpJ3UlYGl0JWBpIV0lYGklaCVgaSFlJWBpflAlM3hPI2klYmlQJWJpUiViaVslYmlhJWJpcCViaSFRJWJpIWolYmkhbiViaSNQJWJpI2wlYmkjbSViaSNuJWJpI28lYmkjcCViaSNxJWJpI3IlYmkjcyViaSN0JWJpI3UlYmkjdyViaSN5JWJpI3olYmkneCViaShfJWJpKHAlYmkhaSViaSFXJWJpJ3UlYml0JWJpIV0lYmklaCViaSFlJWJpflAlNGtPIVonV2EhaSdXYX5QITpUTyFaLm9PIWkoaWl+TyN9I2FpIVojYWkhWyNhaX5QI0JQT1AkW09SI3pPIU8jeU8hUSN7TyFqI3hPIW4kW08oX1ZPWyNraXAja2kjUCNraSNtI2tpI24ja2kjbyNraSNwI2tpI3Eja2kjciNraSNzI2tpI3Qja2kjdSNraSN3I2tpI3kja2kjeiNraSN9I2tpKHAja2kodyNraSh4I2tpIVoja2khWyNraX5PI2wja2l+UCVNUU8jbDxQT35QJU1RT1AkW09SI3pPcDxdTyFPI3lPIVEje08haiN4TyFuJFtPI2w8UE8jbTxRTyNuPFFPI288UU8oX1ZPWyNraSNQI2tpI3Eja2kjciNraSNzI2tpI3Qja2kjdSNraSN3I2tpI3kja2kjeiNraSN9I2tpKHAja2kodyNraSh4I2tpIVoja2khWyNraX5PI3Aja2l+UCYgWU8jcDxST35QJiBZT1AkW09SI3pPWzxfT3A8XU8hTyN5TyFRI3tPIWojeE8hbiRbTyNQPFNPI2w8UE8jbTxRTyNuPFFPI288UU8jcDxSTyNxPFNPI3I8U08jczxeTyN0PFNPKF9WTyN3I2tpI3kja2kjeiNraSN9I2tpKHAja2kodyNraSh4I2tpIVoja2khWyNraX5PI3Uja2l+UCYjYk9QJFtPUiN6T1s8X09wPF1PIU8jeU8hUSN7TyFqI3hPIW4kW08jUDxTTyNsPFBPI208UU8jbjxRTyNvPFFPI3A8Uk8jcTxTTyNyPFNPI3M8Xk8jdDxTTyN1PFRPKF9WTyh4I31PI3kja2kjeiNraSN9I2tpKHAja2kodyNraSFaI2tpIVsja2l+TyN3PFZPflAmJWNPI3cja2l+UCYlY08jdTxUT35QJiNiT1AkW09SI3pPWzxfT3A8XU8hTyN5TyFRI3tPIWojeE8hbiRbTyNQPFNPI2w8UE8jbTxRTyNuPFFPI288UU8jcDxSTyNxPFNPI3I8U08jczxeTyN0PFNPI3U8VE8jdzxWTyhfVk8odyN8Tyh4I31PI3oja2kjfSNraShwI2tpIVoja2khWyNraX5PI3kja2l+UCYnck8jeTxYT35QJidyT2Eje3khWiN7eSd4I3t5J3Uje3khVyN7eSFpI3t5dCN7eSFdI3t5JWgje3khZSN7eX5QITpUT1sja2lwI2tpI1Aja2kjcCNraSNxI2tpI3Ija2kjcyNraSN0I2tpI3Uja2kjdyNraSN5I2tpI3oja2kjfSNraShwI2tpIVoja2khWyNraX5PUCRbT1Ijek8hTyN5TyFRI3tPIWojeE8hbiRbTyNsPFBPI208UU8jbjxRTyNvPFFPKF9WTyh3I2tpKHgja2l+UCYqbk9sPX1PIU8pfE8ndyl9Tyh3JH1PKHglUE9QI2tpUiNraSFRI2tpIWoja2khbiNraSNsI2tpI20ja2kjbiNraSNvI2tpKF8ja2l+UCYqbk8jUSRkT1AoXlhSKF5YWyheWGwoXlhwKF5YIU8oXlghUSheWCFqKF5YIW4oXlgjUCheWCNsKF5YI20oXlgjbiheWCNvKF5YI3AoXlgjcSheWCNyKF5YI3MoXlgjdCheWCN1KF5YI3coXlgjeSheWCN6KF5YI30oXlgndyheWChfKF5YKHAoXlgodyheWCh4KF5YIVooXlghWyheWH5PI30kT2khWiRPaSFbJE9pflAjQlBPI30hcGkhWyFwaX5QJCpPT2cnWmEhWidaYX5QITB1TyFbN2RPfk8hWidiYSFbJ2JhflAjQlBPIVc3ZU9+UCMue08hZSN2TyhwJ25PIVonY2EhaSdjYX5PIVova08haSh8aX5PIVova08hZSN2TyFpKHxpfk9nJHtxIVoke3EjXiR7cSN9JHtxflAhMHVPIVcnZWEhWidlYX5QIy57TyFlN2xPfk8hWi9zTyFXKH1pflAjLntPIVovc08hVyh9aX5PIVc3b09+T2glVk9wN3RPIWolZE8ocCduT35PIWUjdk8jdDd2T35PcDd5TyFlI3ZPKHAnbk9+TyFPKXxPJ3cpfU8oeCVQT2wnaGEodydoYSFaJ2hhI14naGF+T2cnaGEjfSdoYX5QJjNvTyFPKXxPJ3cpfU9sJ2phKHcnamEoeCdqYSFaJ2phI14namF+T2cnamEjfSdqYX5QJjRiTyFXN3tPfk9nJH1xIVokfXEjXiR9cSN9JH1xflAhMHVPZyhdcSFaKF1xflAhMHVPI143fE9nKF1xIVooXXF+UCEwdU9hJG55IVokbnkneCRueSd1JG55IVckbnkhaSRueXQkbnkhXSRueSVoJG55IWUkbnl+UCE6VE8hZTZoT35PIVo1Uk8hXSlPYX5PIV0nXk9QJFNhUiRTYVskU2FwJFNhIU8kU2EhUSRTYSFaJFNhIWokU2EhbiRTYSNQJFNhI2wkU2EjbSRTYSNuJFNhI28kU2EjcCRTYSNxJFNhI3IkU2EjcyRTYSN0JFNhI3UkU2EjdyRTYSN5JFNhI3okU2EoXyRTYShwJFNhKHckU2EoeCRTYX5PJWg2fE9+UCY3U08lXThRT2ElWmkhXSVaaSd4JVppIVolWml+T2EjYXkhWiNheSd4I2F5J3UjYXkhVyNheSFpI2F5dCNheSFdI2F5JWgjYXkhZSNheX5QITpUT1s4U09+T2I4VU8oUituTyhUVE8oV1VPfk8hWjB9TyFbKVZpfk9gOFlPfk8oYyh6TyFaJ25YIVsnblh+TyFaNWtPIVspU2F+TyFbOGNPflAlOlJPKG0hc09+UCQkb08jWThkT35PIV0xZ09+TyFdMWdPJWg4Zk9+T2w4aU8hXTFnTyVoOGZPfk9bOG5PIVoncWEhWydxYX5PIVoxck8hWylUaX5PIWk4ck9+TyFpOHNPfk8haTh2T35PIWk4dk9+UCVbT2E4eE9+TyFlOHlPfk8haTh6T35PIVoodWkhWyh1aX5QI0JQT2ElbU8jXjlTTyd4JW1Pfk8hWihyeSFpKHJ5YShyeSd4KHJ5flAhOlRPIVooaE8haShxeX5PJWg5Vk9+UCY3U08hXSdeTyVoOVZPfk8jaSR7cVAke3FSJHtxWyR7cWEke3FwJHtxIVEke3EhWiR7cSFqJHtxIW4ke3EjUCR7cSNsJHtxI20ke3EjbiR7cSNvJHtxI3Ake3EjcSR7cSNyJHtxI3Mke3EjdCR7cSN1JHtxI3cke3EjeSR7cSN6JHtxJ3gke3EoXyR7cShwJHtxIWkke3EhVyR7cSd1JHtxI14ke3F0JHtxIV0ke3ElaCR7cSFlJHtxflAjLntPI2knaGFQJ2hhUidoYVsnaGFhJ2hhcCdoYSFRJ2hhIWonaGEhbidoYSNQJ2hhI2wnaGEjbSdoYSNuJ2hhI28naGEjcCdoYSNxJ2hhI3InaGEjcydoYSN0J2hhI3UnaGEjdydoYSN5J2hhI3onaGEneCdoYShfJ2hhKHAnaGEhaSdoYSFXJ2hhJ3UnaGF0J2hhIV0naGElaCdoYSFlJ2hhflAmM29PI2knamFQJ2phUidqYVsnamFhJ2phcCdqYSFRJ2phIWonamEhbidqYSNQJ2phI2wnamEjbSdqYSNuJ2phI28namEjcCdqYSNxJ2phI3InamEjcydqYSN0J2phI3UnamEjdydqYSN5J2phI3onamEneCdqYShfJ2phKHAnamEhaSdqYSFXJ2phJ3UnamF0J2phIV0namElaCdqYSFlJ2phflAmNGJPI2kkfXFQJH1xUiR9cVskfXFhJH1xcCR9cSFRJH1xIVokfXEhaiR9cSFuJH1xI1AkfXEjbCR9cSNtJH1xI24kfXEjbyR9cSNwJH1xI3EkfXEjciR9cSNzJH1xI3QkfXEjdSR9cSN3JH1xI3kkfXEjeiR9cSd4JH1xKF8kfXEocCR9cSFpJH1xIVckfXEndSR9cSNeJH1xdCR9cSFdJH1xJWgkfXEhZSR9cX5QIy57TyFaJ1dpIWknV2l+UCE6VE8jfSNhcSFaI2FxIVsjYXF+UCNCUE8odyR9T1AlYGFSJWBhWyVgYXAlYGEhUSVgYSFqJWBhIW4lYGEjUCVgYSNsJWBhI20lYGEjbiVgYSNvJWBhI3AlYGEjcSVgYSNyJWBhI3MlYGEjdCVgYSN1JWBhI3clYGEjeSVgYSN6JWBhI30lYGEoXyVgYShwJWBhIVolYGEhWyVgYX5PbCVgYSFPJWBhJ3clYGEoeCVgYX5QJkhnTyh4JVBPUCViYVIlYmFbJWJhcCViYSFRJWJhIWolYmEhbiViYSNQJWJhI2wlYmEjbSViYSNuJWJhI28lYmEjcCViYSNxJWJhI3IlYmEjcyViYSN0JWJhI3UlYmEjdyViYSN5JWJhI3olYmEjfSViYShfJWJhKHAlYmEhWiViYSFbJWJhfk9sJWJhIU8lYmEndyViYSh3JWJhflAmSm5PbD19TyFPKXxPJ3cpfU8oeCVQT35QJkhnT2w9fU8hTyl8Tyd3KX1PKHckfU9+UCZKbk9SMGNPIU8wY08hUTBkTyNRJGRPUHthW3thbHthcHthIWp7YSFue2EjUHthI2x7YSNte2EjbnthI297YSNwe2EjcXthI3J7YSNze2EjdHthI3V7YSN3e2EjeXthI3p7YSN9e2End3thKF97YShwe2Eod3thKHh7YSFae2EhW3thfk8hTyl8Tyd3KX1PUCRyYVIkcmFbJHJhbCRyYXAkcmEhUSRyYSFqJHJhIW4kcmEjUCRyYSNsJHJhI20kcmEjbiRyYSNvJHJhI3AkcmEjcSRyYSNyJHJhI3MkcmEjdCRyYSN1JHJhI3ckcmEjeSRyYSN6JHJhI30kcmEoXyRyYShwJHJhKHckcmEoeCRyYSFaJHJhIVskcmF+TyFPKXxPJ3cpfU9QJHRhUiR0YVskdGFsJHRhcCR0YSFRJHRhIWokdGEhbiR0YSNQJHRhI2wkdGEjbSR0YSNuJHRhI28kdGEjcCR0YSNxJHRhI3IkdGEjcyR0YSN0JHRhI3UkdGEjdyR0YSN5JHRhI3okdGEjfSR0YShfJHRhKHAkdGEodyR0YSh4JHRhIVokdGEhWyR0YX5PbD19TyFPKXxPJ3cpfU8odyR9Tyh4JVBPfk9QJVNhUiVTYVslU2FwJVNhIVElU2EhaiVTYSFuJVNhI1AlU2EjbCVTYSNtJVNhI24lU2EjbyVTYSNwJVNhI3ElU2EjciVTYSNzJVNhI3QlU2EjdSVTYSN3JVNhI3klU2EjeiVTYSN9JVNhKF8lU2EocCVTYSFaJVNhIVslU2F+UCclc08jfSRscSFaJGxxIVskbHF+UCNCUE8jfSRucSFaJG5xIVskbnF+UCNCUE8hWzlkT35PI305ZU9+UCEwdU8hZSN2TyFaJ2NpIWknY2l+TyFlI3ZPKHAnbk8hWidjaSFpJ2Npfk8hWi9rTyFpKHxxfk8hVydlaSFaJ2VpflAjLntPIVovc08hVyh9cX5PcDlsTyFlI3ZPKHAnbk9+T1s5bk8hVzltT35QIy57TyFXOW1Pfk8hZSN2TyN0OXRPfk9nKF15IVooXXl+UCEwdU8hWidsYSFdJ2xhflAjLntPYSVacSFdJVpxJ3glWnEhWiVacX5QIy57T1s5eU9+TyFaMH1PIVspVnF+TyNeOX1PIVonbmEhWyduYX5PIVo1a08hWylTaX5QI0JQTyFROlBPfk8hXTFnTyVoOlNPfk8oVFRPKFdVTyhjOlhPfk8hWjFyTyFbKVRxfk8haTpbT35PIWk6XU9+TyFpOl5Pfk8haTpeT35QJVtPI146YU8hWiNmeSFbI2Z5fk8hWiNmeSFbI2Z5flAjQlBPJWg6Zk9+UCY3U08hXSdeTyVoOmZPfk8jfSN7eSFaI3t5IVsje3l+UCNCUE9QJHtpUiR7aVske2lwJHtpIVEke2khaiR7aSFuJHtpI1Ake2kjbCR7aSNtJHtpI24ke2kjbyR7aSNwJHtpI3Eke2kjciR7aSNzJHtpI3Qke2kjdSR7aSN3JHtpI3kke2kjeiR7aSN9JHtpKF8ke2kocCR7aSFaJHtpIVske2l+UCclc08hTyl8Tyd3KX1PKHglUE9QJ2dhUidnYVsnZ2FsJ2dhcCdnYSFRJ2dhIWonZ2EhbidnYSNQJ2dhI2wnZ2EjbSdnYSNuJ2dhI28nZ2EjcCdnYSNxJ2dhI3InZ2EjcydnYSN0J2dhI3UnZ2EjdydnYSN5J2dhI3onZ2EjfSdnYShfJ2dhKHAnZ2EodydnYSFaJ2dhIVsnZ2F+TyFPKXxPJ3cpfU9QJ2lhUidpYVsnaWFsJ2lhcCdpYSFRJ2lhIWonaWEhbidpYSNQJ2lhI2wnaWEjbSdpYSNuJ2lhI28naWEjcCdpYSNxJ2lhI3InaWEjcydpYSN0J2lhI3UnaWEjdydpYSN5J2lhI3onaWEjfSdpYShfJ2lhKHAnaWEodydpYSh4J2lhIVonaWEhWydpYX5PKHckfU9QJWBpUiVgaVslYGlsJWBpcCVgaSFPJWBpIVElYGkhaiVgaSFuJWBpI1AlYGkjbCVgaSNtJWBpI24lYGkjbyVgaSNwJWBpI3ElYGkjciVgaSNzJWBpI3QlYGkjdSVgaSN3JWBpI3klYGkjeiVgaSN9JWBpJ3clYGkoXyVgaShwJWBpKHglYGkhWiVgaSFbJWBpfk8oeCVQT1AlYmlSJWJpWyViaWwlYmlwJWJpIU8lYmkhUSViaSFqJWJpIW4lYmkjUCViaSNsJWJpI20lYmkjbiViaSNvJWJpI3AlYmkjcSViaSNyJWJpI3MlYmkjdCViaSN1JWJpI3clYmkjeSViaSN6JWJpI30lYmkndyViaShfJWJpKHAlYmkodyViaSFaJWJpIVslYml+TyN9JG55IVokbnkhWyRueX5QI0JQTyN9I2F5IVojYXkhWyNheX5QI0JQTyFlI3ZPIVonY3EhaSdjcX5PIVova08haSh8eX5PIVcnZXEhWidlcX5QIy57T3A6cE8hZSN2TyhwJ25Pfk9bOnRPIVc6c09+UCMue08hVzpzT35PZyhdIVIhWihdIVJ+UCEwdU9hJVp5IV0lWnkneCVaeSFaJVp5flAjLntPIVowfU8hWylWeX5PIVo1a08hWylTcX5PKFI6ek9+TyFdMWdPJWg6fU9+TyFpO1FPfk8laDtWT35QJjdTT1Ake3FSJHtxWyR7cXAke3EhUSR7cSFqJHtxIW4ke3EjUCR7cSNsJHtxI20ke3EjbiR7cSNvJHtxI3Ake3EjcSR7cSNyJHtxI3Mke3EjdCR7cSN1JHtxI3cke3EjeSR7cSN6JHtxI30ke3EoXyR7cShwJHtxIVoke3EhWyR7cX5QJyVzTyFPKXxPJ3cpfU8oeCVQT1AnaGFSJ2hhWydoYWwnaGFwJ2hhIVEnaGEhaidoYSFuJ2hhI1AnaGEjbCdoYSNtJ2hhI24naGEjbydoYSNwJ2hhI3EnaGEjcidoYSNzJ2hhI3QnaGEjdSdoYSN3J2hhI3knaGEjeidoYSN9J2hhKF8naGEocCdoYSh3J2hhIVonaGEhWydoYX5PIU8pfE8ndyl9T1AnamFSJ2phWydqYWwnamFwJ2phIVEnamEhaidqYSFuJ2phI1AnamEjbCdqYSNtJ2phI24namEjbydqYSNwJ2phI3EnamEjcidqYSNzJ2phI3QnamEjdSdqYSN3J2phI3knamEjeidqYSN9J2phKF8namEocCdqYSh3J2phKHgnamEhWidqYSFbJ2phfk9QJH1xUiR9cVskfXFwJH1xIVEkfXEhaiR9cSFuJH1xI1AkfXEjbCR9cSNtJH1xI24kfXEjbyR9cSNwJH1xI3EkfXEjciR9cSNzJH1xI3QkfXEjdSR9cSN3JH1xI3kkfXEjeiR9cSN9JH1xKF8kfXEocCR9cSFaJH1xIVskfXF+UCclc09nJWQhWiFaJWQhWiNeJWQhWiN9JWQhWn5QITB1TyFXO1pPflAjLntPcDtbTyFlI3ZPKHAnbk9+T1s7Xk8hVztaT35QIy57TyFaJ25xIVsnbnF+UCNCUE8hWiNmIVohWyNmIVp+UCNCUE8jaSVkIVpQJWQhWlIlZCFaWyVkIVphJWQhWnAlZCFaIVElZCFaIVolZCFaIWolZCFaIW4lZCFaI1AlZCFaI2wlZCFaI20lZCFaI24lZCFaI28lZCFaI3AlZCFaI3ElZCFaI3IlZCFaI3MlZCFaI3QlZCFaI3UlZCFaI3clZCFaI3klZCFaI3olZCFaJ3glZCFaKF8lZCFaKHAlZCFaIWklZCFaIVclZCFaJ3UlZCFaI14lZCFadCVkIVohXSVkIVolaCVkIVohZSVkIVp+UCMue09wO2ZPIWUjdk8ocCduT35PIVc7Z09+UCMue09wO25PIWUjdk8ocCduT35PIVc7b09+UCMue09QJWQhWlIlZCFaWyVkIVpwJWQhWiFRJWQhWiFqJWQhWiFuJWQhWiNQJWQhWiNsJWQhWiNtJWQhWiNuJWQhWiNvJWQhWiNwJWQhWiNxJWQhWiNyJWQhWiNzJWQhWiN0JWQhWiN1JWQhWiN3JWQhWiN5JWQhWiN6JWQhWiN9JWQhWihfJWQhWihwJWQhWiFaJWQhWiFbJWQhWn5QJyVzT3A7ck8hZSN2TyhwJ25Pfk90KGRYflAxcU8hTyVxT35QISh5TyhTIWxPflAhKHlPIVdmWCFaZlgjXmZYflAlMFhPUF1YUl1YW11YcF1YIU9dWCFRXVghWl1YIVpmWCFqXVghbl1YI1BdWCNRXVgjXl1YI15mWCNpZlgjbF1YI21dWCNuXVgjb11YI3BdWCNxXVgjcl1YI3NdWCN0XVgjdV1YI3ddWCN5XVgjel1YJFBdWChfXVgocF1YKHddWCh4XVh+TyFlZlghaV1YIWlmWChwZlh+UCdKbE9QO3ZPUTt2T1NmT2Q9ck9lIWlPbmtPcDt2T3FrT3JrT3hrT3o7dk98O3ZPIVFXTyFVa08hVmtPIV1YTyFnO3lPIWpaTyFtO3ZPIW47dk8hbzt2TyFxO3pPIXM7fU8hdiFoTyRWIWtPJG09cE8oUilaTyhUVE8oV1VPKF9WTyhtW09+TyFaPFpPIVskcGF+T2glVk9uJVdPcCVYT3EkdE9yJHRPeCVZT3olWk98PGZPIVEke08hXSR8TyFnPXdPIWokeE8jaDxsTyRWJV9PJHM8aE8kdTxqTyR4JWBPKFIodE8oVFRPKFdVTyhfJHVPKHckfU8oeCVQT35PailiT35QKCBiT3AhY1gocCFjWH5QIyBxT3AoaFgocChoWH5QIyFkTyFbXVghW2ZYflAnSmxPIVdmWCFXJHlYIVpmWCFaJHlYI15mWH5QIS9xTyNpPE9Pfk8hZSN2TyNpPE9Pfk8jXjxgT35PI3Q8U09+TyNePHBPIVoodVghWyh1WH5PI148YE8hWihzWCFbKHNYfk8jaTxxT35PZzxzT35QITB1TyNpPHlPfk8jaTx6T35PIWUjdk8jaTx7T35PIWUjdk8jaTxxT35PI308fE9+UCNCUE8jaTx9T35PI2k9T09+TyNpPVRPfk8jaT1VT35PI2k9Vk9+TyNpPVdPfk8jfT1YT35QITB1TyN9PVlPflAhMHVPI1EjUiNTI1UjViNZI2cjaCNzJG0kcyR1JHglWyVdJWclaCVpJXAlciV1JXYleCV6fid8VCNtIVYneihTI25xI2wjb3AhTyd7JFsneyhSJF4oY35cIixcbiAgZ290bzogXCIkOGYpWlBQUFBQUClbUFApX1ApcFArUS9WUFBQUDZhUFA2d1BQPG9QQGNQQHlQQHlQUFBAeVBDUlBAeVBAeVBAeVBDVlBDW1BDeVBIc1BQUEh3UFBQUEh3S3pQUFBMUUxyUEh3UEh3UFAhIFFId1BQUEh3UEh3UCEjWEh3UCEmbyEndCEnfVAhKHEhKHUhKHEhLFNQUFBQUFBQISxzISd0UFAhLVQhLnVQITJSSHdIdyEyVyE1ZCE6USE6USE+UFBQUCE+WEh3UFBQUFBQUFBQUCFBaFAhQnVQUEh3IURXUEh3UEh3SHdId0h3SHdQSHchRWpQIUh0UCFLelAhTE8hTFkhTF4hTF5QIUhxUCFMYiFMYlAjIGhQIyBsSHdQSHcjIHIjJHdDVkB5UEB5UEB5QHlQIyZVQHlAeSMoaEB5IytgQHkjLWxAeUB5Iy5bIzBwIzBwIzB1IzFPIzBwIzFaUFAjMHBQQHkjMXNAeSM1ckB5QHk2YVBQUCM5d1BQUCM6YiM6YlAjOmJQIzp4IzpiUFAjO09QIzp1UCM6dSM7YyM6dSM7fSM8VCM8VylfIzxaKV9QIzxiIzxiIzxiUClfUClfUClfUClfUFApX1AjPGgjPGtQIzxrKV9QIzxvUCM8clApX1ApX1ApX1ApX1ApX1ApXylfUFAjPHgjPU8jPVojPWEjPWcjPW0jPXMjPlIjPlgjPmMjPmkjPnMjPnkjP1ojP2EjQFIjQGUjQGsjQHEjQVAjQWYjQ1ojQ2kjQ3AjRVsjRWojR1sjR2ojR3AjR3YjR3wjSFcjSF4jSGQjSG4jSVEjSVdQUFBQUFBQUFBQUCNJXlBQUFBQUFAjSlIjTVkjTnIjTnkkIFJQUFAkJm1QJCZ2JClvJDBZJDBdJDBgJDFfJDFiJDFpJDFxUCQxdyQxelAkMmgkMmwkM2QkNHIkNHckNV9QUCQ1ZCQ1aiQ1biQ1cSQ1dSQ1eSQ2dSQ3XiQ3dSQ3eSQ3fCQ4UCQ4ViQ4WSQ4XiQ4YlIhfFJvcU9Yc3QhWiNkJWwmcCZyJnMmdSxuLHMyUzJWWSF2USdeLWAxZzVxUSVzdlEle3lRJlN8USZoIVZTJ1UhZS1XUSdkIWlTJ2ohciF5VSpoJHwqWCpsUStsJXxRK3kmVVEsXyZiUS1eJ11RLWgnZVEtcCdrUTBVKm5RMXEsYFI8bTt6JVNkT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVsJXMmUSZpJmwmcCZyJnMmdSZ5J1InYCdwKFIoVChaKGIodih4KHwpeypmK1UrWSxrLG4scy1kLWwtei5RLm8udi9pMFYwZDBsMHwxajF6MXsxfTJQMlMyVjJYMngzTzNkNHE1eTZaNls2XzZyOGk4eDlTUyNxXTt3IXIpXSRaJG4nVilxLVAtUy9RMmgzezVtNmk5fTphO3Y7eTt6O308TzxQPFE8UjxTPFQ8VTxWPFc8WDxZPFo8XTxgPG08cDxxPHM8ezx8PVY9Vz1zVSp7JVs8ZTxmUStxJk9RLGEmZVEsaCZtUTByK2RRMHUrZlExUytyUTF5LGZRM1cuYlE1VjB3UTVdMH1RNlExclE3TzNbUThVNV5SOVk3USdRa09QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJWwlcyZRJmkmbCZtJnAmciZzJnUmeSdSJ1YnYCdwKFIoVChaKGIodih4KHwpcSl7KmYrVStZK2QsayxuLHMtUC1TLWQtbC16LlEuYi5vLnYvUS9pMFYwZDBsMHwxajF6MXsxfTJQMlMyVjJYMmgyeDNPM1szZDN7NHE1bTV5Nlo2WzZfNmk2cjdROGk4eDlTOX06YTt2O3k7ejt9PE88UDxRPFI8UzxUPFU8VjxXPFg8WTxaPF08YDxtPHA8cTxzPHs8fD1WPVc9cyFTIW5RIXIhdiF5IXokfCdVJ10nXidqJ2snbCpoKmwqbipvLVctXi1gLXAwVTBYMWc1cTVzJVskdGkjdiRiJGMkZCR4JHslTyVRJV0lXiViKXcqUCpSKlQqVypeKmQqdCp1K2MrZit9LFEuYS56L18vaC9yL3MvdTBZMFswZzBoMGkxXjFhMWkzWjRVNFY0YTRmNHc1UjVVNXg2fDdsN3Y3fDhROGY5VjllOW45dDpTOmY6dDp9O1Y7XjxePF88YTxiPGM8ZDxnPGg8aTxqPGs8bDx0PHU8djx3PHk8ejx9PU89UD1RPVI9Uz1UPVU9WD1ZPXA9eD15PXw9fVEmVnxRJ1MhZVMnWSVoLVpRK3EmT1EsYSZlUTBmK09RMVMrclExWCt4UTF4LGVRMXksZlE1XTB9UTVmMVpRNlExclE2VDF0UTZVMXdROFU1XlE4WDVjUThxNldROXw4WVE6WThuUjxvKlhybk9Yc3QhViFaI2QlbCZnJnAmciZzJnUsbixzMlMyVlIsYyZpJnpeT1BYWXN0dXZ3eiFaIWAhZyFqIW8jUyNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbCVzJlEmaSZsJm0mcCZyJnMmdSZ5J1InYCdwKFQoWihiKHYoeCh8KXEpeypmK1UrWStkLGssbixzLVAtUy1kLWwtei5RLmIuby52L1EvaTBWMGQwbDB8MWoxejF7MX0yUDJTMlYyWDJoMngzTzNbM2QzezRxNW01eTZaNls2XzZpNnI3UThpOHg5Uzl9OmE7djt5O3o7fTxPPFA8UTxSPFM8VDxVPFY8VzxYPFk8WjxdPGA8bTxwPHE8czx7PHw9Vj1XPXI9c1sjXVdaI1cjWidWKFIhYiVpbSNoI2kjbCR4JWQlZyhbKGYoZyhoKlcqWypfK1crWCtaLGotUS5PLlUuVi5XLlkvaC9rMlszUzNUNFg2aDZ5USV2eFElenlTJlB8JlVRJl0hVFEnYSFoUSdjIWlRKG8jc1MrayV7JXxRK28mT1EsWSZgUSxeJmJTLWcnZCdlUS5kKHBRMHsrbFExUityUTFUK3NRMVcrd1ExbCxaUzFwLF8sYFEydC1oUTVbMH1RNWAxUVE1ZTFZUTZQMXFROFQ1XlE4VzViUTl4OFNSOnc5eSFVJHppJGQlTyVRJV0lXiViKlAqUipeKnQqdS56L3IwWTBbMGcwaDBpNFY0dzd8OWU9cD14PXkhXiV4eSFpIXUleiV7JXwnVCdjJ2QnZSdpJ3MqZytrK2wtVC1nLWgtby97ME8wezJtMnQyezRpNGo0bTdzOXBRK2UldlEsTyZZUSxSJlpRLF0mYlEuYyhvUTFrLFlVMW8sXixfLGBRM10uZFE1ejFsUzZPMXAxcVE4bTZQI2Y9dCN2JGIkYyR4JHspdypUKlcqZCtjK2YrfSxRLmEvXy9oL3MvdTFeMWExaTNaNFU0YTRmNVI1VTV4Nnw3bDd2OFE4ZjlWOW45dDpTOmY6dDp9O1Y7XjxhPGM8ZzxpPGs8dDx2PHk8fT1QPVI9VD1YPXw9fW89dTxePF88YjxkPGg8ajxsPHU8dzx6PU89UT1TPVU9WVclVGklVip2PXBTJlkhUSZnUSZaIVJRJlshU1ErUyVjUit8JlclXSVTaSN2JGIkYyRkJHgkeyVPJVElXSVeJWIpdypQKlIqVCpXKl4qZCp0KnUrYytmK30sUS5hLnovXy9oL3Ivcy91MFkwWzBnMGgwaTFeMWExaTNaNFU0VjRhNGY0dzVSNVU1eDZ8N2w3djd8OFE4ZjlWOWU5bjl0OlM6Zjp0On07VjtePF48XzxhPGI8YzxkPGc8aDxpPGo8azxsPHQ8dTx2PHc8eTx6PH09Tz1QPVE9Uj1TPVQ9VT1YPVk9cD14PXk9fD19VCl4JHUpeVYqeyVbPGU8ZlcnWSFlJWgqWC1aUyh7I3kjelErYCVxUSt2JlJTLl0oayhsUTFiLFNRNHgwY1I4XjVrJ1FrT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbCVzJlEmaSZsJm0mcCZyJnMmdSZ5J1InVidgJ3AoUihUKFooYih2KHgofClxKXsqZitVK1krZCxrLG4scy1QLVMtZC1sLXouUS5iLm8udi9RL2kwVjBkMGwwfDFqMXoxezF9MlAyUzJWMlgyaDJ4M08zWzNkM3s0cTVtNXk2WjZbNl82aTZyN1E4aTh4OVM5fTphO3Y7eTt6O308TzxQPFE8UjxTPFQ8VTxWPFc8WDxZPFo8XTxgPG08cDxxPHM8ezx8PVY9Vz1zJGkkXmMjWSNlJXAlciV0KFEoVyhyKHcpUClRKVIpUylUKVUpVilXKVgpWSlbKV4pYCllKW8rYSt1LVUtcy14LX0uUC5uLnEudS53LngueS9dMGoyYzJmMnYyfTNjM2gzaTNqM2szbDNtM24zbzNwM3EzcjNzM3QzdzN4NFA1TzVZNms2cTZ2N1Y3VzdhN2I4YDh8OVE5WzliOWM6Yzp5O1I7eD1nVCNUViNVJ1JrT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbCVzJlEmaSZsJm0mcCZyJnMmdSZ5J1InVidgJ3AoUihUKFooYih2KHgofClxKXsqZitVK1krZCxrLG4scy1QLVMtZC1sLXouUS5iLm8udi9RL2kwVjBkMGwwfDFqMXoxezF9MlAyUzJWMlgyaDJ4M08zWzNkM3s0cTVtNXk2WjZbNl82aTZyN1E4aTh4OVM5fTphO3Y7eTt6O308TzxQPFE8UjxTPFQ8VTxWPFc8WDxZPFo8XTxgPG08cDxxPHM8ezx8PVY9Vz1zUSdXIWVSMmktVyFXIW5RIWUhciF2IXkheiR8J1UnXSdeJ2onaydsKlgqaCpsKm4qby1XLV4tYC1wMFUwWDFnNXE1c1IxZCxVbnFPWHN0IVojZCVsJnAmciZzJnUsbixzMlMyVlEmdyFeUSd0IXhTKHEjdTxPUStpJXlRLFcmXVEsWCZfUS1lJ2JRLXInbVMubSh2PHFTMGsrVTx7UTB5K2pRMWYsVlEyWix1UTJdLHZRMmUtUlEyci1mUTJ1LWpTNVAwbD1WUTVXMHpTNVowfD1XUTZqMmdRNm4yc1E2czJ6UThSNVhROH02bFE5TzZvUTlSNnRSOmA4eiRkJF1jI1kjZSVyJXQoUShXKHIodylQKVEpUilTKVQpVSlWKVcpWClZKVspXilgKWUpbythK3UtVS1zLXgtfS5QLm4ucS51LngueS9dMGoyYzJmMnYyfTNjM2gzaTNqM2szbDNtM24zbzNwM3EzcjNzM3QzdzN4NFA1TzVZNms2cTZ2N1Y3VzdhN2I4YDh8OVE5WzliOWM6Yzp5O1I7eD1nUyhtI3AnZ1EofSN6UytfJXAud1MuXihsKG5SM1UuXydRa09QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJWwlcyZRJmkmbCZtJnAmciZzJnUmeSdSJ1YnYCdwKFIoVChaKGIodih4KHwpcSl7KmYrVStZK2QsayxuLHMtUC1TLWQtbC16LlEuYi5vLnYvUS9pMFYwZDBsMHwxajF6MXsxfTJQMlMyVjJYMmgyeDNPM1szZDN7NHE1bTV5Nlo2WzZfNmk2cjdROGk4eDlTOX06YTt2O3k7ejt9PE88UDxRPFI8UzxUPFU8VjxXPFg8WTxaPF08YDxtPHA8cTxzPHs8fD1WPVc9c1MjcV07d1EmciFYUSZzIVlRJnUhW1EmdiFdUjJSLHFRJ18haFErYiV2US1jJ2FTLmAobytlUTJwLWJXM1kuYy5kMHEwc1E2bTJxVzZ6M1YzWDNdNVRVOVU2ezZ9N1BVOmU5VzlYOVpTO1Q6ZDpnUTtiO1VSO2o7Y1Uhd1EnXi1gVDVvMWc1cSFRX09YWmBzdCFWIVojZCNoJWQlbCZnJmkmcCZyJnMmdShoLG4scy5WMlMyVl0hcFEhcideLWAxZzVxVCNxXTt3JV57T1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVsJXMmUSZpJmwmbSZwJnImcyZ1JnknUidgJ3AoUihUKFooYih2KHgofCl7KmYrVStZK2QsayxuLHMtZC1sLXouUS5iLm8udi9pMFYwZDBsMHwxajF6MXsxfTJQMlMyVjJYMngzTzNbM2Q0cTV5Nlo2WzZfNnI3UThpOHg5U1MoeyN5I3pTLl0oayhsIXM9XiRaJG4nVilxLVAtUy9RMmgzezVtNmk5fTphO3Y7eTt6O308TzxQPFE8UjxTPFQ8VTxWPFc8WDxZPFo8XTxgPG08cDxxPHM8ezx8PVY9Vz1zVSRmZCldLGhTKG4jcCdnVSpzJVIodTN2VTBlKnouaTddUTVUMHJRNnszV1E5WDdPUjpnOVltIXRRIXIhdiF5IXonXidqJ2snbC1gLXAxZzVxNXNRJ3IhdVMoZCNnMXxTLW4naSd1US9uKlpRL3sqZ1EyfC1xUTRdL29RNGkvfVE0ajBPUTRvMFdRN2g0V1M3czRrNG1TN3c0cDRyUTlnN2lROWs3b1E5cDd0UTl1N3lTOm85bDltUztZOnA6c1M7ZTtaO1tTO207ZjtnUztxO247b1I7dDtyUSN3YlEncSF1UyhjI2cxfFMoZSNtK1RRK1YlZVErZyV3USttJX1VLW0naSdyJ3VRLlIoZFEvbSpaUS98KmdRMFAqaVEweCtoUTFtLFtTMnktbi1xUTNSLlpTNFsvbi9vUTRlL3lTNGgvezBXUTRsMFFRNXwxblE2dTJ8UTdnNFdRN2s0XVU3cjRpNG80clE3dTRuUThrNX1TOWY3aDdpUTlqN29ROXI3d1E5czd4UTpWOGxROm05Z1M6bjlrOW1ROnY5dVE7UDpXUztYOm86c1M7ZDtZO1pTO2w7ZTtnUztwO207b1E7cztxUTt1O3RRPWE9W1E9bD1lUj1tPWZWIXdRJ14tYCVeYU9QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbCVzJlEmaSZsJm0mcCZyJnMmdSZ5J1InYCdwKFIoVChaKGIodih4KHwpeypmK1UrWStkLGssbixzLWQtbC16LlEuYi5vLnYvaTBWMGQwbDB8MWoxejF7MX0yUDJTMlYyWDJ4M08zWzNkNHE1eTZaNls2XzZyN1E4aTh4OVNTI3d6IWohcj1aJFokbidWKXEtUC1TL1EyaDN7NW02aTl9OmE7djt5O3o7fTxPPFA8UTxSPFM8VDxVPFY8VzxYPFk8WjxdPGA8bTxwPHE8czx7PHw9Vj1XPXNSPWE9ciVeYk9QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbCVzJlEmaSZsJm0mcCZyJnMmdSZ5J1InYCdwKFIoVChaKGIodih4KHwpeypmK1UrWStkLGssbixzLWQtbC16LlEuYi5vLnYvaTBWMGQwbDB8MWoxejF7MX0yUDJTMlYyWDJ4M08zWzNkNHE1eTZaNls2XzZyN1E4aTh4OVNRJWVqIV4ld3khaSF1JXoleyV8J1QnYydkJ2UnaSdzKmcraytsLVQtZy1oLW8vezBPMHsybTJ0Mns0aTRqNG03czlwUyV9eiFqUStoJXhRLFsmYlcxbixdLF4sXyxgVTV9MW8xcDFxUzhsNk82UFE6VzhtIXI9WyRaJG4nVilxLVAtUy9RMmgzezVtNmk5fTphO3Y7eTt6O308TzxQPFE8UjxTPFQ8VTxWPFc8WDxZPFo8XTxgPG08cDxxPHM8ezx8PVY9Vz1zUT1lPXFSPWY9ciVRZU9QWFlzdHV2dyFaIWAhZyFvI1MjZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbCVzJlEmaSZsJnAmciZzJnUmeSdSJ2AncChUKFooYih2KHgofCl7KmYrVStZK2QsayxuLHMtZC1sLXouUS5iLm8udi9pMFYwZDBsMHwxajF6MXsxfTJQMlMyVjJYMngzTzNbM2Q0cTV5Nlo2WzZfNnI3UThpOHg5U1kjYldaI1cjWihSIWIlaW0jaCNpI2wkeCVkJWcoWyhmKGcoaCpXKlsqXytXK1grWixqLVEuTy5VLlYuVy5ZL2gvazJbM1MzVDRYNmg2eVEsaSZtIXA9XSRaJG4pcS1QLVMvUTJoM3s1bTZpOX06YTt2O3k7ejt9PE88UDxRPFI8UzxUPFU8VjxXPFg8WTxaPF08YDxtPHA8cTxzPHs8fD1WPVc9c1I9YCdWVSdaIWUlaCpYUjJrLVolU2RPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJF8kYSRlJWwlcyZRJmkmbCZwJnImcyZ1JnknUidgJ3AoUihUKFooYih2KHgofCl7KmYrVStZLGssbixzLWQtbC16LlEuby52L2kwVjBkMGwwfDFqMXoxezF9MlAyUzJWMlgyeDNPM2Q0cTV5Nlo2WzZfNnI4aTh4OVMhcildJFokbidWKXEtUC1TL1EyaDN7NW02aTl9OmE7djt5O3o7fTxPPFA8UTxSPFM8VDxVPFY8VzxYPFk8WjxdPGA8bTxwPHE8czx7PHw9Vj1XPXNRLGgmbVEwcitkUTNXLmJRN08zW1I5WTdRIWIkVGMjWSVwKFEoVyhyKHcpWClZKV4pZSt1LXMteC19LlAubi5xL10wajJ2Mn0zYzNzNU81WTZxNnY3VjlROmM7eCFQPFUpWylvLVUudzJjMmYzaDNxM3IzdzRQNms3VzdhN2I4YDh8OVs5YjljOnk7Uj1nIWYkVmMjWSVwKFEoVyhyKHcpVSlWKVgpWSleKWUrdS1zLXgtfS5QLm4ucS9dMGoydjJ9M2MzczVPNVk2cTZ2N1Y5UTpjO3ghVDxXKVspby1VLncyYzJmM2gzbjNvM3EzcjN3NFA2azdXN2E3YjhgOHw5WzliOWM6eTtSPWchXiRaYyNZJXAoUShXKHIodyleKWUrdS1zLXgtfS5QLm4ucS9dMGoydjJ9M2MzczVPNVk2cTZ2N1Y5UTpjO3hRNFYvZno9cylbKW8tVS53MmMyZjNoM3c0UDZrN1c3YTdiOGA4fDlbOWI5Yzp5O1I9Z1E9eD16Uj15PXsnUWtPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVsJXMmUSZpJmwmbSZwJnImcyZ1JnknUidWJ2AncChSKFQoWihiKHYoeCh8KXEpeypmK1UrWStkLGssbixzLVAtUy1kLWwtei5RLmIuby52L1EvaTBWMGQwbDB8MWoxejF7MX0yUDJTMlYyWDJoMngzTzNbM2QzezRxNW01eTZaNls2XzZpNnI3UThpOHg5Uzl9OmE7djt5O3o7fTxPPFA8UTxSPFM8VDxVPFY8VzxYPFk8WjxdPGA8bTxwPHE8czx7PHw9Vj1XPXNTJG9oJHBSM3wvUCdYZ09QV1hZWmhzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiRwJWwlcyZRJmkmbCZtJnAmciZzJnUmeSdSJ1YnYCdwKFIoVChaKGIodih4KHwpcSl7KmYrVStZK2QsayxuLHMtUC1TLWQtbC16LlEuYi5vLnYvUC9RL2kwVjBkMGwwfDFqMXoxezF9MlAyUzJWMlgyaDJ4M08zWzNkM3s0cTVtNXk2WjZbNl82aTZyN1E4aTh4OVM5fTphO3Y7eTt6O308TzxQPFE8UjxTPFQ8VTxWPFc8WDxZPFo8XTxgPG08cDxxPHM8ezx8PVY9Vz1zVCRrZiRxUSRpZlMpaCRsKWxSKXQkcVQkamYkcVQpaiRsKWwnWGhPUFdYWVpoc3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4kcCVsJXMmUSZpJmwmbSZwJnImcyZ1JnknUidWJ2AncChSKFQoWihiKHYoeCh8KXEpeypmK1UrWStkLGssbixzLVAtUy1kLWwtei5RLmIuby52L1AvUS9pMFYwZDBsMHwxajF6MXsxfTJQMlMyVjJYMmgyeDNPM1szZDN7NHE1bTV5Nlo2WzZfNmk2cjdROGk4eDlTOX06YTt2O3k7ejt9PE88UDxRPFI8UzxUPFU8VjxXPFg8WTxaPF08YDxtPHA8cTxzPHs8fD1WPVc9c1Qkb2gkcFEkcmhSKXMkcCVeak9QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbCVzJlEmaSZsJm0mcCZyJnMmdSZ5J1InYCdwKFIoVChaKGIodih4KHwpeypmK1UrWStkLGssbixzLWQtbC16LlEuYi5vLnYvaTBWMGQwbDB8MWoxejF7MX0yUDJTMlYyWDJ4M08zWzNkNHE1eTZaNls2XzZyN1E4aTh4OVMhcz1xJFokbidWKXEtUC1TL1EyaDN7NW02aTl9OmE7djt5O3o7fTxPPFA8UTxSPFM8VDxVPFY8VzxYPFk8WjxdPGA8bTxwPHE8czx7PHw9Vj1XPXMjZ2xPUFhac3QhWiFgIW8jUyNkI28jeyRuJWwmaSZsJm0mcCZyJnMmdSZ5J1InYCh8KXEqZitZK2QsayxuLHMtZC5iL1EvaTBWMGQxajF6MXsxfTJQMlMyVjJYM1szezRxNXk2WjZbNl83UThpOHghVSVSaSRkJU8lUSVdJV4lYipQKlIqXip0KnUuei9yMFkwWzBnMGgwaTRWNHc3fDllPXA9eD15I2YodSN2JGIkYyR4JHspdypUKlcqZCtjK2YrfSxRLmEvXy9oL3MvdTFeMWExaTNaNFU0YTRmNVI1VTV4Nnw3bDd2OFE4ZjlWOW45dDpTOmY6dDp9O1Y7XjxhPGM8ZzxpPGs8dDx2PHk8fT1QPVI9VD1YPXw9fVErUCVgUS9eKXxvM3Y8XjxfPGI8ZDxoPGo8bDx1PHc8ej1PPVE9Uz1VPVkhVSR5aSRkJU8lUSVdJV4lYipQKlIqXip0KnUuei9yMFkwWzBnMGgwaTRWNHc3fDllPXA9eD15USpgJHpVKmkkfCpYKmxRK1ElYVEwUSpqI2Y9YyN2JGIkYyR4JHspdypUKlcqZCtjK2YrfSxRLmEvXy9oL3MvdTFeMWExaTNaNFU0YTRmNVI1VTV4Nnw3bDd2OFE4ZjlWOW45dDpTOmY6dDp9O1Y7XjxhPGM8ZzxpPGs8dDx2PHk8fT1QPVI9VD1YPXw9fW49ZDxePF88YjxkPGg8ajxsPHU8dzx6PU89UT1TPVU9WVE9aD10UT1pPXVRPWo9dlI9az13IVUlUmkkZCVPJVElXSVeJWIqUCpSKl4qdCp1LnovcjBZMFswZzBoMGk0VjR3N3w5ZT1wPXg9eSNmKHUjdiRiJGMkeCR7KXcqVCpXKmQrYytmK30sUS5hL18vaC9zL3UxXjFhMWkzWjRVNGE0ZjVSNVU1eDZ8N2w3djhROGY5VjluOXQ6UzpmOnQ6fTtWO148YTxjPGc8aTxrPHQ8djx5PH09UD1SPVQ9WD18PX1vM3Y8XjxfPGI8ZDxoPGo8bDx1PHc8ej1PPVE9Uz1VPVlub09Yc3QhWiNkJWwmcCZyJnMmdSxuLHMyUzJWUypjJHsqV1EsfCZ8USx9J09SNGAvcyVbJVNpI3YkYiRjJGQkeCR7JU8lUSVdJV4lYil3KlAqUipUKlcqXipkKnQqdStjK2YrfSxRLmEuei9fL2gvci9zL3UwWTBbMGcwaDBpMV4xYTFpM1o0VTRWNGE0ZjR3NVI1VTV4Nnw3bDd2N3w4UThmOVY5ZTluOXQ6UzpmOnQ6fTtWO148XjxfPGE8YjxjPGQ8ZzxoPGk8ajxrPGw8dDx1PHY8dzx5PHo8fT1PPVA9UT1SPVM9VD1VPVg9WT1wPXg9eT18PX1RLFAmWlExYCxSUTVpMV9SOF01alYqayR8KlgqbFUqayR8KlgqbFQ1cDFnNXFTL3kqZi9pUTRuMFZUN3g0cTpQUStnJXdRMFAqaVEweCtoUTFtLFtRNXwxblE4azV9UTpWOGxSO1A6VyFVJU9pJGQlTyVRJV0lXiViKlAqUipeKnQqdS56L3IwWTBbMGcwaDBpNFY0dzd8OWU9cD14PXl4KlAkdiljKlEqcitSL3EwXjBfM3k0XjR7NHw0fTdmN3o5djpsPWI9bj1vUzBZKnEwWiNmPGEjdiRiJGMkeCR7KXcqVCpXKmQrYytmK30sUS5hL18vaC9zL3UxXjFhMWkzWjRVNGE0ZjVSNVU1eDZ8N2w3djhROGY5VjluOXQ6UzpmOnQ6fTtWO148YTxjPGc8aTxrPHQ8djx5PH09UD1SPVQ9WD18PX1uPGI8XjxfPGI8ZDxoPGo8bDx1PHc8ej1PPVE9Uz1VPVkhZDx0KHMpYSpZKmIuZS5oLmwvWS9mL3YwcDFdM2A0UzRfNGM1aDdSN1U3bTdwN304UDlpOXE5dzpxOnU7VztdO2g9ej17YDx1M3U3WDdbN2A5XTpoOms7a1M9UC5nM2FUPVE3WjlgIVUlUWkkZCVPJVElXSVeJWIqUCpSKl4qdCp1LnovcjBZMFswZzBoMGk0VjR3N3w5ZT1wPXg9eXwqUiR2KWMqUypxK1IvYi9xMF4wXzN5NF40czR7NHw0fTdmN3o5djpsPWI9bj1vUzBbKnIwXSNmPGMjdiRiJGMkeCR7KXcqVCpXKmQrYytmK30sUS5hL18vaC9zL3UxXjFhMWkzWjRVNGE0ZjVSNVU1eDZ8N2w3djhROGY5VjluOXQ6UzpmOnQ6fTtWO148YTxjPGc8aTxrPHQ8djx5PH09UD1SPVQ9WD18PX1uPGQ8XjxfPGI8ZDxoPGo8bDx1PHc8ej1PPVE9Uz1VPVkhaDx2KHMpYSpZKmIuZi5nLmwvWS9mL3YwcDFdM14zYDRTNF80YzVoN1I3UzdVN203cDd9OFA5aTlxOXc6cTp1O1c7XTtoPXo9e2Q8dzN1N1k3WjdgOV05XjpoOmk6aztrUz1SLmgzYlQ9UzdbOWFybk9Yc3QhViFaI2QlbCZnJnAmciZzJnUsbixzMlMyVlEmZCFVUixrJm1ybk9Yc3QhViFaI2QlbCZnJnAmciZzJnUsbixzMlMyVlImZCFVUSxUJltSMVsrfHNuT1hzdCFWIVojZCVsJmcmcCZyJnMmdSxuLHMyUzJWUTFoLFlTNXcxazFsVThlNXU1djV6UzpSOGc4aFM6ezpROlRRO186fFI7aTtgUSZrIVZSLGQmZ1I2VDF0UjpZOG5TJlB8JlVSMVQrc1EmcCFXUixuJnFSLHQmdlQyVCxzMlZSLHgmd1EsdyZ3UjJeLHhRJ3che1ItdCd3U3NPdFEjZFhUJW9zI2RRI09UUid5I09RI1JVUid7I1JRKXkkdVIvWil5USNVVlIoTyNVUSNYV1UoVSNYKFYte1EoViNZUi17KFdRLVgnV1Iyai1YUS5wKHdTM2UucDNmUjNmLnFRLWAnXlIybi1gWSFyUSdeLWAxZzVxUidoIXJRLnspY1Izei57VSNfVyVnKldVKF0jXyheLXxRKF4jYFItfChYUS1bJ1pSMmwtW3RgT1hzdCFWIVojZCVsJmcmaSZwJnImcyZ1LG4sczJTMlZTI2haJWRVI3JgI2guVlIuVihoUShpI2pRLlMoZVcuWyhpLlMzUDZ3UTNQLlRSNnczUVEpbCRsUi9SKWxRJHBoUilyJHBRJGBjVSlfJGAtdzxbUS13O3hSPFspb1EvbCpaVzRZL2w0WjdqOWhVNFovbS9uL29TN2o0WzRdUjloN2skZSpPJHYocylhKWMqWSpiKnEqcip8Kn0rUi5nLmguai5rLmwvWS9iL2QvZi9xL3YwXjBfMHAxXTNeM18zYDN1M3k0UzReNF80YzRzNHU0ezR8NH01aDdSN1M3VDdVN1o3WzdeN183YDdmN203cDd6N304UDldOV45XzlpOXE5djl3Omg6aTpqOms6bDpxOnU7VztdO2g7az1iPW49bz16PXtRL3QqYlU0Yi90NGQ3blE0ZC92UjduNGNTKmwkfCpYUjBTKmx4KlEkdiljKnEqcitSL3EwXjBfM3k0XjR7NHw0fTdmN3o5djpsPWI9bj1vIWQuZShzKWEqWSpiLmcuaC5sL1kvZi92MHAxXTNgNFM0XzRjNWg3UjdVN203cDd9OFA5aTlxOXc6cTp1O1c7XTtoPXo9e1UvYypRLmU3WGE3WDN1N1o3WzdgOV06aDprO2tRMFoqcVEzYS5nVTR0MFozYTlgUjlgN1p8KlMkdiljKnEqcitSL2IvcTBeMF8zeTReNHM0ezR8NH03Zjd6OXY6bD1iPW49byFoLmYocylhKlkqYi5nLmgubC9ZL2YvdjBwMV0zXjNgNFM0XzRjNWg3UjdTN1U3bTdwN304UDlpOXE5dzpxOnU7VztdO2g9ej17VS9lKlMuZjdZZTdZM3U3WjdbN2A5XTleOmg6aTprO2tRMF0qclEzYi5oVTR2MF0zYjlhUjlhN1tRKnclVVIwYSp3UTVTMHBSOE81U1ErWyVqUjBvK1tRNWwxYlM4XzVsOk9SOk84YFEsViZdUjFlLFZRNXExZ1I4YjVxUTFzLGFTNlIxczhvUjhvNlRRMU8rb1c1XzFPNWE4Vjl6UTVhMVJROFY1YFI5ejhXUSt0JlBSMVUrdFEyVixzUjZjMlZZck9Yc3QjZFEmdCFaUSteJWxRLG0mcFEsbyZyUSxwJnNRLHImdVEyUSxuUzJULHMyVlI2YjJTUSVucFEmeCFfUSZ7IWFRJn0hYlEnUCFjUSdvIXVRK10la1EraSV5USt7JlZRLGMma1EseiZ6Vy1rJ2kncSdyJ3VRLXInbVEwUiprUTB5K2pTMXYsZCxnUTJfLHlRMmAsfFEyYSx9UTJ1LWpXMnctbS1uLXEtc1E1VzB6UTVkMVhRNWcxXVE1ezFtUTZWMXhRNmEyUlU2cDJ2MnkyfFE2czJ6UThSNVhROFo1ZlE4WzVoUThhNXBROGo1fFE4cDZVUzlQNnE2dVE5UjZ0UTl7OFhROlU4a1E6WjhxUTpiOVFROng5fFE7TzpWUTtTOmNSO2E7UFEleXlRJ2IhaVEnbSF1VStqJXoleyV8US1SJ1RVLWYnYydkJ2VTLWonaSdzUS96KmdTMHoraytsUTJnLVRTMnMtZy1oUTJ6LW9TNGcvezBPUTVYMHtRNmwybVE2bzJ0UTZ0MntVN3E0aTRqNG1ROW83c1I6cjlwUyR3aT1wUip4JVZVJVVpJVY9cFIwYCp2USR2aVMocyN2K2ZTKWEkYiRjUSljJGRRKlkkeFMqYiR7KldRKnElT1EqciVRUSp8JV1RKn0lXlErUiViUS5nPGFRLmg8Y1EuajxnUS5rPGlRLmw8a1EvWSl3US9iKlBRL2QqUlEvZipUUS9xKl5TL3YqZC9oUTBeKnRRMF8qdWwwcCtjLFEuYTFhMWkzWjV4Nnw4ZjlWOlM6Zjp9O1ZRMV0rfVEzXjx0UTNfPHZRM2A8eVMzdTxePF9RM3kuelM0Uy9fNFVRNF4vclE0Xy9zUTRjL3VRNHMwWVE0dTBbUTR7MGdRNHwwaFE0fTBpUTVoMV5RN1I8fVE3Uz1QUTdUPVJRN1U9VFE3WjxiUTdbPGRRN148aFE3XzxqUTdgPGxRN2Y0VlE3bTRhUTdwNGZRN3o0d1E3fTVSUThQNVVROV08elE5Xjx1UTlfPHdROWk3bFE5cTd2UTl2N3xROXc4UVE6aD1PUTppPVFROmo9U1E6az1VUTpsOWVROnE5blE6dTl0UTtXPVhRO106dFE7aDteUTtrPVlRPWI9cFE9bj14UT1vPXlRPXo9fFI9ez19USp6JVtRLmk8ZVI3XTxmbnBPWHN0IVojZCVsJnAmciZzJnUsbixzMlMyVlEhZlBTI2ZaI29RJnohYFcnZiFvKmYwVjRxUSd9I1NRKU8je1EpcCRuUyxnJmkmbFEsbCZtUSx5JnlTLU8nUi9pUS1iJ2BRLnMofFEvVilxUTBtK1lRMHMrZFEyTyxrUTJxLWRRM1guYlE0Ty9RUTR5MGRRNXYxalE2WDF6UTZZMXtRNl4xfVE2YDJQUTZlMlhRN1AzW1E3YzN7UThoNXlROHQ2WlE4dTZbUTh3Nl9ROVo3UVE6VDhpUjpfOHgjW2NPUFhac3QhWiFgIW8jZCNvI3slbCZpJmwmbSZwJnImcyZ1JnknUidgKHwqZitZK2QsayxuLHMtZC5iL2kwVjBkMWoxejF7MX0yUDJTMlYyWDNbNHE1eTZaNls2XzdROGk4eFEjWVdRI2VZUSVwdVElcnZTJXR3IWdTKFEjVyhUUShXI1pRKHIjdVEodyN4USlQJE9RKVEkUFEpUiRRUSlTJFJRKVQkU1EpVSRUUSlWJFVRKVckVlEpWCRXUSlZJFhRKVskWlEpXiRfUSlgJGFRKWUkZVcpbyRuKXEvUTN7USthJXNRK3UmUVMtVSdWMmhRLXMncFMteChSLXpRLX0oWlEuUChiUS5uKHZRLnEoeFEudTt2US53O3lRLng7elEueTt9US9dKXtRMGorVVEyYy1QUTJmLVNRMnYtbFEyfS5RUTNjLm9RM2g8T1EzaTxQUTNqPFFRM2s8UlEzbDxTUTNtPFRRM248VVEzbzxWUTNwPFdRM3E8WFEzcjxZUTNzLnZRM3Q8XVEzdzxgUTN4PG1RNFA8WlE1TzBsUTVZMHxRNms8cFE2cTJ4UTZ2M09RN1YzZFE3VzxxUTdhPHNRN2I8e1E4YDVtUTh8NmlROVE2clE5Wzx8UTliPVZROWM9V1E6YzlTUTp5OX1RO1I6YVE7eCNTUj1nPXNSI1tXUidYIWVsIXRRIXIhdiF5IXonXidqJ2snbC1gLXAxZzVxNXNTJ1QhZS1XVSpnJHwqWCpsUy1UJ1UnXVMwTypoKm5RMFcqb1EybS1eUTRtMFVSNHIwWFIoeSN4USFmUVQtXydeLWBdIXFRIXInXi1gMWc1cVEjcF1SJ2c7d1IpZCRkWSF1USdeLWAxZzVxUSdpIXJTJ3MhdiF5Uyd1IXo1c1MtbydqJ2tRLXEnbFIyey1wVCNrWiVkUyNqWiVkUyVqbSxqVShlI2gjaSNsUy5UKGYoZ1EuWChoUTBuK1pRM1EuVVUzUi5WLlcuWVM2eDNTM1RSOVQ2eWQjXlcjVyNaJWcoUihbKlcrVy5PL2hyI2dabSNoI2kjbCVkKGYoZyhoK1ouVS5WLlcuWTNTM1Q2eVMqWiR4Kl9RL28qW1ExfCxqUTJkLVFRNFcva1E2ZzJbUTdpNFhROHs2aFQ9XydWK1hWI2FXJWcqV1UjYFclZypXUyhTI1coW1UoWCNaK1cvaFMtVidWK1hULXkoUi5PVidbIWUlaCpYUSRsZlIpdiRxVClrJGwpbFIzfS9QVCpdJHgqX1QqZSR7KldRMHErY1ExXyxRUTNWLmFRNWoxYVE1dTFpUTZ9M1pROGc1eFE5VzZ8UTpROGZROmQ5VlE6fDpTUTtVOmZRO2A6fVI7YztWbnFPWHN0IVojZCVsJnAmciZzJnUsbixzMlMyVlEmaiFWUixjJmd0bU9Yc3QhVSFWIVojZCVsJmcmcCZyJnMmdSxuLHMyUzJWUixqJm1UJWttLGpSMWMsU1IsYiZlUSZUfFIreiZVUitwJk9UJm4hVyZxVCZvIVcmcVQyVSxzMlZcIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBBcml0aE9wIEFyaXRoT3AgPy4gSlNYU3RhcnRUYWcgTGluZUNvbW1lbnQgQmxvY2tDb21tZW50IFNjcmlwdCBIYXNoYmFuZyBFeHBvcnREZWNsYXJhdGlvbiBleHBvcnQgU3RhciBhcyBWYXJpYWJsZU5hbWUgU3RyaW5nIEVzY2FwZSBmcm9tIDsgZGVmYXVsdCBGdW5jdGlvbkRlY2xhcmF0aW9uIGFzeW5jIGZ1bmN0aW9uIFZhcmlhYmxlRGVmaW5pdGlvbiA+IDwgVHlwZVBhcmFtTGlzdCBjb25zdCBUeXBlRGVmaW5pdGlvbiBleHRlbmRzIFRoaXNUeXBlIHRoaXMgTGl0ZXJhbFR5cGUgQXJpdGhPcCBOdW1iZXIgQm9vbGVhbkxpdGVyYWwgVGVtcGxhdGVUeXBlIEludGVycG9sYXRpb25FbmQgSW50ZXJwb2xhdGlvbiBJbnRlcnBvbGF0aW9uU3RhcnQgTnVsbFR5cGUgbnVsbCBWb2lkVHlwZSB2b2lkIFR5cGVvZlR5cGUgdHlwZW9mIE1lbWJlckV4cHJlc3Npb24gLiBQcm9wZXJ0eU5hbWUgWyBUZW1wbGF0ZVN0cmluZyBFc2NhcGUgSW50ZXJwb2xhdGlvbiBzdXBlciBSZWdFeHAgXSBBcnJheUV4cHJlc3Npb24gU3ByZWFkICwgfSB7IE9iamVjdEV4cHJlc3Npb24gUHJvcGVydHkgYXN5bmMgZ2V0IHNldCBQcm9wZXJ0eURlZmluaXRpb24gQmxvY2sgOiBOZXdUYXJnZXQgbmV3IE5ld0V4cHJlc3Npb24gKSAoIEFyZ0xpc3QgVW5hcnlFeHByZXNzaW9uIGRlbGV0ZSBMb2dpY09wIEJpdE9wIFlpZWxkRXhwcmVzc2lvbiB5aWVsZCBBd2FpdEV4cHJlc3Npb24gYXdhaXQgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gQ2xhc3NFeHByZXNzaW9uIGNsYXNzIENsYXNzQm9keSBNZXRob2REZWNsYXJhdGlvbiBEZWNvcmF0b3IgQCBNZW1iZXJFeHByZXNzaW9uIFByaXZhdGVQcm9wZXJ0eU5hbWUgQ2FsbEV4cHJlc3Npb24gVHlwZUFyZ0xpc3QgQ29tcGFyZU9wIDwgZGVjbGFyZSBQcml2YWN5IHN0YXRpYyBhYnN0cmFjdCBvdmVycmlkZSBQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uIFByb3BlcnR5RGVjbGFyYXRpb24gcmVhZG9ubHkgYWNjZXNzb3IgT3B0aW9uYWwgVHlwZUFubm90YXRpb24gRXF1YWxzIFN0YXRpY0Jsb2NrIEZ1bmN0aW9uRXhwcmVzc2lvbiBBcnJvd0Z1bmN0aW9uIFBhcmFtTGlzdCBQYXJhbUxpc3QgQXJyYXlQYXR0ZXJuIE9iamVjdFBhdHRlcm4gUGF0dGVyblByb3BlcnR5IFByaXZhY3kgcmVhZG9ubHkgQXJyb3cgTWVtYmVyRXhwcmVzc2lvbiBCaW5hcnlFeHByZXNzaW9uIEFyaXRoT3AgQXJpdGhPcCBBcml0aE9wIEFyaXRoT3AgQml0T3AgQ29tcGFyZU9wIGluc3RhbmNlb2Ygc2F0aXNmaWVzIGluIENvbXBhcmVPcCBCaXRPcCBCaXRPcCBCaXRPcCBMb2dpY09wIExvZ2ljT3AgQ29uZGl0aW9uYWxFeHByZXNzaW9uIExvZ2ljT3AgTG9naWNPcCBBc3NpZ25tZW50RXhwcmVzc2lvbiBVcGRhdGVPcCBQb3N0Zml4RXhwcmVzc2lvbiBDYWxsRXhwcmVzc2lvbiBJbnN0YW50aWF0aW9uRXhwcmVzc2lvbiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gRHluYW1pY0ltcG9ydCBpbXBvcnQgSW1wb3J0TWV0YSBKU1hFbGVtZW50IEpTWFNlbGZDbG9zZUVuZFRhZyBKU1hTZWxmQ2xvc2luZ1RhZyBKU1hJZGVudGlmaWVyIEpTWEJ1aWx0aW4gSlNYSWRlbnRpZmllciBKU1hOYW1lc3BhY2VkTmFtZSBKU1hNZW1iZXJFeHByZXNzaW9uIEpTWFNwcmVhZEF0dHJpYnV0ZSBKU1hBdHRyaWJ1dGUgSlNYQXR0cmlidXRlVmFsdWUgSlNYRXNjYXBlIEpTWEVuZFRhZyBKU1hPcGVuVGFnIEpTWEZyYWdtZW50VGFnIEpTWFRleHQgSlNYRXNjYXBlIEpTWFN0YXJ0Q2xvc2VUYWcgSlNYQ2xvc2VUYWcgUHJlZml4Q2FzdCA8IEFycm93RnVuY3Rpb24gVHlwZVBhcmFtTGlzdCBTZXF1ZW5jZUV4cHJlc3Npb24gSW5zdGFudGlhdGlvbkV4cHJlc3Npb24gS2V5b2ZUeXBlIGtleW9mIFVuaXF1ZVR5cGUgdW5pcXVlIEltcG9ydFR5cGUgSW5mZXJyZWRUeXBlIGluZmVyIFR5cGVOYW1lIFBhcmVudGhlc2l6ZWRUeXBlIEZ1bmN0aW9uU2lnbmF0dXJlIFBhcmFtTGlzdCBOZXdTaWduYXR1cmUgSW5kZXhlZFR5cGUgVHVwbGVUeXBlIExhYmVsIEFycmF5VHlwZSBSZWFkb25seVR5cGUgT2JqZWN0VHlwZSBNZXRob2RUeXBlIFByb3BlcnR5VHlwZSBJbmRleFNpZ25hdHVyZSBQcm9wZXJ0eURlZmluaXRpb24gQ2FsbFNpZ25hdHVyZSBUeXBlUHJlZGljYXRlIGFzc2VydHMgaXMgTmV3U2lnbmF0dXJlIG5ldyBVbmlvblR5cGUgTG9naWNPcCBJbnRlcnNlY3Rpb25UeXBlIExvZ2ljT3AgQ29uZGl0aW9uYWxUeXBlIFBhcmFtZXRlcml6ZWRUeXBlIENsYXNzRGVjbGFyYXRpb24gYWJzdHJhY3QgaW1wbGVtZW50cyB0eXBlIFZhcmlhYmxlRGVjbGFyYXRpb24gbGV0IHZhciB1c2luZyBUeXBlQWxpYXNEZWNsYXJhdGlvbiBJbnRlcmZhY2VEZWNsYXJhdGlvbiBpbnRlcmZhY2UgRW51bURlY2xhcmF0aW9uIGVudW0gRW51bUJvZHkgTmFtZXNwYWNlRGVjbGFyYXRpb24gbmFtZXNwYWNlIG1vZHVsZSBBbWJpZW50RGVjbGFyYXRpb24gZGVjbGFyZSBHbG9iYWxEZWNsYXJhdGlvbiBnbG9iYWwgQ2xhc3NEZWNsYXJhdGlvbiBDbGFzc0JvZHkgQW1iaWVudEZ1bmN0aW9uRGVjbGFyYXRpb24gRXhwb3J0R3JvdXAgVmFyaWFibGVOYW1lIFZhcmlhYmxlTmFtZSBJbXBvcnREZWNsYXJhdGlvbiBJbXBvcnRHcm91cCBGb3JTdGF0ZW1lbnQgZm9yIEZvclNwZWMgRm9ySW5TcGVjIEZvck9mU3BlYyBvZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBXaXRoU3RhdGVtZW50IHdpdGggRG9TdGF0ZW1lbnQgZG8gSWZTdGF0ZW1lbnQgaWYgZWxzZSBTd2l0Y2hTdGF0ZW1lbnQgc3dpdGNoIFN3aXRjaEJvZHkgQ2FzZUxhYmVsIGNhc2UgRGVmYXVsdExhYmVsIFRyeVN0YXRlbWVudCB0cnkgQ2F0Y2hDbGF1c2UgY2F0Y2ggRmluYWxseUNsYXVzZSBmaW5hbGx5IFJldHVyblN0YXRlbWVudCByZXR1cm4gVGhyb3dTdGF0ZW1lbnQgdGhyb3cgQnJlYWtTdGF0ZW1lbnQgYnJlYWsgQ29udGludWVTdGF0ZW1lbnQgY29udGludWUgRGVidWdnZXJTdGF0ZW1lbnQgZGVidWdnZXIgTGFiZWxlZFN0YXRlbWVudCBFeHByZXNzaW9uU3RhdGVtZW50IFNpbmdsZUV4cHJlc3Npb24gU2luZ2xlQ2xhc3NJdGVtXCIsXG4gIG1heFRlcm06IDM3OCxcbiAgY29udGV4dDogdHJhY2tOZXdsaW5lLFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJpc29sYXRlXCIsIC04LDUsNiwxNCwzNSwzNyw0OSw1MSw1MyxcIlwiXSxcbiAgICBbXCJncm91cFwiLCAtMjYsOSwxNywxOSw2NiwyMDYsMjEwLDIxNCwyMTUsMjE3LDIyMCwyMjMsMjMzLDIzNSwyNDEsMjQzLDI0NSwyNDcsMjUwLDI1NiwyNjIsMjY0LDI2NiwyNjgsMjcwLDI3MiwyNzMsXCJTdGF0ZW1lbnRcIiwtMzQsMTMsMTQsMzAsMzMsMzQsNDAsNDksNTIsNTMsNTUsNjAsNjgsNzAsNzQsNzgsODAsODIsODMsMTA4LDEwOSwxMTgsMTE5LDEzNSwxMzgsMTQwLDE0MSwxNDIsMTQzLDE0NCwxNDYsMTQ3LDE2NiwxNjgsMTcwLFwiRXhwcmVzc2lvblwiLC0yMywyOSwzMSwzNSwzOSw0MSw0MywxNzIsMTc0LDE3NiwxNzcsMTc5LDE4MCwxODEsMTgzLDE4NCwxODUsMTg3LDE4OCwxODksMjAwLDIwMiwyMDQsMjA1LFwiVHlwZVwiLC0zLDg2LDEwMSwxMDcsXCJDbGFzc0l0ZW1cIl0sXG4gICAgW1wib3BlbmVkQnlcIiwgMjMsXCI8XCIsMzYsXCJJbnRlcnBvbGF0aW9uU3RhcnRcIiw1NCxcIltcIiw1OCxcIntcIiw3MSxcIihcIiwxNTksXCJKU1hTdGFydENsb3NlVGFnXCJdLFxuICAgIFtcImNsb3NlZEJ5XCIsIC0yLDI0LDE2NyxcIj5cIiwzOCxcIkludGVycG9sYXRpb25FbmRcIiw0OCxcIl1cIiw1OSxcIn1cIiw3MixcIilcIiwxNjQsXCJKU1hFbmRUYWdcIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtqc0hpZ2hsaWdodF0sXG4gIHNraXBwZWROb2RlczogWzAsNSw2LDI3Nl0sXG4gIHJlcGVhdE5vZGVDb3VudDogMzcsXG4gIHRva2VuRGF0YTogXCIkRnEwN1tSIWJPWCVaWFkrZ1laLXlaWytnW10lWl1eLmNecCVacHErZ3FyL21yczNjc3Q6X3R1RXJ1dkpTdndMa3d4ISBZeHkhJ2l5eiEoc3p7ISl9e3whLHF8fSEuT30hTyEscSFPIVAhL1khUCFRITlqIVEhUiM6TyFSIVsjPF8hWyFdI0lfIV0hXiNKayFeIV8jS3UhXyFgJCFbIWAhYSQkdiFhIWIkKlQhYiFjJCxyIWMhfUVyIX0jTyQtfCNPI1AkL1cjUCNRJDRvI1EjUiQ1eSNSI1NFciNTI1QkN1cjVCNvJDhiI28jcCQ8ciNwI3EkPWgjcSNyJD54I3IjcyRAVSNzJGYlWiRmJGcrZyRnI0JZRXIjQlkjQlokQWAjQlokSVNFciRJUyRJXyRBYCRJXyRJfEVyJEl8JEl9JERrJEl9JEpPJERrJEpPJEpURXIkSlQkSlUkQWAkSlUkS1ZFciRLViRLVyRBYCRLVyZGVUVyJkZVJkZWJEFgJkZWOydTRXI7J1M7PWBJfDwlbD9IVEVyP0hUP0hVJEFgP0hVT0VyKG4lZF8kaCZqKFVwKFghYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJmomaFQkaCZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMmaiZ6UDs9YDwlbCZjJ3wnVV0kaCZqKFghYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFiKFNVKFghYk9ZJ31adyd9eCNPJ30jUDsnUyd9OydTOz1gKGY8JWxPJ30hYihpUDs9YDwlbCd9J3wob1A7PWA8JWwmfSdbKHldJGgmaihVcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocnApd1UoVXBPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylycCpeUDs9YDwlbClyJ1sqZFA7PWA8JWwociNTKm5YKFVwKFghYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcjUyteUDs9YDwlbCpnKG4rZFA7PWA8JWwlWjA3WytycSRoJmooVXAoWCFiJ3owL2xPWCVaWFkrZ1laJmNaWytnW3AlWnBxK2dxciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcCRmJVokZiRnK2ckZyNCWSVaI0JZI0JaK2cjQlokSVMlWiRJUyRJXytnJElfJEpUJVokSlQkSlUrZyRKVSRLViVaJEtWJEtXK2ckS1cmRlUlWiZGVSZGVitnJkZWOydTJVo7J1M7PWArYTwlbD9IVCVaP0hUP0hVK2c/SFVPJVowN1suU1QoViNTJGgmaid7MC9sTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMwN1subl8kaCZqKFVwKFghYid7MC9sT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVopM3AveGAkaCZqIW4pLFEoVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMHohYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1cxVmAjdShDaCRoJmooVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMlghYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1cyZF8jdShDaCRoJmooVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQXQzbF8oVCc6ZiRoJmooWCFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsoXjRyXyRoJmooWCFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsmejV2WCRoJmpPcjVxcnM2Y3MhXjVxIV4hXzZ5IV8jbzVxI28jcDZ5I3A7J1M1cTsnUzs9YDdoPCVsTzVxJno2alQkY2AkaCZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmNgNnxUT3I2eXJzN11zOydTNnk7J1M7PWA3YjwlbE82eWA3Yk8kY2BgN2VQOz1gPCVsNnkmejdrUDs9YDwlbDVxKF43d10kY2AkaCZqKFghYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFyOHVaKFghYk9ZOHBZWjZ5WnI4cHJzOWhzdzhwd3g2eXgjTzhwI08jUDZ5I1A7J1M4cDsnUzs9YDpSPCVsTzhwIXI5b1UkY2AoWCFiT1knfVp3J314I08nfSNQOydTJ307J1M7PWAoZjwlbE8nfSFyOlVQOz1gPCVsOHAoXjpbUDs9YDwlbDRrJTlbOmhoJGgmaihVcChYIWJPWSVaWVomY1pxJVpxcjxTcnMmfXN0JVp0dUNydXclWnd4KHJ4IV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DcihyPF9fV1MkaCZqKFVwKFghYk9ZPFNZWiZjWnI8U3JzPV5zdzxTd3hAbnghXjxTIV4hX0JtIV8jTzxTI08jUD5gI1AjbzxTI28jcEJtI3A7J1M8UzsnUzs9YENsPCVsTzxTKFE9Z11XUyRoJmooWCFiT1k9XllaJmNadz1ed3g+YHghXj1eIV4hXz9xIV8jTz1eI08jUD5gI1Ajbz1eI28jcD9xI3A7J1M9XjsnUzs9YEBoPCVsTz1eJm4+Z1hXUyRoJmpPWT5gWVomY1ohXj5gIV4hXz9TIV8jbz5gI28jcD9TI3A7J1M+YDsnUzs9YD9rPCVsTz5gUz9YU1dTT1k/U1o7J1M/UzsnUzs9YD9lPCVsTz9TUz9oUDs9YDwlbD9TJm4/blA7PWA8JWw+YCFmP3hXV1MoWCFiT1k/cVp3P3F3eD9TeCNPP3EjTyNQP1MjUDsnUz9xOydTOz1gQGI8JWxPP3EhZkBlUDs9YDwlbD9xKFFAa1A7PWA8JWw9XidgQHddV1MkaCZqKFVwT1lAbllaJmNackBucnM+YHMhXkBuIV4hX0FwIV8jT0BuI08jUD5gI1Ajb0BuI28jcEFwI3A7J1NAbjsnUzs9YEJnPCVsT0BudEF3V1dTKFVwT1lBcFpyQXBycz9TcyNPQXAjTyNQP1MjUDsnU0FwOydTOz1gQmE8JWxPQXB0QmRQOz1gPCVsQXAnYEJqUDs9YDwlbEBuI1dCdllXUyhVcChYIWJPWUJtWnJCbXJzP3Fzd0Jtd3hBcHgjT0JtI08jUD9TI1A7J1NCbTsnUzs9YENmPCVsT0JtI1dDaVA7PWA8JWxCbShyQ29QOz1gPCVsPFMlOVtDfWkkaCZqKG0lMWwoVXAoWCFiT1klWllaJmNaciVacnMmfXN0JVp0dUNydXclWnd4KHJ4IVElWiFRIVtDciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DciU5W0VvUDs9YDwlbENyMDdbRlJrJGgmaihVcChYIWIkWyN0KFIsMmooYyRJW09ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyK2RIUmskaCZqKFVwKFghYiRbI3RPWSVaWVomY1pyJVpycyZ9c3QlWnR1R3Z1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtHdiFbIV4lWiFeIV8qZyFfIWMlWiFjIX1HdiF9I08lWiNPI1AmYyNQI1IlWiNSI1NHdiNTI1QlWiNUI29HdiNvI3AqZyNwJGclWiRnOydTR3Y7J1M7PWBJdjwlbE9HditkSXlQOz1gPCVsR3YwN1tKUFA7PWA8JWxFcihLV0pfYCRoJmooVXAoWCFiI24oQ2hPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLV0tsXyRoJmokUChDaChVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiwjeEx2YSh4K0pZJGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3YlWnZ3TXt3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1dOV2AkaCZqI3koQ2goVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQXQhIGNfKFcnO1ckaCZqKFVwT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWInbCEhaV8kaCZqKFVwT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWImeiEjbVgkaCZqT3chI2h3eDZjeCFeISNoIV4hXyEkWSFfI28hI2gjbyNwISRZI3A7J1MhI2g7J1M7PWAhJHI8JWxPISNoYCEkXVRPdyEkWXd4N114OydTISRZOydTOz1gISRsPCVsTyEkWWAhJG9QOz1gPCVsISRZJnohJHVQOz1gPCVsISNoJ2whJVJdJGNgJGgmaihVcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ociFRISZQWihVcE9ZISV6WVohJFlaciElenJzISRZc3chJXp3eCEmcngjTyEleiNPI1AhJFkjUDsnUyElejsnUzs9YCEnXTwlbE8hJXohUSEmeVUkY2AoVXBPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylyIVEhJ2BQOz1gPCVsISV6J2whJ2ZQOz1gPCVsISFiLzV8ISd0XyFqLy5eJGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMmVSEpT18haSFMZiRoJmooVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVotIW4hKltiJGgmaihVcChYIWIoUyUmZiNvKENoT1klWllaJmNaciVacnMmfXN3JVp3eChyeHolWnp7IStkeyFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1chK29gJGgmaihVcChYIWIjbChDaE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKzt4ISx8YCRoJmooVXAoWCFicCs0WU9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaLCRVIS5aXyFaK0pmJGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA3WyEvZWMkaCZqKFVwKFghYiFPLjJeT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITBwIVAhUSVaIVEhWyEzWSFbIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMlfCEweWEkaCZqKFVwKFghYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEyTyFQIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiMlfCEyWl8hWSFMXiRoJmooVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQhM2VnJGgmaihVcChYIWJxJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbITNZIVshXiVaIV4hXypnIV8hZyVaIWchaCE0fCFoI08lWiNPI1AmYyNQI1IlWiNSI1MhM1kjUyNYJVojWCNZITR8I1kjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkITVWZyRoJmooVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeHslWnt8ITZufH0lWn0hTyE2biFPIVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkITZ3YyRoJmooVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbIThTIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyE4UyNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCE4X2MkaCZqKFVwKFghYnEnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDdbITl1ZiRoJmooVXAoWCFiI20oQ2hPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3h6ITtaensjLX17IVAhO1ohUCFRIy9kIVEhXiE7WiFeIV8jKGkhXyFgIzdTIWAhYSM4aSFhIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaP08hO2ZiJGgmaihVcChYIWIhVjdgT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghTGN4IVAhO1ohUCFRIyZgIVEhXiE7WiFeIV8jKGkhXyF9ITtaIX0jTyMsZiNPI1AhRHkjUCNvITtaI28jcCMoaSNwOydTITtaOydTOz1gIy13PCVsTyE7Wj5eITx3YCRoJmooWCFiIVY3YE9ZITxuWVomY1p3ITxud3ghPXl4IVAhPG4hUCFRIUVxIVEhXiE8biFeIV8hR3IhXyF9ITxuIX0jTyFLUyNPI1AhRHkjUCNvITxuI28jcCFHciNwOydTITxuOydTOz1gIUxdPCVsTyE8bjx6IT5RXiRoJmohVjdgT1khPXlZWiZjWiFQIT15IVAhUSE+fCFRIV4hPXkhXiFfIUBjIV8hfSE9eSF9I08hQ1cjTyNQIUR5I1AjbyE9eSNvI3AhQGMjcDsnUyE9eTsnUzs9YCFFazwlbE8hPXk8eiE/VGQkaCZqIVY3YE8hXiZjIV8jVyZjI1cjWCE+fCNYI1omYyNaI1shPnwjWyNdJmMjXSNeIT58I14jYSZjI2EjYiE+fCNiI2cmYyNnI2ghPnwjaCNpJmMjaSNqIT58I2ojayE+fCNrI20mYyNtI24hPnwjbiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmM3YCFAaFghVjdgT1khQGNaIVAhQGMhUCFRIUFUIVEhfSFAYyF9I08hQXIjTyNQIUJxI1A7J1MhQGM7J1M7PWAhQ1E8JWxPIUBjN2AhQVlXIVY3YCNXI1ghQVQjWiNbIUFUI10jXiFBVCNhI2IhQVQjZyNoIUFUI2kjaiFBVCNqI2shQVQjbSNuIUFUN2AhQXVWT1khQXJaI08hQXIjTyNQIUJbI1AjUSFAYyNROydTIUFyOydTOz1gIUJrPCVsTyFBcjdgIUJfU09ZIUFyWjsnUyFBcjsnUzs9YCFCazwlbE8hQXI3YCFCblA7PWA8JWwhQXI3YCFCdFNPWSFAY1o7J1MhQGM7J1M7PWAhQ1E8JWxPIUBjN2AhQ1RQOz1gPCVsIUBjPHohQ11bJGgmak9ZIUNXWVomY1ohXiFDVyFeIV8hQXIhXyNPIUNXI08jUCFEUiNQI1EhPXkjUSNvIUNXI28jcCFBciNwOydTIUNXOydTOz1gIURzPCVsTyFDVzx6IURXWCRoJmpPWSFDV1laJmNaIV4hQ1chXiFfIUFyIV8jbyFDVyNvI3AhQXIjcDsnUyFDVzsnUzs9YCFEczwlbE8hQ1c8eiFEdlA7PWA8JWwhQ1c8eiFFT1gkaCZqT1khPXlZWiZjWiFeIT15IV4hXyFAYyFfI28hPXkjbyNwIUBjI3A7J1MhPXk7J1M7PWAhRWs8JWxPIT15PHohRW5QOz1gPCVsIT15Pl4hRXpsJGgmaihYIWIhVjdgT1kmfVlaJmNadyZ9d3gmY3ghXiZ9IV4hXyd9IV8jTyZ9I08jUCZjI1AjVyZ9I1cjWCFFcSNYI1omfSNaI1shRXEjWyNdJn0jXSNeIUVxI14jYSZ9I2EjYiFFcSNiI2cmfSNnI2ghRXEjaCNpJn0jaSNqIUVxI2ojayFFcSNrI20mfSNtI24hRXEjbiNvJn0jbyNwJ30jcDsnUyZ9OydTOz1gKGw8JWxPJn04ciFHeVooWCFiIVY3YE9ZIUdyWnchR3J3eCFAY3ghUCFHciFQIVEhSGwhUSF9IUdyIX0jTyFKVSNPI1AhQnEjUDsnUyFHcjsnUzs9YCFKfDwlbE8hR3I4ciFIc2UoWCFiIVY3YE9ZJ31adyd9eCNPJ30jUCNXJ30jVyNYIUhsI1gjWid9I1ojWyFIbCNbI10nfSNdI14hSGwjXiNhJ30jYSNiIUhsI2IjZyd9I2cjaCFIbCNoI2knfSNpI2ohSGwjaiNrIUhsI2sjbSd9I20jbiFIbCNuOydTJ307J1M7PWAoZjwlbE8nfThyIUpaWChYIWJPWSFKVVp3IUpVd3ghQXJ4I08hSlUjTyNQIUJbI1AjUSFHciNROydTIUpVOydTOz1gIUp2PCVsTyFKVThyIUp5UDs9YDwlbCFKVThyIUtQUDs9YDwlbCFHcj5eIUtaXiRoJmooWCFiT1khS1NZWiZjWnchS1N3eCFDV3ghXiFLUyFeIV8hSlUhXyNPIUtTI08jUCFEUiNQI1EhPG4jUSNvIUtTI28jcCFKVSNwOydTIUtTOydTOz1gIUxWPCVsTyFLUz5eIUxZUDs9YDwlbCFLUz5eIUxgUDs9YDwlbCE8bj1sIUxsYCRoJmooVXAhVjdgT1khTGNZWiZjWnIhTGNycyE9eXMhUCFMYyFQIVEhTW4hUSFeIUxjIV4hXyMgbyFfIX0hTGMhfSNPIyVQI08jUCFEeSNQI28hTGMjbyNwIyBvI3A7J1MhTGM7J1M7PWAjJlk8JWxPIUxjPWwhTXdsJGgmaihVcCFWN2BPWShyWVomY1pyKHJycyZjcyFeKHIhXiFfKXIhXyNPKHIjTyNQJmMjUCNXKHIjVyNYIU1uI1gjWihyI1ojWyFNbiNbI10ociNdI14hTW4jXiNhKHIjYSNiIU1uI2IjZyhyI2cjaCFNbiNoI2kociNpI2ohTW4jaiNrIU1uI2sjbShyI20jbiFNbiNuI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocjhRIyB2WihVcCFWN2BPWSMgb1pyIyBvcnMhQGNzIVAjIG8hUCFRIyFpIVEhfSMgbyF9I08jJFIjTyNQIUJxI1A7J1MjIG87J1M7PWAjJHk8JWxPIyBvOFEjIXBlKFVwIVY3YE9ZKXJacilycyNPKXIjUCNXKXIjVyNYIyFpI1gjWilyI1ojWyMhaSNbI10pciNdI14jIWkjXiNhKXIjYSNiIyFpI2IjZylyI2cjaCMhaSNoI2kpciNpI2ojIWkjaiNrIyFpI2sjbSlyI20jbiMhaSNuOydTKXI7J1M7PWAqWjwlbE8pcjhRIyRXWChVcE9ZIyRSWnIjJFJycyFBcnMjTyMkUiNPI1AhQlsjUCNRIyBvI1E7J1MjJFI7J1M7PWAjJHM8JWxPIyRSOFEjJHZQOz1gPCVsIyRSOFEjJHxQOz1gPCVsIyBvPWwjJVdeJGgmaihVcE9ZIyVQWVomY1pyIyVQcnMhQ1dzIV4jJVAhXiFfIyRSIV8jTyMlUCNPI1AhRFIjUCNRIUxjI1EjbyMlUCNvI3AjJFIjcDsnUyMlUDsnUzs9YCMmUzwlbE8jJVA9bCMmVlA7PWA8JWwjJVA9bCMmXVA7PWA8JWwhTGM/TyMma24kaCZqKFVwKFghYiFWN2BPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1clWiNXI1gjJmAjWCNaJVojWiNbIyZgI1sjXSVaI10jXiMmYCNeI2ElWiNhI2IjJmAjYiNnJVojZyNoIyZgI2gjaSVaI2kjaiMmYCNqI2sjJmAjayNtJVojbSNuIyZgI24jbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaOWQjKHJdKFVwKFghYiFWN2BPWSMoaVpyIyhpcnMhR3JzdyMoaXd4IyBveCFQIyhpIVAhUSMpayFRIX0jKGkhfSNPIytgI08jUCFCcSNQOydTIyhpOydTOz1gIyxgPCVsTyMoaTlkIyl0aChVcChYIWIhVjdgT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQI1cqZyNXI1gjKWsjWCNaKmcjWiNbIylrI1sjXSpnI10jXiMpayNeI2EqZyNhI2IjKWsjYiNnKmcjZyNoIylrI2gjaSpnI2kjaiMpayNqI2sjKWsjayNtKmcjbSNuIylrI247J1MqZzsnUzs9YCtaPCVsTypnOWQjK2daKFVwKFghYk9ZIytgWnIjK2BycyFKVXN3Iytgd3gjJFJ4I08jK2AjTyNQIUJbI1AjUSMoaSNROydTIytgOydTOz1gIyxZPCVsTyMrYDlkIyxdUDs9YDwlbCMrYDlkIyxjUDs9YDwlbCMoaT9PIyxvYCRoJmooVXAoWCFiT1kjLGZZWiZjWnIjLGZycyFLU3N3Iyxmd3gjJVB4IV4jLGYhXiFfIytgIV8jTyMsZiNPI1AhRFIjUCNRITtaI1EjbyMsZiNvI3AjK2AjcDsnUyMsZjsnUzs9YCMtcTwlbE8jLGY/TyMtdFA7PWA8JWwjLGY/TyMtelA7PWA8JWwhO1owN1sjLltiJGgmaihVcChYIWInfDAvbCFWN2BPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3ghUCE7WiFQIVEjJmAhUSFeITtaIV4hXyMoaSFfIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaMDdbIy9vXyRoJmooVXAoWCFiVDAvbE9ZIy9kWVomY1pyIy9kcnMjMG5zdyMvZHd4IzRPeCFeIy9kIV4hXyM1fSFfI08jL2QjTyNQIzFwI1AjbyMvZCNvI3AjNX0jcDsnUyMvZDsnUzs9YCM2fDwlbE8jL2QwNmojMHddJGgmaihYIWJUMC9sT1kjMG5ZWiZjWncjMG53eCMxcHghXiMwbiFeIV8jM1IhXyNPIzBuI08jUCMxcCNQI28jMG4jbyNwIzNSI3A7J1MjMG47J1M7PWAjM3g8JWxPIzBuMDVXIzF3WCRoJmpUMC9sT1kjMXBZWiZjWiFeIzFwIV4hXyMyZCFfI28jMXAjbyNwIzJkI3A7J1MjMXA7J1M7PWAjMns8JWxPIzFwMC9sIzJpU1QwL2xPWSMyZFo7J1MjMmQ7J1M7PWAjMnU8JWxPIzJkMC9sIzJ4UDs9YDwlbCMyZDA1VyMzT1A7PWA8JWwjMXAwMU8jM1lXKFghYlQwL2xPWSMzUlp3IzNSd3gjMmR4I08jM1IjTyNQIzJkI1A7J1MjM1I7J1M7PWAjM3I8JWxPIzNSMDFPIzN1UDs9YDwlbCMzUjA2aiMze1A7PWA8JWwjMG4wNXgjNFhdJGgmaihVcFQwL2xPWSM0T1laJmNaciM0T3JzIzFwcyFeIzRPIV4hXyM1USFfI08jNE8jTyNQIzFwI1AjbyM0TyNvI3AjNVEjcDsnUyM0TzsnUzs9YCM1dzwlbE8jNE8wMF4jNVhXKFVwVDAvbE9ZIzVRWnIjNVFycyMyZHMjTyM1USNPI1AjMmQjUDsnUyM1UTsnUzs9YCM1cTwlbE8jNVEwMF4jNXRQOz1gPCVsIzVRMDV4IzV6UDs9YDwlbCM0TzAxcCM2V1koVXAoWCFiVDAvbE9ZIzV9WnIjNX1ycyMzUnN3IzV9d3gjNVF4I08jNX0jTyNQIzJkI1A7J1MjNX07J1M7PWAjNnY8JWxPIzV9MDFwIzZ5UDs9YDwlbCM1fTA3WyM3UFA7PWA8JWwjL2QpM2gjN2FiJGgmaiRQKENoKFVwKFghYiFWN2BPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3ghUCE7WiFQIVEjJmAhUSFeITtaIV4hXyMoaSFfIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaQXQjOHZiJFkjdCRoJmooVXAoWCFiIVY3YE9ZITtaWVomY1pyITtacnMhPG5zdyE7Wnd4IUxjeCFQITtaIVAhUSMmYCFRIV4hO1ohXiFfIyhpIV8hfSE7WiF9I08jLGYjTyNQIUR5I1AjbyE7WiNvI3AjKGkjcDsnUyE7WjsnUzs9YCMtdzwlbE8hO1onQWQjOlpwJGgmaihVcChYIWJxJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITNZIVAhUSVaIVEhWyM8XyFbIV4lWiFeIV8qZyFfIWclWiFnIWghNHwhaCNPJVojTyNQJmMjUCNSJVojUiNTIzxfI1MjVSVaI1UjViM/aSNWI1glWiNYI1khNHwjWSNiJVojYiNjIz5fI2MjZCNCcSNkI2wlWiNsI20jRXMjbSNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjPGprJGgmaihVcChYIWJxJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITNZIVAhUSVaIVEhWyM8XyFbIV4lWiFeIV8qZyFfIWclWiFnIWghNHwhaCNPJVojTyNQJmMjUCNSJVojUiNTIzxfI1MjWCVaI1gjWSE0fCNZI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjPmpfJGgmaihVcChYIWJxJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjP3JkJGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVIjQVEhUiFTI0FRIVMhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNBUSNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCNBXWYkaCZqKFVwKFghYnEnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVIjQVEhUiFTI0FRIVMhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNBUSNTI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjQnpjJGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVkjRFYhWSFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTI0RWI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0RiZSRoJmooVXAoWCFicSc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWSNEViFZIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjRFYjUyNiJVojYiNjIz5fI2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0V8ZyRoJmooVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbI0dlIVshXiVaIV4hXypnIV8hYyVaIWMhaSNHZSFpI08lWiNPI1AmYyNQI1IlWiNSI1MjR2UjUyNUJVojVCNaI0dlI1ojbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0dwaSRoJmooVXAoWCFicSc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyNHZSFbIV4lWiFeIV8qZyFfIWMlWiFjIWkjR2UhaSNPJVojTyNQJmMjUCNSJVojUiNTI0dlI1MjVCVaI1QjWiNHZSNaI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoqKXgjSWxfIWUkYiRoJmojfSlMdihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWilbI0p2X2FsJGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA0ZiNMU15oIylgI1AtPFUoVXAoWCFiJG03YE9ZKmdacipncnMnfXN3Kmd3eClyeCFQKmchUCFRI01PIVEhXipnIV4hXyNNdCFfIWAkIGYhYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcobiNNWFgkaiZqKFVwKFghYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcoRWwjTX1aI3AoQ2goVXAoWCFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4IV8qZyFfIWAjTnAhYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcoRWwjTnlYJFAoQ2goVXAoWCFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyhFbCQgb1gjcShDaChVcChYIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnKil4JCFnYSNeKiFZJGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAweiFgIWEkI2whYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1skI3dfI2koQ2wkaCZqKFVwKFghYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKil4JCVWYWchKnIjcShDaCRlI3wkaCZqKFVwKFghYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYCQmWyFgIWEkJ2YhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckJmdfI3EoQ2gkaCZqKFVwKFghYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXJCdxYSNwKENoJGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgIWEkKHYhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckKVJgI3AoQ2gkaCZqKFVwKFghYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtkJCpgYShwKEN0JGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWElWiFhIWIkK2UhYiNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckK3BgJGgmaiN6KENoKFVwKFghYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJSNgJCx9XyF6JElwJGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA0ZiQuWF8hUTAsdiRoJmooVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoobiQvXVokaCZqTyFeJDBPIV4hXyQwZiFfI2kkME8jaSNqJDBrI2ojbCQwTyNsI20kMl4jbSNvJDBPI28jcCQwZiNwOydTJDBPOydTOz1gJDRpPCVsTyQwTyhuJDBWVF8jUyRoJmpPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyNTJDBrT18jUyhuJDBwWyRoJmpPIVEmYyFRIVskMWYhWyFeJmMhXyFjJmMhYyFpJDFmIWkjVCZjI1QjWiQxZiNaI28mYyNvI3AkM3wjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQxa1okaCZqTyFRJmMhUSFbJDJeIVshXiZjIV8hYyZjIWMhaSQyXiFpI1QmYyNUI1okMl4jWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQyY1okaCZqTyFRJmMhUSFbJDNVIVshXiZjIV8hYyZjIWMhaSQzVSFpI1QmYyNUI1okM1UjWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQzWlokaCZqTyFRJmMhUSFbJDBPIVshXiZjIV8hYyZjIWMhaSQwTyFpI1QmYyNUI1okME8jWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMjUyQ0UFIhUSFbJDRZIWMhaSQ0WSNUI1okNFkjUyQ0XVMhUSFbJDRZIWMhaSQ0WSNUI1okNFkjcSNyJDBmKG4kNGxQOz1gPCVsJDBPIzFbJDR6XyFXIylsJGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLVyQ2VWAjdyhDaCRoJmooVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVorO3AkN2NfJGgmaihVcChYIWIoXys0UU9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDdbJDhxayRoJmooVXAoWCFiKFIsMmokXiN0KGMkSVtPWSVaWVomY1pyJVpycyZ9c3QlWnR1JDhidXclWnd4KHJ4fSVafSFPJDpmIU8hUSVaIVEhWyQ4YiFbIV4lWiFeIV8qZyFfIWMlWiFjIX0kOGIhfSNPJVojTyNQJmMjUCNSJVojUiNTJDhiI1MjVCVaI1QjbyQ4YiNvI3AqZyNwJGclWiRnOydTJDhiOydTOz1gJDxsPCVsTyQ4YitkJDpxayRoJmooVXAoWCFiJF4jdE9ZJVpZWiZjWnIlWnJzJn1zdCVadHUkOmZ1dyVad3gocnh9JVp9IU8kOmYhTyFRJVohUSFbJDpmIVshXiVaIV4hXypnIV8hYyVaIWMhfSQ6ZiF9I08lWiNPI1AmYyNQI1IlWiNSI1MkOmYjUyNUJVojVCNvJDpmI28jcCpnI3AkZyVaJGc7J1MkOmY7J1M7PWAkPGY8JWxPJDpmK2QkPGlQOz1gPCVsJDpmMDdbJDxvUDs9YDwlbCQ4YiNKZiQ8e1ghXSNIYihVcChYIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnLCN4JD1zYSh3K0pZJGgmaihVcChYIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwI3EkK2UjcTsnUyVaOydTOz1gK2E8JWxPJVopPnYkP1ZfIVsoQ2R0QnIkaCZqKFVwKFghYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaP08kQGFfIW83YCRoJmooVXAoWCFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVowN1skQXF8JGgmaihVcChYIWInejAvbCRbI3QoUiwyaihjJElbT1glWlhZK2dZWiZjWlsrZ1twJVpwcStncXIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZiVaJGYkZytnJGcjQllFciNCWSNCWiRBYCNCWiRJU0VyJElTJElfJEFgJElfJEpURXIkSlQkSlUkQWAkSlUkS1ZFciRLViRLVyRBYCRLVyZGVUVyJkZVJkZWJEFgJkZWOydTRXI7J1M7PWBJfDwlbD9IVEVyP0hUP0hVJEFgP0hVT0VyMDdbJER8ayRoJmooVXAoWCFiJ3swL2wkWyN0KFIsMmooYyRJW09ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyXCIsXG4gIHRva2VuaXplcnM6IFtub1NlbWljb2xvbiwgbm9TZW1pY29sb25UeXBlLCBvcGVyYXRvclRva2VuLCBqc3gsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgaW5zZXJ0U2VtaWNvbG9uLCBuZXcgbHIuTG9jYWxUb2tlbkdyb3VwKFwiJFN+UlJ0dVsjTyNQZyNTI1QjfH5fUCNvI3BifmdPdn5+alZPI2khUCNpI2ohVSNqI2whUCNsI20hcSNtOydTIVA7J1M7PWAjdjwlbE8hUH4hVU8hU35+IVhTIVEhWyFlIWMhaSFlI1QjWiFlI28jcCNafiFoUiFRIVshcSFjIWkhcSNUI1ohcX4hdFIhUSFbIX0hYyFpIX0jVCNaIX1+I1FSIVEhWyFQIWMhaSFQI1QjWiFQfiNeUiFRIVsjZyFjIWkjZyNUI1ojZ34jalMhUSFbI2chYyFpI2cjVCNaI2cjcSNyIVB+I3lQOz1gPCVsIVB+JFJPKGF+flwiLCAxNDEsIDMzOCksIG5ldyBsci5Mb2NhbFRva2VuR3JvdXAoXCJqflJRWVpYentefl5PKE9+fmFQIVAhUWR+aU8oUH5+XCIsIDI1LCAzMjEpXSxcbiAgdG9wUnVsZXM6IHtcIlNjcmlwdFwiOlswLDddLFwiU2luZ2xlRXhwcmVzc2lvblwiOlsxLDI3NF0sXCJTaW5nbGVDbGFzc0l0ZW1cIjpbMiwyNzVdfSxcbiAgZGlhbGVjdHM6IHtqc3g6IDAsIHRzOiAxNTA5MX0sXG4gIGR5bmFtaWNQcmVjZWRlbmNlczoge1wiNzhcIjoxLFwiODBcIjoxLFwiOTJcIjoxLFwiMTY4XCI6MSxcIjE5OFwiOjF9LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiAzMjUsIGdldDogKHZhbHVlKSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfSx7dGVybTogMzQxLCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY193b3JkW3ZhbHVlXSB8fCAtMX0se3Rlcm06IDkzLCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY19MZXNzVGhhblt2YWx1ZV0gfHwgLTF9XSxcbiAgdG9rZW5QcmVjOiAxNTExNlxufSk7XG5cbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnQGxlemVyL2NvbW1vbicpO1xuXG4vKipcbkEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xucGFyc2luZyBwcm9ncmVzcy4gVGhleSBhbHNvIHByb3ZpZGUgc29tZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXG50aGF0IGV4dGVybmFsIGNvZGUgc3VjaCBhcyBhIHRva2VuaXplciBjYW4gdXNlIHRvIGdldCBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YWNrIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwYXJzZSB0aGF0IHRoaXMgc3RhY2sgaXMgcGFydCBvZiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHAsIFxuICAgIC8qKlxuICAgIEhvbGRzIHN0YXRlLCBpbnB1dCBwb3MsIGJ1ZmZlciBpbmRleCB0cmlwbGV0cyBmb3IgYWxsIGJ1dCB0aGVcbiAgICB0b3Agc3RhdGUgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGFjaywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLy8gVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBuZXh0IHJlZHVjZSBzaG91bGQgdGFrZSBwbGFjZS4gVGhpc1xuICAgIC8vIGNhbiBiZSBsZXNzIHRoYW4gYHRoaXMucG9zYCB3aGVuIHNraXBwZWQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuXG4gICAgLy8gYWRkZWQgdG8gdGhlIHN0YWNrICh3aGljaCBzaG91bGQgYmUgbW92ZWQgb3V0c2lkZSBvZiB0aGUgbmV4dFxuICAgIC8vIHJlZHVjdGlvbilcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlZHVjZVBvcywgXG4gICAgLyoqXG4gICAgVGhlIGlucHV0IHBvc2l0aW9uIHVwIHRvIHdoaWNoIHRoaXMgc3RhY2sgaGFzIHBhcnNlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIGR5bmFtaWMgc2NvcmUgb2YgdGhlIHN0YWNrLCBpbmNsdWRpbmcgZHluYW1pYyBwcmVjZWRlbmNlXG4gICAgYW5kIGVycm9yLXJlY292ZXJ5IHBlbmFsdGllc1xuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NvcmUsIFxuICAgIC8vIFRoZSBvdXRwdXQgYnVmZmVyLiBIb2xkcyAodHlwZSwgc3RhcnQsIGVuZCwgc2l6ZSkgcXVhZHNcbiAgICAvLyByZXByZXNlbnRpbmcgbm9kZXMgY3JlYXRlZCBieSB0aGUgcGFyc2VyLCB3aGVyZSBgc2l6ZWAgaXNcbiAgICAvLyBhbW91bnQgb2YgYnVmZmVyIGFycmF5IGVudHJpZXMgY292ZXJlZCBieSB0aGlzIG5vZGUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJ1ZmZlckJhc2UsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3VyQ29udGV4dCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb29rQWhlYWQgPSAwLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gcmVkdWNlUG9zO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5idWZmZXJCYXNlID0gYnVmZmVyQmFzZTtcbiAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gY3VyQ29udGV4dDtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuc3RhY2suZmlsdGVyKChfLCBpKSA9PiBpICUgMyA9PSAwKS5jb25jYXQodGhpcy5zdGF0ZSl9XUAke3RoaXMucG9zfSR7dGhpcy5zY29yZSA/IFwiIVwiICsgdGhpcy5zY29yZSA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLy8gU3RhcnQgYW4gZW1wdHkgc3RhY2tcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBzdGFydChwLCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICBsZXQgY3ggPSBwLnBhcnNlci5jb250ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHAsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBjeCA/IG5ldyBTdGFja0NvbnRleHQoY3gsIGN4LnN0YXJ0KSA6IG51bGwsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RhY2sncyBjdXJyZW50IFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIpIHZhbHVlLCBpZlxuICAgIGFueS4gSXRzIHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIGNvbnRleHQgdHJhY2tlcidzIHR5cGVcbiAgICBwYXJhbWV0ZXIsIG9yIGl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGNvbnRleHRcbiAgICB0cmFja2VyLlxuICAgICovXG4gICAgZ2V0IGNvbnRleHQoKSB7IHJldHVybiB0aGlzLmN1ckNvbnRleHQgPyB0aGlzLmN1ckNvbnRleHQuY29udGV4dCA6IG51bGw7IH1cbiAgICAvLyBQdXNoIGEgc3RhdGUgb250byB0aGUgc3RhY2ssIHRyYWNraW5nIGl0cyBzdGFydCBwb3NpdGlvbiBhcyB3ZWxsXG4gICAgLy8gYXMgdGhlIGJ1ZmZlciBiYXNlIGF0IHRoYXQgcG9pbnQuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwdXNoU3RhdGUoc3RhdGUsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCBzdGFydCwgdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvLyBBcHBseSBhIHJlZHVjZSBhY3Rpb25cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgbGV0IGxvb2thaGVhZFJlY29yZCA9IHRoaXMucmVkdWNlUG9zIDwgdGhpcy5wb3MgLSAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovO1xuICAgICAgICBpZiAobG9va2FoZWFkUmVjb3JkKVxuICAgICAgICAgICAgdGhpcy5zZXRMb29rQWhlYWQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgZFByZWMgPSBwYXJzZXIuZHluYW1pY1ByZWNlZGVuY2UodHlwZSk7XG4gICAgICAgIGlmIChkUHJlYylcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gZFByZWM7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwYXJzZXIuZ2V0R290byh0aGlzLnN0YXRlLCB0eXBlLCB0cnVlKSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCBsb29rYWhlYWRSZWNvcmQgPyA4IDogNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGJhc2UgaW5kZXggaW50byBgdGhpcy5zdGFja2AsIGNvbnRlbnQgYWZ0ZXIgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBkcm9wcGVkLiBOb3RlIHRoYXQgd2l0aCBgU3RheUZsYWdgIHJlZHVjdGlvbnMgd2UgbmVlZCB0b1xuICAgICAgICAvLyBjb25zdW1lIHR3byBleHRyYSBmcmFtZXMgKHRoZSBkdW1teSBwYXJlbnQgbm9kZSBmb3IgdGhlIHNraXBwZWRcbiAgICAgICAgLy8gZXhwcmVzc2lvbiBhbmQgdGhlIHN0YXRlIHRoYXQgd2UnbGwgYmUgc3RheWluZyBpbiwgd2hpY2ggc2hvdWxkXG4gICAgICAgIC8vIGJlIG1vdmVkIHRvIGB0aGlzLnN0YXRlYCkuXG4gICAgICAgIGxldCBiYXNlID0gdGhpcy5zdGFjay5sZW5ndGggLSAoKGRlcHRoIC0gMSkgKiAzKSAtIChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovID8gNiA6IDApO1xuICAgICAgICBsZXQgc3RhcnQgPSBiYXNlID8gdGhpcy5zdGFja1tiYXNlIC0gMl0gOiB0aGlzLnAucmFuZ2VzWzBdLmZyb20sIHNpemUgPSB0aGlzLnJlZHVjZVBvcyAtIHN0YXJ0O1xuICAgICAgICAvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIHRyeSBhbmQgZGV0ZWN0IG92ZXJseSBkZWVwIGxlZnQtYXNzb2NpYXRpdmVcbiAgICAgICAgLy8gdHJlZXMsIHdoaWNoIHdpbGwgbm90IGluY3JlYXNlIHRoZSBwYXJzZSBzdGFjayBkZXB0aCBhbmQgdGh1c1xuICAgICAgICAvLyB3b24ndCBiZSBjYXVnaHQgYnkgdGhlIHJlZ3VsYXIgc3RhY2stZGVwdGggbGltaXQgY2hlY2suXG4gICAgICAgIGlmIChzaXplID49IDIwMDAgLyogUmVjb3Zlci5NaW5CaWdSZWR1Y3Rpb24gKi8gJiYgISgoX2EgPSB0aGlzLnAucGFyc2VyLm5vZGVTZXQudHlwZXNbdHlwZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Fub255bW91cykpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmJpZ1JlZHVjdGlvbkNvdW50Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA8IHNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuYmlnUmVkdWN0aW9uQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gYmFzZSA/IHRoaXMuc3RhY2tbYmFzZSAtIDFdIDogMCwgY291bnQgPSB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGggLSBidWZmZXJCYXNlO1xuICAgICAgICAvLyBTdG9yZSBub3JtYWwgdGVybXMgb3IgYFIgLT4gUiBSYCByZXBlYXQgcmVkdWN0aW9uc1xuICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtIHx8IChhY3Rpb24gJiAxMzEwNzIgLyogQWN0aW9uLlJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFN0YXRlRmxhZy5Ta2lwcGVkICovKSA/IHRoaXMucG9zIDogdGhpcy5yZWR1Y2VQb3M7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCBzdGFydCwgcG9zLCBjb3VudCArIDQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1tiYXNlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiYXNlU3RhdGVJRCA9IHRoaXMuc3RhY2tbYmFzZSAtIDNdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHBhcnNlci5nZXRHb3RvKGJhc2VTdGF0ZUlELCB0eXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiBiYXNlKVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5yZWR1Y2VDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICB9XG4gICAgLy8gU2hpZnQgYSB2YWx1ZSBpbnRvIHRoZSBidWZmZXJcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0b3JlTm9kZSh0ZXJtLCBzdGFydCwgZW5kLCBzaXplID0gNCwgbXVzdFNpbmsgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGVybSA9PSAwIC8qIFRlcm0uRXJyICovICYmXG4gICAgICAgICAgICAoIXRoaXMuc3RhY2subGVuZ3RoIHx8IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA8IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMuYnVmZmVyQmFzZSkpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBvbWl0L21lcmdlIGFkamFjZW50IGVycm9yIG5vZGVzXG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcywgdG9wID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvcCA9PSAwICYmIGN1ci5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBjdXIuYnVmZmVyQmFzZSAtIGN1ci5wYXJlbnQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCA+IDAgJiYgY3VyLmJ1ZmZlclt0b3AgLSA0XSA9PSAwIC8qIFRlcm0uRXJyICovICYmIGN1ci5idWZmZXJbdG9wIC0gMV0gPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBlbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLmJ1ZmZlclt0b3AgLSAyXSA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIuYnVmZmVyW3RvcCAtIDJdID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbXVzdFNpbmsgfHwgdGhpcy5wb3MgPT0gZW5kKSB7IC8vIFNpbXBsZSBjYXNlLCBqdXN0IGFwcGVuZFxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0ZXJtLCBzdGFydCwgZW5kLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gVGhlcmUgbWF5IGJlIHNraXBwZWQgbm9kZXMgdGhhdCBoYXZlIHRvIGJlIG1vdmVkIGZvcndhcmRcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSA0XSAhPSAwIC8qIFRlcm0uRXJyICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IGluZGV4OyBzY2FuID4gMCAmJiB0aGlzLmJ1ZmZlcltzY2FuIC0gMl0gPiBlbmQ7IHNjYW4gLT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5idWZmZXJbc2NhbiAtIDFdID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11c3RNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtdXN0TW92ZSlcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoaXMgcmVjb3JkIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gdGhpcy5idWZmZXJbaW5kZXggLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCAtPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGVybTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhIHNoaWZ0IGFjdGlvblxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2hpZnQoYWN0aW9uLCB0eXBlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChhY3Rpb24gJiAxMzEwNzIgLyogQWN0aW9uLkdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8pID09IDApIHsgLy8gUmVndWxhciBzaGlmdFxuICAgICAgICAgICAgbGV0IG5leHRTdGF0ZSA9IGFjdGlvbiwgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0aGlzLnBvcyB8fCB0eXBlIDw9IHBhcnNlci5tYXhOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuc3RhdGVGbGFnKG5leHRTdGF0ZSwgMSAvKiBTdGF0ZUZsYWcuU2tpcHBlZCAqLykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkdWNlUG9zID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgICAgICAgICBpZiAodHlwZSA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHR5cGUsIHN0YXJ0LCBlbmQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBTaGlmdC1hbmQtc3RheSwgd2hpY2ggbWVhbnMgdGhpcyBpcyBhIHNraXBwZWQgdG9rZW5cbiAgICAgICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godHlwZSwgc3RhcnQsIGVuZCwgNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBseShhY3Rpb24sIG5leHQsIG5leHRTdGFydCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pXG4gICAgICAgICAgICB0aGlzLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dFN0YXJ0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgKHJldXNlZCkgbm9kZSBpbnRvIHRoZSBidWZmZXIuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1c2VOb2RlKHZhbHVlLCBuZXh0KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMucC5yZXVzZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLnAucmV1c2VkW2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wLnJldXNlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3MgPSBzdGFydCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dCwgc3RhcnQpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGluZGV4LCBzdGFydCwgdGhpcy5yZWR1Y2VQb3MsIC0xIC8qIHNpemUgPT0gLTEgbWVhbnMgdGhpcyBpcyBhIHJldXNlZCB2YWx1ZSAqLyk7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmV1c2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHZhbHVlLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHRoaXMucG9zIC0gdmFsdWUubGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLyBTcGxpdCB0aGUgc3RhY2suIER1ZSB0byB0aGUgYnVmZmVyIHNoYXJpbmcgYW5kIHRoZSBmYWN0XG4gICAgLy8gdGhhdCBgdGhpcy5zdGFja2AgdGVuZHMgdG8gc3RheSBxdWl0ZSBzaGFsbG93LCB0aGlzIGlzbid0IHZlcnlcbiAgICAvLyBleHBlbnNpdmUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzcGxpdCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgIGxldCBvZmYgPSBwYXJlbnQuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGUgdG9wIG9mIHRoZSBidWZmZXIgKGFmdGVyIHRoaXMucG9zKSBtYXkgYmUgbXV0YXRlZFxuICAgICAgICAvLyB0byByZW9yZGVyIHJlZHVjdGlvbnMgYW5kIHNraXBwZWQgdG9rZW5zLCBhbmQgc2hhcmVkIGJ1ZmZlcnNcbiAgICAgICAgLy8gc2hvdWxkIGJlIGltbXV0YWJsZSwgdGhpcyBjb3BpZXMgYW55IG91dHN0YW5kaW5nIHNraXBwZWQgdG9rZW5zXG4gICAgICAgIC8vIHRvIHRoZSBuZXcgYnVmZmVyLCBhbmQgcHV0cyB0aGUgYmFzZSBwb2ludGVyIGJlZm9yZSB0aGVtLlxuICAgICAgICB3aGlsZSAob2ZmID4gMCAmJiBwYXJlbnQuYnVmZmVyW29mZiAtIDJdID4gcGFyZW50LnJlZHVjZVBvcylcbiAgICAgICAgICAgIG9mZiAtPSA0O1xuICAgICAgICBsZXQgYnVmZmVyID0gcGFyZW50LmJ1ZmZlci5zbGljZShvZmYpLCBiYXNlID0gcGFyZW50LmJ1ZmZlckJhc2UgKyBvZmY7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBwYXJlbnQgcG9pbnRzIHRvIGFuIGFjdHVhbCBwYXJlbnQgd2l0aCBjb250ZW50LCBpZiB0aGVyZSBpcyBzdWNoIGEgcGFyZW50LlxuICAgICAgICB3aGlsZSAocGFyZW50ICYmIGJhc2UgPT0gcGFyZW50LmJ1ZmZlckJhc2UpXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHRoaXMucCwgdGhpcy5zdGFjay5zbGljZSgpLCB0aGlzLnN0YXRlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5wb3MsIHRoaXMuc2NvcmUsIGJ1ZmZlciwgYmFzZSwgdGhpcy5jdXJDb250ZXh0LCB0aGlzLmxvb2tBaGVhZCwgcGFyZW50KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHJlY292ZXIgZnJvbSBhbiBlcnJvciBieSAnZGVsZXRpbmcnIChpZ25vcmluZykgb25lIHRva2VuLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3ZlckJ5RGVsZXRlKG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IGlzTm9kZSA9IG5leHQgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlO1xuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQsIDQpO1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgbmV4dEVuZCwgaXNOb2RlID8gOCA6IDQpO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgdGhpcy5zY29yZSAtPSAxOTAgLyogUmVjb3Zlci5EZWxldGUgKi87XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICAgIGFmdGVyIHNvbWUgcmVkdWN0aW9ucykgb24gdGhpcyBzdGFjay4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxuICAgIGV4dGVybmFsIHRva2VuaXplcnMgdGhhdCB3YW50IHRvIG1ha2Ugc3VyZSB0aGV5IG9ubHkgcHJvdmlkZSBhXG4gICAgZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAgICovXG4gICAgY2FuU2hpZnQodGVybSkge1xuICAgICAgICBmb3IgKGxldCBzaW0gPSBuZXcgU2ltdWxhdGVkU3RhY2sodGhpcyk7Oykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMucC5wYXJzZXIuc3RhdGVTbG90KHNpbS5zdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pIHx8IHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHNpbS5zdGF0ZSwgdGVybSk7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHNpbS5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSB1cCB0byBSZWNvdmVyLk1heE5leHQgcmVjb3ZlcnkgYWN0aW9ucyB0aGF0IGNvbmNlcHR1YWxseVxuICAgIC8vIGluc2VydHMgc29tZSBtaXNzaW5nIHRva2VuIG9yIHJ1bGUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyQnlJbnNlcnQobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwIC8qIFJlY292ZXIuTWF4SW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IG5leHRTdGF0ZXMgPSB0aGlzLnAucGFyc2VyLm5leHRTdGF0ZXModGhpcy5zdGF0ZSk7XG4gICAgICAgIGlmIChuZXh0U3RhdGVzLmxlbmd0aCA+IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovIDw8IDEgfHwgdGhpcy5zdGFjay5sZW5ndGggPj0gMTIwIC8qIFJlY292ZXIuRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLykge1xuICAgICAgICAgICAgbGV0IGJlc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICgocyA9IG5leHRTdGF0ZXNbaSArIDFdKSAhPSB0aGlzLnN0YXRlICYmIHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHMsIG5leHQpKVxuICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxMjAgLyogUmVjb3Zlci5EYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBiZXN0Lmxlbmd0aCA8IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovIDw8IDEgJiYgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZXN0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSBzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0U3RhdGVzID0gYmVzdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICBpZiAocyA9PSB0aGlzLnN0YXRlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaFN0YXRlKHMsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCBzdGFjay5wb3MsIHN0YWNrLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFjay5zaGlmdENvbnRleHQobmV4dFN0YXRlc1tpXSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICBzdGFjay5zY29yZSAtPSAyMDAgLyogUmVjb3Zlci5JbnNlcnQgKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3JjZVJlZHVjZSgpIHtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGxldCByZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDUgLyogUGFyc2VTdGF0ZS5Gb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXBhcnNlci52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCByZWR1Y2UpKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSByZWR1Y2UgPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8sIHRlcm0gPSByZWR1Y2UgJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gZGVwdGggKiAzO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA8IDAgfHwgcGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0YXJnZXRdLCB0ZXJtLCBmYWxzZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhY2t1cCA9IHRoaXMuZmluZEZvcmNlZFJlZHVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChiYWNrdXAgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlZHVjZSA9IGJhY2t1cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjb3JlIC09IDEwMCAvKiBSZWNvdmVyLlJlZHVjZSAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZShyZWR1Y2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIHNjYW4gdGhyb3VnaCB0aGUgYXV0b21hdG9uIHRvIGZpbmQgc29tZSBraW5kIG9mIHJlZHVjdGlvblxuICAgIHRoYXQgY2FuIGJlIGFwcGxpZWQuIFVzZWQgd2hlbiB0aGUgcmVndWxhciBGb3JjZWRSZWR1Y2UgZmllbGRcbiAgICBpc24ndCBhIHZhbGlkIGFjdGlvbi4gQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kRm9yY2VkUmVkdWN0aW9uKCkge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucCwgc2VlbiA9IFtdO1xuICAgICAgICBsZXQgZXhwbG9yZSA9IChzdGF0ZSwgZGVwdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluY2x1ZGVzKHN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWVuLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5hbGxBY3Rpb25zKHN0YXRlLCAoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAmICgyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovIHwgMTMxMDcyIC8qIEFjdGlvbi5Hb3RvRmxhZyAqLykpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgckRlcHRoID0gKGFjdGlvbiA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLykgLSBkZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJEZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgdGFyZ2V0ID0gdGhpcy5zdGFjay5sZW5ndGggLSByRGVwdGggKiAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA+PSAwICYmIHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyRGVwdGggPDwgMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8pIHwgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8gfCB0ZXJtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBleHBsb3JlKGFjdGlvbiwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBleHBsb3JlKHRoaXMuc3RhdGUsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcmNlQWxsKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMucC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogU3RhdGVGbGFnLkFjY2VwdGluZyAqLykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JjZVJlZHVjZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGhhcyBubyBmdXJ0aGVyIGFjdGlvbnMgKGFzc3VtZWQgdG8gYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGVcbiAgICB0b3Agc3RhdGUsIHNpbmNlIGFueSBvdGhlciBzdGF0ZXMgbXVzdCBiZSBhYmxlIHRvIGNvbnRpbnVlXG4gICAgc29tZWhvdykuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5kYXRhW3BhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovICYmXG4gICAgICAgICAgICAhcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICB3aGVuIHRoaXMuc3RhY2subGVuZ3RoID09IDMgKHN0YXRlIGlzIGRpcmVjdGx5IGJlbG93IHRoZSB0b3BcbiAgICBzdGF0ZSkuIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzYW1lU3RhdGUob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gb3RoZXIuc3RhdGUgfHwgdGhpcy5zdGFjay5sZW5ndGggIT0gb3RoZXIuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFja1tpXSAhPSBvdGhlci5zdGFja1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgKi9cbiAgICBnZXQgcGFyc2VyKCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlcjsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciBhIGdpdmVuIGRpYWxlY3QgKGJ5IG51bWVyaWMgSUQsIGFzIGV4cG9ydGVkIGZyb21cbiAgICB0aGUgdGVybXMgZmlsZSkgaXMgZW5hYmxlZC5cbiAgICAqL1xuICAgIGRpYWxlY3RFbmFibGVkKGRpYWxlY3RJRCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlci5kaWFsZWN0LmZsYWdzW2RpYWxlY3RJRF07IH1cbiAgICBzaGlmdENvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zaGlmdCh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgcmVkdWNlQ29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJlZHVjZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbWl0Q29udGV4dCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTMpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VyQ29udGV4dC5oYXNoLCB0aGlzLnBvcywgdGhpcy5wb3MsIC0zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbWl0TG9va0FoZWFkKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtNClcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5sb29rQWhlYWQsIHRoaXMucG9zLCB0aGlzLnBvcywgLTQpO1xuICAgIH1cbiAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgIT0gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQpIHtcbiAgICAgICAgICAgIGxldCBuZXdDeCA9IG5ldyBTdGFja0NvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG5ld0N4Lmhhc2ggIT0gdGhpcy5jdXJDb250ZXh0Lmhhc2gpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gbmV3Q3g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXRMb29rQWhlYWQobG9va0FoZWFkKSB7XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiB0aGlzLmxvb2tBaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0TG9va0FoZWFkKCk7XG4gICAgICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdClcbiAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9va0FoZWFkID4gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0cmFja2VyLnN0cmljdCA/IHRyYWNrZXIuaGFzaChjb250ZXh0KSA6IDA7XG4gICAgfVxufVxuLy8gVXNlZCB0byBjaGVhcGx5IHJ1biBzb21lIHJlZHVjdGlvbnMgdG8gc2NhbiBhaGVhZCB3aXRob3V0IG11dGF0aW5nXG4vLyBhbiBlbnRpcmUgc3RhY2tcbmNsYXNzIFNpbXVsYXRlZFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YXJ0LnN0YWNrO1xuICAgICAgICB0aGlzLmJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB9XG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2sgPT0gdGhpcy5zdGFydC5zdGFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iYXNlICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgLT0gKGRlcHRoIC0gMSkgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb3RvID0gdGhpcy5zdGFydC5wLnBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGhpcy5iYXNlIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaywgcG9zID0gc3RhY2suYnVmZmVyQmFzZSArIHN0YWNrLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcihzdGFjaywgcG9zLCBwb3MgLSBzdGFjay5idWZmZXJCYXNlKTtcbiAgICB9XG4gICAgbWF5YmVOZXh0KCkge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuc3RhY2sucGFyZW50O1xuICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5idWZmZXJCYXNlIC0gbmV4dC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5leHQuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gNDtcbiAgICAgICAgdGhpcy5wb3MgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIGZvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3IodGhpcy5zdGFjaywgdGhpcy5wb3MsIHRoaXMuaW5kZXgpO1xuICAgIH1cbn1cblxuLy8gU2VlIGxlemVyLWdlbmVyYXRvci9zcmMvZW5jb2RlLnRzIGZvciBjb21tZW50cyBhYm91dCB0aGUgZW5jb2Rpbmdcbi8vIHVzZWQgaGVyZVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoaW5wdXQsIFR5cGUgPSBVaW50MTZBcnJheSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIGxldCBhcnJheSA9IG51bGw7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgb3V0ID0gMDsgcG9zIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSAxMjYgLyogRW5jb2RlLkJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEVuY29kZS5CaWdWYWwgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA+PSA5MiAvKiBFbmNvZGUuR2FwMiAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBpZiAobmV4dCA+PSAzNCAvKiBFbmNvZGUuR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogRW5jb2RlLlN0YXJ0ICovO1xuICAgICAgICAgICAgaWYgKGRpZ2l0ID49IDQ2IC8qIEVuY29kZS5CYXNlICovKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgLT0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5KVxuICAgICAgICAgICAgYXJyYXlbb3V0KytdID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmNsYXNzIENhY2hlZFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIHRoaXMuZW5kID0gLTE7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSAwO1xuICAgICAgICB0aGlzLm1hc2sgPSAwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSAwO1xuICAgIH1cbn1cbmNvbnN0IG51bGxUb2tlbiA9IG5ldyBDYWNoZWRUb2tlbjtcbi8qKlxuW1Rva2VuaXplcnNdKCNsci5FeHRlcm5hbFRva2VuaXplcikgaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXRcbnRocm91Z2ggdGhpcyBpbnRlcmZhY2UuIEl0IHByZXNlbnRzIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZlxuY2hhcmFjdGVycywgdHJhY2tpbmcgbG9va2FoZWFkIGFuZCBoaWRpbmcgdGhlIGNvbXBsZXhpdHkgb2ZcbltyYW5nZXNdKCNjb21tb24uUGFyc2VyLnBhcnNlXnJhbmdlcykgZnJvbSB0b2tlbml6ZXIgY29kZS5cbiovXG5jbGFzcyBJbnB1dFN0cmVhbSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmdlcykge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgQmFja3VwIGNodW5rXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsyID0gXCJcIjtcbiAgICAgICAgdGhpcy5jaHVuazJQb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGNoYXJhY3RlciBjb2RlIG9mIHRoZSBuZXh0IGNvZGUgdW5pdCBpbiB0aGUgaW5wdXQsIG9yIC0xXG4gICAgICAgIHdoZW4gdGhlIHN0cmVhbSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuZW5kID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVPZmZzZXQob2Zmc2V0LCBhc3NvYykge1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJhbmdlLCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICB3aGlsZSAocG9zIDwgcmFuZ2UuZnJvbSkge1xuICAgICAgICAgICAgaWYgKCFpbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbLS1pbmRleF07XG4gICAgICAgICAgICBwb3MgLT0gcmFuZ2UuZnJvbSAtIG5leHQudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFzc29jIDwgMCA/IHBvcyA+IHJhbmdlLnRvIDogcG9zID49IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbKytpbmRleF07XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5mcm9tIC0gcmFuZ2UudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjbGlwUG9zKHBvcykge1xuICAgICAgICBpZiAocG9zID49IHRoaXMucmFuZ2UuZnJvbSAmJiBwb3MgPCB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG4gICAgICAgICAgICBpZiAocmFuZ2UudG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHBvcywgcmFuZ2UuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBhdCBhIGNvZGUgdW5pdCBuZWFyIHRoZSBzdHJlYW0gcG9zaXRpb24uIGAucGVlaygwKWAgZXF1YWxzXG4gICAgYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICAgIG9uLlxuICAgIFxuICAgIE5vdGUgdGhhdCBsb29raW5nIGFyb3VuZCBkdXJpbmcgdG9rZW5pemluZyBjcmVhdGVzIGRlcGVuZGVuY2llc1xuICAgIG9uIHBvdGVudGlhbGx5IGZhci1hd2F5IGNvbnRlbnQsIHdoaWNoIG1heSByZWR1Y2UgdGhlXG4gICAgZWZmZWN0aXZlbmVzcyBpbmNyZW1lbnRhbCBwYXJzaW5n4oCUd2hlbiBsb29raW5nIGZvcndhcmTigJRvciBldmVuXG4gICAgY2F1c2UgaW52YWxpZCByZXBhcnNlcyB3aGVuIGxvb2tpbmcgYmFja3dhcmQgbW9yZSB0aGFuIDI1IGNvZGVcbiAgICB1bml0cywgc2luY2UgdGhlIGxpYnJhcnkgZG9lcyBub3QgdHJhY2sgbG9va2JlaGluZC5cbiAgICAqL1xuICAgIHBlZWsob2Zmc2V0KSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmNodW5rT2ZmICsgb2Zmc2V0LCBwb3MsIHJlc3VsdDtcbiAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlT2Zmc2V0KG9mZnNldCwgMSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBwb3MgPSByZXNvbHZlZDtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgcG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KHBvcyAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpID0gdGhpcy5yYW5nZUluZGV4LCByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJhbmdlLnRvIDw9IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlc1srK2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLmNodW5rMlBvcyA9IHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCA+IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bmsyLnNsaWNlKDAsIHJhbmdlLnRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFjY2VwdCBhIHRva2VuLiBCeSBkZWZhdWx0LCB0aGUgZW5kIG9mIHRoZSB0b2tlbiBpcyBzZXQgdG8gdGhlXG4gICAgY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICAgIHRoZSBzdHJlYW0gcG9zaXRpb24pIHRvIGNoYW5nZSB0aGF0LlxuICAgICovXG4gICAgYWNjZXB0VG9rZW4odG9rZW4sIGVuZE9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGVuZCA9IGVuZE9mZnNldCA/IHRoaXMucmVzb2x2ZU9mZnNldChlbmRPZmZzZXQsIC0xKSA6IHRoaXMucG9zO1xuICAgICAgICBpZiAoZW5kID09IG51bGwgfHwgZW5kIDwgdGhpcy50b2tlbi5zdGFydClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVG9rZW4gZW5kIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFjY2VwdCBhIHRva2VuIGVuZGluZyBhdCBhIHNwZWNpZmljIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgYWNjZXB0VG9rZW5Ubyh0b2tlbiwgZW5kUG9zKSB7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmRQb3M7XG4gICAgfVxuICAgIGdldENodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgdGhpcy5wb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgY2h1bmssIGNodW5rUG9zIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IHRoaXMuY2h1bmsyO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMuY2h1bmsyUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSBjaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gY2h1bmtQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gdGhpcy5wb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgbGV0IG5leHRDaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5wb3MpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucG9zICsgbmV4dENodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBlbmQgPiB0aGlzLnJhbmdlLnRvID8gbmV4dENodW5rLnNsaWNlKDAsIHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcykgOiBuZXh0Q2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPj0gdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2h1bmsoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID09IHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KHRoaXMuY2h1bmtPZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBzdHJlYW0gZm9yd2FyZCBOIChkZWZhdWx0cyB0byAxKSBjb2RlIHVuaXRzLiBSZXR1cm5zXG4gICAgdGhlIG5ldyB2YWx1ZSBvZiBbYG5leHRgXSgjbHIuSW5wdXRTdHJlYW0ubmV4dCkuXG4gICAgKi9cbiAgICBhZHZhbmNlKG4gPSAxKSB7XG4gICAgICAgIHRoaXMuY2h1bmtPZmYgKz0gbjtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zICsgbiA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgbiAtPSB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJhbmdlLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIHNldERvbmUoKSB7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHRoaXMuZW5kO1xuICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4ID0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQocG9zLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgdG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4uZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zICE9IHBvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgICAgICBpZiAocG9zID09IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGhpcy5yYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1stLXRoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB3aGlsZSAocG9zID49IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVua1BvcyAmJiBwb3MgPCB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gcG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVua1BvcyAmJiB0byA8PSB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuay5zbGljZShmcm9tIC0gdGhpcy5jaHVua1BvcywgdG8gLSB0aGlzLmNodW5rUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVuazJQb3MgJiYgdG8gPD0gdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuazIuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmsyUG9zLCB0byAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5yYW5nZS5mcm9tICYmIHRvIDw9IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yZWFkKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuaW5wdXQucmVhZChNYXRoLm1heChyLmZyb20sIGZyb20pLCBNYXRoLm1pbihyLnRvLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgIHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgdGhpcy5pZCwgcGFyc2VyLmRhdGEsIHBhcnNlci50b2tlblByZWNUYWJsZSk7XG4gICAgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vKipcbkBoaWRlXG4qL1xuY2xhc3MgTG9jYWxUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwcmVjVGFibGUsIGVsc2VUb2tlbikge1xuICAgICAgICB0aGlzLnByZWNUYWJsZSA9IHByZWNUYWJsZTtcbiAgICAgICAgdGhpcy5lbHNlVG9rZW4gPSBlbHNlVG9rZW47XG4gICAgICAgIHRoaXMuZGF0YSA9IHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIgPyBkZWNvZGVBcnJheShkYXRhKSA6IGRhdGE7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgc3RhcnQgPSBpbnB1dC5wb3MsIHNraXBwZWQgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYXRFb2YgPSBpbnB1dC5uZXh0IDwgMCwgbmV4dFBvcyA9IGlucHV0LnJlc29sdmVPZmZzZXQoMSwgMSk7XG4gICAgICAgICAgICByZWFkVG9rZW4odGhpcy5kYXRhLCBpbnB1dCwgc3RhY2ssIDAsIHRoaXMuZGF0YSwgdGhpcy5wcmVjVGFibGUpO1xuICAgICAgICAgICAgaWYgKGlucHV0LnRva2VuLnZhbHVlID4gLTEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5lbHNlVG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWF0RW9mKVxuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgIGlmIChuZXh0UG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpbnB1dC5yZXNldChuZXh0UG9zLCBpbnB1dC50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnJlc2V0KHN0YXJ0LCBpbnB1dC50b2tlbik7XG4gICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0aGlzLmVsc2VUb2tlbiwgc2tpcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Mb2NhbFRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLyoqXG5gQGV4dGVybmFsIHRva2Vuc2AgZGVjbGFyYXRpb25zIGluIHRoZSBncmFtbWFyIHNob3VsZCByZXNvbHZlIHRvXG5hbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuKi9cbmNsYXNzIEV4dGVybmFsVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gICAgcmVjb2duaXplcyBhdCB0aGUgc3RyZWFtJ3MgcG9zaXRpb24sIGFuZCBjYWxsc1xuICAgIFtgYWNjZXB0VG9rZW5gXSgjbHIuSW5wdXRTdHJlYW0uYWNjZXB0VG9rZW4pIHdoZW4gaXQgZmluZHNcbiAgICBvbmUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGBpbnB1dC50b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHN0YWNrLCBncm91cCwgcHJlY1RhYmxlLCBwcmVjT2Zmc2V0KSB7XG4gICAgbGV0IHN0YXRlID0gMCwgZ3JvdXBNYXNrID0gMSA8PCBncm91cCwgeyBkaWFsZWN0IH0gPSBzdGFjay5wLnBhcnNlcjtcbiAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5wdXQudG9rZW4udmFsdWUgPT0gLTEgfHwgaW5wdXQudG9rZW4udmFsdWUgPT0gdGVybSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzKHRlcm0sIGlucHV0LnRva2VuLnZhbHVlLCBwcmVjVGFibGUsIHByZWNPZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGlucHV0Lm5leHQsIGxvdyA9IDAsIGhpZ2ggPSBkYXRhW3N0YXRlICsgMl07XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgRU9GXG4gICAgICAgIGlmIChpbnB1dC5uZXh0IDwgMCAmJiBoaWdoID4gbG93ICYmIGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAzXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAxXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAoOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdIHx8IDB4MTAwMDA7XG4gICAgICAgICAgICBpZiAobmV4dCA8IGZyb20pXG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gdG8pXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogU2VxLkVuZCAqLzsgaSsrKVxuICAgICAgICBpZiAobmV4dCA9PSB0ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIGkgLSBzdGFydDtcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBvdmVycmlkZXModG9rZW4sIHByZXYsIHRhYmxlRGF0YSwgdGFibGVPZmZzZXQpIHtcbiAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRhYmxlRGF0YSwgdGFibGVPZmZzZXQsIHByZXYpO1xuICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0YWJsZURhdGEsIHRhYmxlT2Zmc2V0LCB0b2tlbikgPCBpUHJldjtcbn1cblxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGNvbnNvbGUgb3V0cHV0XG5jb25zdCB2ZXJib3NlID0gdHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBzdGFja0lEcyA9IG51bGw7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5jdXJzb3IoY29tbW9uLkl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpO1xuICAgIGN1cnNvci5tb3ZlVG8ocG9zKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICghKHNpZGUgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHBvcykgOiBjdXJzb3IuY2hpbGRBZnRlcihwb3MpKSlcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPCAwID8gY3Vyc29yLnRvIDwgcG9zIDogY3Vyc29yLmZyb20gPiBwb3MpICYmICFjdXJzb3IudHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbihjdXJzb3IudG8gLSAxLCBwb3MgLSAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4odHJlZS5sZW5ndGgsIE1hdGgubWF4KGN1cnNvci5mcm9tICsgMSwgcG9zICsgMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLykpO1xuICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyAwIDogdHJlZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cywgbm9kZVNldCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbm9kZVNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FmZUZyb20gPSAtMTtcbiAgICAgICAgdGhpcy5zYWZlVG8gPSAtMTtcbiAgICAgICAgdGhpcy50cmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICBsZXQgZnIgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5pID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IG51bGwgOiB0aGlzLmZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgICAgIGlmIChmcikge1xuICAgICAgICAgICAgdGhpcy5zYWZlRnJvbSA9IGZyLm9wZW5TdGFydCA/IGN1dEF0KGZyLnRyZWUsIGZyLmZyb20gKyBmci5vZmZzZXQsIDEpIC0gZnIub2Zmc2V0IDogZnIuZnJvbTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvID0gZnIub3BlbkVuZCA/IGN1dEF0KGZyLnRyZWUsIGZyLnRvICsgZnIub2Zmc2V0LCAtMSkgLSBmci5vZmZzZXQgOiBmci50bztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRyZWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKGZyLnRyZWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKC1mci5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLm5leHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLnNhZmVUbyA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnRyZWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHsgLy8gRW5kIG9mIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudHJlZXNbbGFzdF0sIGluZGV4ID0gdGhpcy5pbmRleFtsYXN0XTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0b3AuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YXJ0W2xhc3RdICsgdG9wLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBjb21tb24uVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5zYWZlRnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA8PSB0aGlzLnNhZmVUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IG5leHQucHJvcChjb21tb24uTm9kZVByb3AubG9va0FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9va0FoZWFkIHx8IGVuZCArIGxvb2tBaGVhZCA8IHRoaXMuZnJhZ21lbnQudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IE1hdGgubWF4KHRoaXMuc2FmZUZyb20sIHBvcykpIHsgLy8gRW50ZXIgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrKSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IHRva2VuaXplcnMgfSA9IHBhcnNlcjtcbiAgICAgICAgbGV0IG1hc2sgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCAzIC8qIFBhcnNlU3RhdGUuVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3RhY2suY3VyQ29udGV4dCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgIGxldCBsb29rQWhlYWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoKDEgPDwgaSkgJiBtYXNrKSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRva2VuaXplciA9IHRva2VuaXplcnNbaV0sIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAobWFpbiAmJiAhdG9rZW5pemVyLmZhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRva2VuaXplci5jb250ZXh0dWFsIHx8IHRva2VuLnN0YXJ0ICE9IHN0YWNrLnBvcyB8fCB0b2tlbi5tYXNrICE9IG1hc2sgfHwgdG9rZW4uY29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgdG9rZW4ubWFzayA9IG1hc2s7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4ubG9va0FoZWFkID4gdG9rZW4uZW5kICsgMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBNYXRoLm1heCh0b2tlbi5sb29rQWhlYWQsIGxvb2tBaGVhZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgIT0gMCAvKiBUZXJtLkVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmIChsb29rQWhlYWQpXG4gICAgICAgICAgICBzdGFjay5zZXRMb29rQWhlYWQobG9va0FoZWFkKTtcbiAgICAgICAgaWYgKCFtYWluICYmIHN0YWNrLnBvcyA9PSB0aGlzLnN0cmVhbS5lbmQpIHtcbiAgICAgICAgICAgIG1haW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4gICAgICAgICAgICBtYWluLnZhbHVlID0gc3RhY2sucC5wYXJzZXIuZW9mVGVybTtcbiAgICAgICAgICAgIG1haW4uc3RhcnQgPSBtYWluLmVuZCA9IHN0YWNrLnBvcztcbiAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCBtYWluLnZhbHVlLCBtYWluLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgZ2V0TWFpblRva2VuKHN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW5Ub2tlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW5Ub2tlbjtcbiAgICAgICAgbGV0IG1haW4gPSBuZXcgQ2FjaGVkVG9rZW4sIHsgcG9zLCBwIH0gPSBzdGFjaztcbiAgICAgICAgbWFpbi5zdGFydCA9IHBvcztcbiAgICAgICAgbWFpbi5lbmQgPSBNYXRoLm1pbihwb3MgKyAxLCBwLnN0cmVhbS5lbmQpO1xuICAgICAgICBtYWluLnZhbHVlID0gcG9zID09IHAuc3RyZWFtLmVuZCA/IHAucGFyc2VyLmVvZlRlcm0gOiAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICByZXR1cm4gbWFpbjtcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdHJlYW0uY2xpcFBvcyhzdGFjay5wb3MpO1xuICAgICAgICB0b2tlbml6ZXIudG9rZW4odGhpcy5zdHJlYW0ucmVzZXQoc3RhcnQsIHRva2VuKSwgc3RhY2spO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZXIuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zcGVjaWFsaXplZFtpXSA9PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VyLnNwZWNpYWxpemVyc1tpXSh0aGlzLnN0cmVhbS5yZWFkKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPj0gMCAmJiBzdGFjay5wLnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgICAgICB0b2tlbi5lbmQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YXJ0ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgZGF0YSB9ID0gcGFyc2VyO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDAgJiYgZGF0YVtpICsgMV0gPT0gMiAvKiBTZXEuT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAyKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSAwO1xuICAgICAgICB0aGlzLm5leHRTdGFja0lEID0gMHgyNjU0OyAvLyDimZQsIOKZlSwg4pmWLCDimZcsIOKZmCwg4pmZLCDimaAsIOKZoSwg4pmiLCDimaMsIOKZpCwg4pmlLCDimaYsIOKZp1xuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gMDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gMDtcbiAgICAgICAgdGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IElucHV0U3RyZWFtKGlucHV0LCByYW5nZXMpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlciwgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICBsZXQgeyBmcm9tIH0gPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIGZyb20pXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoICYmIHRoaXMuc3RyZWFtLmVuZCAtIGZyb20gPiBwYXJzZXIuYnVmZmVyTGVuZ3RoICogNFxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzLCBwYXJzZXIubm9kZVNldCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5TdGFja1BvcztcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5taW5TdGFja1BvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICAvLyBJZiBhIGxhcmdlIGFtb3VudCBvZiByZWR1Y3Rpb25zIGhhcHBlbmVkIHdpdGggdGhlIHNhbWUgc3RhcnRcbiAgICAgICAgLy8gcG9zaXRpb24sIGZvcmNlIHRoZSBzdGFjayBvdXQgb2YgdGhhdCBwcm9kdWN0aW9uIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGF2b2lkIGNyZWF0aW5nIGEgdHJlZSB0b28gZGVlcCB0byByZWN1cnNlIHRocm91Z2guXG4gICAgICAgIC8vIChUaGlzIGlzIGFuIHVnbHkga2x1ZGdlLCBiZWNhdXNlIHVuZm9ydHVuYXRlbHkgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gc3RyYWlnaHRmb3J3YXJkLCBjaGVhcCB3YXkgdG8gY2hlY2sgZm9yIHRoaXMgaGFwcGVuaW5nLCBkdWUgdG9cbiAgICAgICAgLy8gdGhlIGhpc3Rvcnkgb2YgcmVkdWN0aW9ucyBvbmx5IGJlaW5nIGF2YWlsYWJsZSBpbiBhblxuICAgICAgICAvLyBleHBlbnNpdmUtdG8tYWNjZXNzIGZvcm1hdCBpbiB0aGUgc3RhY2sgYnVmZmVycy4pXG4gICAgICAgIGlmICh0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID4gMzAwIC8qIFJlYy5NYXhMZWZ0QXNzb2NpYXRpdmVSZWR1Y3Rpb25Db3VudCAqLyAmJiBzdGFja3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBbc10gPSBzdGFja3M7XG4gICAgICAgICAgICB3aGlsZSAocy5mb3JjZVJlZHVjZSgpICYmIHMuc3RhY2subGVuZ3RoICYmIHMuc3RhY2tbcy5zdGFjay5sZW5ndGggLSAyXSA+PSB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCkgeyB9XG4gICAgICAgICAgICB0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID0gdGhpcy5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCBhZHZhbmNpbmcgYW55IHN0YWNrcyBhdCBgcG9zYCB1bnRpbCB0aGV5IGVpdGhlciBtb3ZlXG4gICAgICAgIC8vIGZvcndhcmQgb3IgY2FuJ3QgYmUgYWR2YW5jZWQuIEdhdGhlciBzdGFja3MgdGhhdCBjYW4ndCBiZVxuICAgICAgICAvLyBhZHZhbmNlZCBmdXJ0aGVyIGluIGBzdG9wcGVkYC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbmV3U3RhY2tzLCBzdGFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvayA9IHRoaXMudG9rZW5zLmdldE1haW5Ub2tlbihzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmluaXNoIHdpdGggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UgJiYgc3RvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdHVjayB3aXRoIHRva2VuIFwiICsgKHRoaXMudG9rZW5zLm1haW5Ub2tlbiA/IHRoaXMucGFyc2VyLmdldE5hbWUodGhpcy50b2tlbnMubWFpblRva2VuLnZhbHVlKSA6IFwibm9uZVwiKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY292ZXJpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gNSAvKiBSZWMuRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0b3BwZWRbMF0ucG9zID4gdGhpcy5zdG9wcGVkQXQgPyBzdG9wcGVkWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3JjZS1maW5pc2ggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBSZWMuTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8gJiYgb3RoZXIuYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8pXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZSgxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLywgbmV3U3RhY2tzLmxlbmd0aCAtIDEyIC8qIFJlYy5NYXhTdGFja0NvdW50ICovKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzWzBdLnBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnBvcyA8IHRoaXMubWluU3RhY2tQb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1tpXS5wb3M7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBtb3ZlIHN0b3BwZWRBdCBmb3J3YXJkXCIpO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IHBhcnNlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RhcnQgPiB0aGlzLnN0b3BwZWRBdClcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5mb3JjZVJlZHVjZSgpID8gc3RhY2sgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGxldCBzdHJpY3RDeCA9IHN0YWNrLmN1ckNvbnRleHQgJiYgc3RhY2suY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCwgY3hIYXNoID0gc3RyaWN0Q3ggPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGggJiYgKCFzdHJpY3RDeCB8fCAoY2FjaGVkLnByb3AoY29tbW9uLk5vZGVQcm9wLmNvbnRleHRIYXNoKSB8fCAwKSA9PSBjeEhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVzZU5vZGUoY2FjaGVkLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmV1c2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShjYWNoZWQudHlwZS5pZCl9KWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVkIGluc3RhbmNlb2YgY29tbW9uLlRyZWUpIHx8IGNhY2hlZC5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCBjYWNoZWQucG9zaXRpb25zWzBdID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gY2FjaGVkLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lciBpbnN0YW5jZW9mIGNvbW1vbi5UcmVlICYmIGNhY2hlZC5wb3NpdGlvbnNbMF0gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdFJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgaWYgKGRlZmF1bHRSZWR1Y2UgPiAwKSB7XG4gICAgICAgICAgICBzdGFjay5yZWR1Y2UoZGVmYXVsdFJlZHVjZSk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSBhbHdheXMtcmVkdWNlICR7cGFyc2VyLmdldE5hbWUoZGVmYXVsdFJlZHVjZSAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8pfSlgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5zdGFjay5sZW5ndGggPj0gODQwMCAvKiBSZWMuQ3V0RGVwdGggKi8pIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5zdGFjay5sZW5ndGggPiA2MDAwIC8qIFJlYy5DdXRUbyAqLyAmJiBzdGFjay5mb3JjZVJlZHVjZSgpKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMudG9rZW5zLmdldEFjdGlvbnMoc3RhY2spO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNbaSsrXSwgdGVybSA9IGFjdGlvbnNbaSsrXSwgZW5kID0gYWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGFjdGlvbnMubGVuZ3RoIHx8ICFzcGxpdDtcbiAgICAgICAgICAgIGxldCBsb2NhbFN0YWNrID0gbGFzdCA/IHN0YWNrIDogc3RhY2suc3BsaXQoKTtcbiAgICAgICAgICAgIGxldCBtYWluID0gdGhpcy50b2tlbnMubWFpblRva2VuO1xuICAgICAgICAgICAgbG9jYWxTdGFjay5hcHBseShhY3Rpb24sIHRlcm0sIG1haW4gPyBtYWluLnN0YXJ0IDogbG9jYWxTdGFjay5wb3MsIGVuZCk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGxvY2FsU3RhY2spICsgYCAodmlhICR7KGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwID8gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgIDogYHJlZHVjZSBvZiAke3BhcnNlci5nZXROYW1lKGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8pfWB9IGZvciAke3BhcnNlci5nZXROYW1lKHRlcm0pfSBAICR7c3RhcnR9JHtsb2NhbFN0YWNrID09IHN0YWNrID8gXCJcIiA6IFwiLCBzcGxpdFwifSlgKTtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxTdGFjay5wb3MgPiBzdGFydClcbiAgICAgICAgICAgICAgICBzdGFja3MucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzcGxpdC5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWR2YW5jZSBhIGdpdmVuIHN0YWNrIGZvcndhcmQgYXMgZmFyIGFzIGl0IHdpbGwgZ28uIFJldHVybnMgdGhlXG4gICAgLy8gKHBvc3NpYmx5IHVwZGF0ZWQpIHN0YWNrIGlmIGl0IGdvdCBzdHVjaywgb3IgbnVsbCBpZiBpdCBtb3ZlZFxuICAgIC8vIGZvcndhcmQgYW5kIHdhcyBnaXZlbiB0byBgcHVzaFN0YWNrRGVkdXBgLlxuICAgIGFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBwb3MgPSBzdGFjay5wb3M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG51bGwsIG51bGwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5SZWNvdmVyeShzdGFja3MsIHRva2VucywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBmaW5pc2hlZCA9IG51bGwsIHJlc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldLCB0b2tlbiA9IHRva2Vuc1tpIDw8IDFdLCB0b2tlbkVuZCA9IHRva2Vuc1soaSA8PCAxKSArIDFdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChzdGFjay5kZWFkRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmVzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFjay5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgKHJlc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBzdGFjay5zcGxpdCgpLCBmb3JjZUJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGZvcmNlLmZvcmNlUmVkdWNlKCkgJiYgaiA8IDEwIC8qIFJlYy5Gb3JjZVJlZHVjZUxpbWl0ICovOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZm9yY2VCYXNlICsgdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiICh2aWEgZm9yY2UtcmVkdWNlKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KGZvcmNlLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VCYXNlID0gdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiIC0+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaW5zZXJ0IG9mIHN0YWNrLnJlY292ZXJCeUluc2VydCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChpbnNlcnQpICsgXCIgKHZpYSByZWNvdmVyLWluc2VydClcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlRnVsbHkoaW5zZXJ0LCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmVuZCA+IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkVuZCA9PSBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmQrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFjay5yZWNvdmVyQnlEZWxldGUodG9rZW4sIHRva2VuRW5kKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmVjb3Zlci1kZWxldGUgJHt0aGlzLnBhcnNlci5nZXROYW1lKHRva2VuKX0pYCk7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmluaXNoZWQgfHwgZmluaXNoZWQuc2NvcmUgPCBzdGFjay5zY29yZSkge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBzdGFjaydzIGJ1ZmZlciB0byBhIHN5bnRheCB0cmVlLlxuICAgIHN0YWNrVG9UcmVlKHN0YWNrKSB7XG4gICAgICAgIHN0YWNrLmNsb3NlKCk7XG4gICAgICAgIHJldHVybiBjb21tb24uVHJlZS5idWlsZCh7IGJ1ZmZlcjogU3RhY2tCdWZmZXJDdXJzb3IuY3JlYXRlKHN0YWNrKSxcbiAgICAgICAgICAgIG5vZGVTZXQ6IHRoaXMucGFyc2VyLm5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogdGhpcy50b3BUZXJtLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiB0aGlzLnBhcnNlci5idWZmZXJMZW5ndGgsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMucmV1c2VkLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBsZW5ndGg6IHN0YWNrLnBvcyAtIHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBtaW5SZXBlYXRUeXBlOiB0aGlzLnBhcnNlci5taW5SZXBlYXRUZXJtIH0pO1xuICAgIH1cbiAgICBzdGFja0lEKHN0YWNrKSB7XG4gICAgICAgIGxldCBpZCA9IChzdGFja0lEcyB8fCAoc3RhY2tJRHMgPSBuZXcgV2Vha01hcCkpLmdldChzdGFjayk7XG4gICAgICAgIGlmICghaWQpXG4gICAgICAgICAgICBzdGFja0lEcy5zZXQoc3RhY2ssIGlkID0gU3RyaW5nLmZyb21Db2RlUG9pbnQodGhpcy5uZXh0U3RhY2tJRCsrKSk7XG4gICAgICAgIHJldHVybiBpZCArIHN0YWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3NbaV07XG4gICAgICAgIGlmIChvdGhlci5wb3MgPT0gc3RhY2sucG9zICYmIG90aGVyLnNhbWVTdGF0ZShzdGFjaykpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0uc2NvcmUgPCBzdGFjay5zY29yZSlcbiAgICAgICAgICAgICAgICBuZXdTdGFja3NbaV0gPSBzdGFjaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG59XG5jbGFzcyBEaWFsZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGZsYWdzLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIGFsbG93cyh0ZXJtKSB7IHJldHVybiAhdGhpcy5kaXNhYmxlZCB8fCB0aGlzLmRpc2FibGVkW3Rlcm1dID09IDA7IH1cbn1cbmNvbnN0IGlkID0geCA9PiB4O1xuLyoqXG5Db250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbmluZGVudGF0aW9uIGluIHRoZSBQeXRob24gZ3JhbW1hciwgb3IgcGFyZW50IGVsZW1lbnRzIGluIHRoZSBYTUxcbmdyYW1tYXIpIG5lZWRlZCBieSBleHRlcm5hbCB0b2tlbml6ZXJzLiBZb3UgZGVjbGFyZSB0aGVtIGluIGFcbmdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuXG5Db250ZXh0IHZhbHVlcyBzaG91bGQgYmUgaW1tdXRhYmxlLCBhbmQgY2FuIGJlIHVwZGF0ZWQgKHJlcGxhY2VkKVxub24gc2hpZnQgb3IgcmVkdWNlIGFjdGlvbnMuXG5cblRoZSBleHBvcnQgdXNlZCBpbiBhIGBAY29udGV4dGAgZGVjbGFyYXRpb24gc2hvdWxkIGJlIG9mIHRoaXNcbnR5cGUuXG4qL1xuY2xhc3MgQ29udGV4dFRyYWNrZXIge1xuICAgIC8qKlxuICAgIERlZmluZSBhIGNvbnRleHQgdHJhY2tlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHNwZWMuc3RhcnQ7XG4gICAgICAgIHRoaXMuc2hpZnQgPSBzcGVjLnNoaWZ0IHx8IGlkO1xuICAgICAgICB0aGlzLnJlZHVjZSA9IHNwZWMucmVkdWNlIHx8IGlkO1xuICAgICAgICB0aGlzLnJldXNlID0gc3BlYy5yZXVzZSB8fCBpZDtcbiAgICAgICAgdGhpcy5oYXNoID0gc3BlYy5oYXNoIHx8ICgoKSA9PiAwKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBzcGVjLnN0cmljdCAhPT0gZmFsc2U7XG4gICAgfVxufVxuLyoqXG5Ib2xkcyB0aGUgcGFyc2UgdGFibGVzIGZvciBhIGdpdmVuIGdyYW1tYXIsIGFzIGdlbmVyYXRlZCBieVxuYGxlemVyLWdlbmVyYXRvcmAsIGFuZCBwcm92aWRlcyBbbWV0aG9kc10oI2NvbW1vbi5QYXJzZXIpIHRvIHBhcnNlXG5jb250ZW50IHdpdGguXG4qL1xuY2xhc3MgTFJQYXJzZXIgZXh0ZW5kcyBjb21tb24uUGFyc2VyIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBwZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnZlcnNpb24gIT0gMTQgLyogRmlsZS5WZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezE0IC8qIEZpbGUuVmVyc2lvbiAqL30pYCk7XG4gICAgICAgIGxldCBub2RlTmFtZXMgPSBzcGVjLm5vZGVOYW1lcy5zcGxpdChcIiBcIik7XG4gICAgICAgIHRoaXMubWluUmVwZWF0VGVybSA9IG5vZGVOYW1lcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlYy5yZXBlYXROb2RlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIG5vZGVOYW1lcy5wdXNoKFwiXCIpO1xuICAgICAgICBsZXQgdG9wVGVybXMgPSBPYmplY3Qua2V5cyhzcGVjLnRvcFJ1bGVzKS5tYXAociA9PiBzcGVjLnRvcFJ1bGVzW3JdWzFdKTtcbiAgICAgICAgbGV0IG5vZGVQcm9wcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVOYW1lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVQcm9wcy5wdXNoKFtdKTtcbiAgICAgICAgZnVuY3Rpb24gc2V0UHJvcChub2RlSUQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBub2RlUHJvcHNbbm9kZUlEXS5wdXNoKFtwcm9wLCBwcm9wLmRlc2VyaWFsaXplKFN0cmluZyh2YWx1ZSkpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWMubm9kZVByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcFNwZWMgb2Ygc3BlYy5ub2RlUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHByb3BTcGVjWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBwcm9wID0gY29tbW9uLk5vZGVQcm9wW3Byb3BdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcFNwZWMubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHByb3BTcGVjW2krK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AobmV4dCwgcHJvcCwgcHJvcFNwZWNbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wU3BlY1tpICsgLW5leHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IC1uZXh0OyBqID4gMDsgai0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AocHJvcFNwZWNbaSsrXSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVTZXQgPSBuZXcgY29tbW9uLk5vZGVTZXQobm9kZU5hbWVzLm1hcCgobmFtZSwgaSkgPT4gY29tbW9uLk5vZGVUeXBlLmRlZmluZSh7XG4gICAgICAgICAgICBuYW1lOiBpID49IHRoaXMubWluUmVwZWF0VGVybSA/IHVuZGVmaW5lZCA6IG5hbWUsXG4gICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgIHByb3BzOiBub2RlUHJvcHNbaV0sXG4gICAgICAgICAgICB0b3A6IHRvcFRlcm1zLmluZGV4T2YoaSkgPiAtMSxcbiAgICAgICAgICAgIGVycm9yOiBpID09IDAsXG4gICAgICAgICAgICBza2lwcGVkOiBzcGVjLnNraXBwZWROb2RlcyAmJiBzcGVjLnNraXBwZWROb2Rlcy5pbmRleE9mKGkpID4gLTFcbiAgICAgICAgfSkpKTtcbiAgICAgICAgaWYgKHNwZWMucHJvcFNvdXJjZXMpXG4gICAgICAgICAgICB0aGlzLm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLnNwZWMucHJvcFNvdXJjZXMpO1xuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IGNvbW1vbi5EZWZhdWx0QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgdG9rZW5BcnJheSA9IGRlY29kZUFycmF5KHNwZWMudG9rZW5EYXRhKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gc3BlYy5jb250ZXh0O1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVyU3BlY3MgPSBzcGVjLnNwZWNpYWxpemVkIHx8IFtdO1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVkID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuc3BlY2lhbGl6ZWRbaV0gPSB0aGlzLnNwZWNpYWxpemVyU3BlY3NbaV0udGVybTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplcnMgPSB0aGlzLnNwZWNpYWxpemVyU3BlY3MubWFwKGdldFNwZWNpYWxpemVyKTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlcywgVWludDMyQXJyYXkpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlRGF0YSk7XG4gICAgICAgIHRoaXMuZ290byA9IGRlY29kZUFycmF5KHNwZWMuZ290byk7XG4gICAgICAgIHRoaXMubWF4VGVybSA9IHNwZWMubWF4VGVybTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXJzID0gc3BlYy50b2tlbml6ZXJzLm1hcCh2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IG5ldyBUb2tlbkdyb3VwKHRva2VuQXJyYXksIHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgdGhpcy50b3BSdWxlcyA9IHNwZWMudG9wUnVsZXM7XG4gICAgICAgIHRoaXMuZGlhbGVjdHMgPSBzcGVjLmRpYWxlY3RzIHx8IHt9O1xuICAgICAgICB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcyA9IHNwZWMuZHluYW1pY1ByZWNlZGVuY2VzIHx8IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5QcmVjVGFibGUgPSBzcGVjLnRva2VuUHJlYztcbiAgICAgICAgdGhpcy50ZXJtTmFtZXMgPSBzcGVjLnRlcm1OYW1lcyB8fCBudWxsO1xuICAgICAgICB0aGlzLm1heE5vZGUgPSB0aGlzLm5vZGVTZXQudHlwZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoKTtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcFJ1bGVzW09iamVjdC5rZXlzKHRoaXMudG9wUnVsZXMpWzBdXTtcbiAgICB9XG4gICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IG5ldyBQYXJzZSh0aGlzLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCB3IG9mIHRoaXMud3JhcHBlcnMpXG4gICAgICAgICAgICBwYXJzZSA9IHcocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIHJldHVybiBwYXJzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEdvdG8oc3RhdGUsIHRlcm0sIGxvb3NlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy5nb3RvO1xuICAgICAgICBpZiAodGVybSA+PSB0YWJsZVswXSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdGFibGVbdGVybSArIDFdOzspIHtcbiAgICAgICAgICAgIGxldCBncm91cFRhZyA9IHRhYmxlW3BvcysrXSwgbGFzdCA9IGdyb3VwVGFnICYgMTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0YWJsZVtwb3MrK107XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsb29zZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgZW5kID0gcG9zICsgKGdyb3VwVGFnID4+IDEpOyBwb3MgPCBlbmQ7IHBvcysrKVxuICAgICAgICAgICAgICAgIGlmICh0YWJsZVtwb3NdID09IHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIGlmIHRoaXMgc3RhdGUgaGFzIGFuIGFjdGlvbiBmb3IgYSBnaXZlbiB0ZXJtaW5hbCBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pLCBuZXh0OzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXh0ID0gZGF0YVtpXSkgPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogU2VxLk90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gdGVybWluYWwgfHwgbmV4dCA9PSAwIC8qIFRlcm0uRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGVTbG90KHN0YXRlLCBzbG90KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlc1soc3RhdGUgKiA2IC8qIFBhcnNlU3RhdGUuU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZUZsYWcoc3RhdGUsIGZsYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMCAvKiBQYXJzZVN0YXRlLkZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB2YWxpZEFjdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYWxsQWN0aW9ucyhzdGF0ZSwgYSA9PiBhID09IGFjdGlvbiA/IHRydWUgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhbGxBY3Rpb25zKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlZmx0ID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGRlZmx0ID8gYWN0aW9uKGRlZmx0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyk7IHJlc3VsdCA9PSBudWxsOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBhY3Rpb24ocGFpcih0aGlzLmRhdGEsIGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIGdvdG8ganVtcHMuIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmV4dFN0YXRlcyhzdGF0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLmRhdGFbaSArIDJdICYgKDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovID4+IDE2KSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIGdpdmVuIHNldHRpbmdzIG1vZGlmaWVkLiBTZXR0aW5ncyBub3QgcHJvdmlkZWQgaW4gYGNvbmZpZ2AgYXJlXG4gICAga2VwdCBmcm9tIHRoZSBvcmlnaW5hbCBwYXJzZXIuXG4gICAgKi9cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKExSUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zcGVjaWFsaXplcnMpIHtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJTcGVjcyA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5tYXAoKHMsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcuc3BlY2lhbGl6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gcy5leHRlcm5hbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgbGV0IHNwZWMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHMpLCB7IGV4dGVybmFsOiBmb3VuZC50byB9KTtcbiAgICAgICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVyc1tpXSA9IGdldFNwZWNpYWxpemVyKHNwZWMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0VHJhY2tlcilcbiAgICAgICAgICAgIGNvcHkuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0VHJhY2tlcjtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICBjb3B5LndyYXBwZXJzID0gY29weS53cmFwcGVycy5jb25jYXQoY29uZmlnLndyYXApO1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgYW55IFtwYXJzZSB3cmFwcGVyc10oI2xyLlBhcnNlckNvbmZpZy53cmFwKVxuICAgIGFyZSByZWdpc3RlcmVkIGZvciB0aGlzIHBhcnNlci5cbiAgICAqL1xuICAgIGhhc1dyYXBwZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBuYW1lIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlcm0uIFRoaXMgd2lsbCBvbmx5XG4gICAgd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gICAgYC0tbmFtZXNgIG9wdGlvbi4gQnkgZGVmYXVsdCwgb25seSB0aGUgbmFtZXMgb2YgdGFnZ2VkIHRlcm1zIGFyZVxuICAgIHN0b3JlZC5cbiAgICAqL1xuICAgIGdldE5hbWUodGVybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1t0ZXJtXSA6IFN0cmluZyh0ZXJtIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbdGVybV0ubmFtZSB8fCB0ZXJtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVvZiB0ZXJtIGlkIGlzIGFsd2F5cyBhbGxvY2F0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIG5vZGVcbiAgICB0eXBlcy4gQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZW9mVGVybSgpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSArIDE7IH1cbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0b3Agbm9kZSBwcm9kdWNlZCBieSB0aGUgcGFyc2VyLlxuICAgICovXG4gICAgZ2V0IHRvcE5vZGUoKSB7IHJldHVybiB0aGlzLm5vZGVTZXQudHlwZXNbdGhpcy50b3BbMV1dOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkeW5hbWljUHJlY2VkZW5jZSh0ZXJtKSB7XG4gICAgICAgIGxldCBwcmVjID0gdGhpcy5keW5hbWljUHJlY2VkZW5jZXM7XG4gICAgICAgIHJldHVybiBwcmVjID09IG51bGwgPyAwIDogcHJlY1t0ZXJtXSB8fCAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHBhcnNlRGlhbGVjdChkaWFsZWN0KSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgZmxhZ3MgPSB2YWx1ZXMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKGRpYWxlY3QpXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIGRpYWxlY3Quc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdmFsdWVzLmluZGV4T2YocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkID49IDApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFmbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpYWxlY3RzW3ZhbHVlc1tpXV0sIGlkOyAoaWQgPSB0aGlzLmRhdGFbaisrXSkgIT0gNjU1MzUgLyogU2VxLkVuZCAqLzspXG4gICAgICAgICAgICAgICAgICAgIChkaXNhYmxlZCB8fCAoZGlzYWJsZWQgPSBuZXcgVWludDhBcnJheSh0aGlzLm1heFRlcm0gKyAxKSkpW2lkXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGlhbGVjdChkaWFsZWN0LCBmbGFncywgZGlzYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGJ5IHRoZSBvdXRwdXQgb2YgdGhlIHBhcnNlciBnZW5lcmF0b3IuIE5vdCBhdmFpbGFibGUgdG9cbiAgICB1c2VyIGNvZGUuIEBoaWRlXG4gICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IExSUGFyc2VyKHNwZWMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhaXIoZGF0YSwgb2ZmKSB7IHJldHVybiBkYXRhW29mZl0gfCAoZGF0YVtvZmYgKyAxXSA8PCAxNik7IH1cbmZ1bmN0aW9uIGZpbmRGaW5pc2hlZChzdGFja3MpIHtcbiAgICBsZXQgYmVzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGxldCBzdG9wcGVkID0gc3RhY2sucC5zdG9wcGVkQXQ7XG4gICAgICAgIGlmICgoc3RhY2sucG9zID09IHN0YWNrLnAuc3RyZWFtLmVuZCB8fCBzdG9wcGVkICE9IG51bGwgJiYgc3RhY2sucG9zID4gc3RvcHBlZCkgJiZcbiAgICAgICAgICAgIHN0YWNrLnAucGFyc2VyLnN0YXRlRmxhZyhzdGFjay5zdGF0ZSwgMiAvKiBTdGF0ZUZsYWcuQWNjZXB0aW5nICovKSAmJlxuICAgICAgICAgICAgKCFiZXN0IHx8IGJlc3Quc2NvcmUgPCBzdGFjay5zY29yZSkpXG4gICAgICAgICAgICBiZXN0ID0gc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBiZXN0O1xufVxuZnVuY3Rpb24gZ2V0U3BlY2lhbGl6ZXIoc3BlYykge1xuICAgIGlmIChzcGVjLmV4dGVybmFsKSB7XG4gICAgICAgIGxldCBtYXNrID0gc3BlYy5leHRlbmQgPyAxIC8qIFNwZWNpYWxpemUuRXh0ZW5kICovIDogMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi87XG4gICAgICAgIHJldHVybiAodmFsdWUsIHN0YWNrKSA9PiAoc3BlYy5leHRlcm5hbCh2YWx1ZSwgc3RhY2spIDw8IDEpIHwgbWFzaztcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMuZ2V0O1xufVxuXG5leHBvcnRzLkNvbnRleHRUcmFja2VyID0gQ29udGV4dFRyYWNrZXI7XG5leHBvcnRzLkV4dGVybmFsVG9rZW5pemVyID0gRXh0ZXJuYWxUb2tlbml6ZXI7XG5leHBvcnRzLklucHV0U3RyZWFtID0gSW5wdXRTdHJlYW07XG5leHBvcnRzLkxSUGFyc2VyID0gTFJQYXJzZXI7XG5leHBvcnRzLkxvY2FsVG9rZW5Hcm91cCA9IExvY2FsVG9rZW5Hcm91cDtcbmV4cG9ydHMuU3RhY2sgPSBTdGFjaztcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHZpZXcgPSByZXF1aXJlKCdAY29kZW1pcnJvci92aWV3Jyk7XG52YXIgc3RhdGUgPSByZXF1aXJlKCdAY29kZW1pcnJvci9zdGF0ZScpO1xudmFyIGxhbmd1YWdlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnKTtcbnZhciBjb21tYW5kcyA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL2NvbW1hbmRzJyk7XG52YXIgc2VhcmNoID0gcmVxdWlyZSgnQGNvZGVtaXJyb3Ivc2VhcmNoJyk7XG52YXIgYXV0b2NvbXBsZXRlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlJyk7XG52YXIgbGludCA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL2xpbnQnKTtcblxuLy8gKFRoZSBzdXBlcmZsdW91cyBmdW5jdGlvbiBjYWxscyBhcm91bmQgdGhlIGxpc3Qgb2YgZXh0ZW5zaW9ucyB3b3JrXG4vLyBhcm91bmQgY3VycmVudCBsaW1pdGF0aW9ucyBpbiB0cmVlLXNoYWtpbmcgc29mdHdhcmUuKVxuLyoqXG5UaGlzIGlzIGFuIGV4dGVuc2lvbiB2YWx1ZSB0aGF0IGp1c3QgcHVsbHMgdG9nZXRoZXIgYSBudW1iZXIgb2ZcbmV4dGVuc2lvbnMgdGhhdCB5b3UgbWlnaHQgd2FudCBpbiBhIGJhc2ljIGVkaXRvci4gSXQgaXMgbWVhbnQgYXMgYVxuY29udmVuaWVudCBoZWxwZXIgdG8gcXVpY2tseSBzZXQgdXAgQ29kZU1pcnJvciB3aXRob3V0IGluc3RhbGxpbmdcbmFuZCBpbXBvcnRpbmcgYSBsb3Qgb2Ygc2VwYXJhdGUgcGFja2FnZXMuXG5cblNwZWNpZmljYWxseSwgaXQgaW5jbHVkZXMuLi5cblxuIC0gW3RoZSBkZWZhdWx0IGNvbW1hbmQgYmluZGluZ3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVmYXVsdEtleW1hcClcbiAtIFtsaW5lIG51bWJlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5saW5lTnVtYmVycylcbiAtIFtzcGVjaWFsIGNoYXJhY3RlciBoaWdobGlnaHRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRTcGVjaWFsQ2hhcnMpXG4gLSBbdGhlIHVuZG8gaGlzdG9yeV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5oaXN0b3J5KVxuIC0gW2EgZm9sZCBndXR0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEd1dHRlcilcbiAtIFtjdXN0b20gc2VsZWN0aW9uIGRyYXdpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKVxuIC0gW2Ryb3AgY3Vyc29yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJvcEN1cnNvcilcbiAtIFttdWx0aXBsZSBzZWxlY3Rpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKVxuIC0gW3JlaW5kZW50YXRpb24gb24gaW5wdXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50T25JbnB1dClcbiAtIFt0aGUgZGVmYXVsdCBoaWdobGlnaHQgc3R5bGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmYXVsdEhpZ2hsaWdodFN0eWxlKSAoYXMgZmFsbGJhY2spXG4gLSBbYnJhY2tldCBtYXRjaGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5icmFja2V0TWF0Y2hpbmcpXG4gLSBbYnJhY2tldCBjbG9zaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbG9zZUJyYWNrZXRzKVxuIC0gW2F1dG9jb21wbGV0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hdXRvY29tcGxldGlvbilcbiAtIFtyZWN0YW5ndWxhciBzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5yZWN0YW5ndWxhclNlbGVjdGlvbikgYW5kIFtjcm9zc2hhaXIgY3Vyc29yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuY3Jvc3NoYWlyQ3Vyc29yKVxuIC0gW2FjdGl2ZSBsaW5lIGhpZ2hsaWdodGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmUpXG4gLSBbYWN0aXZlIGxpbmUgZ3V0dGVyIGhpZ2hsaWdodGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIpXG4gLSBbc2VsZWN0aW9uIG1hdGNoIGhpZ2hsaWdodGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcylcbiAtIFtzZWFyY2hdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlYXJjaEtleW1hcClcbiAtIFtsaW50aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubGludEtleW1hcClcblxuKFlvdSdsbCBwcm9iYWJseSB3YW50IHRvIGFkZCBzb21lIGxhbmd1YWdlIHBhY2thZ2UgdG8geW91ciBzZXR1cFxudG9vLilcblxuVGhpcyBleHRlbnNpb24gZG9lcyBub3QgYWxsb3cgY3VzdG9taXphdGlvbi4gVGhlIGlkZWEgaXMgdGhhdCxcbm9uY2UgeW91IGRlY2lkZSB5b3Ugd2FudCB0byBjb25maWd1cmUgeW91ciBlZGl0b3IgbW9yZSBwcmVjaXNlbHksXG55b3UgdGFrZSB0aGlzIHBhY2thZ2UncyBzb3VyY2UgKHdoaWNoIGlzIGp1c3QgYSBidW5jaCBvZiBpbXBvcnRzXG5hbmQgYW4gYXJyYXkgbGl0ZXJhbCksIGNvcHkgaXQgaW50byB5b3VyIG93biBjb2RlLCBhbmQgYWRqdXN0IGl0XG5hcyBkZXNpcmVkLlxuKi9cbmNvbnN0IGJhc2ljU2V0dXAgPSAoKCkgPT4gW1xuICAgIHZpZXcubGluZU51bWJlcnMoKSxcbiAgICB2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIoKSxcbiAgICB2aWV3LmhpZ2hsaWdodFNwZWNpYWxDaGFycygpLFxuICAgIGNvbW1hbmRzLmhpc3RvcnkoKSxcbiAgICBsYW5ndWFnZS5mb2xkR3V0dGVyKCksXG4gICAgdmlldy5kcmF3U2VsZWN0aW9uKCksXG4gICAgdmlldy5kcm9wQ3Vyc29yKCksXG4gICAgc3RhdGUuRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMub2YodHJ1ZSksXG4gICAgbGFuZ3VhZ2UuaW5kZW50T25JbnB1dCgpLFxuICAgIGxhbmd1YWdlLnN5bnRheEhpZ2hsaWdodGluZyhsYW5ndWFnZS5kZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIHsgZmFsbGJhY2s6IHRydWUgfSksXG4gICAgbGFuZ3VhZ2UuYnJhY2tldE1hdGNoaW5nKCksXG4gICAgYXV0b2NvbXBsZXRlLmNsb3NlQnJhY2tldHMoKSxcbiAgICBhdXRvY29tcGxldGUuYXV0b2NvbXBsZXRpb24oKSxcbiAgICB2aWV3LnJlY3Rhbmd1bGFyU2VsZWN0aW9uKCksXG4gICAgdmlldy5jcm9zc2hhaXJDdXJzb3IoKSxcbiAgICB2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmUoKSxcbiAgICBzZWFyY2guaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcygpLFxuICAgIHZpZXcua2V5bWFwLm9mKFtcbiAgICAgICAgLi4uYXV0b2NvbXBsZXRlLmNsb3NlQnJhY2tldHNLZXltYXAsXG4gICAgICAgIC4uLmNvbW1hbmRzLmRlZmF1bHRLZXltYXAsXG4gICAgICAgIC4uLnNlYXJjaC5zZWFyY2hLZXltYXAsXG4gICAgICAgIC4uLmNvbW1hbmRzLmhpc3RvcnlLZXltYXAsXG4gICAgICAgIC4uLmxhbmd1YWdlLmZvbGRLZXltYXAsXG4gICAgICAgIC4uLmF1dG9jb21wbGV0ZS5jb21wbGV0aW9uS2V5bWFwLFxuICAgICAgICAuLi5saW50LmxpbnRLZXltYXBcbiAgICBdKVxuXSkoKTtcbi8qKlxuQSBtaW5pbWFsIHNldCBvZiBleHRlbnNpb25zIHRvIGNyZWF0ZSBhIGZ1bmN0aW9uYWwgZWRpdG9yLiBPbmx5XG5pbmNsdWRlcyBbdGhlIGRlZmF1bHQga2V5bWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlZmF1bHRLZXltYXApLCBbdW5kb1xuaGlzdG9yeV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5oaXN0b3J5KSwgW3NwZWNpYWwgY2hhcmFjdGVyXG5oaWdobGlnaHRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRTcGVjaWFsQ2hhcnMpLCBbY3VzdG9tIHNlbGVjdGlvblxuZHJhd2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pLCBhbmQgW2RlZmF1bHQgaGlnaGxpZ2h0XG5zdHlsZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5kZWZhdWx0SGlnaGxpZ2h0U3R5bGUpLlxuKi9cbmNvbnN0IG1pbmltYWxTZXR1cCA9ICgoKSA9PiBbXG4gICAgdmlldy5oaWdobGlnaHRTcGVjaWFsQ2hhcnMoKSxcbiAgICBjb21tYW5kcy5oaXN0b3J5KCksXG4gICAgdmlldy5kcmF3U2VsZWN0aW9uKCksXG4gICAgbGFuZ3VhZ2Uuc3ludGF4SGlnaGxpZ2h0aW5nKGxhbmd1YWdlLmRlZmF1bHRIaWdobGlnaHRTdHlsZSwgeyBmYWxsYmFjazogdHJ1ZSB9KSxcbiAgICB2aWV3LmtleW1hcC5vZihbXG4gICAgICAgIC4uLmNvbW1hbmRzLmRlZmF1bHRLZXltYXAsXG4gICAgICAgIC4uLmNvbW1hbmRzLmhpc3RvcnlLZXltYXAsXG4gICAgXSlcbl0pKCk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRWRpdG9yVmlldycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmlldy5FZGl0b3JWaWV3OyB9XG59KTtcbmV4cG9ydHMuYmFzaWNTZXR1cCA9IGJhc2ljU2V0dXA7XG5leHBvcnRzLm1pbmltYWxTZXR1cCA9IG1pbmltYWxTZXR1cDtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY3JlbHQoKSB7XG4gIHZhciBlbHQgPSBhcmd1bWVudHNbMF07XG4gIGlmICh0eXBlb2YgZWx0ID09IFwic3RyaW5nXCIpIGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWx0KTtcbiAgdmFyIGkgPSAxLCBuZXh0ID0gYXJndW1lbnRzWzFdO1xuICBpZiAobmV4dCAmJiB0eXBlb2YgbmV4dCA9PSBcIm9iamVjdFwiICYmIG5leHQubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbmV4dCkgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0LCBuYW1lKSkge1xuICAgICAgdmFyIHZhbHVlID0gbmV4dFtuYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikgZWx0LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSBlbHRbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhZGQoZWx0LCBhcmd1bWVudHNbaV0pO1xuICByZXR1cm4gZWx0XG59XG5cbmZ1bmN0aW9uIGFkZChlbHQsIGNoaWxkKSB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT0gXCJzdHJpbmdcIikge1xuICAgIGVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCkpO1xuICB9IGVsc2UgaWYgKGNoaWxkID09IG51bGwpIDsgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgIT0gbnVsbCkge1xuICAgIGVsdC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKSBhZGQoZWx0LCBjaGlsZFtpXSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbnN1cHBvcnRlZCBjaGlsZCBub2RlOiBcIiArIGNoaWxkKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlbHQ7XG4iLCJ2YXIgQyA9IFwiXFx1MDM3Y1wiXG52YXIgQ09VTlQgPSB0eXBlb2YgU3ltYm9sID09IFwidW5kZWZpbmVkXCIgPyBcIl9fXCIgKyBDIDogU3ltYm9sLmZvcihDKVxudmFyIFNFVCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJ1bmRlZmluZWRcIiA/IFwiX19zdHlsZVNldFwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU4KSA6IFN5bWJvbChcInN0eWxlU2V0XCIpXG52YXIgdG9wID0gdHlwZW9mIGdsb2JhbFRoaXMgIT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fVxuXG4vLyA6OiAtIFN0eWxlIG1vZHVsZXMgZW5jYXBzdWxhdGUgYSBzZXQgb2YgQ1NTIHJ1bGVzIGRlZmluZWQgZnJvbVxuLy8gSmF2YVNjcmlwdC4gVGhlaXIgZGVmaW5pdGlvbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gRE9NXG4vLyByb290IGFmdGVyIGl0IGhhcyBiZWVuIF9tb3VudGVkXyB0aGVyZSB3aXRoIGBTdHlsZU1vZHVsZS5tb3VudGAuXG4vL1xuLy8gU3R5bGUgbW9kdWxlcyBzaG91bGQgYmUgY3JlYXRlZCBvbmNlIGFuZCBzdG9yZWQgc29tZXdoZXJlLCBhc1xuLy8gb3Bwb3NlZCB0byByZS1jcmVhdGluZyB0aGVtIGV2ZXJ5IHRpbWUgeW91IG5lZWQgdGhlbS4gVGhlIGFtb3VudCBvZlxuLy8gQ1NTIHJ1bGVzIGdlbmVyYXRlZCBmb3IgYSBnaXZlbiBET00gcm9vdCBpcyBib3VuZGVkIGJ5IHRoZSBhbW91bnRcbi8vIG9mIHN0eWxlIG1vZHVsZXMgdGhhdCB3ZXJlIHVzZWQuIFNvIHRvIGF2b2lkIGxlYWtpbmcgcnVsZXMsIGRvbid0XG4vLyBjcmVhdGUgdGhlc2UgZHluYW1pY2FsbHksIGJ1dCB0cmVhdCB0aGVtIGFzIG9uZS10aW1lIGFsbG9jYXRpb25zLlxudmFyIFN0eWxlTW9kdWxlID0gZXhwb3J0cy5TdHlsZU1vZHVsZSA9IGZ1bmN0aW9uIFN0eWxlTW9kdWxlKHNwZWMsIG9wdGlvbnMpIHtcbiAgdGhpcy5ydWxlcyA9IFtdXG4gIHZhciByZWYgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgZmluaXNoID0gcmVmLmZpbmlzaDtcblxuICBmdW5jdGlvbiBzcGxpdFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIC9eQC8udGVzdChzZWxlY3RvcikgPyBbc2VsZWN0b3JdIDogc2VsZWN0b3Iuc3BsaXQoLyxcXHMqLylcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlcihzZWxlY3RvcnMsIHNwZWMsIHRhcmdldCwgaXNLZXlmcmFtZXMpIHtcbiAgICB2YXIgbG9jYWwgPSBbXSwgaXNBdCA9IC9eQChcXHcrKVxcYi8uZXhlYyhzZWxlY3RvcnNbMF0pLCBrZXlmcmFtZXMgPSBpc0F0ICYmIGlzQXRbMV0gPT0gXCJrZXlmcmFtZXNcIlxuICAgIGlmIChpc0F0ICYmIHNwZWMgPT0gbnVsbCkgeyByZXR1cm4gdGFyZ2V0LnB1c2goc2VsZWN0b3JzWzBdICsgXCI7XCIpIH1cbiAgICBmb3IgKHZhciBwcm9wIGluIHNwZWMpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHNwZWNbcHJvcF1cbiAgICAgIGlmICgvJi8udGVzdChwcm9wKSkge1xuICAgICAgICByZW5kZXIocHJvcC5zcGxpdCgvLFxccyovKS5tYXAoZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIHNlbGVjdG9ycy5tYXAoZnVuY3Rpb24gKHNlbCkgeyByZXR1cm4gcGFydC5yZXBsYWNlKC8mLywgc2VsKTsgfSk7IH0pLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH0pLFxuICAgICAgICAgICAgICAgdmFsdWUsIHRhcmdldClcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKCFpc0F0KSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgKFwiICsgcHJvcCArIFwiKSBzaG91bGQgYmUgYSBwcmltaXRpdmUgdmFsdWUuXCIpIH1cbiAgICAgICAgcmVuZGVyKHNwbGl0U2VsZWN0b3IocHJvcCksIHZhbHVlLCBsb2NhbCwga2V5ZnJhbWVzKVxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGxvY2FsLnB1c2gocHJvcC5yZXBsYWNlKC9fLiovLCBcIlwiKS5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbiAobCkgeyByZXR1cm4gXCItXCIgKyBsLnRvTG93ZXJDYXNlKCk7IH0pICsgXCI6IFwiICsgdmFsdWUgKyBcIjtcIilcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxvY2FsLmxlbmd0aCB8fCBrZXlmcmFtZXMpIHtcbiAgICAgIHRhcmdldC5wdXNoKChmaW5pc2ggJiYgIWlzQXQgJiYgIWlzS2V5ZnJhbWVzID8gc2VsZWN0b3JzLm1hcChmaW5pc2gpIDogc2VsZWN0b3JzKS5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgXCIge1wiICsgbG9jYWwuam9pbihcIiBcIikgKyBcIn1cIilcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBwcm9wIGluIHNwZWMpIHsgcmVuZGVyKHNwbGl0U2VsZWN0b3IocHJvcCksIHNwZWNbcHJvcF0sIHRoaXMucnVsZXMpIH1cbn07XG5cbi8vIDo6ICgpIOKGkiBzdHJpbmdcbi8vIFJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbW9kdWxlJ3MgQ1NTIHJ1bGVzLlxuU3R5bGVNb2R1bGUucHJvdG90eXBlLmdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXMgKCkgeyByZXR1cm4gdGhpcy5ydWxlcy5qb2luKFwiXFxuXCIpIH07XG5cbi8vIDo6ICgpIOKGkiBzdHJpbmdcbi8vIEdlbmVyYXRlIGEgbmV3IHVuaXF1ZSBDU1MgY2xhc3MgbmFtZS5cblN0eWxlTW9kdWxlLm5ld05hbWUgPSBmdW5jdGlvbiBuZXdOYW1lICgpIHtcbiAgdmFyIGlkID0gdG9wW0NPVU5UXSB8fCAxXG4gIHRvcFtDT1VOVF0gPSBpZCArIDFcbiAgcmV0dXJuIEMgKyBpZC50b1N0cmluZygzNilcbn07XG5cbi8vIDo6ICh1bmlvbjxEb2N1bWVudCwgU2hhZG93Um9vdD4sIHVuaW9uPFtTdHlsZU1vZHVsZV0sIFN0eWxlTW9kdWxlPiwgP3tub25jZTogP3N0cmluZ30pXG4vL1xuLy8gTW91bnQgdGhlIGdpdmVuIHNldCBvZiBtb2R1bGVzIGluIHRoZSBnaXZlbiBET00gcm9vdCwgd2hpY2ggZW5zdXJlc1xuLy8gdGhhdCB0aGUgQ1NTIHJ1bGVzIGRlZmluZWQgYnkgdGhlIG1vZHVsZSBhcmUgYXZhaWxhYmxlIGluIHRoYXRcbi8vIGNvbnRleHQuXG4vL1xuLy8gUnVsZXMgYXJlIG9ubHkgYWRkZWQgdG8gdGhlIGRvY3VtZW50IG9uY2UgcGVyIHJvb3QuXG4vL1xuLy8gUnVsZSBvcmRlciB3aWxsIGZvbGxvdyB0aGUgb3JkZXIgb2YgdGhlIG1vZHVsZXMsIHNvIHRoYXQgcnVsZXMgZnJvbVxuLy8gbW9kdWxlcyBsYXRlciBpbiB0aGUgYXJyYXkgdGFrZSBwcmVjZWRlbmNlIG9mIHRob3NlIGZyb20gZWFybGllclxuLy8gbW9kdWxlcy4gSWYgeW91IGNhbGwgdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWUgcm9vdFxuLy8gaW4gYSB3YXkgdGhhdCBjaGFuZ2VzIHRoZSBvcmRlciBvZiBhbHJlYWR5IG1vdW50ZWQgbW9kdWxlcywgdGhlIG9sZFxuLy8gb3JkZXIgd2lsbCBiZSBjaGFuZ2VkLlxuLy9cbi8vIElmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgbm9uY2UgaXMgcHJvdmlkZWQsIGl0IGlzIGFkZGVkIHRvXG4vLyB0aGUgYDxzdHlsZT5gIHRhZyBnZW5lcmF0ZWQgYnkgdGhlIGxpYnJhcnkuXG5TdHlsZU1vZHVsZS5tb3VudCA9IGZ1bmN0aW9uIG1vdW50IChyb290LCBtb2R1bGVzLCBvcHRpb25zKSB7XG4gIHZhciBzZXQgPSByb290W1NFVF0sIG5vbmNlID0gb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlXG4gIGlmICghc2V0KSB7IHNldCA9IG5ldyBTdHlsZVNldChyb290LCBub25jZSkgfVxuICBlbHNlIGlmIChub25jZSkgeyBzZXQuc2V0Tm9uY2Uobm9uY2UpIH1cbiAgc2V0Lm1vdW50KEFycmF5LmlzQXJyYXkobW9kdWxlcykgPyBtb2R1bGVzIDogW21vZHVsZXNdLCByb290KVxufTtcblxudmFyIGFkb3B0ZWRTZXQgPSBuZXcgTWFwIC8vPERvY3VtZW50LCBTdHlsZVNldD5cblxudmFyIFN0eWxlU2V0ID0gZnVuY3Rpb24gU3R5bGVTZXQocm9vdCwgbm9uY2UpIHtcbiAgdmFyIGRvYyA9IHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXdcbiAgaWYgKCFyb290LmhlYWQgJiYgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgJiYgd2luLkNTU1N0eWxlU2hlZXQpIHtcbiAgICB2YXIgYWRvcHRlZCA9IGFkb3B0ZWRTZXQuZ2V0KGRvYylcbiAgICBpZiAoYWRvcHRlZCkgeyByZXR1cm4gcm9vdFtTRVRdID0gYWRvcHRlZCB9XG4gICAgdGhpcy5zaGVldCA9IG5ldyB3aW4uQ1NTU3R5bGVTaGVldFxuICAgIGFkb3B0ZWRTZXQuc2V0KGRvYywgdGhpcylcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0eWxlVGFnID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKVxuICAgIGlmIChub25jZSkgeyB0aGlzLnN0eWxlVGFnLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKSB9XG4gIH1cbiAgdGhpcy5tb2R1bGVzID0gW11cbiAgcm9vdFtTRVRdID0gdGhpc1xufTtcblxuU3R5bGVTZXQucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gbW91bnQgKG1vZHVsZXMsIHJvb3QpIHtcbiAgdmFyIHNoZWV0ID0gdGhpcy5zaGVldFxuICB2YXIgcG9zID0gMCAvKiBDdXJyZW50IHJ1bGUgb2Zmc2V0ICovLCBqID0gMCAvKiBJbmRleCBpbnRvIHRoaXMubW9kdWxlcyAqL1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbW9kID0gbW9kdWxlc1tpXSwgaW5kZXggPSB0aGlzLm1vZHVsZXMuaW5kZXhPZihtb2QpXG4gICAgaWYgKGluZGV4IDwgaiAmJiBpbmRleCA+IC0xKSB7IC8vIE9yZGVyaW5nIGNvbmZsaWN0XG4gICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgai0tXG4gICAgICBpbmRleCA9IC0xXG4gICAgfVxuICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgdGhpcy5tb2R1bGVzLnNwbGljZShqKyssIDAsIG1vZClcbiAgICAgIGlmIChzaGVldCkgeyBmb3IgKHZhciBrID0gMDsgayA8IG1vZC5ydWxlcy5sZW5ndGg7IGsrKylcbiAgICAgICAgeyBzaGVldC5pbnNlcnRSdWxlKG1vZC5ydWxlc1trXSwgcG9zKyspIH0gfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoaiA8IGluZGV4KSB7IHBvcyArPSB0aGlzLm1vZHVsZXNbaisrXS5ydWxlcy5sZW5ndGggfVxuICAgICAgcG9zICs9IG1vZC5ydWxlcy5sZW5ndGhcbiAgICAgIGorK1xuICAgIH1cbiAgfVxuXG4gIGlmIChzaGVldCkge1xuICAgIGlmIChyb290LmFkb3B0ZWRTdHlsZVNoZWV0cy5pbmRleE9mKHRoaXMuc2hlZXQpIDwgMClcbiAgICAgIHsgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgPSBbdGhpcy5zaGVldCBdLmNvbmNhdCggcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMpIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGV4dCA9IFwiXCJcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLm1vZHVsZXMubGVuZ3RoOyBpJDErKylcbiAgICAgIHsgdGV4dCArPSB0aGlzLm1vZHVsZXNbaSQxXS5nZXRSdWxlcygpICsgXCJcXG5cIiB9XG4gICAgdGhpcy5zdHlsZVRhZy50ZXh0Q29udGVudCA9IHRleHRcbiAgICB2YXIgdGFyZ2V0ID0gcm9vdC5oZWFkIHx8IHJvb3RcbiAgICBpZiAodGhpcy5zdHlsZVRhZy5wYXJlbnROb2RlICE9IHRhcmdldClcbiAgICAgIHsgdGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLnN0eWxlVGFnLCB0YXJnZXQuZmlyc3RDaGlsZCkgfVxuICB9XG59O1xuXG5TdHlsZVNldC5wcm90b3R5cGUuc2V0Tm9uY2UgPSBmdW5jdGlvbiBzZXROb25jZSAobm9uY2UpIHtcbiAgaWYgKHRoaXMuc3R5bGVUYWcgJiYgdGhpcy5zdHlsZVRhZy5nZXRBdHRyaWJ1dGUoXCJub25jZVwiKSAhPSBub25jZSlcbiAgICB7IHRoaXMuc3R5bGVUYWcuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpIH1cbn07XG5cbi8vIFN0eWxlOjpPYmplY3Q8dW5pb248U3R5bGUsc3RyaW5nPj5cbi8vXG4vLyBBIHN0eWxlIGlzIGFuIG9iamVjdCB0aGF0LCBpbiB0aGUgc2ltcGxlIGNhc2UsIG1hcHMgQ1NTIHByb3BlcnR5XG4vLyBuYW1lcyB0byBzdHJpbmdzIGhvbGRpbmcgdGhlaXIgdmFsdWVzLCBhcyBpbiBge2NvbG9yOiBcInJlZFwiLFxuLy8gZm9udFdlaWdodDogXCJib2xkXCJ9YC4gVGhlIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBnaXZlbiBpblxuLy8gY2FtZWwtY2FzZeKAlHRoZSBsaWJyYXJ5IHdpbGwgaW5zZXJ0IGEgZGFzaCBiZWZvcmUgY2FwaXRhbCBsZXR0ZXJzXG4vLyB3aGVuIGNvbnZlcnRpbmcgdGhlbSB0byBDU1MuXG4vL1xuLy8gSWYgeW91IGluY2x1ZGUgYW4gdW5kZXJzY29yZSBpbiBhIHByb3BlcnR5IG5hbWUsIGl0IGFuZCBldmVyeXRoaW5nXG4vLyBhZnRlciBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgb3V0cHV0LCB3aGljaCBjYW4gYmUgdXNlZnVsIHdoZW5cbi8vIHByb3ZpZGluZyBhIHByb3BlcnR5IG11bHRpcGxlIHRpbWVzLCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4vLyByZWFzb25zLlxuLy9cbi8vIEEgcHJvcGVydHkgaW4gYSBzdHlsZSBvYmplY3QgY2FuIGFsc28gYmUgYSBzdWItc2VsZWN0b3IsIHdoaWNoXG4vLyBleHRlbmRzIHRoZSBjdXJyZW50IGNvbnRleHQgdG8gYWRkIGEgcHNldWRvLXNlbGVjdG9yIG9yIGEgY2hpbGRcbi8vIHNlbGVjdG9yLiBTdWNoIGEgcHJvcGVydHkgc2hvdWxkIGNvbnRhaW4gYSBgJmAgY2hhcmFjdGVyLCB3aGljaFxuLy8gd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgY3VycmVudCBzZWxlY3Rvci4gRm9yIGV4YW1wbGUgYHtcIiY6YmVmb3JlXCI6XG4vLyB7Y29udGVudDogJ1wiaGlcIid9fWAuIFN1Yi1zZWxlY3RvcnMgYW5kIHJlZ3VsYXIgcHJvcGVydGllcyBjYW5cbi8vIGZyZWVseSBiZSBtaXhlZCBpbiBhIGdpdmVuIG9iamVjdC4gQW55IHByb3BlcnR5IGNvbnRhaW5pbmcgYSBgJmAgaXNcbi8vIGFzc3VtZWQgdG8gYmUgYSBzdWItc2VsZWN0b3IuXG4vL1xuLy8gRmluYWxseSwgYSBwcm9wZXJ0eSBjYW4gc3BlY2lmeSBhbiBALWJsb2NrIHRvIGJlIHdyYXBwZWQgYXJvdW5kIHRoZVxuLy8gc3R5bGVzIGRlZmluZWQgaW5zaWRlIHRoZSBvYmplY3QgdGhhdCdzIHRoZSBwcm9wZXJ0eSdzIHZhbHVlLiBGb3Jcbi8vIGV4YW1wbGUgdG8gY3JlYXRlIGEgbWVkaWEgcXVlcnkgeW91IGNhbiBkbyBge1wiQG1lZGlhIHNjcmVlbiBhbmRcbi8vIChtaW4td2lkdGg6IDQwMHB4KVwiOiB7Li4ufX1gLlxuXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIlxufTtcblxudmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiXG59O1xuXG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbnZhciBpZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBcXGR8VHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykgYmFzZVs0OCArIGldID0gYmFzZVs5NiArIGldID0gU3RyaW5nKGkpO1xuXG4vLyBUaGUgZnVuY3Rpb24ga2V5c1xuZm9yICh2YXIgaSA9IDE7IGkgPD0gMjQ7IGkrKykgYmFzZVtpICsgMTExXSA9IFwiRlwiICsgaTtcblxuLy8gQW5kIHRoZSBhbHBoYWJldGljIGtleXNcbmZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XG4gIGJhc2VbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAzMik7XG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbn1cblxuLy8gRm9yIGVhY2ggY29kZSB0aGF0IGRvZXNuJ3QgaGF2ZSBhIHNoaWZ0LWVxdWl2YWxlbnQsIGNvcHkgdGhlIGJhc2UgbmFtZVxuZm9yICh2YXIgY29kZSBpbiBiYXNlKSBpZiAoIXNoaWZ0Lmhhc093blByb3BlcnR5KGNvZGUpKSBzaGlmdFtjb2RlXSA9IGJhc2VbY29kZV07XG5cbmZ1bmN0aW9uIGtleU5hbWUoZXZlbnQpIHtcbiAgLy8gT24gbWFjT1MsIGtleXMgaGVsZCB3aXRoIFNoaWZ0IGFuZCBDbWQgZG9uJ3QgcmVmbGVjdCB0aGUgZWZmZWN0IG9mIFNoaWZ0IGluIGAua2V5YC5cbiAgLy8gT24gSUUsIHNoaWZ0IGVmZmVjdCBpcyBuZXZlciBpbmNsdWRlZCBpbiBgLmtleWAuXG4gIHZhciBpZ25vcmVLZXkgPSBtYWMgJiYgZXZlbnQubWV0YUtleSAmJiBldmVudC5zaGlmdEtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5IHx8XG4gICAgICBpZSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PSAxIHx8XG4gICAgICBldmVudC5rZXkgPT0gXCJVbmlkZW50aWZpZWRcIjtcbiAgdmFyIG5hbWUgPSAoIWlnbm9yZUtleSAmJiBldmVudC5rZXkpIHx8XG4gICAgKGV2ZW50LnNoaWZ0S2V5ID8gc2hpZnQgOiBiYXNlKVtldmVudC5rZXlDb2RlXSB8fFxuICAgIGV2ZW50LmtleSB8fCBcIlVuaWRlbnRpZmllZFwiO1xuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiO1xuICBpZiAobmFtZSA9PSBcIkRlbFwiKSBuYW1lID0gXCJEZWxldGVcIjtcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvODg2MDU3MS9cbiAgaWYgKG5hbWUgPT0gXCJMZWZ0XCIpIG5hbWUgPSBcIkFycm93TGVmdFwiO1xuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIjtcbiAgaWYgKG5hbWUgPT0gXCJSaWdodFwiKSBuYW1lID0gXCJBcnJvd1JpZ2h0XCI7XG4gIGlmIChuYW1lID09IFwiRG93blwiKSBuYW1lID0gXCJBcnJvd0Rvd25cIjtcbiAgcmV0dXJuIG5hbWVcbn1cblxuZXhwb3J0cy5iYXNlID0gYmFzZTtcbmV4cG9ydHMua2V5TmFtZSA9IGtleU5hbWU7XG5leHBvcnRzLnNoaWZ0ID0gc2hpZnQ7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJ2YXIgc2NyaXB0VXJsO1xuaWYgKF9fd2VicGFja19yZXF1aXJlX18uZy5pbXBvcnRTY3JpcHRzKSBzY3JpcHRVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcubG9jYXRpb24gKyBcIlwiO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmRvY3VtZW50O1xuaWYgKCFzY3JpcHRVcmwgJiYgZG9jdW1lbnQpIHtcblx0aWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdTQ1JJUFQnKVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuXHRpZiAoIXNjcmlwdFVybCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0aWYoc2NyaXB0cy5sZW5ndGgpIHtcblx0XHRcdHZhciBpID0gc2NyaXB0cy5sZW5ndGggLSAxO1xuXHRcdFx0d2hpbGUgKGkgPiAtMSAmJiAoIXNjcmlwdFVybCB8fCAhL15odHRwKHM/KTovLnRlc3Qoc2NyaXB0VXJsKSkpIHNjcmlwdFVybCA9IHNjcmlwdHNbaS0tXS5zcmM7XG5cdFx0fVxuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybDsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5jID0gdW5kZWZpbmVkOyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9